#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use des_core::*;
use des_macros::Network;
mod members {
    use des_core::*;
    use des_macros::Module;
    use log::info;
    use std::ops::Deref;
    #[ndl_workspace = "ndl"]
    pub struct Alice(ModuleCore);
    impl ::des_core::StaticModuleCore for Alice {
        fn module_core(&self) -> &::des_core::ModuleCore {
            &self.0
        }
        fn module_core_mut(&mut self) -> &mut ::des_core::ModuleCore {
            &mut self.0
        }
    }
    impl ::des_core::NdlBuildableModule for Alice {
        fn build<A>(mut self: Box<Self>, rt: &mut des_core::NetworkRuntime<A>) -> Box<Self> {
            let _ = self.create_gate_cluster("netIn", 3usize);
            let _ = self.create_gate_cluster("netOut", 3usize);
            self
        }
    }
    impl Module for Alice {
        fn handle_message(&mut self, msg: Message) {
            let mut pkt = msg.extract_content::<Packet>();
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &["Received at ", ": Message #", " content: "],
                            &match (
                                &sim_time_fmt(),
                                &pkt.id(),
                                &pkt.extract_content_ref::<String>().deref(),
                            ) {
                                _args => [
                                    ::core::fmt::ArgumentV1::new(
                                        _args.0,
                                        ::core::fmt::Display::fmt,
                                    ),
                                    ::core::fmt::ArgumentV1::new(
                                        _args.1,
                                        ::core::fmt::Display::fmt,
                                    ),
                                    ::core::fmt::ArgumentV1::new(
                                        _args.2,
                                        ::core::fmt::Display::fmt,
                                    ),
                                ],
                            },
                        ),
                        lvl,
                        &(
                            self.name().unwrap(),
                            "ndl::members",
                            "ndl\\members.rs",
                            15u32,
                        ),
                    );
                }
            };
            if pkt.hop_count() > 100_000 {
            } else {
                pkt.inc_hop_count();
                self.send(
                    Message::new_interned(1, self.id(), SimTime::ZERO, pkt),
                    ("netOut", 0),
                )
            }
        }
    }
    impl NdlCompatableModule for Alice {
        fn named(name: String) -> Self {
            Self(ModuleCore::named(name))
        }
    }
    #[ndl_workspace = "ndl"]
    pub struct Bob(ModuleCore);
    impl ::des_core::StaticModuleCore for Bob {
        fn module_core(&self) -> &::des_core::ModuleCore {
            &self.0
        }
        fn module_core_mut(&mut self) -> &mut ::des_core::ModuleCore {
            &mut self.0
        }
    }
    impl ::des_core::NdlBuildableModule for Bob {
        fn build<A>(mut self: Box<Self>, rt: &mut des_core::NetworkRuntime<A>) -> Box<Self> {
            let mut child_child: Box<Alice> =
                Alice::build_named_with_parent("child", &mut self, rt);
            let _ = self.create_gate_cluster("netIn", 3usize);
            let _ = self.create_gate_cluster("netOut", 3usize);
            let _ = self.create_gate_cluster("uplink", 1usize);
            let mut netOut_gate0_ref: &mut des_core::Gate = self
                .gate_mut("netOut", 0usize)
                .expect("Internal macro err.");
            let mut child_child_netIn_gate0: &mut des_core::Gate = child_child
                .gate_mut("netIn", 0usize)
                .expect("Internal macro err.");
            let channel = rt.create_channel(des_core::ChannelMetrics {
                bitrate: 100usize,
                latency: des_core::SimTime::new(0.1f64),
                jitter: des_core::SimTime::new(0.1f64),
            });
            netOut_gate0_ref.set_next_gate(child_child_netIn_gate0.id());
            netOut_gate0_ref.set_channel(channel);
            let mut netOut_gate1_ref: &mut des_core::Gate = self
                .gate_mut("netOut", 1usize)
                .expect("Internal macro err.");
            let mut child_child_netIn_gate1: &mut des_core::Gate = child_child
                .gate_mut("netIn", 1usize)
                .expect("Internal macro err.");
            let channel = rt.create_channel(des_core::ChannelMetrics {
                bitrate: 100usize,
                latency: des_core::SimTime::new(0.1f64),
                jitter: des_core::SimTime::new(0.1f64),
            });
            netOut_gate1_ref.set_next_gate(child_child_netIn_gate1.id());
            netOut_gate1_ref.set_channel(channel);
            let mut netOut_gate2_ref: &mut des_core::Gate = self
                .gate_mut("netOut", 2usize)
                .expect("Internal macro err.");
            let mut child_child_netIn_gate2: &mut des_core::Gate = child_child
                .gate_mut("netIn", 2usize)
                .expect("Internal macro err.");
            let channel = rt.create_channel(des_core::ChannelMetrics {
                bitrate: 100usize,
                latency: des_core::SimTime::new(0.1f64),
                jitter: des_core::SimTime::new(0.1f64),
            });
            netOut_gate2_ref.set_next_gate(child_child_netIn_gate2.id());
            netOut_gate2_ref.set_channel(channel);
            let mut child_child_netOut_gate0: &mut des_core::Gate = child_child
                .gate_mut("netOut", 0usize)
                .expect("Internal macro err.");
            let mut netIn_gate0_ref: &mut des_core::Gate =
                self.gate_mut("netIn", 0usize).expect("Internal macro err.");
            let channel = rt.create_channel(des_core::ChannelMetrics {
                bitrate: 100usize,
                latency: des_core::SimTime::new(0.1f64),
                jitter: des_core::SimTime::new(0.1f64),
            });
            child_child_netOut_gate0.set_next_gate(netIn_gate0_ref.id());
            child_child_netOut_gate0.set_channel(channel);
            let mut child_child_netOut_gate1: &mut des_core::Gate = child_child
                .gate_mut("netOut", 1usize)
                .expect("Internal macro err.");
            let mut netIn_gate1_ref: &mut des_core::Gate =
                self.gate_mut("netIn", 1usize).expect("Internal macro err.");
            let channel = rt.create_channel(des_core::ChannelMetrics {
                bitrate: 100usize,
                latency: des_core::SimTime::new(0.1f64),
                jitter: des_core::SimTime::new(0.1f64),
            });
            child_child_netOut_gate1.set_next_gate(netIn_gate1_ref.id());
            child_child_netOut_gate1.set_channel(channel);
            let mut child_child_netOut_gate2: &mut des_core::Gate = child_child
                .gate_mut("netOut", 2usize)
                .expect("Internal macro err.");
            let mut netIn_gate2_ref: &mut des_core::Gate =
                self.gate_mut("netIn", 2usize).expect("Internal macro err.");
            let channel = rt.create_channel(des_core::ChannelMetrics {
                bitrate: 100usize,
                latency: des_core::SimTime::new(0.1f64),
                jitter: des_core::SimTime::new(0.1f64),
            });
            child_child_netOut_gate2.set_next_gate(netIn_gate2_ref.id());
            child_child_netOut_gate2.set_channel(channel);
            rt.create_module(child_child);
            self
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Bob {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Bob(ref __self_0_0) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Bob");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl Module for Bob {
        fn handle_message(&mut self, msg: Message) {
            if msg.kind == 0xff {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api_log(
                            ::core::fmt::Arguments::new_v1(
                                &["Initalizing"],
                                &match () {
                                    _args => [],
                                },
                            ),
                            lvl,
                            &("Bob", "ndl::members", "ndl\\members.rs", 53u32),
                        );
                    }
                };
                drop(msg);
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api_log(
                            ::core::fmt::Arguments::new_v1(
                                &["Dropped init msg"],
                                &match () {
                                    _args => [],
                                },
                            ),
                            lvl,
                            &("Bob", "ndl::members", "ndl\\members.rs", 55u32),
                        );
                    }
                };
                self.send(
                    Message::new(
                        1,
                        GATE_SELF,
                        self.id(),
                        MODULE_NULL,
                        SimTime::now(),
                        Packet::new(
                            (0x7f_00_00_01, 80),
                            (0x7f_00_00_02, 80),
                            String::from("Ping"),
                        ),
                    ),
                    ("netOut", 2),
                );
            } else {
                let mut pkt = msg.extract_content::<Packet>();
                pkt.inc_hop_count();
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api_log(
                            ::core::fmt::Arguments::new_v1(
                                &["Received at ", ": Message #", " content: "],
                                &match (
                                    &sim_time_fmt(),
                                    &pkt.id(),
                                    &pkt.extract_content_ref::<String>().deref(),
                                ) {
                                    _args => [
                                        ::core::fmt::ArgumentV1::new(
                                            _args.0,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            _args.1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            _args.2,
                                            ::core::fmt::Display::fmt,
                                        ),
                                    ],
                                },
                            ),
                            lvl,
                            &(
                                self.name().unwrap(),
                                "ndl::members",
                                "ndl\\members.rs",
                                75u32,
                            ),
                        );
                    }
                };
                pkt.extract_content_ref::<String>().push('#');
                self.send(
                    Message::new_interned(1, self.id(), SimTime::ZERO, pkt),
                    ("netOut", 2),
                );
            }
        }
    }
    impl NdlCompatableModule for Bob {
        fn named(name: String) -> Self {
            Self(ModuleCore::named(name))
        }
    }
    #[ndl_workspace = "ndl"]
    pub struct Eve(pub ModuleCore);
    impl ::des_core::StaticModuleCore for Eve {
        fn module_core(&self) -> &::des_core::ModuleCore {
            &self.0
        }
        fn module_core_mut(&mut self) -> &mut ::des_core::ModuleCore {
            &mut self.0
        }
    }
    impl ::des_core::NdlBuildableModule for Eve {
        fn build<A>(mut self: Box<Self>, rt: &mut des_core::NetworkRuntime<A>) -> Box<Self> {
            let _ = self.create_gate_cluster("link", 1usize);
            self
        }
    }
    impl Module for Eve {
        fn handle_message(&mut self, _msg: Message) {}
    }
    impl NdlCompatableModule for Eve {
        fn named(name: String) -> Self {
            Self(ModuleCore::named(name))
        }
    }
}
use members::*;
use rand::{prelude::StdRng, SeedableRng};
#[ndl_workspace = "ndl"]
struct A();
impl A {
    pub fn run(self) -> (Self, des_core::SimTime) {
        self.run_with_options(des_core::RuntimeOptions::default())
    }
    pub fn run_with_options(self, options: des_core::RuntimeOptions) -> (Self, des_core::SimTime) {
        use des_core::NetworkRuntime;
        use des_core::Runtime;
        let net_rt = self.build_rt();
        let rt = Runtime::<NetworkRuntime<Self>>::new_with(net_rt, options);
        let (net_rt, end_time) = rt.run().expect("RT exceeded itr limit.");
        (net_rt.finish(), end_time)
    }
    pub fn build_rt(self) -> NetworkRuntime<Self> {
        let mut runtime = des_core::NetworkRuntime::new(self);
        let rt: &mut des_core::NetworkRuntime<Self> = &mut runtime;
        let mut router_child: Box<Eve> = Eve::build_named("router", rt);
        let mut bob1_child: Box<Bob> = Bob::build_named("bob1", rt);
        let mut bob2_child: Box<Bob> = Bob::build_named("bob2", rt);
        let mut bob3_child: Box<Bob> = Bob::build_named("bob3", rt);
        let mut bob4_child: Box<Bob> = Bob::build_named("bob4", rt);
        let mut bob5_child: Box<Bob> = Bob::build_named("bob5", rt);
        let mut bob1_child_uplink_gate0: &mut des_core::Gate = bob1_child
            .gate_mut("uplink", 0usize)
            .expect("Internal macro err.");
        let mut router_child_link_gate0: &mut des_core::Gate = router_child
            .gate_mut("link", 0usize)
            .expect("Internal macro err.");
        let channel = rt.create_channel(des_core::ChannelMetrics {
            bitrate: 100usize,
            latency: des_core::SimTime::new(0.1f64),
            jitter: des_core::SimTime::new(0.1f64),
        });
        bob1_child_uplink_gate0.set_next_gate(router_child_link_gate0.id());
        bob1_child_uplink_gate0.set_channel(channel);
        rt.create_module(router_child);
        rt.create_module(bob1_child);
        rt.create_module(bob2_child);
        rt.create_module(bob3_child);
        rt.create_module(bob4_child);
        rt.create_module(bob5_child);
        runtime
    }
}
fn main() {
    let app: NetworkRuntime<A> = A().build_rt();
    let bob1_id = app.module(|m| m.name().unwrap() == "bob1").unwrap().id();
    let bob2_id = app.module(|m| m.name().unwrap() == "bob2").unwrap().id();
    let bob3_id = app.module(|m| m.name().unwrap() == "bob3").unwrap().id();
    let bob4_id = app.module(|m| m.name().unwrap() == "bob4").unwrap().id();
    let bob5_id = app.module(|m| m.name().unwrap() == "bob5").unwrap().id();
    let mut rt = Runtime::new_with(
        app,
        des_core::RuntimeOptions {
            sim_base_unit: des_core::SimTimeUnit::Seconds,
            rng: StdRng::seed_from_u64(0x123),
            max_itr: !0,
        },
    );
    for id in [bob1_id, bob2_id, bob3_id, bob4_id, bob5_id] {
        let msg = Message::new(
            0xff,
            GATE_NULL,
            MODULE_NULL,
            MODULE_NULL,
            SimTime::now(),
            String::from("Init"),
        );
        let arr_time = id.0 as f64 / 1000.0;
        rt.handle_message_on(id, msg, arr_time.into());
    }
    let (_, end_time) = rt.run().unwrap();
    {
        ::std::io::_print(::core::fmt::Arguments::new_v1(
            &["Sim finished ", "\n"],
            &match (&SimTimeUnit::fmt_compact(end_time, SimTimeUnit::Seconds),) {
                _args => [::core::fmt::ArgumentV1::new(
                    _args.0,
                    ::core::fmt::Display::fmt,
                )],
            },
        ));
    };
}
