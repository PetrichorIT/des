<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","mk","Developer","rust","des","des","src","doc","mod.rs"],"content":"//! Guide-level documentation\n//!\n//! DES offers multiple levels of abstraction to create\n//! discrete event-simulations. To illustrate the thoses\n//! tools a simple Ping-Pong simulation will be implemented using\n//! all three levels of abstraction:\n//!\n//! - A simple discrete-event-simulation using a custom event set [see here](pingpong_1),\n//! - A network-simulation using a generic network layer [see here](pingpong_2),\n//!\n\npub mod pingpong_1;\npub mod pingpong_2;\n// pub mod pingpong_3;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","doc","pingpong_1.rs"],"content":"//! Ping-Pong as a simple event simulation\n//!\n//! # The task\n//!\n//! Two nodes 'Ping' and 'Pong' can communicate with each other\n//! using a bidirection channel. 'Ping' sends 30 ping-messages\n//! with at an interval of 1s. 'Pong' receives the messages and\n//! responds with a pong-message, that 'Ping' receives. Both\n//! 'Ping' and 'Pong' count the number of messages received and send\n//! by them.\n//!\n//! # The simulation\n//!\n//! ### An event-set\n//!\n//! When constructing a simple event simulation, an event set must be provided.\n//! This event-set should be able to represent all activity that can happen\n//! within the scope of the simulation. If this cast this encompasses:\n//!\n//! - The 1s interval to send ping-messages\n//! - The ping-messages that will be received by 'Pong'\n//! - The pong-message that will be received by 'Ping'\n//!\n//! Accordingly an event set can be constructed:\n//!\n//! ```rust\n//! use des::prelude::*;\n//! use des::event_set;\n//!\n//! event_set!(\n//!     enum PingPongEventSet {\n//!         type App = PingPongApp;\n//!     \n//!         IntervalEvent(IntervalEvent),\n//!         PingArrival(PingArrival),\n//!         PongArrival(PongArrival),\n//!     };\n//! );\n//!\n//! struct IntervalEvent;\n//! struct PingArrival;\n//! struct PongArrival;\n//! #\n//! # struct PingPongApp { /* ... */ }\n//! # impl Application for PingPongApp {\n//! #    type EventSet = PingPongEventSet;\n//! #    type Lifecycle = ();\n//! # }\n//! # impl Event\u003cPingPongApp\u003e for IntervalEvent { fn handle(self, _rt: \u0026mut Runtime\u003cPingPongApp\u003e) {} }\n//! # impl Event\u003cPingPongApp\u003e for PingArrival { fn handle(self, _rt: \u0026mut Runtime\u003cPingPongApp\u003e) {} }\n//! # impl Event\u003cPingPongApp\u003e for PongArrival { fn handle(self, _rt: \u0026mut Runtime\u003cPingPongApp\u003e) {} }\n//! ```\n//!\n//! ### An application\n//!\n//! However to define an event-set you must define an application first.\n//! This application serves as a global persistent storage point that manages\n//! the lifecycle of the simulation. To define a application define a\n//! abitray type that implements the trait [Application](crate::runtime::Application).\n//! In this example we will use the application to record messages and check the number\n//! of messages after the simulation has concluded:\n//!\n//! ```rust\n//! # use des::prelude::*;\n//! #[derive(Debug)]\n//! struct PingPongApp {\n//!     pings_send: usize,\n//!     pings_recv: usize,\n//!     pongs_send: usize,\n//!     pongs_recv: usize,\n//! }\n//!\n//! impl Application for PingPongApp {\n//!     type EventSet = PingPongEventSet;\n//!     type Lifecycle = Self;\n//! }\n//! impl EventLifecycle for PingPongApp {\n//!     fn at_sim_end(rt: \u0026mut Runtime\u003cSelf\u003e) {\n//!         assert_eq!(rt.app.pings_send, 30);\n//!         assert_eq!(rt.app.pings_recv, 30);\n//!         assert_eq!(rt.app.pongs_send, 30);\n//!         assert_eq!(rt.app.pongs_recv, 30);    \n//!     }\n//! }\n//! # struct PingPongEventSet;\n//! # impl EventSet\u003cPingPongApp\u003e for PingPongEventSet { fn handle(self, _: \u0026mut Runtime\u003cPingPongApp\u003e) {} }\n//! ```\n//!\n//! ### The event handlers\n//!\n//! Now we have to specify what happens when a event is executed. Therefor each event in the event set\n//! must implement the trait [Event](crate::runtime::Event). This trait includes a handler that consumes\n//! the event itself, while holding a reference to the runtime to create new event if nessecary. In\n//! out example we shall first define the interval event which sends messages from 'Ping' to\n//! 'Pong':\n//!\n//! ```rust\n//! # use des::prelude::*;\n//! # struct IntervalEvent;\n//! impl Event\u003cPingPongApp\u003e for IntervalEvent {\n//!     fn handle(self, rt: \u0026mut Runtime\u003cPingPongApp\u003e) {\n//!         // Send a ping message, that will arrive in 20ms\n//!         rt.add_event_in(PingArrival, Duration::from_millis(20));\n//!         rt.app.pings_send += 1;\n//!         // reschedule the interval event\n//!         if SimTime::now().as_secs() \u003c 30 {\n//!             rt.add_event_in(self, Duration::from_secs(1));\n//!         }\n//!     }\n//! }\n//! # struct PingPongApp { pings_send: usize }\n//! # struct PingPongEventSet {}\n//! # impl Application for PingPongApp { type EventSet = PingPongEventSet; type Lifecycle = (); }\n//! # impl EventSet\u003cPingPongApp\u003e for PingPongEventSet { fn handle(self, _: \u0026mut Runtime\u003cPingPongApp\u003e) {}}\n//! # impl From\u003cIntervalEvent\u003e for PingPongEventSet { fn from(_: IntervalEvent) -\u003e Self { todo!() }}\n//! # struct PingArrival;\n//! # impl From\u003cPingArrival\u003e for PingPongEventSet { fn from(_: PingArrival) -\u003e Self { todo!() }}\n//! ```\n//!\n//! After that lets, define what happens once the ping-message arrives:\n//!\n//! ```rust\n//! # use des::prelude::*;\n//! # struct PingArrival;\n//! impl Event\u003cPingPongApp\u003e for PingArrival {\n//!     fn handle(self, rt: \u0026mut Runtime\u003cPingPongApp\u003e) {\n//!         // Bounce back a pong message, that will arrive in 20ms\n//!         rt.add_event_in(PongArrival, Duration::from_millis(20));\n//!         rt.app.pings_recv += 1;\n//!         rt.app.pongs_send += 1;\n//!     }\n//! }\n//! # struct PingPongApp { pings_recv: usize, pongs_send: usize }\n//! # struct PingPongEventSet {}\n//! # impl Application for PingPongApp { type EventSet = PingPongEventSet; type Lifecycle = (); }\n//! # impl EventSet\u003cPingPongApp\u003e for PingPongEventSet { fn handle(self, _: \u0026mut Runtime\u003cPingPongApp\u003e) {}}\n//! # impl From\u003cPingArrival\u003e for PingPongEventSet { fn from(_: PingArrival) -\u003e Self { todo!() }}\n//! # struct PongArrival;\n//! # impl From\u003cPongArrival\u003e for PingPongEventSet { fn from(_: PongArrival) -\u003e Self { todo!() }}\n//! ```\n//!\n//! And finally lets define what happens once the pong arrives:\n//!\n//! ```rust\n//! # use des::prelude::*;\n//! # struct PongArrival;\n//! impl Event\u003cPingPongApp\u003e for PongArrival {\n//!     fn handle(self, rt: \u0026mut Runtime\u003cPingPongApp\u003e) {\n//!         rt.app.pongs_recv += 1;\n//!     }\n//! }\n//! # struct PingPongApp { pongs_recv: usize }\n//! # struct PingPongEventSet {}\n//! # impl Application for PingPongApp { type EventSet = PingPongEventSet;type Lifecycle = ();  }\n//! # impl EventSet\u003cPingPongApp\u003e for PingPongEventSet { fn handle(self, _: \u0026mut Runtime\u003cPingPongApp\u003e) {}}\n//! ```\n//!\n//! # The main function\n//!\n//! Now we have createa all that is nessecary to perform our event simulation.\n//! Thus we must define the main function and provide the inital event that is nessecary.\n//!\n//! ````rust\n//! # use des::prelude::*;\n//! fn main() {\n//!     # return;\n//!     let app = PingPongApp {\n//!         pings_send: 0, pings_recv: 0,\n//!         pongs_send: 0, pongs_recv: 0,\n//!     };\n//!     let mut rt = Builder::new().build(app);\n//!     rt.add_event(IntervalEvent, SimTime::ZERO);\n//!     let result = rt.run();\n//!     println!(\"{:?}\", result);\n//! }\n//! # #[derive(Debug)]\n//! # struct PingPongApp { pings_send: usize, pings_recv: usize, pongs_send: usize, pongs_recv: usize }\n//! # struct PingPongEventSet {}\n//! # struct IntervalEvent;\n//! # impl Application for PingPongApp { type EventSet = PingPongEventSet;type Lifecycle = ();  }\n//! # impl EventSet\u003cPingPongApp\u003e for PingPongEventSet { fn handle(self, _: \u0026mut Runtime\u003cPingPongApp\u003e) {}}\n//! # impl From\u003cIntervalEvent\u003e for PingPongEventSet { fn from(_: IntervalEvent) -\u003e Self { todo!()}}\n//! ````\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","doc","pingpong_2.rs"],"content":"//! Ping-Pong as a generic network-simulation\n//!\n//! # The task\n//!\n//! Two nodes 'Ping' and 'Pong' want to communicate with each other\n//! using a bidirection channel. 'Ping' sends a total of 30 `Ping`-messages\n//! in intervals of 1s. 'Pong' receives these messages and\n//! responds with a `Pong`-Message, that 'Ping' receives. Both\n//! 'Ping' and 'Pong' count the number of messages received and send\n//! by them.\n//!\n//! # The simulation\n//!\n//! This network-simulation is created by using the features `net` and `ndl`.\n//!\n//! ### NDL\n//!\n//! The feature `net` provides the core abstractions for a network-like\n//! simulation. These are Modules, Gates and Channels. Modules represent\n//! network nodes with custom state and behaviour. They are user defined\n//! and can be created by implementing the [`Module`](crate::net::module::Module)\n//! trait on a type. Gates act as physical (or logical) ports on a module. They can be\n//! chained together into gate-chains, thus connecting multiple modules.\n//! By default gate-chains act as link with infinite bandwith and zero latency.\n//! If a gate-chain should act as a real physical link would do, Channels\n//! can be attached to a gate chain to define the delay / drop metric of the link.\n//!\n//! While the feature `net` provides the appropiate base abstractions, creating\n//! a network can be tiresome. However, using the feature `ndl`, users\n//! can automatically create networks by defining just the networks\n//! topology using the `NetworkDescriptionLanguage`. Such definitions\n//! can be placed in files ending in '.ndl'. This language desribes networks\n//! as a topology of modules, gates and links, without requiring any custom\n//! logic that will later be associated with the modules. At first let's\n//! describe the network at hand:\n//!\n//! ```text\n//! // 'Main.ndl'\n//! module Ping {\n//!     gates {\n//!         in @input,\n//!         out @output,\n//!     }\n//! }\n//!\n//! module Pong {\n//!     gates {\n//!         in @input,\n//!         out @output,\n//!     }\n//! }\n//! ```\n//!\n//! We define two module, 'Ping' and 'Pong' that both possesing two gates.\n//! Links in NDL are unidirectional so each modules requires two to facilitate bidirectional\n//! communication. Gates can also be annotated with their typ (input or output) to prevent\n//! unwanted topologies. Using this definition, both modules can be sure, that all incoming\n//! packets must come via the 'in' gate. Now using the basic definition of our two modules\n//! we may create our network.\n//!\n//! ```text\n//! // 'Main.ndl'\n//! link MyLink {\n//!     bitrate: 100000\n//!     latency: 0.1\n//!     jitter: 0.0\n//! }\n//!\n//! module MyNetwork {\n//!     submodules {\n//!         ping: Ping,\n//!         pong: Pong,\n//!     }\n//!     connections {\n//!         ping/out --\u003e MyLink --\u003e pong/in,\n//!         pong/out --\u003e MyLink --\u003e ping/in,\n//!     }\n//! }\n//!\n//! entry MyNetwork;\n//! ```\n//!\n//! The module `MyNetwork` represents the entry point to our simulation. While `MyNetwork` itself could\n//! act as a network node, it is more of an abstract composite node in this example. By declaring\n//! two submodules 'ping' and 'pong' we declare, that each instance of `MyNetwork` should contain\n//! a `Ping` and a `Pong` instance. In the connections section we define a link (gate-chain)\n//! between the output gate of 'ping' and the input gate if 'pong' (and vice versa).\n//! This gate chain will be augmented using a Channel with the characteristics defined\n//! on `MyLink`. Finally we declare the module `MyNetwork` to be the entry point / root of\n//! our network.\n//!\n//! # The Modules\n//!\n//! Once we have defined the network topology, modules can be defined in rust code.\n//! For that you may define a struct or enum of the with the same name as the described\n//! module.\n//!\n//! ```\n//! # use des::prelude::*;\n//! struct Ping {\n//!     pongs_recv: usize,\n//!     pings_send: usize,\n//! }\n//! struct Pong {\n//!     pings_recv: usize,\n//!     pongs_send: usize,\n//! }\n//! ```\n//!\n//! This trait provides a number of available functions.\n//! This function should be used to create a new instance of the custom state for a\n//! network node. Note that this function is not nessecryly executed within the context\n//! of an event, so dont put complex custom logic here.\n//!\n//! ```rust\n//! # use des::prelude::*;\n//! # struct Ping { pongs_recv: usize, pings_send: usize }\n//! # struct Pong { pings_recv: usize, pongs_send: usize }\n//! /* ... */\n//!\n//! impl Module for Ping {\n//!     /* ... */\n//! }\n//!\n//! impl Module for Pong {\n//!     /* ... */\n//! }\n//! ```\n//!\n//! The `Module` trait also provide some other useful functions, that can be overrided.\n//! [`Module::handle_message`](crate::net::module::Module::handle_message)\n//!  is called when a packet arrives at the module. This function\n//! is the heart of most network simulations.\n//! [`Module::at_sim_start`](crate::net::module::Module::at_sim_start) provides a way to\n//! handle more complex logic when the simulation is stared, but now within a fully constructed\n//! topology.  [`Module::at_sim_end`](crate::net::module::Module::at_sim_end)\n//! can be used to make module-specific actions once the simulation is finished,\n//! such as writing metrics to a file, or deallocating internal containers.\n//!\n//! ```\n//! # use des::prelude::*;\n//! # struct Ping { pongs_recv: usize, pings_send: usize }\n//! # struct Pong { pings_recv: usize, pongs_send: usize }\n//! const PING: MessageKind = 10;\n//! const PONG: MessageKind = 42;\n//! const WAKEUP: MessageKind = 69;\n//!\n//! impl Module for Ping {\n//!     /* ... */\n//!\n//!     fn at_sim_start(\u0026mut self, _stage: usize) {\n//!         // Create the inital wakeup event.\n//!         schedule_at(Message::new().kind(WAKEUP).build(), SimTime::ZERO)\n//!     }\n//!\n//!     fn handle_message(\u0026mut self, msg: Message) {\n//!         match msg.header().kind {\n//!             WAKEUP =\u003e {\n//!                 // Send a PING every 1s, for the first 30s\n//!                 send(Message::new().kind(PING).build(), \"out\");\n//!                 self.pings_send += 1;\n//!                 if SimTime::now().as_secs() \u003c 30 {\n//!                     schedule_in(msg, Duration::from_secs(1));\n//!                 }\n//!             },\n//!             PONG =\u003e self.pongs_recv += 1,\n//!             _ =\u003e todo!()\n//!         }    \n//!     }\n//!\n//!     fn at_sim_end(\u0026mut self) {\n//!         assert_eq!(self.pongs_recv, 30);\n//!         assert_eq!(self.pings_send, 30);\n//!     }\n//! }\n//!\n//! impl Module for Pong {\n//!     /* ... */\n//!\n//!     fn handle_message(\u0026mut self, msg: Message) {\n//!         assert_eq!(msg.header().kind, PING);\n//!         self.pings_recv += 1;\n//!         send(Message::new().kind(PONG).build(), \"out\");\n//!         self.pongs_send += 1;\n//!     }\n//!\n//!     fn at_sim_end(\u0026mut self) {\n//!         assert_eq!(self.pings_recv, 30);\n//!         assert_eq!(self.pongs_send, 30);\n//!     }\n//! }\n//! ```\n//!\n//! ### The app\n//!\n//! Now that we have defined the **real** modules we can do the same with the  more abstract modules.\n//! Since we dont have any intersting buisness logic for this module, we just\n//! insert some placeholder code.\n//!\n//! ```\n//! # use des::prelude::*;\n//! /* ... */\n//!\n//! struct MyTestCase;\n//! impl Module for MyTestCase {\n//! }\n//! ```\n//!\n//! Now we have defined everything to create the simulation. To do that create an\n//! NDL simulation to load our network topology. This application requies\n//! a [`Registry`](crate::ndl::Registry) of all known modules types, to link the Ndl-Modules to their rust struct.\n//! This application can be used to instantiate a [`Sim`](crate::net::Sim)\n//! (provided by feature `net`),\n//! which in turn can be passed to the core [`Runtime`](crate::runtime::Runtime) of [`des`](crate).\n//! This runtime can than be executed, to run the simulation to its end.\n//!\n//! ```\n//! # use des::prelude::*;\n//! # use des::registry;\n//! # #[derive(Default)]\n//! # struct Ping;\n//! # impl Module for Ping {}\n//! # #[derive(Default)]\n//! # struct Pong;\n//! # impl Module for Pong {}\n//! # #[derive(Default)]\n//! # struct MyTestCase;\n//! # impl Module for MyTestCase {}\n//! /* ... */\n//!\n//! fn main() {\n//!     # return;\n//!     let app = Sim::ndl(\"main.ndl\", registry![Ping, Pong, MyTestCase]).unwrap();\n//!     let rt = Builder::new().build(app);\n//!     let result = rt.run();\n//!     println!(\"{:?}\", result);\n//! }\n//! ```\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","doc","pingpong_3.rs"],"content":"//! Ping-Pong as an asynchronous network-simulation with TCP socket\n//!\n//!\n//!\n//! ```\n//! use des::prelude::*;\n//! use des::registry;\n//! use inet::interface::*;\n//!\n//! struct Ping;\n//!\n//! \n//! impl AsyncModule for Ping {\n//!     fn new() -\u003e Ping {\n//!         Ping\n//!     }\n//!\n//!     async fn at_sim_start(\u0026mut self, _: usize) {\n//!         add_interface(\n//!             Interface::ethv4(\n//!                 NetworkDevice::eth(),\n//!                 Ipv4Addr::new(209, 0, 3, 103)\n//!             )\n//!         );\n//!\n//!         let sock = inet::UdpSocket::bind(\"0.0.0.0:0\").await.unwrap();\n//!         /* ... */\n//!     }\n//! }\n//!\n//! fn main() {\n//!     # return;\n//!     inet::init();\n//!     let app = NdlApplication::new(\"path/to/ndl\", registry![Ping])\n//!         .map_err(|e| println!(\"{e}\"))\n//!         .unwrap();\n//!     let rt = Runtime::new(NetworkApplication::new(app));\n//!     let _  = rt.run();\n//! }\n//! ```\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","lib.rs"],"content":"// Lints\n#![deny(unused_must_use)]\n#![warn(clippy::pedantic)]\n#![warn(missing_docs, missing_debug_implementations, unreachable_pub)]\n#![allow(\n    clippy::needless_doctest_main,\n    clippy::module_name_repetitions,\n    clippy::arc_with_non_send_sync\n)]\n\n//!\n//! A discrete event simulator.\n//!\n//! DES is a discrete event simulation tool that makes building simulations for\n//! networks easy. DES provides the tools to build a event simulation from the\n//! groud up, with a implemented module system or with a asynchronous context in\n//! mind.\n//!\n//! # Building a simple event simulation\n//!\n//! At its core DES provides the tools to easily and efficently build an event simulation\n//! with completely generic event set. This can be done independent of features used,\n//! but usually only optimization features like `cqueue` or montioring tools like `metrics`\n//! are used in this context.\n//!\n//! ```\n//! use des::prelude::*;\n//!\n//! enum MyEventSet {\n//!     EventA { what_happend: String },\n//!     EventB { ack: bool },\n//! }\n//!\n//! impl EventSet\u003cMyApp\u003e for MyEventSet {\n//!     fn handle(self, _rt: \u0026mut Runtime\u003cMyApp\u003e) {\n//!         // Do something\n//!     }\n//! }\n//!\n//! #[derive(Default)]\n//! struct MyApp {\n//!     global_value: usize,\n//!     logs: Vec\u003cString\u003e,\n//! }\n//!\n//! impl Application for MyApp {\n//!     type EventSet = MyEventSet;\n//!     type Lifecycle = ();\n//! }\n//!\n//! fn main() {\n//!     let app = MyApp::default();\n//!     let rt = Builder::new().build(app);\n//!     let result = rt.run();\n//! }\n//! ```\n//!\n//! This simulation will now provide a [`runtime`] with\n//! [`time`] managment and a future event set to execute events.\n//! If a event is executed [`MyEventSet::handle`](crate::runtime::EventSet::handle)\n//! will be called with the runtime as parameter. If new events are to be created\n//! as result of a event execution this mutable reference can be used\n//! to add new events to the future event set.\n//!\n//! The [`Application`](crate::runtime::Application) object (in this case `MyApp`) is used as a global context handle that\n//! it stored inside the runtime. It can be accessed via 'rt.app' and can be used\n//! to record state during the simulation. Note that the [`EventSet`](crate::runtime::EventSet)\n//! and the [`Application`](crate::runtime::Application) are linked via a trait with generic parameters. This means\n//! that `MyEvents` could implement [`EventSet`](crate::runtime::EventSet) a second time for another application.\n//!\n//! # Using a module oriented system\n//!\n//! DES is able to provide tools for simulating network-like structures with [Modules](crate::net::module::Module).\n//! These modules are self contained units with their own state, connected via [Channels](crate::net::channel::Channel)\n//! (network links) that are attached to [Gates](crate::net::gate::Gate) (physical ports) on modules.\n//! Modules can send messages (packtes) through these gates / channels to communicated\n//! with other modules. Additionally modules can be created in a tree like structure,\n//! providing links like [`parent`] or [`child`].\n//!\n//! These tools are available in the [`net`] module\n//! when the feature `net` is active.\n//!\n//! ```toml\n//! des = { version = \"*\", features = [ \"net\" ] }\n//! ```\n//!\n//! # Asynchrounous simulation\n//!\n//! As a final addition DES provides tools for dealing with the simulation of\n//! asynchronous systems through the feature `async`.\n//! These tools are build onto of the feature `net` and\n//! help with asynchronously managing module activity. With this feature\n//! active, network-primitives like `TcpListener` or `UdpSocket`,\n//! as well as time-primitives like `des::time::sleep` can be\n//! used.\n//!\n//! ```toml\n//! des = { version = \"*\", features = [ \"net\", \"async\" ] }\n//! ```\n//!\n//! While this feature activates smaller additions to the existing functionallity of\n//! [`net`], it also contains a full reexport of [tokio](https://docs.rs/tokio) with modifications\n//! to fit the simulation context. This version of tokio is implicitly reexported with the\n//! newly added feature sim to integrate into a simulation context and thus does NOT\n//! provide access to the [`fs`](https://docs.rs/tokio/latest/tokio/fs/index.html),\n//! [`signal`](https://docs.rs/tokio/latest/tokio/signal/index.html) or modules.\n//! Additionally this version only supports current-thread runtimes.\n//!\n//! However it supports all synchronisation primitives (excluding Barrier)\n//! through the [`sync`](tokio::sync) module, asynchronous green tasks\n//! through [`task`](tokio::task), custom runtimes through [`runtime`](tokio::runtime)\n//! and simulation specific time primitives through [`time`] replacing the\n//! standart [`time`](https://docs.rs/tokio/latest/tokio/time/index.html) module,\n//! aswell as simulation specifc network primitives replacing the standart\n//! [`net`](https://docs.rs/tokio/latest/tokio/net/index.html) module.\n//!\n//! [`time`]: crate::time\n//! [`net`]: crate::net\n//! [`runtime`]: crate::runtime\n//! [`parent`]: crate::net::module::ModuleContext::parent\n//! [`child`]: crate::net::module::ModuleContext::child\n\n#[macro_use]\n#[doc(hidden)]\npub mod macros;\n\npub(crate) mod sync;\n\npub mod prelude;\n\npub mod doc;\npub mod runtime;\npub mod time;\n\ncfg_net! {\n    pub mod net;\n    pub mod tracing;\n}\n\ncfg_ndl! {\n    pub mod ndl;\n}\n\ncfg_macros! {\n    pub use des_macros::*;\n}\n\n// # Features\n//\n// | Feature          | Description                                                              |\n// |------------------|--------------------------------------------------------------------------|\n// | net              | Adds a module oriented design-abstraction that provides its own events.  |\n// | cqueue           | Configures the runtime to use a calender queue for better performance.   |\n// | metrics | Collects internal metrics about the runtime, to improve parametrization. |\n// | async            | Provides utilites and modifications for simulating asynchronous systems including a full reexport of safe tokio funtions. |\n//\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","macros","cfg.rs"],"content":"#![allow(unused_macros)]\n\nmacro_rules! cfg_net {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(feature = \"net\")]\n            #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_ndl {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(feature = \"ndl\")]\n            #[cfg_attr(docsrs, doc(cfg(feature = \"ndl\")))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_macros {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(feature = \"macros\")]\n            #[cfg_attr(docsrs, doc(cfg(feature = \"macros\")))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_async {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(feature = \"async\")]\n            #[cfg_attr(docsrs, doc(cfg(feature = \"async\")))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_not_async {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(not(feature = \"async\"))]\n            #[cfg_attr(docsrs, doc(cfg(not(feature = \"async\"))))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_multi_threaded {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(feature = \"multi-threaded\")]\n            #[cfg_attr(docsrs, doc(cfg(feature = \"multi-threaded\")))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_not_multi_threaded {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(not(feature = \"multi-threaded\"))]\n            #[cfg_attr(docsrs, doc(cfg(not(feature = \"multi-threaded\"))))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_cqueue {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(feature = \"cqueue\")]\n            #[cfg_attr(docsrs, doc(cfg(feature = \"cqueue\")))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_not_cqueue {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(not(feature = \"cqueue\"))]\n            #[cfg_attr(docsrs, doc(cfg(not(feature = \"cqueue\"))))]\n            $item\n        )*\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","macros","event_set.rs"],"content":"///\n/// A declaritive macro for generating event sets.\n///\n/// This macro combines an number of types that implement [`Event`](crate::runtime::Event)\n/// into an `EventSet` for an application 'App'.\n///\n/// ```rust\n/// # use des::prelude::*;\n/// # use des::event_set;\n/// struct PingEvent;\n/// struct PongEvent;\n/// /* ... */\n/// # impl Event\u003cApp\u003e for PingEvent { fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) { } }\n/// # impl Event\u003cApp\u003e for PongEvent { fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) { } }\n///\n/// struct App;\n/// impl Application for App {\n///     /* ... */\n/// #   type EventSet = Events;\n/// #   type Lifecycle = ();\n/// }\n///\n/// event_set! {\n///     #[derive(Debug)]\n///     pub enum Events {\n///         type App = App;\n///         \n///         PingEvent(PingEvent),\n///         PongEvent(PongEvent),\n///     };\n/// }\n/// ```\n#[macro_export]\nmacro_rules! event_set {\n\n    (\n        $(#[$outer:meta])*\n        $vis: vis enum $ident: ident {\n            type App = $ty:ident \u003c $( $N:ident $(: $b0:ident $(+$b:ident)* )? ),* \u003e;\n\n            $(\n                $variant:ident($variant_ty: ty),\n            )+\n        };\n    ) =\u003e {\n        $(#[$outer])*\n        $vis enum $ident {\n            $(\n                $variant($variant_ty),\n            )+\n        }\n\n        impl\u003c $( $N $(: $b0 $(+$b)* )? ),* \u003e EventSet\u003c$ty\u003c $( $N ),* \u003e\u003e for $ident {\n            fn handle(self, rt: \u0026mut Runtime\u003c$ty\u003c $( $N ),* \u003e\u003e) {\n                match self {\n                    $(\n                        Self::$variant(event) =\u003e event.handle(rt),\n                    )+\n                }\n            }\n        }\n\n        $(\n            impl From\u003c$variant_ty\u003e for $ident {\n                fn from(variant: $variant_ty) -\u003e Self {\n                    Self::$variant(variant)\n                }\n            }\n        )+\n    };\n    (\n        $(#[$outer:meta])*\n        $vis: vis enum $ident: ident {\n            type App = $ty:ident;\n\n            $(\n                $variant: ident($variant_ty: ty),\n            )+\n        };\n    ) =\u003e {\n        $crate::event_set!(\n            $vis enum $ident {\n                type App = $ty\u003c\u003e;\n\n                $(\n                    $variant($variant_ty),\n                )+\n            };\n        );\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","macros","mod.rs"],"content":"#[macro_use]\nmod cfg;\n\n#[doc(hidden)]\npub mod support;\n\ncfg_macros! {\n    #[macro_use]\n    mod event_set;\n\n    cfg_ndl! {\n        mod registry;\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","macros","registry.rs"],"content":"/// Creates a registry of types that implement [`Module`](crate::net::module::Module),\n/// to link rust structs to NDL modules.\n///\n/// The listing of types can be optionally suffixed with\n/// `else \u003csome_type\u003e`  to declare a fallback module\n/// in the [`Registry`](crate::ndl::Registry). The suffix `else _`\n/// declarse the default fallback module.\n///\n/// # Example\n///\n/// ```rust\n/// # use des::prelude::*;\n/// # use des::registry;\n/// #[derive(Default)]\n/// struct DnsServer;\n/// /* ... */\n/// # impl Module for DnsServer {}\n/// #[derive(Default)]\n/// struct Client;\n/// /* ... */\n/// # impl Module for Client {}\n/// #[derive(Default)]\n/// struct Server;\n/// # impl Module for Server {}\n/// /* ... */\n///\n/// # use des_ndl::error::RootResult as Result;\n/// fn main() -\u003e Result\u003c()\u003e {\n///     let registry = registry![DnsServer, Client, Server, else _];\n///     # return Ok(());\n///     let app = Sim::ndl(\"path/to/ndl\", registry)?;\n///     let rt = Builder::new().build(app);\n///     let r = rt.run();\n/// }\n/// ```\n#[macro_export]\nmacro_rules! registry {\n    ($($t:ty),*) =\u003e {{\n        use $crate::ndl::RegistryCreatable;\n        use $crate::net::module::Module;\n\n        let mut registry = $crate::ndl::Registry::new();\n        $(\n            registry = registry.symbol(stringify!($t), |path| \u003c$t as RegistryCreatable\u003e::create(path, stringify!($t)));\n        )*\n\n        registry\n    }};\n\n    ($($t:ty),*, else _) =\u003e {{\n        use $crate::ndl::RegistryCreatable;\n        use $crate::net::module::Module;\n\n        let mut registry = $crate::ndl::Registry::new();\n        $(\n            registry = registry.symbol(stringify!($t), |path| \u003c$t as RegistryCreatable\u003e::create(path, stringify!($t)));\n        )*\n\n        registry.with_default_fallback()\n    }};\n\n    ($($t:ty),*, else $f:ty) =\u003e {{\n        use $crate::ndl::RegistryCreatable;\n        use $crate::net::module::Module;\n\n        let mut registry = $crate::ndl::Registry::new();\n        $(\n            registry = registry.symbol(stringify!($t), |path| \u003c$t as RegistryCreatable\u003e::create(path, stringify!($t)));\n        )*\n\n        registry.with_fallback(|| \u003c$f as std::default::Default\u003e::default())\n    }};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","macros","support.rs"],"content":"use std::ops::{Deref, DerefMut};\n\npub(crate) struct SyncWrap\u003cT\u003e {\n    inner: T,\n}\n\nimpl\u003cT\u003e SyncWrap\u003cT\u003e {\n    pub(crate) const fn new(item: T) -\u003e Self {\n        Self { inner: item }\n    }\n}\n\nimpl\u003cT\u003e Deref for SyncWrap\u003cT\u003e {\n    type Target = T;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.inner\n    }\n}\n\nimpl\u003cT\u003e DerefMut for SyncWrap\u003cT\u003e {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.inner\n    }\n}\n\n// SAFTY:\n// This wrapper should only be used to make statics thread safe,\n// since by design event simulation is single-threded (in the same context).\nunsafe impl\u003cT\u003e Sync for SyncWrap\u003cT\u003e {}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":422524},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":422524},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":5},{"path":["/","Users","mk","Developer","rust","des","des","src","ndl","mod.rs"],"content":"//! Integration of the Network-Description-Language (NDL).\n//!\n//! # What is NDL ?\n//!\n//! NDL is a decriptory language for defining network topologies.\n//! Refer to [`des_ndl`] for more information.\n//!\n//! # How to use it ?\n//!\n//! This submodule provides an [`Sim::ndl`] that can create a simulation\n//! that builsd a network based on a given topology.\n//! Users can create such an application by providing the path to the\n//! root file of the NDL description, and by providing a registry of modules.\n//! This registry is used to link names of network nodes in NDL to associated\n//! structs that implmenent [`Module`](crate::net::module::Module).\n//! By proving both parameters, the application will load the topology and check\n//! whether the network can be build. If not an descriptive error will be returned.\n//!\n//! ```\n//! # use des::prelude::*;\n//! # use des::ndl::*;\n//! # use des::registry;\n//! #[derive(Default)]\n//! struct ModuleA;\n//! /* ... */\n//!\n//! #[derive(Default)]\n//! struct ModuleB;\n//! /* ... */\n//!\n//! # impl Module for ModuleA {}\n//! # impl Module for ModuleB {}\n//! fn main() {\n//!     # return;\n//!     let app = match Sim::ndl(\"path/to/ndl.ndl\", registry![ModuleA, ModuleB]) {\n//!         Ok(v) =\u003e v,\n//!         Err(e) =\u003e {\n//!             println!(\"{e}\");\n//!             return;\n//!         },\n//!     };\n//!     let rt = Builder::new().build(app);\n//!     let _ = rt.run();\n//! }\n//! ```\n\nuse crate::{\n    net::{channel::ChannelDropBehaviour, module::ModuleContext, ScopedSim, Sim},\n    prelude::{Channel, ChannelMetrics, ModuleRef, ObjectPath},\n    time::Duration,\n};\nuse des_ndl::{\n    error::{Error, ErrorKind, Errors, ErrorsMut, RootError, RootResult},\n    ir::{self, ConnectionEndpoint},\n    Context,\n};\nuse std::{path::Path, sync::Arc};\n\nmod registry;\npub use self::registry::*;\n\nimpl Sim\u003c()\u003e {\n    /// Creates a NDL application with the inner application `()`.\n    ///\n    /// See [`Sim::ndl_with`] for more information.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error, if the provided NDL topology is\n    /// erronous, or the software requirements cannot be fulfilled by the registry.\n    pub fn ndl(path: impl AsRef\u003cPath\u003e, registry: impl AsRef\u003cRegistry\u003e) -\u003e RootResult\u003cSelf\u003e {\n        Self::ndl_with(path, registry, ())\n    }\n}\n\nimpl\u003cA\u003e Sim\u003cA\u003e {\n    /// Creates an NDL application from a topology description at `path`, with\n    /// software defined by `registry` and an inner application `inner`.\n    ///\n    /// The NDL topology desciption found at `path` describes a module tree\n    /// including a root module at the path `\"\"`. Each node in this tree\n    /// is derived from a NDL Module. The name of this module prototype\n    /// is the symbol used in accessed to the registry. The NDL topology\n    /// additionally includes gate and gate-chain definitions.\n    ///\n    /// The tree is initalized depth first. This means for each module:\n    /// - First the gate of the current module are created\n    /// - Then all children are created, including gates **and** connections\n    /// - Then all connections are resolved, since connections statements may depend\n    ///   on the existence of gates in child nodes\n    ///\n    /// The provided parameter `registry` is resposible for attaching software\n    /// to the nodes defined by the topology description. Should the registry\n    /// fail to provide software for a node, this function will fail.\n    ///\n    /// The inner application `inner` is equivalent the inner application\n    /// object of a network simulation, which can be used to define custom\n    /// actions at sim start / end.\n    ///\n    /// **NOTE** that the nodes will be created with a call to this function.\n    ///\n    /// # Errors\n    ///\n    /// Some Errors\n    pub fn ndl_with(\n        path: impl AsRef\u003cPath\u003e,\n        registry: impl AsRef\u003cRegistry\u003e,\n        inner: A,\n    ) -\u003e RootResult\u003cSelf\u003e {\n        let mut this = Sim::new(inner);\n        this.build_ndl(path, registry)?;\n        Ok(this)\n    }\n\n    /// Builds a NDL based application with onto an allready existing [`Sim`] object.\n    ///\n    /// See [`Sim::ndl_with`] for more infomation.\n    ///\n    /// # Errors\n    ///\n    /// This function will fail if either:\n    /// a) some NDL error occures when parsing the NDL tree defined at `path`,\n    /// b) or the registry fails to provide software for some NDL-defined module.\n    pub fn build_ndl(\n        \u0026mut self,\n        path: impl AsRef\u003cPath\u003e,\n        registry: impl AsRef\u003cRegistry\u003e,\n    ) -\u003e RootResult\u003c()\u003e {\n        let mut ctx = Context::load(path)?;\n        let tree = ctx\n            .entry\n            .take()\n            .expect(\"internal NDL error: entry point must be provided on Ok(Context)\");\n\n        let mut errors = Errors::new().as_mut();\n\n        let scoped = ScopedSim::new(self, ObjectPath::default());\n        let _ = scoped.ndl(tree, \u0026mut errors, registry.as_ref());\n\n        if errors.is_empty() {\n            Ok(())\n        } else {\n            Err(RootError::new(errors.into_inner(), ctx.smap))\n        }\n    }\n\n    fn raw_ndl(\n        \u0026mut self,\n        path: \u0026ObjectPath,\n        ty: \u0026str,\n        registry: \u0026Registry,\n        errors: \u0026mut ErrorsMut,\n    ) -\u003e ModuleRef {\n        // Check dup\n        assert!(\n            self.modules().get(path).is_none(),\n            \"cannot crate module at {path}, allready exists\"\n        );\n\n        // Check node path location\n        let ctx = if let Some(parent) = path.parent() {\n            // (a) Check that the parent exists\n            let parent = self\n                .get(\u0026parent)\n                .expect(\"cannot create module, parent missing in NDL build\");\n\n            ModuleContext::child_of(path.name(), parent)\n        } else {\n            ModuleContext::standalone(path.clone())\n        };\n        ctx.activate();\n\n        if let Some(software) = registry.lookup(path, ty) {\n            ctx.upgrade_dummy(software);\n        } else {\n            errors.add(Error::new(\n                ErrorKind::SymbolNotFound,\n                format!(\"symbol '{ty}' at '{path}' could not be resolved by the registry\"),\n            ));\n        }\n\n        // TODO: deactivate module\n        self.modules_mut().add(ctx.clone());\n        ctx\n    }\n}\n\nimpl\u003c'a, A\u003e ScopedSim\u003c'a, A\u003e {\n    #[allow(clippy::needless_pass_by_value)]\n    fn ndl(\n        mut self,\n        ir: Arc\u003cir::Module\u003e,\n        errors: \u0026mut ErrorsMut,\n        registry: \u0026Registry,\n    ) -\u003e Option\u003cModuleRef\u003e {\n        let ty = ir.ident.raw.clone();\n        let scope = \u0026self.scope;\n\n        let ctx = self.base.raw_ndl(scope, \u0026ty, registry, errors);\n\n        for gate in \u0026ir.gates {\n            let _ = ctx.create_gate_cluster(\u0026gate.ident.raw, gate.cluster.as_size());\n        }\n\n        for submod in \u0026ir.submodules {\n            let sir = submod.typ.as_module_arc().expect(\n                \"invalid NDL tree: submodule typ referes does not refer to a module object\",\n            );\n\n            match submod.cluster {\n                ir::Cluster::Standalone =\u003e {\n                    // Resue current struct better for stack\n                    let subscope = self.subscope(\u0026submod.ident.raw);\n                    subscope.ndl(sir, errors, registry);\n                }\n                ir::Cluster::Clusted(n) =\u003e {\n                    for k in 0..n {\n                        let ident = \u0026submod.ident.raw;\n                        let subscope = self.subscope(format!(\"{ident}[{k}]\"));\n                        subscope.ndl(sir.clone(), errors, registry);\n                    }\n                }\n            }\n        }\n\n        for con in \u0026ir.connections {\n            let from = match \u0026con.lhs {\n                ConnectionEndpoint::Local(gate, pos) =\u003e ctx.gate(\u0026gate.raw, pos.as_index()),\n                ConnectionEndpoint::Nonlocal(submod, pos, gate) =\u003e {\n                    let c = ctx\n                        .child(\u0026format!(\"{}{}\", submod.raw, pos))\n                        .expect(\"invalid NDL tree: connection refer to child that does not exist\");\n                    c.gate(\u0026gate.0.raw, gate.1.as_index())\n                }\n            }\n            .expect(\"invalid NDL tree: connections refer to gate(-cluster) not defined by NDL\");\n\n            let to = match \u0026con.rhs {\n                ConnectionEndpoint::Local(gate, pos) =\u003e ctx.gate(\u0026gate.raw, pos.as_index()),\n                ConnectionEndpoint::Nonlocal(submod, pos, gate) =\u003e {\n                    let c = ctx\n                        .child(\u0026format!(\"{}{}\", submod.raw, pos))\n                        .expect(\"invalid NDL tree: connection refer to child that does not exist\");\n                    c.gate(\u0026gate.0.raw, gate.1.as_index())\n                }\n            }\n            .expect(\"invalid NDL tree: connections refer to gate(-cluster) not defined by NDL\");\n\n            from.connect_dedup(\n                to,\n                if let Some(delay) = \u0026con.delay {\n                    let link = delay\n                        .as_link_arc()\n                        .expect(\"invalid NDL tree: link typ does not refer to a link object\");\n                    Some(Channel::new(ChannelMetrics::from(\u0026*link)))\n                } else {\n                    None\n                },\n            );\n        }\n\n        Some(ctx)\n    }\n}\n\nimpl From\u003c\u0026ir::Link\u003e for ChannelMetrics {\n    #[allow(clippy::cast_sign_loss)]\n    fn from(value: \u0026ir::Link) -\u003e Self {\n        ChannelMetrics {\n            bitrate: value.bitrate as usize,\n            jitter: Duration::from_secs_f64(value.jitter),\n            latency: Duration::from_secs_f64(value.latency),\n            drop_behaviour: ChannelDropBehaviour::Queue(Some(\n                value\n                    .fields\n                    .get(\"queuesize\")\n                    .map_or(0, ir::Literal::as_integer_casted) as usize,\n            )),\n        }\n    }\n}\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":131},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":26},"fn_name":null}],"covered":59,"coverable":76},{"path":["/","Users","mk","Developer","rust","des","des","src","ndl","registry.rs"],"content":"use fxhash::{FxBuildHasher, FxHashMap};\nuse std::fmt;\n\nuse crate::{\n    net::processing::{IntoProcessingElements, ProcessingElements},\n    prelude::{Module, ObjectPath},\n};\n\n/// A type that can be created based on the nodes path and a\n/// NDL symbol.\n///\n/// This trait is used in combination with the [`registry`](crate::registry)\n/// macro, when creating a software registry. Note that this type\n/// is automatically derived for any type that implements [`Default`].\npub trait RegistryCreatable {\n    /// Creates a instance of `Self` from a path and symbol.\n    ///\n    /// This function if called by [`Sim::ndl`](crate::net::Sim) will be called\n    /// within node-context.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::ndl::*;\n    /// # use des::registry;\n    /// # fn extract_dns_from_oid(path: \u0026ObjectPath) {}\n    /// struct Server { /* ... */ }\n    ///\n    /// impl RegistryCreatable for Server {\n    ///     fn create(path: \u0026ObjectPath, symbol: \u0026str) -\u003e Self {\n    ///         let dns_name = extract_dns_from_oid(path);\n    ///         Self { /* ... */ }\n    ///     }\n    /// }\n    ///\n    /// impl Module for Server {\n    ///     /* ... */\n    /// }\n    ///\n    /// # return;\n    /// let mut sim = Sim::ndl(\n    ///     \"path/to/ndl\",\n    ///     registry![Server, else _]\n    /// );\n    /// ```\n    fn create(path: \u0026ObjectPath, symbol: \u0026str) -\u003e Self;\n}\n\nimpl\u003cT: Default\u003e RegistryCreatable for T {\n    fn create(_: \u0026ObjectPath, _: \u0026str) -\u003e Self {\n        Self::default()\n    }\n}\n\n/// A registry to attache user-defined software to nodes in\n/// a simulation.\n///\n/// When creating a simulation from a NDL like structure,\n/// that only defines the topological layout of the simulation,\n/// user-defined software must be attached to created nodes to\n/// make the setup complete.\n///\n/// This registry effectivly acts as a `fn (ObjectPath, Symbol) -\u003e Module`\n/// to assign software to each node that will be created. Since these\n/// nodes are related to a NDL-Module the modules name is also provided\n/// as a parameter.\n#[must_use]\npub struct Registry {\n    symbols: FxHashMap\u003cString, Box\u003cGenByObjectPath\u003e\u003e,\n    custom: Vec\u003cBox\u003cGenByObjectPathAndSymbol\u003e\u003e,\n    fallback: Option\u003cBox\u003cFallback\u003e\u003e,\n}\n\ntype GenByObjectPath = dyn Fn(\u0026ObjectPath) -\u003e ProcessingElements;\ntype GenByObjectPathAndSymbol = dyn Fn(\u0026ObjectPath, \u0026str) -\u003e Option\u003cProcessingElements\u003e;\ntype Fallback = dyn Fn() -\u003e ProcessingElements;\n\nimpl Registry {\n    /// Creates a new empty registry.\n    ///\n    /// Registrys can be populated using the builder pattern or using\n    /// the [`registry`](crate::registry) macro.\n    ///\n    /// # Examples\n    ///\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::ndl::*;\n    /// # struct HostModule;\n    /// # impl Module for HostModule {}\n    /// let registry = Registry::new()\n    ///     .symbol(\"Host\", |_| HostModule)\n    ///     .custom(|path, symbol| {\n    ///         /* ... */\n    ///         # Option::\u003cHostModule\u003e::None\n    ///     })\n    ///     .with_default_fallback();\n    /// ```\n    ///\n    /// Or create a registry using macros. Note that the macro returns a `Registry` so\n    /// the builder pattner can still be used. Note that types passed to the macro\n    /// **must** implement the `RegistryCreatable` trait.\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::ndl::*;\n    /// # use des::registry;\n    /// # #[derive(Default)]\n    /// # struct HostModule;\n    /// # impl Module for HostModule {}\n    /// type Host = HostModule; // symbol names and type names must match\n    /// let registry = registry![Host].with_default_fallback();\n    /// ```\n    pub fn new() -\u003e Registry {\n        Self {\n            symbols: FxHashMap::with_hasher(FxBuildHasher::default()),\n            custom: Vec::new(),\n            fallback: None,\n        }\n    }\n\n    /// Sets the `DefaultFallbackModule` as a fallback.\n    ///\n    /// The default fallback module will behave as follows:\n    /// - `at_sim_start` and `t_sim_end` are NOP with 1 sim start stage\n    /// - `reset` is a NOP\n    /// - `handle_message` will log any incoming messages to stderr\n    /// - `DefaultFallbackModule` is **not** async\n    /// - `DefaulfFallbackModule` will **not** load common plugins\n    ///\n    /// See [`Registry::with_fallback`] for more infomation.\n    pub fn with_default_fallback(self) -\u003e Self {\n        self.with_fallback(|| DefaultFallbackModule)\n    }\n\n    /// Sets a fallback module, that will be used if no other\n    /// directive matched.\n    ///\n    /// # Why have a fallback module ?\n    ///\n    /// By their very nature fallback modules all share the same software.\n    /// Additionally the `fallback` function does not take any parameters\n    /// so any fallback solution should not be dependent on any parameters.\n    ///\n    /// Accordingly fallback modules rarely have any meaningful software\n    /// in them, they rather are just dummys for nodes that are not expected\n    /// to receive any message. Such nodes often occur as structual elements in\n    /// topologies to encapsualte certain subtopologies. E.g. a NDL topology\n    /// may include a module `LAN` that internally contains hosts, switches and routers.\n    /// All internal components will have meeaninful software attached, but the `LAN` object\n    /// itself should not, since it only exposes gate chains from child modules. In this\n    /// case `LAN` will never receive any messages itself, so a fallback dummy can be used.\n    ///\n    /// Fallback modules should be used with care, since the existence of a fallback\n    /// solution within a registry implies, that any given topology can be\n    /// populated with this registry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::ndl::*;\n    /// # use des::prelude::*;\n    /// # struct HostModule;\n    /// # impl Module for HostModule {}\n    /// # struct SwitchModule;\n    /// # impl Module for SwitchModule {}\n    /// # struct RouterModule;\n    /// # impl Module for RouterModule {}\n    /// # struct NOP;\n    /// # impl Module for NOP {}\n    /// let registry = Registry::new()\n    ///     .symbol(\"Host\", |_| HostModule)\n    ///     .symbol(\"Switch\", |_| SwitchModule)\n    ///     .symbol(\"Router\", |_| RouterModule)\n    ///     .with_fallback(|| NOP);\n    ///\n    /// # return;\n    /// let mut sim = Sim::ndl(\"path/to/ndl\", registry);\n    /// /* ... */\n    /// ```\n    pub fn with_fallback\u003cM: Module\u003e(mut self, fallback: impl Fn() -\u003e M + 'static) -\u003e Self {\n        self.fallback = Some(Box::new(move || fallback().to_processing_chain()));\n        self\n    }\n\n    /// Adds a symbol mapping to the registry.\n    ///\n    /// All nodes with the symbol `ty` will now use the provided genertator\n    /// function `f` to generate software. This function is thus only parameterized\n    /// by the objects path.\n    ///\n    /// Newer assigments will override older assigments to the same symbol.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::ndl::*;\n    /// # use des::prelude::*;\n    /// struct Host { /* ... */ }\n    ///\n    /// impl Host {\n    ///     fn new(path: \u0026ObjectPath) -\u003e Self {\n    ///         /* .. */\n    /// #       Host {}\n    ///     }\n    /// }\n    ///\n    /// impl Module for Host {\n    ///     /* ... */\n    /// }\n    ///\n    /// /* ... */\n    /// # struct Router;\n    /// # impl Router { fn new(path: \u0026ObjectPath) -\u003e Self { Self } }\n    /// # impl Module for Router {}\n    ///\n    /// let registry = Registry::new()\n    ///     .symbol(\"Host\", |path| Host::new(path))\n    ///     .symbol(\"Router\", |path| Router::new(path));\n    ///\n    /// # return;\n    /// let mut sim = Sim::ndl(\"path/to/ndl\", registry);\n    /// /* ... */\n    /// ```\n    pub fn symbol\u003cM: Module\u003e(\n        mut self,\n        ty: impl AsRef\u003cstr\u003e,\n        f: impl for\u003c'a\u003e Fn(\u0026'a ObjectPath) -\u003e M + 'static,\n    ) -\u003e Self {\n        self.symbols.insert(\n            ty.as_ref().to_string(),\n            Box::new(move |path| f(path).to_processing_chain()),\n        );\n        self\n    }\n\n    /// Adds a custom directive to the registry.\n    ///\n    /// A custom directive is a function that optionally returns a module.\n    /// If `None` is returned that indicates that the directive is not responsible for\n    /// generating software for this node. Custom directive are executed in order\n    /// of definition.\n    ///\n    /// Note that a custom directive that allways returns `Some(...)` is equivalent\n    /// to a fallback module.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::ndl::*;\n    /// # struct GoogleGeneralHost;\n    /// # impl GoogleGeneralHost { fn new(_: \u0026ObjectPath) -\u003e Self { Self }}\n    /// # impl Module for GoogleGeneralHost {}\n    /// let symbols = [\"Host\", \"Client\", \"Server\"];\n    ///\n    /// let registry = Registry::new()\n    ///     .custom(move |path, symbol| {\n    ///         if symbols.contains(\u0026symbol) {\n    ///             if path.as_str().starts_with(\"google\") {\n    ///                 Some(GoogleGeneralHost::new(path))\n    ///             } else {\n    ///                 None\n    ///             }\n    ///         } else {\n    ///             None\n    ///         }\n    ///     });\n    ///\n    /// # return;\n    /// let mut sim = Sim::ndl(\"path/to/ndl\", registry);\n    /// /* ... */\n    /// ```\n    pub fn custom\u003cM: Module\u003e(\n        mut self,\n        f: impl Fn(\u0026ObjectPath, \u0026str) -\u003e Option\u003cM\u003e + 'static,\n    ) -\u003e Self {\n        self.custom.push(Box::new(move |path, symbol| {\n            Some(f(path, symbol)?.to_processing_chain())\n        }));\n        self\n    }\n\n    /// Lookup\n    pub(super) fn lookup(\u0026self, path: \u0026ObjectPath, ty: \u0026str) -\u003e Option\u003cProcessingElements\u003e {\n        // (0) Symbol resolve\n        if let Some(resolver) = self.symbols.get(ty) {\n            return Some(resolver(path));\n        }\n\n        // (1) Check custom handlers\n        for handler in \u0026self.custom {\n            if let Some(resolved) = handler(path, ty) {\n                return Some(resolved);\n            }\n        }\n\n        // (2) Fallback\n        self.fallback.as_ref().map(|fallback| fallback())\n    }\n}\n\nimpl fmt::Debug for Registry {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"Registry\").finish()\n    }\n}\n\nimpl AsRef\u003cRegistry\u003e for Registry {\n    fn as_ref(\u0026self) -\u003e \u0026Registry {\n        self\n    }\n}\n\nimpl Default for Registry {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[derive(Default)]\nstruct DefaultFallbackModule;\nimpl Module for DefaultFallbackModule {\n    fn stack(\u0026self) -\u003e impl IntoProcessingElements {}\n\n    fn handle_message(\u0026mut self, msg: crate::prelude::Message) {\n        tracing::error!(\n            ?msg,\n            \"received message: fallback dummy should never receive any messages\"\n        );\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":34,"coverable":35},{"path":["/","Users","mk","Developer","rust","des","des","src","net","channel.rs"],"content":"//! Physical link abstractions.\n#![allow(clippy::cast_precision_loss)]\n\nuse rand::distributions::Uniform;\nuse rand::prelude::StdRng;\nuse rand::{Rng, RngCore};\nuse std::collections::VecDeque;\nuse std::fmt::{Debug, Display};\nuse std::sync::{Arc, RwLock};\n\nuse crate::net::{\n    message::Message, runtime::ChannelUnbusyNotif, MessageExitingConnection, NetEvents,\n};\nuse crate::runtime::{rng, EventSink};\nuse crate::time::{Duration, SimTime};\n\nuse super::gate::Connection;\n\n/// A readonly reference to a channel.\npub type ChannelRef = Arc\u003cChannel\u003e;\n\n/// A representation of a one directional delayed link,.\npub struct Channel {\n    inner: RwLock\u003cChannelInner\u003e,\n}\n\nstruct ChannelInner {\n    metrics: ChannelMetrics,\n    busy: bool,\n    transmission_finish_time: SimTime,\n    buffer: Buffer,\n    probe: Box\u003cdyn ChannelProbe\u003e,\n}\n\n#[derive(Default)]\nstruct Buffer {\n    packets: VecDeque\u003c(Message, Connection)\u003e,\n    acc_bytes: usize,\n}\n\nimpl Buffer {\n    fn enqueue(\u0026mut self, msg: Message, con: Connection) {\n        self.acc_bytes += msg.length();\n        self.packets.push_back((msg, con));\n    }\n\n    fn dequeue(\u0026mut self) -\u003e Option\u003c(Message, Connection)\u003e {\n        let (msg, gate) = self.packets.pop_front()?;\n        self.acc_bytes -= msg.length();\n        Some((msg, gate))\n    }\n}\n\n/// Metrics that define a channels capabilitites.\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct ChannelMetrics {\n    /// The maximum throughput of the channel in bit/s\n    pub bitrate: usize,\n    /// The latency a message endures while transversing a channel.\n    pub latency: Duration,\n    /// The variance in latency.\n    pub jitter: Duration,\n    /// The size of the channels queue in bytes.\n    pub drop_behaviour: ChannelDropBehaviour,\n}\n\n/// The behaviour a link should follow, if it is oversubscribed\n#[derive(Debug, Default, Clone, Copy, PartialEq)]\npub enum ChannelDropBehaviour {\n    /// If a link is currently busy, drop packets\n    #[default]\n    Drop,\n    /// If a link is currently busy, queue packets up to a\n    /// provided queuelength (None means infinite queuelength)\n    Queue(Option\u003cusize\u003e),\n}\n\nimpl ChannelInner {\n    fn dup(\u0026self) -\u003e Self {\n        Self {\n            metrics: self.metrics,\n            busy: false,\n            transmission_finish_time: SimTime::ZERO,\n            buffer: Buffer::default(),\n            probe: Box::new(DummyChannelProbe),\n        }\n    }\n}\n\nimpl Channel {\n    pub(super) fn dup(\u0026self) -\u003e Self {\n        Channel {\n            inner: RwLock::new(self.inner.read().unwrap().dup()),\n        }\n    }\n\n    /// A description of the channels capabilities,\n    /// independent from its current state.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the simulation core was poisoned.\n    #[must_use]\n    pub fn metrics(\u0026self) -\u003e ChannelMetrics {\n        self.inner.read().unwrap().metrics\n    }\n\n    /// A indicator whether a channel is currently busy transmissting a\n    /// packet onto the medium.\n    ///\n    /// Note that being non-busy does not mean that no packet is currently on the medium\n    /// it just means that all bits have been put onto the medium.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the simulation core was poisoned.\n    #[must_use]\n    pub fn is_busy(\u0026self) -\u003e bool {\n        self.inner.read().unwrap().busy\n    }\n\n    /// Attaches a probe\n    ///\n    /// # Panics\n    ///\n    /// Panics if the channel mutex was poisoned.\n    pub fn attach_probe(\u0026self, probe: impl ChannelProbe) {\n        let mut chan = self\n            .inner\n            .write()\n            .expect(\"failed to get inner channel lock\");\n        let probe = Box::new(probe);\n        chan.probe = probe;\n    }\n\n    /// Sets the channel busy, announcing that the message will be trabsmitted\n    /// in '`sim_time`' time units.\n    pub(crate) fn set_busy_until(\u0026self, sim_time: SimTime) {\n        let mut chan = self.inner.write().unwrap();\n        chan.busy = true;\n        chan.transmission_finish_time = sim_time;\n    }\n\n    /// Returns the time when the packet currently being transmitted onto the medium\n    /// has been fully transmitted, or [`SimTime::ZERO`] if no packet is currently being transmitted.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the simulation core was poisoned.\n    #[must_use]\n    pub fn transmission_finish_time(\u0026self) -\u003e SimTime {\n        self.inner.read().unwrap().transmission_finish_time\n    }\n\n    /// Creates a new channel using the given metrics,\n    /// with an initially unbusy state.\n    #[must_use]\n    pub fn new(metrics: ChannelMetrics) -\u003e ChannelRef {\n        ChannelRef::new(Channel {\n            inner: RwLock::new(ChannelInner {\n                metrics,\n                busy: false,\n                transmission_finish_time: SimTime::ZERO,\n                buffer: Buffer::default(),\n                probe: Box::new(DummyChannelProbe),\n            }),\n        })\n    }\n\n    /// Calcualtes the packet travel duration using the\n    /// underlying metric.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the simulation core was poisoned.\n    pub fn calculate_duration(\u0026self, msg: \u0026Message, rng: \u0026mut StdRng) -\u003e Duration {\n        self.inner\n            .read()\n            .unwrap()\n            .metrics\n            .calculate_duration(msg, rng)\n    }\n\n    /// Calcualtes the busy time of the channel using\n    /// the underlying metric.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the simulation core was poisoned.\n    #[must_use]\n    pub fn calculate_busy(\u0026self, msg: \u0026Message) -\u003e Duration {\n        self.inner.read().unwrap().metrics.calculate_busy(msg)\n    }\n\n    pub(super) fn send_message\u003cS: EventSink\u003cNetEvents\u003e\u003e(\n        self: Arc\u003cSelf\u003e,\n        msg: Message,\n        via: Connection,\n        sink: \u0026mut S,\n    ) {\n        let rng_ref = rng();\n        let mut chan = self.inner.write().unwrap();\n\n        if chan.busy {\n            let ChannelInner {\n                metrics, buffer, ..\n            } = \u0026mut *chan;\n\n            metrics.drop_behaviour.handle(buffer, msg, via);\n        } else {\n            let ChannelInner { probe, metrics, .. } = \u0026mut *chan;\n            probe.on_message_transmit(metrics, \u0026msg);\n\n            let dur = metrics.calculate_duration(\u0026msg, rng_ref);\n            let busy = metrics.calculate_busy(\u0026msg);\n\n            if busy != Duration::ZERO {\n                let transmissin_finish = SimTime::now() + busy;\n\n                drop(chan);\n                self.set_busy_until(transmissin_finish);\n\n                sink.add(\n                    NetEvents::ChannelUnbusyNotif(ChannelUnbusyNotif {\n                        channel: self.clone(),\n                    }),\n                    transmissin_finish,\n                );\n            }\n\n            let next_event_time = SimTime::now() + dur;\n\n            sink.add(\n                NetEvents::MessageExitingConnection(MessageExitingConnection {\n                    con: via.clone(),\n                    msg,\n                }),\n                next_event_time,\n            );\n\n            // must break iteration,\n            // but not perform on-module handling\n        }\n    }\n\n    /// Resets the busy state of a channel.\n    pub(crate) fn unbusy\u003cS: EventSink\u003cNetEvents\u003e\u003e(self: Arc\u003cSelf\u003e, sink: \u0026mut S) {\n        let mut chan = self.inner.write().unwrap();\n\n        chan.busy = false;\n        chan.transmission_finish_time = SimTime::ZERO;\n\n        if let Some((msg, next_gate)) = chan.buffer.dequeue() {\n            drop(chan);\n            self.send_message(msg, next_gate, sink);\n        }\n    }\n}\n\nimpl ChannelDropBehaviour {\n    fn handle(\u0026self, buffer: \u0026mut Buffer, msg: Message, via: Connection) {\n        match self {\n            Self::Drop =\u003e {\n                #[cfg(feature = \"tracing\")]\n                tracing::warn!(\n                    \"Gate '{}' dropping message [{}] pushed onto busy channel\",\n                    via.prev_hop().unwrap().name(),\n                    msg.str(),\n                );\n                drop(msg);\n            }\n            Self::Queue(limit) =\u003e {\n                if buffer.acc_bytes + msg.length() \u003e limit.unwrap_or(usize::MAX) {\n                    #[cfg(feature = \"tracing\")]\n                    tracing::warn!(\n                        \"Gate '{}' dropping message [{}] pushed onto busy channel\",\n                        via.prev_hop().unwrap().name(),\n                        msg.str(),\n                    );\n                    drop(msg);\n                } else {\n                    #[cfg(feature = \"tracing\")]\n                    tracing::trace!(\n                        \"Gate '{}' added message [{}] to queue of channel\",\n                        via.prev_hop().unwrap().name(),\n                        msg.str(),\n                    );\n                    buffer.enqueue(msg, via);\n                }\n            }\n        }\n    }\n}\n\nimpl Debug for Channel {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        #[derive(Debug)]\n        #[allow(unused)]\n        enum FmtChannelState {\n            Idle,\n            Busy {\n                until: SimTime,\n                bytes: usize,\n                packets: usize,\n            },\n        }\n\n        impl FmtChannelState {\n            fn from(channel: \u0026ChannelInner) -\u003e Self {\n                if channel.busy {\n                    Self::Busy {\n                        until: channel.transmission_finish_time,\n                        bytes: channel.buffer.acc_bytes,\n                        packets: channel.buffer.packets.len(),\n                    }\n                } else {\n                    Self::Idle\n                }\n            }\n        }\n\n        let this = self.inner.read().unwrap();\n\n        f.debug_struct(\"Channel\")\n            .field(\"metrics\", \u0026this.metrics)\n            .field(\"state\", \u0026FmtChannelState::from(\u0026this))\n            .finish()\n    }\n}\n\nimpl ChannelMetrics {\n    /// Creates a new instance of channel metrics.\n    #[must_use]\n    pub const fn new(\n        bitrate: usize,\n        latency: Duration,\n        jitter: Duration,\n        drop_behaviour: ChannelDropBehaviour,\n    ) -\u003e Self {\n        Self {\n            bitrate,\n            latency,\n            jitter,\n            drop_behaviour,\n        }\n    }\n\n    /// Calcualtes the duration a message travels on a link.\n    #[allow(clippy::if_same_then_else)]\n    pub fn calculate_duration(\u0026self, msg: \u0026Message, rng: \u0026mut dyn RngCore) -\u003e Duration {\n        let transmission_time = self.calculate_busy(msg);\n        if self.jitter == Duration::ZERO {\n            self.latency + transmission_time\n        } else {\n            let perc = rng.sample(Uniform::new(0.0f64, self.jitter.as_secs_f64()));\n            self.latency + transmission_time + Duration::from_secs_f64(perc)\n        }\n    }\n\n    /// Calculate the duration the channel is busy transmitting the\n    /// message onto the channel.\n    #[must_use]\n    pub fn calculate_busy(\u0026self, msg: \u0026Message) -\u003e Duration {\n        if self.bitrate == 0 {\n            Duration::ZERO\n        } else {\n            let len = msg.length() * 8;\n            Duration::from_secs_f64(len as f64 / self.bitrate as f64)\n        }\n    }\n}\n\nimpl Display for ChannelMetrics {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"ChannelMetrics\")\n            .field(\"bitrate (bit/s)\", \u0026self.bitrate)\n            .field(\"lateny\", \u0026self.latency)\n            .field(\"jitter\", \u0026self.jitter)\n            .finish()\n    }\n}\n\nimpl Eq for ChannelMetrics {}\n\n/// A trait to define channel probing.\npub trait ChannelProbe: 'static {\n    /// Reacts to a message\n    fn on_message_transmit(\u0026mut self, chan: \u0026ChannelMetrics, msg: \u0026Message);\n}\n\nstruct DummyChannelProbe;\nimpl ChannelProbe for DummyChannelProbe {\n    #[inline]\n    fn on_message_transmit(\u0026mut self, _: \u0026ChannelMetrics, _: \u0026Message) {}\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4132},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2079},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2079},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":2079},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2082},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":4142},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":2067},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":4156},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":4156},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":4136},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":4136},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":2074},"fn_name":null}],"covered":116,"coverable":125},{"path":["/","Users","mk","Developer","rust","des","des","src","net","gate.rs"],"content":"//! Module-specific network ports.\n\nuse crate::net::channel::ChannelRef;\nuse std::fmt::Debug;\nuse std::sync::{Arc, Mutex, Weak};\n\nuse super::module::{ModuleContext, ModuleRef, ModuleRefWeak};\nuse super::ObjectPath;\n\n///\n/// A  reference to a gate.\n///\npub type GateRef = Arc\u003cGate\u003e;\n///\n/// A weak reference to a gate.\n///\npub(crate) type GateRefWeak = Weak\u003cGate\u003e;\n\n///\n/// A gate, a message insertion or extraction point used for handeling channels.\n///\n/// * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\npub struct Gate {\n    owner: ModuleRefWeak,\n    name: String,\n\n    size: usize,\n    pos: usize,\n\n    connections: Mutex\u003cConnections\u003e,\n}\n\n/// A kinds of operations supported on a gate.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum GateKind {\n    /// Standalone gates are not connected to any gate chain\n    /// at all. They act as start and endpoint of a gatechain of\n    /// length 0. Messages send onto these gates will never leave\n    /// the sending module.\n    Standalone,\n    /// Endpoint gates are at the start or end of gate chains.\n    /// These gates can be used to send messages onto a gate chain.\n    /// Each endpoint acts as the starting point for one direction.\n    Endpoint,\n    /// Transit gates are in the middle of a gate chain, connected\n    /// to two other gates. These gates cannot be used to start\n    /// a message sending process.\n    Transit,\n}\n\nstruct Connections {\n    connections: [Option\u003cConnection\u003e; 2],\n}\n\n/// A connection to a peering gate\n#[derive(Debug, Clone)]\npub struct Connection {\n    /// The endpoint from the view of the owning gate\n    pub endpoint: GateRef,\n    /// The index of the slot used at the endpoint\n    pub endpoint_id: usize,\n    /// A channel to slow down the connection.\n    pub channel: Option\u003cChannelRef\u003e,\n}\n\nimpl Connection {\n    /// Crease a new pseudo connection, channeling into the\n    /// provided gate\n    ///\n    /// # Panics\n    ///\n    /// Panics if the provided gate is not an endpoint.\n    pub fn new(gate: GateRef) -\u003e Self {\n        assert!(\n            gate.connections\n                .lock()\n                .expect(\"locking failure: GateRef seems to be active on another thread\")\n                .len()\n                \u003c= 1\n        );\n        Self::new_unchecked(gate)\n    }\n\n    ///\n    pub fn new_unchecked(gate: GateRef) -\u003e Self {\n        Self {\n            endpoint: gate,\n            endpoint_id: 1, // TODO: smarter ??\n            channel: None,\n        }\n    }\n\n    /// NEXT\n    ///\n    /// # Panics\n    ///\n    /// May panic on lock poisoning\n    #[must_use]\n    pub fn next_hop(\u0026self) -\u003e Option\u003cConnection\u003e {\n        let idx = [1, 0][self.endpoint_id];\n        let lock = self\n            .endpoint\n            .connections\n            .lock()\n            .expect(\"failed to get lock\");\n        lock.connections[idx].clone()\n    }\n\n    /// PREV\n    /// # Panics\n    ///\n    /// May panic on lock poisoning\n    #[must_use]\n    pub fn prev_hop(\u0026self) -\u003e Option\u003cGateRef\u003e {\n        let lock = self\n            .endpoint\n            .connections\n            .lock()\n            .expect(\"failed to get lock\");\n        Some(\n            lock.connections[self.endpoint_id]\n                .as_ref()?\n                .endpoint\n                .clone(),\n        )\n    }\n\n    /// Retrieves a handle to a channel attached to the connection\n    #[must_use]\n    pub fn channel(\u0026self) -\u003e Option\u003cChannelRef\u003e {\n        self.channel.clone()\n    }\n}\n\nimpl Connections {\n    fn new() -\u003e Self {\n        Self {\n            connections: [None, None],\n        }\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.connections.iter().filter(|v| v.is_some()).count()\n    }\n\n    fn put(\u0026mut self, connection: Connection) {\n        for i in 0..2 {\n            if self.connections[i].is_none() {\n                self.connections[i] = Some(connection);\n                return;\n            }\n        }\n        unreachable!()\n    }\n}\n\nstruct PathIter {\n    con: Option\u003cConnection\u003e,\n}\n\nimpl Iterator for PathIter {\n    type Item = Connection;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let next = self.con.as_ref()?.next_hop()?;\n        self.con = Some(next.clone());\n        Some(next)\n    }\n}\n\nimpl Gate {\n    ///\n    /// Indicator whether a descriptor describes a cluster\n    /// or a single gate\n    ///\n    #[must_use]\n    pub fn is_cluster(\u0026self) -\u003e bool {\n        self.size != 1\n    }\n\n    ///\n    /// The position index of the gate within the descriptor cluster.\n    ///\n    #[must_use]\n    pub fn pos(\u0026self) -\u003e usize {\n        self.pos\n    }\n\n    ///\n    /// The size of the gate cluster.\n    ///\n    #[must_use]\n    pub fn size(\u0026self) -\u003e usize {\n        self.size\n    }\n\n    ///\n    /// The human-readable name for the allocated gate cluster.\n    ///\n    #[must_use]\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    fn name_with_pos(\u0026self) -\u003e String {\n        if self.is_cluster() {\n            format!(\"{}[{}]\", self.name(), self.pos())\n        } else {\n            self.name().to_string()\n        }\n    }\n\n    ///\n    /// Returns a short identifcator that holds all nessecary information.\n    ///\n    #[must_use]\n    pub fn str(\u0026self) -\u003e String {\n        self.name_with_pos()\n    }\n\n    ///\n    /// The full tree path of the gate.\n    ///\n    #[must_use]\n    pub fn path(\u0026self) -\u003e ObjectPath {\n        self.owner().ctx.path.appended_gate(self.name_with_pos())\n    }\n\n    /// Returns the kind of operations allowed on this gate.\n    ///\n    /// # Panics\n    ///\n    /// Panics when accessed during teardown\n    pub fn kind(\u0026self) -\u003e GateKind {\n        match self\n            .connections\n            .try_lock()\n            .expect(\"failed to get lock\")\n            .len()\n        {\n            0 =\u003e GateKind::Standalone,\n            1 =\u003e GateKind::Endpoint,\n            _ =\u003e GateKind::Transit,\n        }\n    }\n\n    /// Connects two gates into a gate chain element.\n    ///\n    /// Gates can be organized into a bidirectional gate chain, that\n    /// forwards messages two the other end. Using this function two gates\n    /// are connected and both gates save their connection state. A gate\n    /// can have up to two other gates connected to it, forming a full gate\n    /// chain in response.\n    ///\n    /// If a channel was provided to enable message delaying on this chain element\n    /// both direction will have unique instances of the channel, with identical\n    /// configuration.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # fn a() -\u003e Option\u003c()\u003e{\n    /// # return None;\n    /// let a = current().gate(\"out\", 0)?;\n    /// let b = current().parent().ok()?.gate(\"in\", 0)?;\n    /// a.connect(b, None);\n    /// # Some(())\n    /// # }\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// This function panic if either of the two gates is allready fully connected in a chain.\n    /// This function also panics if only one gate is provided\n    #[allow(clippy::needless_pass_by_value)]\n    pub fn connect(self: GateRef, other: GateRef, channel: Option\u003cChannelRef\u003e) {\n        assert!(\n            !Arc::ptr_eq(\u0026self, \u0026other),\n            \"Cannot connect gate to itself.\"\n        );\n\n        let mut conns = self.connections.try_lock().expect(\"Failed to get lock\");\n        let mut other_conns = other.connections.try_lock().expect(\"failed to get lock\");\n\n        let conns_pos = conns.len();\n        let other_conns_pos = other_conns.len();\n        assert!(\n            conns_pos \u003c 2 \u0026\u0026 other_conns_pos \u003c 2,\n            \"Cannot add connection, gates allready connected to multiple points\"\n        );\n\n        let ch1 = channel.as_ref().map(|c| Arc::new(c.dup()));\n        let ch2 = channel;\n\n        conns.put(Connection {\n            endpoint: other.clone(),\n            endpoint_id: other_conns_pos,\n            channel: ch1,\n        });\n        other_conns.put(Connection {\n            endpoint: self.clone(),\n            endpoint_id: conns_pos,\n            channel: ch2,\n        });\n    }\n\n    /// DEDUP\n    /// # Panics\n    ///\n    /// May panic when accessed during teardown\n    pub fn connect_dedup(self: GateRef, other: GateRef, channel: Option\u003cChannelRef\u003e) {\n        // Check whether the target is allready connected\n        let conns = self.connections.try_lock().expect(\"failed lock\");\n        for i in 0..2 {\n            if let Some(ref con) = conns.connections[i] {\n                if Arc::ptr_eq(\u0026con.endpoint, \u0026other) {\n                    return;\n                }\n            }\n        }\n\n        drop(conns);\n        self.connect(other, channel);\n    }\n\n    /// CHAN\n    pub fn channel(self: \u0026GateRef) -\u003e Option\u003cChannelRef\u003e {\n        self.path_iter()?.nth(0).and_then(|con| con.channel)\n    }\n\n    /// ITER\n    pub fn path_iter(self: \u0026GateRef) -\u003e Option\u003cimpl Iterator\u003cItem = Connection\u003e\u003e {\n        if self.kind() == GateKind::Transit {\n            None\n        } else {\n            Some(PathIter {\n                con: Some(Connection::new_unchecked(self.clone())),\n            })\n        }\n    }\n\n    /// NEXT GATE\n    pub fn next_gate(self: \u0026GateRef) -\u003e Option\u003cGateRef\u003e {\n        self.path_iter()?.nth(0).map(|c| c.endpoint)\n    }\n\n    /// END\n    pub fn path_end(self: \u0026GateRef) -\u003e Option\u003cGateRef\u003e {\n        self.path_iter()?.last().map(|c| c.endpoint)\n    }\n\n    ///\n    /// Returns the owner module by reference of this gate.\n    ///\n    /// # Panics\n    ///\n    /// May panic when called in Drop, since the owner may allready\n    /// be dropped.\n    ///\n    #[must_use]\n    pub fn owner(\u0026self) -\u003e ModuleRef {\n        self.owner\n            .upgrade()\n            .expect(\"cannot refer to gate owner during drop\")\n    }\n\n    ///\n    /// Creats a new gate using the given values.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the provided size is not real positive.\n    #[must_use]\n    pub fn new(owner: \u0026ModuleRef, name: impl AsRef\u003cstr\u003e, size: usize, pos: usize) -\u003e GateRef {\n        assert!(size \u003e= 1, \"Cannot create with a non-postive size\");\n\n        let this = GateRef::new(Self {\n            owner: ModuleRefWeak::new(owner),\n            name: name.as_ref().to_string(),\n            size,\n            pos,\n            connections: Mutex::new(Connections::new()),\n        });\n\n        this\n    }\n}\n\n#[allow(clippy::missing_fields_in_debug)]\nimpl Debug for Gate {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"Gate\")\n            .field(\"path\", \u0026self.path().as_str())\n            .finish()\n    }\n}\n\n// SAFTY:\n// Gates are never exposed by value to the user so they will be marked\n// as `Send` to fulfill the trait bound for Ptr\u003cGate\u003e to be `Send`.\nunsafe impl Send for Gate {}\n\n// SOLVED ISSUE: stack overflow when comaring circular ptr\n// next_gate \u0026 previous_gate --\u003e Custim PartialEq impl\nimpl PartialEq for Gate {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.name == other.name\n            \u0026\u0026 self.owner().ctx.id == other.owner().ctx.id\n            \u0026\u0026 self.size == other.size\n            \u0026\u0026 self.pos == other.pos\n    }\n}\nimpl Eq for Gate {}\n\nmod private {\n    pub trait Sealed {}\n}\n\n///\n/// A trait for a type to refrence a module specific gate.\n///\npub trait IntoModuleGate: private::Sealed {\n    ///\n    /// Extracts a gate identifier from a module using the given\n    /// value as implicit reference.\n    ///\n    fn as_gate(\u0026self, module: \u0026ModuleContext) -\u003e Option\u003cGateRef\u003e;\n}\n\nimpl\u003cT: IntoModuleGate\u003e IntoModuleGate for \u0026T {\n    fn as_gate(\u0026self, module: \u0026ModuleContext) -\u003e Option\u003cGateRef\u003e {\n        T::as_gate(self, module)\n    }\n}\nimpl\u003cT: IntoModuleGate\u003e private::Sealed for \u0026T {}\n\nimpl IntoModuleGate for GateRef {\n    fn as_gate(\u0026self, _: \u0026ModuleContext) -\u003e Option\u003cGateRef\u003e {\n        Some(self.clone())\n    }\n}\nimpl private::Sealed for GateRef {}\n\nimpl IntoModuleGate for GateRefWeak {\n    fn as_gate(\u0026self, _: \u0026ModuleContext) -\u003e Option\u003cGateRef\u003e {\n        self.upgrade()\n    }\n}\nimpl private::Sealed for GateRefWeak {}\n\nimpl IntoModuleGate for (\u0026str, usize) {\n    fn as_gate(\u0026self, module: \u0026ModuleContext) -\u003e Option\u003cGateRef\u003e {\n        module\n            .gates\n            .read()\n            .iter()\n            .find(|\u0026g| g.name() == self.0 \u0026\u0026 g.pos() == self.1)\n            .cloned()\n    }\n}\nimpl private::Sealed for (\u0026str, usize) {}\n\nimpl IntoModuleGate for \u0026str {\n    fn as_gate(\u0026self, module: \u0026ModuleContext) -\u003e Option\u003cGateRef\u003e {\n        module\n            .gates\n            .read()\n            .iter()\n            .find(|\u0026g| g.name() == *self \u0026\u0026 g.size() == 1)\n            .cloned()\n    }\n}\nimpl private::Sealed for \u0026str {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn fmt() {\n        let owner = ModuleContext::standalone(\"root\".into());\n        let gate = Gate::new(\u0026owner, \"port\", 4, 1);\n        assert_eq!(format!(\"{gate:?}\"), \"Gate { path: \\\"root.port[1]\\\" }\");\n        assert_eq!(gate.str(), \"port[1]\");\n        assert_eq!(gate.path().as_str(), \"root.port[1]\");\n    }\n\n    #[test]\n    fn kind_and_iter() {\n        let owner = ModuleContext::standalone(\"root\".into());\n        let gate_a = Gate::new(\u0026owner, \"port-a\", 1, 0);\n        assert_eq!(gate_a.kind(), GateKind::Standalone);\n\n        let gate_b = Gate::new(\u0026owner, \"port-b\", 1, 0);\n        gate_a.clone().connect(gate_b.clone(), None);\n        assert_eq!(gate_a.kind(), GateKind::Endpoint);\n\n        let gate_c = Gate::new(\u0026owner, \"port-c\", 1, 0);\n        gate_a.clone().connect(gate_c.clone(), None);\n        assert_eq!(gate_a.kind(), GateKind::Transit);\n\n        // Chain chould be c -- a -- b\n        assert_eq!(gate_c.next_gate(), Some(gate_a.clone()));\n        assert_eq!(gate_c.path_end(), Some(gate_b));\n\n        let mut iter = gate_c.path_iter().unwrap();\n        let ca = iter.next().unwrap();\n        assert_eq!(ca.prev_hop(), Some(gate_c));\n        let ab = iter.next().unwrap();\n        assert_eq!(ab.prev_hop(), Some(gate_a));\n    }\n\n    #[test]\n    fn dedup() {\n        let owner = ModuleContext::standalone(\"root\".into());\n        let gate = Gate::new(\u0026owner, \"port\", 1, 0);\n        assert_eq!(gate.kind(), GateKind::Standalone);\n\n        let gate_b = Gate::new(\u0026owner, \"port-b\", 1, 0);\n        gate.clone().connect_dedup(gate_b.clone(), None);\n        assert_eq!(gate.kind(), GateKind::Endpoint);\n\n        gate.clone().connect_dedup(gate_b, None);\n        assert_eq!(gate.kind(), GateKind::Endpoint);\n    }\n\n    #[test]\n    fn into_gate() {\n        let ctx = ModuleContext::standalone(\"root\".into());\n        let gate_a = ctx.create_gate(\"port-a\");\n\n        assert_eq!((\u0026gate_a).as_gate(\u0026ctx.ctx), Some(gate_a.clone()));\n        assert_eq!(\n            Arc::downgrade(\u0026gate_a).as_gate(\u0026ctx.ctx),\n            Some(gate_a.clone())\n        );\n    }\n}\n","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2242},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4438},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4438},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4438},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":4438},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":4438},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":4438},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2195},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":2195},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2340},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":9360},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":186},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":582},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1579},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1579},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1625},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1625},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":7138},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":7138},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":162},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":111},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":111},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":109},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":109},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":10863},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":10863},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":451},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":451},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":1625},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":1625},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":1625},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":11237},"fn_name":null}],"covered":113,"coverable":121},{"path":["/","Users","mk","Developer","rust","des","des","src","net","message","api.rs"],"content":"use crate::{\n    net::{\n        gate::IntoModuleGate,\n        message::Message,\n        module::with_mod_ctx,\n        runtime::{buf_schedule_at, buf_send_at},\n    },\n    time::{Duration, SimTime},\n};\n\n/// Sends a message onto a given gate. The effects of this sending operation\n/// will be observable directly, so an attached channel will be busy right after\n/// the the call to `send`.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// struct MyModule;\n///\n/// impl Module for MyModule {\n///     fn handle_message(\u0026mut self, _msg: Message) {\n///         send(\n///             Message::new().id(123).content(\"Hello world\").build(),\n///             \"out\"\n///         );\n///     }\n/// }\n///\n/// let mut sim = Sim::new(());\n/// sim.node(\"alice\", MyModule);\n/// sim.gate(\"alice\", \"out\");\n/// /* ... */\n///\n/// let _ = Builder::new().build(sim).run();\n/// ```\n#[allow(clippy::needless_pass_by_value)]\npub fn send(msg: impl Into\u003cMessage\u003e, gate: impl IntoModuleGate) {\n    self::send_at(msg, gate, SimTime::now());\n}\n\n/// Sends a message onto a given gate with a delay. If the delay is nonzero\n/// the effects will only be observable later on.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// # struct SomeOtherModule;\n/// # impl Module for SomeOtherModule {}\n/// struct MyModule;\n///\n/// impl Module for MyModule {\n///     fn at_sim_start(\u0026mut self, _: usize) {\n///         send_in(Message::new().kind(42).build(), \"out\", Duration::from_secs(2));\n///         assert!(\n///             !current()\n///                 .gate(\"out\", 0).unwrap()\n///                 .path_iter().unwrap() // an iter can NOT be created for transit gates, no direction info provided\n///                 .next().unwrap() // get next iter element\n///                 .channel().unwrap() // channels attached to connections are optional\n///                 .is_busy()     \n///        );\n///     }\n/// }\n///\n/// let mut sim = Sim::new(());\n/// sim.node(\"alice\", MyModule);\n/// let out_gate = sim.gate(\"alice\", \"out\");\n///\n/// sim.node(\"bob\", SomeOtherModule);\n/// let in_gate = sim.gate(\"bob\", \"in\");\n///\n/// out_gate.connect(in_gate, Some(\n///     /* Channel definition */\n///     # Channel::new(ChannelMetrics { bitrate: 10000, jitter: Duration::ZERO, latency: Duration::from_millis(10), drop_behaviour: ChannelDropBehaviour::Drop })\n/// ));\n///\n/// let _ = Builder::new().build(sim).run();\n///\n/// ```\n#[allow(clippy::needless_pass_by_value)]\npub fn send_in(msg: impl Into\u003cMessage\u003e, gate: impl IntoModuleGate, dur: Duration) {\n    let deadline = SimTime::now() + dur;\n    self::send_at(msg, gate, deadline);\n}\n/// Sends a message onto a given gate at the specific time. This operation is\n/// equivalent to [`send_in`].\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// # Panics\n///\n/// Panics if the send time is in the past.\n#[allow(clippy::needless_pass_by_value)]\npub fn send_at(msg: impl Into\u003cMessage\u003e, gate: impl IntoModuleGate, send_time: SimTime) {\n    assert!(send_time \u003e= SimTime::now());\n    // (0) Cast the message.\n    let msg: Message = msg.into();\n\n    let gate = with_mod_ctx(|ctx| {\n        // (1) Cast the gate\n        #[allow(clippy::explicit_auto_deref)] // IS RIGHT ?\n        gate.as_gate(ctx)\n    });\n\n    if let Some(gate) = gate {\n        // plugin capture\n        // let Some(msg) = plugin::plugin_output_stream(msg) else {\n        //     return\n        // };\n\n        buf_send_at(msg, gate, send_time);\n    } else {\n        #[cfg(feature = \"tracing\")]\n        tracing::error!(\"Error: Could not find gate in current module\");\n    }\n}\n\n/// Enqueues a event that will trigger the\n/// [`Module::handle_message`](crate::net::module::Module::handle_message)\n/// function in duration seconds, shifted by the processing time delay.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// struct Timer { period: Duration }\n/// impl Module for Timer {\n///     fn at_sim_start(\u0026mut self, _: usize) {\n///         schedule_in(Message::new().content(\"wakeup\").build(), self.period);\n///     }\n///\n///     fn handle_message(\u0026mut self, msg: Message) {\n///         assert_eq!(msg.try_content::\u003c\u0026str\u003e(), Some(\u0026\"wakeup\"));\n///         /* Do something periodicly */\n///         schedule_in(msg, self.period);\n///     }\n/// }\n///\n/// let mut sim = Sim::new(());\n/// sim.node(\"timer\", Timer { period: Duration::from_secs(5) });\n/// /* ... */\n///\n/// let _ = Builder::new().max_time(100.0.into()).build(sim).run();\n/// ```\npub fn schedule_in(msg: impl Into\u003cMessage\u003e, dur: Duration) {\n    self::schedule_at(msg, SimTime::now() + dur);\n}\n\n/// Enqueues a event that will trigger the\n/// [`Module::handle_message`](crate::net::module::Module::handle_message)\n/// function at the given `SimTime`. This operation is equivalent to [`schedule_in`].\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// # Panics\n///\n/// Panics if the specified time is in the past.\npub fn schedule_at(msg: impl Into\u003cMessage\u003e, arrival_time: SimTime) {\n    assert!(arrival_time \u003e= SimTime::now());\n    let msg: Message = msg.into();\n\n    // plugin capture\n    // let Some(msg) = plugin::plugin_output_stream(msg) else {\n    //     return\n    // };\n\n    buf_schedule_at(msg, arrival_time);\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":2075},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2075},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":4170},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":4170},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1114},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1114},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null}],"covered":18,"coverable":21},{"path":["/","Users","mk","Developer","rust","des","des","src","net","message","body.rs"],"content":"/// A trait that allows a type to be mesured in bits / bytes.\n///\n/// * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\npub trait MessageBody {\n    /// The length of the message body in bytes.\n    fn byte_len(\u0026self) -\u003e usize;\n}\n\n// # Primitives\n\nmacro_rules! msg_body_primitiv {\n    ($t: ty) =\u003e {\n        impl MessageBody for $t {\n            fn byte_len(\u0026self) -\u003e usize {\n                std::mem::size_of::\u003cSelf\u003e()\n            }\n        }\n    };\n}\n\nmsg_body_primitiv!(());\n\nmsg_body_primitiv!(u8);\nmsg_body_primitiv!(u16);\nmsg_body_primitiv!(u32);\nmsg_body_primitiv!(u64);\nmsg_body_primitiv!(u128);\nmsg_body_primitiv!(usize);\n\nmsg_body_primitiv!(i8);\nmsg_body_primitiv!(i16);\nmsg_body_primitiv!(i32);\nmsg_body_primitiv!(i64);\nmsg_body_primitiv!(i128);\nmsg_body_primitiv!(isize);\n\nmsg_body_primitiv!(f64);\nmsg_body_primitiv!(f32);\n\nmsg_body_primitiv!(bool);\nmsg_body_primitiv!(char);\n\nmacro_rules! msg_body_lenable {\n    ($t: ty) =\u003e {\n        impl MessageBody for $t {\n            fn byte_len(\u0026self) -\u003e usize {\n                self.len()\n            }\n        }\n    };\n}\n\nmsg_body_lenable!(\u0026'static str);\nmsg_body_lenable!(String);\n\n// # Basic types\n\nimpl\u003cT: MessageBody\u003e MessageBody for Box\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        use std::ops::Deref;\n\n        self.deref().byte_len()\n    }\n}\n\nimpl\u003cT: MessageBody\u003e MessageBody for Option\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        match self {\n            Some(ref content) =\u003e content.byte_len(),\n            None =\u003e 0,\n        }\n    }\n}\n\nimpl\u003cT: MessageBody, E: MessageBody\u003e MessageBody for Result\u003cT, E\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        match self {\n            Ok(ref val) =\u003e val.byte_len(),\n            Err(ref err) =\u003e err.byte_len(),\n        }\n    }\n}\n\n// # Collections\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, LinkedList, VecDeque};\n\nimpl\u003cT: MessageBody\u003e MessageBody for Vec\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        self.iter().fold(0, |acc, v| acc + v.byte_len())\n    }\n}\n\nimpl\u003cT: MessageBody\u003e MessageBody for VecDeque\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        self.iter().fold(0, |acc, v| acc + v.byte_len())\n    }\n}\n\nimpl\u003cT: MessageBody\u003e MessageBody for LinkedList\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        self.iter().fold(0, |acc, v| acc + v.byte_len())\n    }\n}\n\nimpl\u003cT: MessageBody, const N: usize\u003e MessageBody for [T; N] {\n    fn byte_len(\u0026self) -\u003e usize {\n        let mut sum = 0;\n        for element in self {\n            sum += element.byte_len();\n        }\n        sum\n    }\n}\n\nimpl\u003cT: MessageBody\u003e MessageBody for \u0026[T] {\n    fn byte_len(\u0026self) -\u003e usize {\n        self.iter().fold(0, |acc, v| acc + v.byte_len())\n    }\n}\n\nimpl\u003cK: MessageBody, V: MessageBody, S\u003e MessageBody for HashMap\u003cK, V, S\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        let mut sum = 0;\n        for (k, v) in self {\n            sum += k.byte_len() + v.byte_len();\n        }\n        sum\n    }\n}\n\nimpl\u003cK: MessageBody, V: MessageBody\u003e MessageBody for BTreeMap\u003cK, V\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        let mut sum = 0;\n        for (k, v) in self {\n            sum += k.byte_len() + v.byte_len();\n        }\n        sum\n    }\n}\n\nimpl\u003cT: MessageBody, S\u003e MessageBody for HashSet\u003cT, S\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        let mut sum = 0;\n        for v in self {\n            sum += v.byte_len();\n        }\n        sum\n    }\n}\n\nimpl\u003cT: MessageBody\u003e MessageBody for BTreeSet\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        let mut sum = 0;\n        for v in self {\n            sum += v.byte_len();\n        }\n        sum\n    }\n}\n\nimpl\u003cT: MessageBody\u003e MessageBody for BinaryHeap\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        let mut sum = 0;\n        for v in self {\n            sum += v.byte_len();\n        }\n        sum\n    }\n}\n\n// # std::net\nuse std::net;\n\nimpl MessageBody for net::Ipv4Addr {\n    fn byte_len(\u0026self) -\u003e usize {\n        4\n    }\n}\n\nimpl MessageBody for net::Ipv6Addr {\n    fn byte_len(\u0026self) -\u003e usize {\n        16\n    }\n}\n\nimpl MessageBody for net::IpAddr {\n    fn byte_len(\u0026self) -\u003e usize {\n        match self {\n            Self::V4(v4) =\u003e v4.byte_len(),\n            Self::V6(v6) =\u003e v6.byte_len(),\n        }\n    }\n}\n\nimpl MessageBody for net::SocketAddrV4 {\n    fn byte_len(\u0026self) -\u003e usize {\n        4 + 2\n    }\n}\n\nimpl MessageBody for net::SocketAddrV6 {\n    fn byte_len(\u0026self) -\u003e usize {\n        16 + 2\n    }\n}\n\nimpl MessageBody for net::SocketAddr {\n    fn byte_len(\u0026self) -\u003e usize {\n        match self {\n            Self::V4(v4) =\u003e v4.byte_len(),\n            Self::V6(v6) =\u003e v6.byte_len(),\n        }\n    }\n}\n\n// # Time\nuse crate::time;\n\nimpl MessageBody for time::Duration {\n    fn byte_len(\u0026self) -\u003e usize {\n        16\n    }\n}\n\nimpl MessageBody for time::SimTime {\n    fn byte_len(\u0026self) -\u003e usize {\n        16\n    }\n}\n\n// # Tuples\n\nimpl\u003cA, B\u003e MessageBody for (A, B)\nwhere\n    A: MessageBody,\n    B: MessageBody,\n{\n    fn byte_len(\u0026self) -\u003e usize {\n        self.0.byte_len() + self.1.byte_len()\n    }\n}\n\nimpl\u003cA, B, C\u003e MessageBody for (A, B, C)\nwhere\n    A: MessageBody,\n    B: MessageBody,\n    C: MessageBody,\n{\n    fn byte_len(\u0026self) -\u003e usize {\n        self.0.byte_len() + self.1.byte_len() + self.2.byte_len()\n    }\n}\n\nimpl\u003cA, B, C, D\u003e MessageBody for (A, B, C, D)\nwhere\n    A: MessageBody,\n    B: MessageBody,\n    C: MessageBody,\n    D: MessageBody,\n{\n    fn byte_len(\u0026self) -\u003e usize {\n        self.0.byte_len() + self.1.byte_len() + self.2.byte_len() + self.3.byte_len()\n    }\n}\n\nimpl\u003cA, B, C, D, E\u003e MessageBody for (A, B, C, D, E)\nwhere\n    A: MessageBody,\n    B: MessageBody,\n    C: MessageBody,\n    D: MessageBody,\n    E: MessageBody,\n{\n    fn byte_len(\u0026self) -\u003e usize {\n        self.0.byte_len()\n            + self.1.byte_len()\n            + self.2.byte_len()\n            + self.3.byte_len()\n            + self.4.byte_len()\n    }\n}\n\nimpl\u003cA, B, C, D, E, F\u003e MessageBody for (A, B, C, D, E, F)\nwhere\n    A: MessageBody,\n    B: MessageBody,\n    C: MessageBody,\n    D: MessageBody,\n    E: MessageBody,\n    F: MessageBody,\n{\n    fn byte_len(\u0026self) -\u003e usize {\n        self.0.byte_len()\n            + self.1.byte_len()\n            + self.2.byte_len()\n            + self.3.byte_len()\n            + self.4.byte_len()\n            + self.5.byte_len()\n    }\n}\n\n///\n/// A message body that does mimics a custom size\n/// independet of actualy size.\n///\n#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct CustomSizeBody\u003cT\u003e {\n    byte_len: usize,\n    inner: T,\n}\n\nimpl\u003cT\u003e CustomSizeBody\u003cT\u003e {\n    ///\n    /// Creates a new instance of `Self`.\n    ///\n    #[must_use]\n    pub fn new(byte_len: usize, inner: T) -\u003e Self {\n        Self { byte_len, inner }\n    }\n\n    ///\n    /// Returns a reference to the real contained body.\n    ///\n    pub fn inner(\u0026self) -\u003e \u0026T {\n        \u0026self.inner\n    }\n\n    ///\n    /// Returns a mutable reference to the real contained body.\n    ///\n    pub fn inner_mut(\u0026mut self) -\u003e \u0026mut T {\n        \u0026mut self.inner\n    }\n\n    ///\n    /// Returns the body, consuming `self`.\n    ///\n    #[must_use]\n    pub fn into_inner(self) -\u003e T {\n        self.inner\n    }\n}\n\nimpl\u003cT\u003e MessageBody for CustomSizeBody\u003cT\u003e\nwhere\n    T: Clone,\n{\n    fn byte_len(\u0026self) -\u003e usize {\n        self.byte_len\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{super::*, *};\n\n    #[test]\n    fn custom_message_body() {\n        let slice = \"Hello world!\";\n\n        let mut body = CustomSizeBody::new(16, slice);\n        assert_eq!(body.inner(), \u0026\"Hello world!\");\n        assert_eq!(body.inner_mut(), \u0026mut \"Hello world!\");\n\n        let msg = Message::new().content(body).build();\n        assert_eq!(msg.length(), 16 + 64);\n\n        let content = msg.content::\u003cCustomSizeBody\u003c\u0026str\u003e\u003e();\n        assert_eq!((*content.inner()).as_ptr(), slice.as_ptr());\n\n        let content = content.clone();\n        assert_eq!(content.into_inner(), \"Hello world!\");\n    }\n\n    #[test]\n    fn auto_impl() {\n        assert_eq!(\n            [1, 2, 3, 4u8]\n                .into_iter()\n                .collect::\u003cVecDeque\u003c_\u003e\u003e()\n                .byte_len(),\n            4\n        );\n\n        assert_eq!(\n            [1, 2, 3, 4u8]\n                .into_iter()\n                .collect::\u003cLinkedList\u003c_\u003e\u003e()\n                .byte_len(),\n            4\n        );\n\n        assert_eq!(\n            [1, 2, 3, 4u8]\n                .into_iter()\n                .collect::\u003cHashSet\u003c_\u003e\u003e()\n                .byte_len(),\n            4\n        );\n\n        assert_eq!(\n            [1, 2, 3, 4u8]\n                .into_iter()\n                .collect::\u003cBTreeSet\u003c_\u003e\u003e()\n                .byte_len(),\n            4\n        );\n\n        assert_eq!(\n            [1, 2, 3, 4u8]\n                .into_iter()\n                .collect::\u003cBinaryHeap\u003c_\u003e\u003e()\n                .byte_len(),\n            4\n        );\n\n        assert_eq!(\n            [(1, 1), (2, 2), (3, 3), (4u8, 4u16)]\n                .into_iter()\n                .collect::\u003cHashMap\u003c_, _\u003e\u003e()\n                .byte_len(),\n            12\n        );\n\n        assert_eq!(\n            [(1, 1), (2, 2), (3, 3), (4u8, 4u16)]\n                .into_iter()\n                .collect::\u003cBTreeMap\u003c_, _\u003e\u003e()\n                .byte_len(),\n            12\n        );\n\n        assert_eq!((\u0026[1, 2, 3, 4u8][..3]).byte_len(), 3);\n\n        assert_eq!(net::Ipv4Addr::new(1, 2, 3, 4).byte_len(), 4);\n        assert_eq!(net::Ipv6Addr::new(1, 2, 3, 4, 0, 0, 0, 0).byte_len(), 16);\n        assert_eq!(\n            net::IpAddr::V4(net::Ipv4Addr::new(1, 2, 3, 4)).byte_len(),\n            4\n        );\n        assert_eq!(\n            net::IpAddr::V6(net::Ipv6Addr::new(1, 2, 3, 4, 0, 0, 0, 0)).byte_len(),\n            16\n        );\n\n        assert_eq!(\n            net::SocketAddrV4::new(net::Ipv4Addr::new(1, 2, 3, 4), 0).byte_len(),\n            4 + 2\n        );\n        assert_eq!(\n            net::SocketAddrV6::new(net::Ipv6Addr::new(1, 2, 3, 4, 0, 0, 0, 0), 0, 0, 0).byte_len(),\n            16 + 2\n        );\n        assert_eq!(\n            net::SocketAddr::V4(net::SocketAddrV4::new(net::Ipv4Addr::new(1, 2, 3, 4), 0))\n                .byte_len(),\n            4 + 2\n        );\n        assert_eq!(\n            net::SocketAddr::V6(net::SocketAddrV6::new(\n                net::Ipv6Addr::new(1, 2, 3, 4, 0, 0, 0, 0),\n                0,\n                0,\n                0\n            ))\n            .byte_len(),\n            16 + 2\n        );\n\n        assert_eq!(time::Duration::from_secs(123).byte_len(), 16);\n        assert_eq!(\n            time::SimTime::from_duration(time::Duration::from_secs(123)).byte_len(),\n            16\n        );\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2623},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":2623},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4145},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4145},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":7685},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2560},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":81,"coverable":100},{"path":["/","Users","mk","Developer","rust","des","des","src","net","message","header.rs"],"content":"#![allow(dead_code)]\n\nuse super::MessageBody;\nuse crate::net::{gate::GateRef, module::ModuleId};\nuse crate::time::SimTime;\n\nuse std::fmt::Debug;\n\n///\n/// A ID that defines the meaning of the message in the simulation context.\n///\n///  * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\npub type MessageId = u16;\n\n///\n/// The type of messages, similar to the TOS field in IP packets.\n///\n///  * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\npub type MessageKind = u16;\n\n///\n/// The metadata attachted to a message, independent of its contents.\n///\n/// * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[allow(missing_docs)]\npub struct MessageHeader {\n    pub id: MessageId,     // Custom\n    pub kind: MessageKind, // Ethertype\n    pub creation_time: SimTime,\n    pub send_time: SimTime,\n\n    pub sender_module_id: ModuleId,   // MAC src\n    pub receiver_module_id: ModuleId, // MAC dest\n    pub last_gate: Option\u003cGateRef\u003e,   // Path info\n\n    pub src: [u8; 6],\n    pub dest: [u8; 6],\n\n    // The packet length in bytes.\n    pub length: u32,\n}\n\n// # DUP\nimpl MessageHeader {\n    pub(super) fn dup(\u0026self, now: SimTime) -\u003e Self {\n        Self {\n            id: self.id,\n            kind: self.kind,\n            creation_time: now,\n            send_time: SimTime::MIN,\n\n            sender_module_id: self.sender_module_id,\n            receiver_module_id: self.receiver_module_id,\n            last_gate: self.last_gate.clone(),\n\n            src: self.src,\n            dest: self.dest,\n\n            length: self.length,\n        }\n    }\n}\n\nimpl Default for MessageHeader {\n    fn default() -\u003e Self {\n        Self {\n            id: 0,\n            kind: 0,\n            creation_time: SimTime::now(),\n            send_time: SimTime::MIN,\n\n            sender_module_id: ModuleId::NULL,\n            receiver_module_id: ModuleId::NULL,\n            last_gate: None,\n\n            src: [0; 6],\n            dest: [0; 6],\n\n            length: 0,\n        }\n    }\n}\n\nimpl MessageBody for MessageHeader {\n    fn byte_len(\u0026self) -\u003e usize {\n        64 // TODO  compute correct header size\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn header_duplication() {\n        let header = MessageHeader {\n            id: 42,\n            kind: 69,\n            creation_time: 100.0.into(),\n            send_time: 150.0.into(),\n            sender_module_id: ModuleId(12),\n            receiver_module_id: ModuleId(14),\n            last_gate: None,\n            src: [1; 6],\n            dest: [2; 6],\n            length: 32,\n        };\n\n        assert_eq!(\n            header.dup(200.0.into()),\n            MessageHeader {\n                id: 42,\n                kind: 69,\n                creation_time: 200.0.into(),\n                send_time: SimTime::MIN,\n                sender_module_id: ModuleId(12),\n                receiver_module_id: ModuleId(14),\n                last_gate: None,\n                src: [1; 6],\n                dest: [2; 6],\n                length: 32,\n            }\n        )\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2325},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2325},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2325},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2325},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":4141},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":4141},"fn_name":null}],"covered":15,"coverable":15},{"path":["/","Users","mk","Developer","rust","des","des","src","net","message","mod.rs"],"content":"//! Generic network messages.\n\nuse crate::net::{gate::GateRef, module::ModuleId};\nuse crate::time::SimTime;\nuse std::fmt::Debug;\nuse std::panic::UnwindSafe;\n\nmod api;\npub use api::*;\n\nmod body;\npub use body::*;\n\nmod util;\nuse util::AnyBox;\n\nmod header;\npub use header::*;\n\n///\n/// A generic network message holding a payload.\n///\n/// * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\n#[derive(Debug)]\npub struct Message {\n    pub(crate) header: Box\u003cMessageHeader\u003e,\n    pub(crate) content: Option\u003cAnyBox\u003e,\n}\n\nimpl Message {\n    ///\n    /// Creates a new instance of self through a builder.\n    ///\n    #[allow(clippy::new_ret_no_self)]\n    #[must_use]\n    pub fn new() -\u003e MessageBuilder {\n        MessageBuilder::new()\n    }\n\n    /// Returns the length of the complete message\n    #[must_use]\n    pub fn length(\u0026self) -\u003e usize {\n        self.header.length as usize + self.header.byte_len()\n    }\n\n    ///\n    /// The metadata attached to the message.\n    ///\n    #[inline]\n    #[must_use]\n    pub fn header(\u0026self) -\u003e \u0026MessageHeader {\n        \u0026self.header\n    }\n\n    ///\n    /// The metadata attached to the message.\n    ///\n    #[inline]\n    #[must_use]\n    pub fn header_mut(\u0026mut self) -\u003e \u0026mut MessageHeader {\n        \u0026mut self.header\n    }\n\n    ///\n    /// A strinification function that reduces it to its identifering pars.\n    ///\n    #[must_use]\n    pub fn str(\u0026self) -\u003e String {\n        format!(\n            \"Message {{ {} bytes {}  }}\",\n            self.header.length,\n            self.content.as_ref().map_or(\"no content\", AnyBox::ty),\n        )\n    }\n}\n\n/// # Content Accessing\nimpl Message {\n    ///\n    /// Trys to return the content by reference casted to the given type T.\n    /// Returns [None] if the no content exists or the content is not of type T.\n    ///\n    #[must_use]\n    pub fn try_content\u003cT: 'static + MessageBody\u003e(\u0026self) -\u003e Option\u003c\u0026T\u003e {\n        Some(self.content.as_ref()?.try_cast_ref::\u003cT\u003e())?\n    }\n\n    ///\n    /// Trys to return the content by reference casted to the given type T.\n    /// Panics if the no content exists or the content is not of type T.\n    ///\n    /// # Panics\n    ///\n    /// Panics if he cast fails.\n    #[must_use]\n    pub fn content\u003cT: 'static + MessageBody\u003e(\u0026self) -\u003e \u0026T {\n        self.try_content().expect(\"Failed to unwrap\")\n    }\n\n    ///\n    /// Trys to return the content by mutable ref casted to the given type T.\n    /// Returns [None] if the no content exists or the content is not of type T.\n    ///\n    pub fn try_content_mut\u003cT: 'static + MessageBody\u003e(\u0026mut self) -\u003e Option\u003c\u0026mut T\u003e {\n        Some(self.content.as_mut()?.try_cast_mut())?\n    }\n\n    ///\n    /// Trys to return the content by mutable ref casted to the given type T.\n    /// Panics if the no content exists or the content is not of type T.\n    ///\n    /// # Panics\n    ///\n    /// Panics if he cast fails.\n    pub fn content_mut\u003cT: 'static + MessageBody\u003e(\u0026mut self) -\u003e \u0026mut T {\n        self.try_content_mut().expect(\"Failed to unwrap\")\n    }\n}\n\n/// # Content casting\nimpl Message {\n    ///\n    /// Indicates wheter a cast to a instance of type T ca\n    /// succeed.\n    ///\n    /// ## Safty\n    ///\n    /// Note that this only gurantees that a cast will result in UB\n    /// if it returns 'false'. Should this function return 'true' it indicates\n    /// that the underlying value was created as a instance of type 'T',\n    /// which does not gurantee that this is a internally valid instance\n    /// of 'T'.\n    ///\n    /// # Panics\n    ///\n    /// Panics if he cast fails.\n    #[inline]\n    #[must_use]\n    pub fn can_cast\u003cT: 'static + MessageBody\u003e(\u0026self) -\u003e bool {\n        self.content.as_ref().map_or(false, AnyBox::can_cast::\u003cT\u003e)\n    }\n\n    ///\n    /// Performs a [`try_cast`](Message::try_cast)unwraping the result.\n    ///\n    /// # Panics\n    ///\n    /// Panics if he cast fails.\n    #[must_use]\n    pub fn cast\u003cT: 'static + MessageBody + Send\u003e(self) -\u003e (T, MessageHeader) {\n        self.try_cast().expect(\"Could not cast to type T\")\n    }\n\n    ///\n    /// Consumes the message casting the stored ptr\n    /// into a Box of type T.\n    ///\n    /// ## Safety\n    ///\n    /// The caller must ensure that the stored data is a valid instance\n    /// of type T. If this cannot be guarnteed this is UB.\n    /// Note that DES guarntees that the data refernced by ptr will not\n    /// be freed until this function is called, and ownership is thereby moved..\n    ///D\n    /// # Errors\n    ///\n    /// Returns an error if either there is no content, or\n    /// the content is not of type T.\n    pub fn try_cast\u003cT: 'static + MessageBody + Send\u003e(self) -\u003e Result\u003c(T, MessageHeader), Self\u003e {\n        // SAFTY:\n        // Since T is 'Send' this is safe within the bounds of Messages safty contract\n        unsafe { self.try_cast_unsafe::\u003cT\u003e() }\n    }\n\n    ///\n    /// Performs a [`try_cast_unsafe`](Message::try_cast_unsafe) unwraping the result.\n    ///\n    /// # Safety\n    ///\n    /// See [`try_cast_unsafe`](Message::try_cast_unsafe)\n    ///\n    /// # Panics\n    ///\n    /// Panics if he cast fails.\n    #[must_use]\n    pub unsafe fn cast_unsafe\u003cT: 'static + MessageBody\u003e(self) -\u003e (T, MessageHeader) {\n        self.try_cast_unsafe().expect(\"Could not cast to type T\")\n    }\n\n    ///\n    /// Consumes the message casting the stored ptr\n    /// into a Box of type T.\n    ///\n    /// ## Safety\n    ///\n    /// The caller must ensure that the stored data is a valid instance\n    /// of type T. If this cannot be guarnteed this is UB.\n    /// Note that DES guarntees that the data refernced by ptr will not\n    /// be freed until this function is called, and ownership is thereby moved..\n    /// Note that this function allows T to be !Send. Be aware of safty problems arriving\n    /// from this.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if either there is no content,\n    /// or the content is not of type T.\n    ///\n\n    pub unsafe fn try_cast_unsafe\u003cT: 'static + MessageBody\u003e(\n        self,\n    ) -\u003e Result\u003c(T, MessageHeader), Self\u003e {\n        let Message { header, content } = self;\n        let content = match content.map(|c| c.try_cast_unsafe::\u003cT\u003e()) {\n            Some(Ok(c)) =\u003e c,\n            Some(Err(content)) =\u003e {\n                return Err(Self {\n                    header,\n                    content: Some(content),\n                })\n            }\n            None =\u003e {\n                return Err(Self {\n                    header,\n                    content: None,\n                })\n            }\n        };\n\n        Ok((content, *header))\n    }\n}\n\nimpl Message {\n    ///\n    /// Duplicates a message.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the contained value is not of type T.\n    ///\n    #[must_use]\n    pub fn dup\u003cT\u003e(\u0026self) -\u003e Self\n    where\n        T: 'static + Clone,\n    {\n        self.try_dup::\u003cT\u003e().expect(\"Failed to duplicate a message\")\n    }\n\n    ///\n    /// Tries to create a duplicate of the message, assuming its content is of type T.\n    ///\n    /// - If the messages body is of type T, the body will be cloned as specified by T\n    /// and the dup will succeed.\n    /// - If the message body is not of type T, this function will return `None`.\n    /// - If the message has no body it will succeed independent of T and clone only the\n    /// attached metadata.\n    ///\n    #[must_use]\n    pub fn try_dup\u003cT\u003e(\u0026self) -\u003e Option\u003cSelf\u003e\n    where\n        T: 'static + Clone,\n    {\n        let content: Option\u003cAnyBox\u003e = if let Some(ref content) = self.content {\n            Some(content.try_dup::\u003cT\u003e()?)\n        } else {\n            None\n        };\n\n        let header = Box::new(self.header.dup(SimTime::now()));\n\n        Some(Self { header, content })\n    }\n}\n\n// SAFTY:\n// A message only contains primitve data, ptrs that are threadsafe\n// and a untyped contained value.\nunsafe impl Send for Message {}\n\nimpl UnwindSafe for Message {}\n\n///\n/// A intermediary type for constructing messages.\n///\npub struct MessageBuilder {\n    pub(crate) header: Box\u003cMessageHeader\u003e,\n    pub(crate) content: Option\u003cAnyBox\u003e,\n}\n\nimpl MessageBuilder {\n    /// Creates a new builder.\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            header: Box::default(),\n            content: None,\n        }\n    }\n\n    /// Sets the field `header`.\n    ///\n    /// Note that the header may change the length field depending on the content\n    /// that may allready be set.\n    #[must_use]\n    pub fn header(mut self, meta: MessageHeader) -\u003e Self {\n        let old_len = self.header.length;\n        self.header = Box::new(meta);\n        self.header.length = old_len;\n        self\n    }\n\n    /// Sets the field `header.id`.\n    #[must_use]\n    pub fn id(mut self, id: MessageId) -\u003e Self {\n        self.header.id = id;\n        self\n    }\n\n    /// Sets the field `header.kind`.\n    #[must_use]\n    pub fn kind(mut self, kind: MessageKind) -\u003e Self {\n        self.header.kind = kind;\n        self\n    }\n\n    /// Sets the field `header.receiver_module_id`.\n    #[must_use]\n    pub fn receiver_module_id(mut self, receiver_module_id: ModuleId) -\u003e Self {\n        self.header.receiver_module_id = receiver_module_id;\n        self\n    }\n\n    /// Sets the field `header.sender_module_id`.\n    #[must_use]\n    pub fn sender_module_id(mut self, sender_module_id: ModuleId) -\u003e Self {\n        self.header.sender_module_id = sender_module_id;\n        self\n    }\n\n    /// Sets the source addr of the message (as eth)\n    #[must_use]\n    pub fn src(mut self, src: [u8; 6]) -\u003e Self {\n        self.header.src = src;\n        self\n    }\n\n    /// Sets the destination addr of the message (as eth)\n    #[must_use]\n    pub fn dest(mut self, dest: [u8; 6]) -\u003e Self {\n        self.header.dest = dest;\n        self\n    }\n\n    /// Sets the field `header.last_gate`.\n    #[must_use]\n    pub fn last_gate(mut self, last_gate: GateRef) -\u003e Self {\n        self.header.last_gate = Some(last_gate);\n        self\n    }\n\n    /// Sets the field `meta`.`creation_time`.\n    #[must_use]\n    pub fn creation_time(mut self, creation_time: SimTime) -\u003e Self {\n        self.header.creation_time = creation_time;\n        self\n    }\n\n    /// Sets the field `header.send_time`.\n    #[must_use]\n    pub fn send_time(mut self, send_time: SimTime) -\u003e Self {\n        self.header.send_time = send_time;\n        self\n    }\n\n    /// Sets the field `content`.\n    #[must_use]\n    #[allow(clippy::cast_possible_truncation)]\n    pub fn content\u003cT\u003e(mut self, content: T) -\u003e Self\n    where\n        T: 'static + MessageBody + Send,\n    {\n        self.header.length = content.byte_len() as u32;\n        self.content = Some(AnyBox::new(content));\n        self\n    }\n\n    /// Sets the field 'content' with a T that is not guarnteed to be Send.\n    pub unsafe fn content_unsafe\u003cT\u003e(mut self, content: T) -\u003e Self\n    where\n        T: 'static + MessageBody,\n    {\n        self.header.length = content.byte_len() as u32;\n        self.content = Some(AnyBox::new(content));\n        self\n    }\n\n    /// Builds a message from the builder.\n    #[must_use]\n    pub fn build(self) -\u003e Message {\n        let MessageBuilder { header, content } = self;\n\n        Message { header, content }\n    }\n}\n\nimpl Default for MessageBuilder {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Debug for MessageBuilder {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"MessageBuilder\")\n    }\n}\n\n// SAFTY:\n// Dervived from safty invariants of [Message].\nunsafe impl Send for MessageBuilder {}\n\n#[cfg(test)]\nmod tests {\n    use crate::{net::module::ModuleContext, prelude::Gate};\n\n    use super::*;\n    use std::{any::type_name, rc::Rc};\n\n    #[test]\n    fn message_fmt() {\n        let msg = Message::new()\n            .id(123)\n            .src([1; 6])\n            .dest([2; 6])\n            .content(String::from(\"Hello world!\"))\n            .build();\n\n        #[cfg(debug_assertions)]\n        assert_eq!(\n            msg.str(),\n            format!(\"Message {{ 12 bytes {}  }}\", type_name::\u003cString\u003e())\n        );\n\n        assert!(msg.can_cast::\u003cString\u003e());\n        assert_eq!(msg.content::\u003cString\u003e(), \"Hello world!\");\n    }\n\n    #[test]\n    fn message_builder_fmt() {\n        assert_eq!(format!(\"{:?}\", MessageBuilder::default()), \"MessageBuilder\");\n    }\n\n    #[test]\n    fn message_cast() {\n        struct A(i32);\n        impl MessageBody for A {\n            fn byte_len(\u0026self) -\u003e usize {\n                0\n            }\n        }\n\n        let msg = Message::new()\n            .header(MessageHeader::default())\n            .id(123)\n            .receiver_module_id(ModuleId(1))\n            .sender_module_id(ModuleId(2))\n            .content(A(42))\n            .build();\n        let (value, header) = msg.cast::\u003cA\u003e();\n        assert_eq!(header.id, 123);\n        assert_eq!(value.0, 42);\n    }\n\n    #[test]\n    fn message_cast_unsafe() {\n        // RC is not send\n        #[derive(Default)]\n        struct A {\n            rc: Rc\u003ci32\u003e,\n        }\n        impl MessageBody for A {\n            fn byte_len(\u0026self) -\u003e usize {\n                0\n            }\n        }\n\n        let module = ModuleContext::standalone(\"root\".into());\n        let gate = Gate::new(\u0026module, \"port\", 1, 0);\n\n        unsafe {\n            let msg = Message::new()\n                .creation_time(10.0.into())\n                .send_time(11.0.into())\n                .last_gate(gate)\n                .content_unsafe(A { rc: Rc::new(42) })\n                .build();\n\n            let msg = msg.try_cast_unsafe::\u003cString\u003e().unwrap_err();\n\n            let (value, _) = msg.cast_unsafe::\u003cA\u003e();\n            assert_eq!(*value.rc, 42);\n\n            // See with None\n\n            let msg = Message::new().build();\n            assert!(msg.try_cast_unsafe::\u003cString\u003e().is_err());\n        }\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":2323},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2323},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4141},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4141},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4846},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4846},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":2324},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":2324},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1121},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1121},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":1121},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":1999},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":1999},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":1999},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":2323},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":2323},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":88,"coverable":97},{"path":["/","Users","mk","Developer","rust","des","des","src","net","message","util.rs"],"content":"use std::{any::Any, fmt::Debug};\n\npub(crate) struct AnyBox {\n    inner: Box\u003cdyn Any\u003e,\n\n    #[cfg(debug_assertions)]\n    ty_info: \u0026'static str,\n}\n\nimpl AnyBox {\n    pub(crate) fn new\u003cT: 'static\u003e(val: T) -\u003e Self {\n        Self {\n            inner: Box::new(val),\n\n            #[cfg(debug_assertions)]\n            ty_info: std::any::type_name::\u003cT\u003e(),\n        }\n    }\n\n    #[cfg(debug_assertions)]\n    pub(crate) fn ty(\u0026self) -\u003e \u0026'static str {\n        self.ty_info\n    }\n\n    #[cfg(not(debug_assertions))]\n    pub(crate) fn ty(\u0026self) -\u003e \u0026'static str {\n        \"no ty info\"\n    }\n\n    pub(crate) fn try_dup\u003cT: 'static + Clone\u003e(\u0026self) -\u003e Option\u003cSelf\u003e {\n        self.inner.downcast_ref::\u003cT\u003e().map(|v| Self {\n            inner: Box::new(v.clone()),\n\n            #[cfg(debug_assertions)]\n            ty_info: std::any::type_name::\u003cT\u003e(),\n        })\n    }\n\n    pub(crate) fn can_cast\u003cT: 'static\u003e(\u0026self) -\u003e bool {\n        self.inner.is::\u003cT\u003e()\n    }\n\n    pub(crate) unsafe fn try_cast_unsafe\u003cT: 'static\u003e(self) -\u003e Result\u003cT, Self\u003e {\n        match self.inner.downcast::\u003cT\u003e() {\n            Ok(v) =\u003e Ok(*v),\n            Err(e) =\u003e Err(Self {\n                inner: e,\n                #[cfg(debug_assertions)]\n                ty_info: self.ty_info,\n            }),\n        }\n    }\n\n    pub(crate) fn try_cast_ref\u003cT: 'static\u003e(\u0026self) -\u003e Option\u003c\u0026T\u003e {\n        self.inner.downcast_ref::\u003cT\u003e()\n    }\n\n    pub(crate) fn try_cast_mut\u003cT: 'static\u003e(\u0026mut self) -\u003e Option\u003c\u0026mut T\u003e {\n        self.inner.downcast_mut::\u003cT\u003e()\n    }\n}\n\nimpl Debug for AnyBox {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        #[cfg(not(debug_assertions))]\n        return write!(f, \"AnyBox\");\n        #[cfg(debug_assertions)]\n        return write!(f, \"AnyBox {{ {} }}\", self.ty_info);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::any::type_name;\n\n    use super::*;\n\n    #[test]\n    #[cfg(debug_assertions)]\n    fn ty_debug_fmt() {\n        use std::any::type_name;\n\n        let boxed = AnyBox::new(String::from(\"Hello World!\"));\n        assert_eq!(boxed.ty(), type_name::\u003cString\u003e())\n    }\n\n    #[test]\n    fn ty_dup() {\n        let boxed = AnyBox::new(String::from(\"Hello World!\"));\n        let duped = boxed\n            .try_dup::\u003cString\u003e()\n            .expect(\"failed to dup as 'String'\");\n\n        assert_ne!(\n            boxed.inner.as_ref() as *const dyn Any,\n            duped.inner.as_ref() as *const dyn Any,\n        );\n    }\n\n    #[test]\n    fn can_cast() {\n        let boxed = AnyBox::new(1i64);\n        assert!(boxed.can_cast::\u003ci64\u003e());\n        assert!(!boxed.can_cast::\u003ci32\u003e());\n        assert!(!boxed.can_cast::\u003cString\u003e());\n        assert!(!boxed.can_cast::\u003c\u0026i64\u003e());\n    }\n\n    #[test]\n    fn fmt() {\n        #[cfg(debug_assertions)]\n        assert_eq!(\n            format!(\"{:?}\", AnyBox::new(String::from(\"Hello World!\"))),\n            format!(\"AnyBox {{ {} }}\", type_name::\u003cString\u003e())\n        );\n\n        #[cfg(not(debug_assertions))]\n        assert_eq!(\n            format!(\"{:?}\", AnyBox::new(String::from(\"Hello World!\"))),\n            \"AnyBox\"\n        );\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","Users","mk","Developer","rust","des","des","src","net","mod.rs"],"content":"//!\n//! Tools for building a module/net oriented simulation.\n//!\n\nmod par;\nmod path;\nmod runtime;\nmod topology;\n\npub mod channel;\npub mod gate;\npub mod message;\npub mod module;\npub mod processing;\n\npub(crate) use self::runtime::HandleMessageEvent;\npub(crate) use self::runtime::MessageExitingConnection;\npub(crate) use self::runtime::NetEvents;\n\npub use self::par::*;\npub use self::path::*;\npub use self::runtime::*;\npub use self::topology::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","api.rs"],"content":"use std::sync::Arc;\n\nuse super::{try_with_mod_ctx, ModuleContext, SETUP_FN};\nuse crate::{\n    net::runtime::buf_schedule_shutdown,\n    time::{Duration, SimTime},\n};\n\n/// Overwrite the setup fn all modules run.\n///\n/// All modules require common functionality based on the baseline setup of the\n/// simulation. Such common functionality is usually provided by plugins,\n/// but manually creating them on each module type is bothersome, and errorprone.\n/// To cirumvent that, a common setup function is provided that initalizes some plugins\n/// on all modules.\npub fn set_setup_fn(f: fn(\u0026ModuleContext)) {\n    *SETUP_FN.write() = f;\n}\n\n/// Retuns a handle to the context of the current module. This\n/// handle can be used on inspect and change the modules simulation\n/// properties, independent of the modules processing elements.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// **This handle is only fully valid, during the execution of the current event,\n/// thus is should never be stored.**\n///\n/// # Example\n///\n/// ```\n/// # use des::prelude::*;\n///\n/// struct MyModule;\n/// impl Module for MyModule {\n///     fn handle_message(\u0026mut self, msg: Message) {\n///         let id = current().id();\n///         if id == msg.header().sender_module_id {\n///             println!(\"Self message received\");\n///         }\n///     }\n/// }\n/// ```\n///\n/// # Panics\n///\n/// This function will panic if not called within a modules context.\n#[must_use]\npub fn current() -\u003e Arc\u003cModuleContext\u003e {\n    try_with_mod_ctx(Arc::clone)\n        .expect(\"cannot retrieve current module context, no module currently in scope\")\n}\n\n// BUF CTX based\n\n/// Shuts down all activity for the module.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// A module that is shut down, will not longer be able to\n/// handle incoming messages, or run any user-defined code.\n/// All plugin activity will be suspendend. However the\n/// custom state will be kept for debug purposes.\n///\n/// This function must be used within a module context\n/// otherwise its effects should be consider UB.\npub fn shutdown() {\n    buf_schedule_shutdown(None);\n}\n\n/// Shuts down all activity for the module.\n/// Restarts after the given duration.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// On restart the module will be reinitalized\n/// using `Module::reset`  and then `Module::at_sim_start`.\n/// Use the reset function to get the custom state to a resonable default\n/// state, which may or may not be defined by `Module::new`.\n/// However you can simulate persistent-beyond-shutdown data\n/// by not reseting this data in `Module::reset`.\n///\n/// ```\n/// # use des::prelude::*;\n/// # type Data = usize;\n/// struct MyModule {\n///     volatile: Data,\n///     persistent: Data,\n/// }\n///\n/// impl Module for MyModule {\n///     fn reset(\u0026mut self) {\n///         self.volatile = 0;\n///     }\n///\n///     fn at_sim_start(\u0026mut self, _: usize) {\n///         println!(\n///             \"Start at {} with volatile := {} and persistent := {}\",\n///             SimTime::now(),\n///             self.volatile,\n///             self.persistent\n///         );\n///\n///         self.volatile = 42;\n///         self.persistent = 1024;\n///\n///         if SimTime::now() == SimTime::ZERO {\n///             shutdow_and_restart_in(Duration::from_secs(10));\n///         }\n///     }\n/// }\n///\n/// fn main() {\n///     let app = /* ... */\n/// #    Sim::new(());\n///     let rt = Builder::new().build(app).run();\n///     // outputs 'Start at 0s with volatile := 0 and persistent := 0'\n///     // outputs 'Start at 10s with volatile := 0 and persistent := 1024'\n/// }\n/// ```\n///\n/// [`Module::new`]: crate::net::module::Module::new\n/// [`Module::reset`]: crate::net::module::Module::reset\n/// [`Module::at_sim_start`]: crate::net::module::Module::at_sim_start\npub fn shutdow_and_restart_in(dur: Duration) {\n    buf_schedule_shutdown(Some(SimTime::now() + dur));\n}\n\n/// Shuts down all activity for the module.\n/// Restarts at the given time.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// The user must ensure that the restart time\n/// point is greater or equal to the current simtime.\n///\n/// See [`shutdow_and_restart_in`] for more information.\npub fn shutdow_and_restart_at(restart_at: SimTime) {\n    buf_schedule_shutdown(Some(restart_at));\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":7268},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":7268},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":8,"coverable":10},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","ctx.rs"],"content":"use fxhash::{FxBuildHasher, FxHashMap};\nuse spin::RwLock;\n\nuse super::{\n    meta::Metadata, DummyModule, ModuleId, ModuleRef, ModuleRefWeak, ModuleReferencingError,\n};\nuse crate::{\n    prelude::{GateRef, ObjectPath},\n    sync::SwapLock,\n    tracing::{new_scope, ScopeToken},\n};\nuse std::{\n    any::Any,\n    fmt::Debug,\n    sync::{atomic::AtomicBool, Arc},\n};\n\n#[cfg(feature = \"async\")]\nuse crate::net::module::core::AsyncCoreExt;\n\npub(crate) static MOD_CTX: SwapLock\u003cOption\u003cArc\u003cModuleContext\u003e\u003e\u003e = SwapLock::new(None);\npub(crate) static SETUP_FN: RwLock\u003cfn(\u0026ModuleContext)\u003e = RwLock::new(_default_setup);\n\npub(crate) fn _default_setup(_: \u0026ModuleContext) {}\n\npub(crate) fn module_ctx_drop() {\n    MOD_CTX.swap(\u0026mut None);\n}\n\n/// The topological components of a module, not including the attached\n/// software.\n///\n/// The term `within node-context` refers to the presence of a `ModuleContext`\n/// in the global scope, that indicates that a module is currently active.\n///\n/// This type is internally used to create the simulations layout, but\n/// creating module contexts on your own is highly discouraged, since\n/// managing these structures is rather complicated. However the nessecary\n/// constructors are still available, so use them with care.\npub struct ModuleContext {\n    pub(crate) active: AtomicBool,\n    pub(crate) id: ModuleId,\n\n    pub(crate) path: ObjectPath,\n    pub(crate) gates: RwLock\u003cVec\u003cGateRef\u003e\u003e,\n\n    pub(super) meta: RwLock\u003cMetadata\u003e,\n    pub(crate) scope_token: ScopeToken,\n\n    #[cfg(feature = \"async\")]\n    pub(crate) async_ext: RwLock\u003cAsyncCoreExt\u003e,\n    pub(crate) parent: Option\u003cModuleRefWeak\u003e,\n    pub(crate) children: RwLock\u003cFxHashMap\u003cString, ModuleRef\u003e\u003e,\n}\n\nimpl ModuleContext {\n    /// Creates a new standalone instance of a new node.\n    ///\n    /// Note that this function returns a `ModuleRef`.\n    /// A `ModuleRef` contains both the topological properties of a node\n    /// if form of a `ModuleContext` as well as some attached software.\n    /// The sofware attched to the returned reference is a dummy module\n    /// that should be replaced before the simulation is started.\n    pub fn standalone(path: ObjectPath) -\u003e ModuleRef {\n        let this = ModuleRef::dummy(Arc::new(Self {\n            #[cfg(feature = \"async\")]\n            async_ext: RwLock::new(AsyncCoreExt::new()),\n\n            meta: RwLock::new(Metadata::new()),\n            scope_token: new_scope(path.clone()),\n\n            active: AtomicBool::new(true),\n            id: ModuleId::gen(),\n            path,\n\n            gates: RwLock::new(Vec::new()),\n\n            parent: None,\n            children: RwLock::new(FxHashMap::with_hasher(FxBuildHasher::default())),\n        }));\n\n        SETUP_FN.read()(\u0026this);\n\n        this\n    }\n\n    /// Creates a instance within a module tree.\n    ///  \n    /// Note that this function returns a `ModuleRef`.\n    /// A `ModuleRef` contains both the topological properties of a node\n    /// if form of a `ModuleContext` as well as some attached software.\n    /// The sofware attched to the returned reference is a dummy module\n    /// that should be replaced before the simulation is started.\n    #[allow(clippy::needless_pass_by_value)]\n    pub fn child_of(name: \u0026str, parent: ModuleRef) -\u003e ModuleRef {\n        let path = ObjectPath::appended(\u0026parent.ctx.path, name);\n        let this = ModuleRef::dummy(Arc::new(Self {\n            #[cfg(feature = \"async\")]\n            async_ext: RwLock::new(AsyncCoreExt::new()),\n\n            meta: RwLock::new(Metadata::new()),\n            scope_token: new_scope(path.clone()),\n\n            active: AtomicBool::new(true),\n\n            id: ModuleId::gen(),\n            path,\n\n            gates: RwLock::new(Vec::new()),\n\n            parent: Some(ModuleRefWeak::new(\u0026parent)),\n            children: RwLock::new(FxHashMap::with_hasher(FxBuildHasher::default())),\n        }));\n\n        SETUP_FN.read()(\u0026this);\n\n        parent\n            .ctx\n            .children\n            .write()\n            .insert(name.to_string(), this.clone());\n\n        this\n    }\n\n    pub(crate) fn place(self: Arc\u003cSelf\u003e) -\u003e Option\u003cArc\u003cModuleContext\u003e\u003e {\n        let mut this = Some(self);\n        MOD_CTX.swap(\u0026mut this);\n        this\n    }\n\n    pub(crate) fn take() -\u003e Option\u003cArc\u003cModuleContext\u003e\u003e {\n        let mut this = None;\n        MOD_CTX.swap(\u0026mut this);\n        this\n    }\n\n    /// Returns a runtime-unqiue identifier for the currently active module.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// struct MyModule;\n    /// impl Module for MyModule {\n    ///     fn handle_message(\u0026mut self, msg: Message) {\n    ///         let id = current().id();\n    ///         assert_eq!(id, msg.header().receiver_module_id);    \n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`Module`]: crate::net::module::Module\n    pub fn id(\u0026self) -\u003e ModuleId {\n        self.id\n    }\n\n    /// Returns a runtime-unqiue identifier for the currently active module,\n    /// based on its place in the module graph.\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// struct MyModule;\n    /// impl Module for MyModule {\n    ///     fn handle_message(\u0026mut self, msg: Message) {\n    ///         let path = current().path();\n    ///         println!(\"[{path}] recv message: {}\", msg.str())  \n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`Module`]: crate::net::module::Module\n    pub fn path(\u0026self) -\u003e ObjectPath {\n        self.path.clone()\n    }\n\n    /// Returns the name for the currently active module.\n    ///\n    /// Note that the module name is just the last component of the module\n    /// path.\n    pub fn name(\u0026self) -\u003e String {\n        self.path.name().to_string()\n    }\n\n    /// Returns a unstructured list of all gates from the current module.\n    pub fn gates(\u0026self) -\u003e Vec\u003cGateRef\u003e {\n        self.gates.read().clone()\n    }\n\n    /// Returns a ref to a gate of the current module dependent on its name and cluster position\n    /// if possible.\n    pub fn gate(\u0026self, name: \u0026str, pos: usize) -\u003e Option\u003cGateRef\u003e {\n        self.gates\n            .read()\n            .iter()\n            .find(|\u0026g| g.name() == name \u0026\u0026 g.pos() == pos)\n            .cloned()\n    }\n\n    /// Retrieves metadata about a module, based on a type.\n    ///\n    /// # Examples\n    ///\n    /// # Panics\n    ///\n    /// Panics when concurrently accessed from multiple threads.\n    pub fn meta\u003cT: Any + Clone\u003e(\u0026self) -\u003e Option\u003cT\u003e {\n        Some(\n            self.meta\n                .try_read()\n                .expect(\"Failed lock\")\n                .get::\u003cT\u003e()?\n                .clone(),\n        )\n    }\n\n    /// Sets a metadata object.\n    ///\n    /// # Panics\n    ///\n    /// Panics when concurrently accessed from multiple threads.\n    pub fn set_meta\u003cT: Any + Clone\u003e(\u0026self, value: T) {\n        self.meta.try_write().expect(\"Failed lock\").set(value);\n    }\n\n    /// Returns a reference to a parent module\n    ///\n    /// Use this handle to either access the parent modules topological\n    /// state, or cast it to access the custom state of the parent.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if no parent exists, or\n    /// the parent is currently shut down.\n    ///\n    /// # Panics\n    ///\n    /// May panic when the simulation is currently being dropped.\n    pub fn parent(\u0026self) -\u003e Result\u003cModuleRef, ModuleReferencingError\u003e {\n        if let Some(ref parent) = self.parent {\n            let strong = parent\n                .upgrade()\n                .expect(\"Failed to fetch parent, ptr missing in drop\");\n\n            if !strong.is_active() {\n                return Err(ModuleReferencingError::CurrentlyInactive(format!(\n                    \"The parent module of '{}' is currently shut down, thus cannot be accessed\",\n                    self.path,\n                )));\n            }\n\n            if strong.try_as_ref::\u003cDummyModule\u003e().is_some() {\n                Err(ModuleReferencingError::NotYetInitalized(\n                    format!(\"The parent ptr of module '{}' is existent but not yet initalized, according to the load order.\", self.path)\n                ))\n            } else {\n                Ok(strong)\n            }\n        } else {\n            Err(ModuleReferencingError::NoEntry(format!(\n                \"The module '{}' does not posses a parent ptr\",\n                self.path\n            )))\n        }\n    }\n\n    /// Returns a handle to the child element, with the provided module name.\n    ///\n    /// Use this handle to either access and modify the childs modules topological\n    /// state, or cast it to access its custom state .\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if no child was found under the given name,\n    /// or the child is currently shut down.\n    pub fn child(\u0026self, name: \u0026str) -\u003e Result\u003cModuleRef, ModuleReferencingError\u003e {\n        if let Some(child) = self.children.read().get(name) {\n            if !child.is_active() {\n                return Err(ModuleReferencingError::CurrentlyInactive(format!(\n                    \"The child module '{}' of '{}' is currently shut down, thus cannot be accessed\",\n                    name, self.path,\n                )));\n            }\n\n            Ok(child.clone())\n        } else {\n            Err(ModuleReferencingError::NoEntry(format!(\n                \"The module '{}' does not posses a child ptr with the name '{}'\",\n                self.path, name\n            )))\n        }\n    }\n}\n\nimpl Debug for ModuleContext {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"ModuleContext\").finish()\n    }\n}\n\nunsafe impl Send for ModuleContext {}\nunsafe impl Sync for ModuleContext {}\n\npub(crate) fn with_mod_ctx\u003cR\u003e(f: impl FnOnce(\u0026Arc\u003cModuleContext\u003e) -\u003e R) -\u003e R {\n    let lock = MOD_CTX.read();\n    let ctx = lock\n        .as_ref()\n        .expect(\"failed operation: no module currently in scope\");\n    let r = f(ctx);\n    drop(lock);\n    r\n}\n\npub(crate) fn try_with_mod_ctx\u003cR\u003e(f: impl FnOnce(\u0026Arc\u003cModuleContext\u003e) -\u003e R) -\u003e Option\u003cR\u003e {\n    let lock = MOD_CTX.read();\n    if let Some(ctx) = lock.as_real_inner() {\n        let r = f(ctx);\n        drop(lock);\n        Some(r)\n    } else {\n        None\n    }\n}\n\n// pub(crate) fn with_mod_ctx_lock() -\u003e SwapLockReadGuard\u003c'static, Option\u003cArc\u003cModuleContext\u003e\u003e\u003e {\n//     MOD_CTX.read()\n// }\n\ncfg_async! {\n    use tokio::runtime::Runtime;\n    use tokio::task::JoinHandle;\n    use tokio::task::LocalSet;\n    use tokio::sync::mpsc::{UnboundedReceiver, error::SendError};\n    use super::ext::WaitingMessage;\n    use std::rc::Rc;\n\n    pub(crate) fn async_get_rt() -\u003e Option\u003c(Arc\u003cRuntime\u003e, Rc\u003cLocalSet\u003e)\u003e {\n        with_mod_ctx(|ctx| ctx.async_ext.write().rt.current())\n    }\n\n    pub(super) fn async_ctx_reset() {\n        with_mod_ctx(|ctx| ctx.async_ext.write().reset());\n    }\n\n    // Wait queue\n\n    pub(super) fn async_wait_queue_tx_send(msg: WaitingMessage) -\u003e Result\u003c(), SendError\u003cWaitingMessage\u003e\u003e {\n        with_mod_ctx(|ctx| ctx.async_ext.write().wait_queue_tx.send(msg))\n    }\n\n    pub(super) fn async_wait_queue_rx_take() -\u003e Option\u003cUnboundedReceiver\u003cWaitingMessage\u003e\u003e {\n        with_mod_ctx(|ctx| ctx.async_ext.write().wait_queue_rx.take())\n    }\n\n    pub(super) fn async_set_wait_queue_join(join: JoinHandle\u003c()\u003e) {\n        with_mod_ctx(|ctx| ctx.async_ext.write().wait_queue_join = Some(join));\n    }\n\n    // Sim Staart\n\n    pub(super) fn async_sim_start_rx_take() -\u003e Option\u003cUnboundedReceiver\u003cusize\u003e\u003e {\n        with_mod_ctx(|ctx| ctx.async_ext.write().sim_start_rx.take())\n    }\n\n    pub(super) fn async_set_sim_start_join(join: JoinHandle\u003c()\u003e) {\n        with_mod_ctx(|ctx| ctx.async_ext.write().sim_start_join = Some(join));\n    }\n\n    pub(super) fn async_sim_start_tx_send(stage: usize) -\u003e Result\u003c(), SendError\u003cusize\u003e\u003e  {\n        with_mod_ctx(|ctx| ctx.async_ext.write().sim_start_tx.send(stage))\n    }\n\n    pub(super) fn async_sim_start_join_take() -\u003e Option\u003cJoinHandle\u003c()\u003e\u003e {\n        with_mod_ctx(|ctx| ctx.async_ext.write().sim_start_join.take())\n    }\n\n    // SIM END\n\n    pub(super) fn async_sim_end_join_set(join: JoinHandle\u003c()\u003e)  {\n        with_mod_ctx(|ctx| ctx.async_ext.write().sim_end_join = Some(join));\n    }\n\n    pub(super) fn async_sim_end_join_take() -\u003e Option\u003cJoinHandle\u003c()\u003e\u003e {\n        with_mod_ctx(|ctx| ctx.async_ext.write().sim_end_join.take())\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":261},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3416},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":3416},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4678},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":4678},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":564},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":564},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":10508},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":131},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":7268},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":7268},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":14535},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":844},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":2532},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":132},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":876},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":426},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":426},"fn_name":null}],"covered":114,"coverable":121},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","dummy.rs"],"content":"use super::Module;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub(crate) struct DummyModule {}\n\nimpl Module for DummyModule {\n    fn handle_message(\u0026mut self, _msg: crate::prelude::Message) {\n        panic!(\"A dummy module is only a placeholder in the load process. No `dyn Module` functions should be called.\")\n    }\n\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        panic!(\"A dummy module is only a placeholder in the load process. No `dyn Module` functions should be called.\")\n    }\n\n    fn num_sim_start_stages(\u0026self) -\u003e usize {\n        panic!(\"A dummy module is only a placeholder in the load process. No `dyn Module` functions should be called.\")\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        panic!(\"A dummy module is only a placeholder in the load process. No `dyn Module` functions should be called.\")\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","error.rs"],"content":"use std::{error::Error, fmt::Display};\n\n/// An error while resolving a reference to another module.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ModuleReferencingError {\n    /// No reference exists.\n    NoEntry(String),\n    /// The reference is not of the given type.\n    TypeError(String),\n    /// The load order dicates that the parent is not yet ready.\n    NotYetInitalized(String),\n    /// The reference module is currently inactive, so should not be accessed.\n    CurrentlyInactive(String),\n}\n\nimpl Display for ModuleReferencingError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::NoEntry(str)\n            | Self::TypeError(str)\n            | Self::NotYetInitalized(str)\n            | Self::CurrentlyInactive(str) =\u003e {\n                write!(f, \"{str}\")\n            }\n        }\n    }\n}\n\nimpl Error for ModuleReferencingError {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn fmt() {\n        assert_eq!(\n            ModuleReferencingError::NoEntry(\"Hello world!\".to_string()).to_string(),\n            \"Hello world!\"\n        );\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":7},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","ext","core.rs"],"content":"use std::{rc::Rc, sync::Arc};\n\nuse crate::{\n    net::message::Message,\n    prelude::random,\n    time::{Driver, SimTime},\n};\nuse tokio::{\n    runtime::{Builder, RngSeed, Runtime},\n    sync::mpsc::{unbounded_channel, UnboundedReceiver, UnboundedSender},\n    task::{JoinHandle, LocalSet},\n};\n\npub(crate) struct AsyncCoreExt {\n    pub(crate) rt: Rt,\n    pub(crate) driver: Option\u003cDriver\u003e,\n\n    pub(crate) wait_queue_tx: UnboundedSender\u003cWaitingMessage\u003e,\n    pub(crate) wait_queue_rx: Option\u003cUnboundedReceiver\u003cWaitingMessage\u003e\u003e,\n    pub(crate) wait_queue_join: Option\u003cJoinHandle\u003c()\u003e\u003e,\n\n    pub(crate) sim_start_tx: UnboundedSender\u003cusize\u003e,\n    pub(crate) sim_start_rx: Option\u003cUnboundedReceiver\u003cusize\u003e\u003e,\n    pub(crate) sim_start_join: Option\u003cJoinHandle\u003c()\u003e\u003e,\n\n    pub(crate) sim_end_join: Option\u003cJoinHandle\u003c()\u003e\u003e,\n}\n\n#[allow(clippy::large_enum_variant)]\npub(crate) enum Rt {\n    Builder(Builder),\n    Runtime((Arc\u003cRuntime\u003e, Rc\u003cLocalSet\u003e)),\n    Shutdown,\n}\n\nimpl AsyncCoreExt {\n    pub(crate) fn new() -\u003e AsyncCoreExt {\n        // let (tx, rx) = unbounded_channel();\n        let (wtx, wrx) = unbounded_channel();\n        let (stx, srx) = unbounded_channel();\n\n        #[allow(unused_mut)]\n        let mut builder = Builder::new_current_thread();\n\n        #[cfg(feature = \"unstable-tokio-enable-time\")]\n        builder.enable_time();\n\n        Self {\n            rt: Rt::Builder(builder),\n\n            driver: Some(Driver::new()),\n\n            wait_queue_tx: wtx,\n            wait_queue_rx: Some(wrx),\n            wait_queue_join: None,\n\n            sim_start_tx: stx,\n            sim_start_rx: Some(srx),\n            sim_start_join: None,\n\n            sim_end_join: None,\n        }\n    }\n\n    pub(crate) fn reset(\u0026mut self) {\n        self.rt = Rt::Runtime((\n            Arc::new(\n                Builder::new_current_thread()\n                    .rng_seed(RngSeed::from_bytes(\u0026random::\u003cu64\u003e().to_le_bytes()))\n                    .build()\n                    .expect(\"Failed to build tokio runtime\"),\n            ),\n            Rc::new(LocalSet::new()),\n        ));\n\n        // let (tx, rx) = unbounded_channel();\n        let (wtx, wrx) = unbounded_channel();\n        let (stx, srx) = unbounded_channel();\n\n        // self.buffers = rx;\n        // self.handle = tx;\n\n        self.wait_queue_tx = wtx;\n        self.wait_queue_rx = Some(wrx);\n        self.wait_queue_join = None;\n\n        self.sim_start_tx = stx;\n        self.sim_start_rx = Some(srx);\n        self.sim_start_join = None;\n\n        self.sim_end_join = None;\n    }\n}\n\nimpl Rt {\n    pub(crate) fn current(\u0026mut self) -\u003e Option\u003c(Arc\u003cRuntime\u003e, Rc\u003cLocalSet\u003e)\u003e {\n        match self {\n            Rt::Builder(builder) =\u003e {\n                let seed = RngSeed::from_bytes(\u0026random::\u003cu64\u003e().to_le_bytes());\n                *self = Rt::Runtime((\n                    Arc::new(\n                        builder\n                            .rng_seed(seed)\n                            .build()\n                            .expect(\"Failed to build tokio runtime\"),\n                    ),\n                    Rc::new(LocalSet::new()),\n                ));\n                self.current()\n            }\n            Rt::Runtime(tupel) =\u003e Some(tupel.clone()),\n            Rt::Shutdown =\u003e None,\n        }\n    }\n\n    pub(crate) fn shutdown(\u0026mut self) {\n        *self = Self::Shutdown;\n    }\n}\n\n#[derive(Debug)]\npub(crate) struct WaitingMessage {\n    pub(crate) msg: Message,\n    #[allow(dead_code)]\n    pub(crate) time: SimTime,\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":986},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":986},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":844},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":17},"fn_name":null}],"covered":41,"coverable":42},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","ext","mod.rs"],"content":"#![allow(clippy::unused_async)]\n\nuse crate::net::{message::Message, module::Module};\nuse crate::time::SimTime;\nuse tokio::task::yield_now;\n\npub(crate) mod core;\npub(crate) use self::core::WaitingMessage;\n\n/// A set of user defined functions for customizing the behaviour\n/// of an asynchronous module.\n///\n/// This trait is just a async version of [`Module`](crate::net::module::Module).\n#[allow(async_fn_in_trait)]\npub trait AsyncModule: Send {\n    /// Resets the custom state after shutdown.\n    fn reset(\u0026mut self) {}\n\n    ///\n    /// A message handler for receiving events, user defined.\n    ///\n    /// # Note\n    ///\n    /// The function may block beyond the evaluation of the current event.\n    /// If that happens, other messages that will be received will be queued\n    /// until the evaluation of this event has concluded. For non-blocking\n    /// event execution use [`tokio::spawn`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use des::prelude::*;\n    ///\n    /// struct MyAsyncModule {\n    ///     prop_1: f64,\n    ///     prop_2: String,\n    /// }\n    ///\n    ///\n    /// impl AsyncModule for MyAsyncModule {\n    ///     /* ... */    \n    ///\n    ///     async fn handle_message(\u0026mut self, msg: Message) {\n    ///         println!(\"Received {:?}\", msg);\n    ///     }\n    /// }\n    /// ```\n    async fn handle_message(\u0026mut self, _: Message) {}\n\n    ///\n    /// A function that is run at the start of each simulation, for each module.\n    /// The order in which modules are called is not guranteed but the stage numbers are.\n    /// That means that all stage-0 calls for all modules happen before the first (if any) stage-1 calls.\n    /// Generaly speaking, all stage-i calls finish before the first stage-i+1 call.\n    ///\n    /// # Note\n    ///\n    /// The user must ensure that all calls of `at_sim_start` will terminate at last\n    /// once all stages of `at_sim_start` of all modules have been called.\n    /// The stages will be executed in order.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use des::prelude::*;\n    ///\n    /// # type Config = ();\n    /// async fn fetch_config(id: ModuleId) -\u003e Config {\n    ///     // ...\n    /// }\n    ///\n    /// struct MyModule {\n    ///     config: Config,\n    ///     records: Vec\u003cf64\u003e,\n    /// }\n    ///\n    ///\n    /// impl AsyncModule for MyModule {\n    ///     /* ... */    \n    ///\n    ///     async fn handle_message(\u0026mut self, _: Message) {\n    ///         // ...\n    ///     }\n    ///\n    ///     async fn at_sim_start(\u0026mut self, _stage: usize) {\n    ///         self.config = fetch_config(current().id()).await;\n    ///         self.records.clear();\n    ///     }\n    /// }\n    ///\n    /// ```\n    async fn at_sim_start(\u0026mut self, _: usize) {}\n\n    ///\n    /// A function that is called once the simulation has terminated.\n    /// Any event created by this function will be ignored.\n    ///\n    async fn at_sim_end(\u0026mut self) {}\n\n    ///\n    /// A function that returns the number of required startup stages\n    /// of a module.\n    ///\n    fn num_sim_start_stages(\u0026self) -\u003e usize {\n        1\n    }\n}\n\nimpl\u003cT\u003e Module for T\nwhere\n    T: 'static + AsyncModule,\n{\n    fn __indicate_async(\u0026self) -\u003e bool {\n        true\n    }\n\n    fn reset(\u0026mut self) {\n        super::async_ctx_reset();\n\n        \u003cT as AsyncModule\u003e::reset(self);\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        // (1) Fetch the runtime and initial the time context.\n        let Some(rt) = super::async_get_rt() else {\n            return;\n        };\n\n        // (2) Ignore notifty message only relevant for a\n        // call to poll_until_idle\n        super::async_wait_queue_tx_send(WaitingMessage {\n            msg,\n            time: SimTime::now(),\n        })\n        .expect(\"Failed to forward message to 'handle_message'\");\n\n        rt.1.block_on(\u0026rt.0, yield_now());\n    }\n\n    fn at_sim_start(\u0026mut self, stage: usize) {\n        // time is 0\n        let Some(rt) = super::async_get_rt() else {\n            return;\n        };\n\n        // # Setup message receive handle.\n        if stage == 0 {\n            // SAFTEY:\n            // We can guarantee the validity of the pointer:\n            // 1) The module is pinned while the simulation is running.\n            // 2) The module is not dropped while the simulation is running.\n            // 3) While we may create mutiple \u0026mut T, handle_message is never run fully\n            //    async (current thread runtime) and mutiple calls of `handle_messsage`\n            //    wont overlap, since the queue rx synchronises and delays them.\n            // 4) References to at_sim_start have been droped since all futures of at_sim_start\n            //    must be resoved before event 1\n            let self_ref: \u0026'static mut T = {\n                let ptr: *mut T = self;\n                unsafe { \u0026mut *ptr }\n            };\n\n            let mut rx = super::async_wait_queue_rx_take().expect(\"We have been robbed\");\n\n            super::async_set_wait_queue_join(rt.1.spawn_local(async move {\n                while let Some(wmsg) = rx.recv().await {\n                    let WaitingMessage { msg, .. } = wmsg;\n                    \u003cT as AsyncModule\u003e::handle_message(self_ref, msg).await;\n                }\n            }));\n        }\n\n        // # Setup Sim-Start Task\n        if stage == 0 {\n            // SAFTEY:\n            // SimStart will complete before event id 1. thus this is quasai sync\n            let self_ref: \u0026'static mut T = {\n                let ptr: *mut T = self;\n                unsafe { \u0026mut *ptr }\n            };\n\n            let mut srx =\n                super::async_sim_start_rx_take().expect(\"We have been robbed at sim start\");\n\n            super::async_set_sim_start_join(rt.1.spawn_local(async move {\n                while let Some(stage) = srx.recv().await {\n                    if stage == usize::MAX {\n                        srx.close();\n                        break;\n                    }\n                    \u003cT as AsyncModule\u003e::at_sim_start(self_ref, stage).await;\n                }\n            }));\n        }\n\n        super::async_sim_start_tx_send(stage).expect(\"Failed to send to unbounded sender\");\n\n        rt.1.block_on(\u0026rt.0, yield_now());\n    }\n\n    fn finish_sim_start(\u0026mut self) {\n        let Some(rt) = super::async_get_rt() else {\n            return;\n        };\n\n        super::async_sim_start_tx_send(usize::MAX)\n            .expect(\"Failed to send close signal to sim_start_task\");\n\n        rt.1.block_on(\u0026rt.0, yield_now());\n\n        // The join must succeed else saftey invariant cannot be archived.\n        let handle = super::async_sim_start_join_take().expect(\"Crime\");\n        let _g = rt.0.enter();\n        assert!(handle.is_finished());\n        rt.0.block_on(handle)\n            .expect(\"could not finish all sim start stages without time progression\");\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        let Some(rt) = super::async_get_rt() else {\n            return;\n        };\n\n        // SAFTEY:\n        // Sim end means only this function will be executed before drop\n        // thus 'static can be assumed.\n        let self_ptr: *mut T = self;\n        let self_ref: \u0026'static mut T = unsafe { \u0026mut *self_ptr };\n\n        super::async_sim_end_join_set(rt.1.spawn_local(\u003cT as AsyncModule\u003e::at_sim_end(self_ref)));\n\n        rt.1.block_on(\u0026rt.0, yield_now());\n    }\n\n    fn finish_sim_end(\u0026mut self) {\n        let Some(rt) = super::async_get_rt() else {\n            return;\n        };\n\n        rt.1.block_on(\u0026rt.0, yield_now());\n\n        let handle = super::async_sim_end_join_take().expect(\"Crime\");\n        let _g = rt.0.enter();\n        assert!(\n            handle.is_finished(),\n            \"at_sim_end() could not complete, since it is stuck at some await point\"\n        );\n        rt.0.block_on(handle)\n            .expect(\"could not finish all sim end stages without time progession\");\n    }\n\n    fn num_sim_start_stages(\u0026self) -\u003e usize {\n        // Needs at least one sim_start stage to setup the recv handle\n        \u003cT as AsyncModule\u003e::num_sim_start_stages(self).max(1)\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":512},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":512},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":88},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":88},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":275},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":730},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":141},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":288},"fn_name":null}],"covered":47,"coverable":71},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","meta.rs"],"content":"use std::any::Any;\n\n/// Metadata exposed by a module.\n#[derive(Debug)]\npub(super) struct Metadata {\n    blobs: Vec\u003cBox\u003cdyn Any\u003e\u003e\n}\n\nimpl Metadata {\n    pub(super) fn new() -\u003e Self {\n        Self { blobs: Vec::new() }\n    }\n\n    /// Tries to retrieve a data object from the store.\n    pub(super) fn get\u003cT: Any\u003e(\u0026self) -\u003e Option\u003c\u0026T\u003e {\n        self.blobs.iter().find_map(|blob| blob.downcast_ref())\n    }\n\n    pub(super) fn set\u003cT: Any\u003e(\u0026mut self, value: T) {\n        self.blobs.retain(|v| !v.is::\u003cT\u003e());\n        self.blobs.push(Box::new(value));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn store_insert_and_retrive() {\n        let mut meta = Metadata { blobs: Vec::new() };\n        meta.set(String::from(\"Hello World!\"));\n        assert_eq!(meta.get::\u003cString\u003e(), Some(\u0026String::from(\"Hello World!\")));\n        assert_eq!(meta.get::\u003cu8\u003e(), None);\n    }\n}","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","mod.rs"],"content":"//! Network nodes with custom state.\n\nuse crate::net::message::Message;\nuse std::{\n    any::Any,\n    sync::atomic::{AtomicU16, Ordering},\n};\n\nmod ctx;\npub use self::ctx::ModuleContext;\npub(crate) use self::ctx::*;\n\nmod reference;\npub use reference::*;\n\nmod error;\npub use error::*;\n\nmod api;\npub use api::*;\n\nmod dummy;\npub(crate) use dummy::*;\n\nmod meta;\n\n#[cfg(test)]\nmod tests;\n\nuse super::processing::{BaseLoader, IntoProcessingElements, ProcessingElements};\n\ncfg_async! {\n    mod ext;\n    pub use self::ext::*;\n}\n\n/// A unique identifier for a module.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[repr(transparent)]\npub struct ModuleId(pub u16);\n\nstatic MODULE_ID: AtomicU16 = AtomicU16::new(0xff);\n\nimpl ModuleId {\n    /// A general purpose ID indicating None.\n    pub const NULL: ModuleId = ModuleId(0);\n\n    /// Generates a unique module ID.\n    pub fn gen() -\u003e Self {\n        Self(MODULE_ID.fetch_add(1, Ordering::SeqCst))\n    }\n}\n\n///\n/// A set of user defined functions for customizing the\n/// behaviour of a module.\n///\n/// * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\npub trait Module: Any {\n    /// Resets the custom state when a module is restarted.\n    fn reset(\u0026mut self) {\n        #[cfg(feature = \"tracing\")]\n        tracing::warn!(\"Module has been shutdown and restarted, but reset() was not defined. This may lead to invalid custom state.\");\n    }\n\n    /// Defines the required stack.\n    fn stack(\u0026self) -\u003e impl IntoProcessingElements\n    where\n        Self: Sized,\n    {\n        BaseLoader\n    }\n\n    /// BUILD\n    fn to_processing_chain(self) -\u003e ProcessingElements\n    where\n        Self: Sized + 'static,\n    {\n        let stack = \u003cSelf as Module\u003e::stack(\u0026self).to_processing_elements();\n        ProcessingElements::new(stack, self)\n    }\n\n    ///\n    /// A message handler for receiving events, user defined.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// struct MyModule {\n    ///     my_prop_1: f64,\n    ///     my_prop_2: String,\n    /// };\n    ///\n    /// impl Module for MyModule {\n    ///     /* ... */    \n    ///\n    ///     fn handle_message(\u0026mut self, msg: Message) {\n    ///         println!(\"Received {:?}\", msg);\n    ///     }\n    /// }\n    /// ```\n    ///\n    fn handle_message(\u0026mut self, _msg: Message) {}\n\n    ///\n    /// A function that is run at the start of each simulation,\n    /// for each module. The order in which modules are called is not guranteed\n    /// but the stage numbers are. That means that all stage-0 calls for all modules\n    /// happen before the first (if any) stage-1 calls. Generaly speaking, all stage-i\n    /// calls finish before the first stage-i+1 call.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use des::prelude::*;\n    /// # type Config = ();\n    /// # type Record = u8;\n    /// # fn fetch_config(s: \u0026str, id: ModuleId) -\u003e Config {}\n    ///\n    /// struct SomeModule {\n    ///     config: Config,\n    ///     records: Vec\u003cRecord\u003e,\n    /// };\n    ///\n    /// impl Module for SomeModule {\n    ///     /* ... */\n    ///     \n    ///     fn at_sim_start(\u0026mut self, _stage: usize) {\n    ///         self.config = fetch_config(\"https://mysimconfig.com/simrun1\", current().id());\n    ///         self.records.clear();\n    ///     }\n    ///\n    ///     fn handle_message(\u0026mut self, msg: Message) {\n    ///         todo!()\n    ///     }\n    /// }\n    /// ```\n    ///\n    fn at_sim_start(\u0026mut self, _stage: usize) {}\n\n    ///\n    /// A function that is called when all `sim_start` stages of all modules\n    /// are done. Used to resolve all async `sim_start_stages`.\n    ///\n    #[cfg(feature = \"async\")]\n    #[doc(hidden)]\n    fn finish_sim_start(\u0026mut self) {}\n\n    ///\n    /// The number of stages used for the module initalization.\n    ///\n    fn num_sim_start_stages(\u0026self) -\u003e usize {\n        1\n    }\n\n    ///\n    /// A callback function that is invoked should the simulation finish.\n    /// All events emitted by this function will NOT be processed.\n    ///\n    fn at_sim_end(\u0026mut self) {}\n\n    ///\n    /// A function that is called when all `sim_end` stages of all modules\n    /// are done. Used to resolve all async `sim_end_stages`.\n    ///\n    #[cfg(feature = \"async\")]\n    #[doc(hidden)]\n    fn finish_sim_end(\u0026mut self) {}\n\n    #[cfg(feature = \"async\")]\n    #[doc(hidden)]\n    fn __indicate_async(\u0026self) -\u003e bool {\n        false\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":454},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":454},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":469},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":469},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":469},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":155},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":155},"fn_name":null}],"covered":17,"coverable":19},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","reference.rs"],"content":"use crate::net::processing::ProcessingElements;\nuse crate::net::NetEvents;\nuse crate::prelude::{Gate, GateRef};\nuse crate::runtime::EventSink;\nuse crate::tracing::{enter_scope, leave_scope};\n\nuse super::{DummyModule, Module, ModuleContext};\nuse std::any::{Any, TypeId};\nuse std::cell::{Ref, RefCell, RefMut};\nuse std::fmt::Debug;\nuse std::ops::Deref;\nuse std::sync::{Arc, Weak};\n\n#[derive(Clone)]\npub(crate) struct ModuleRefWeak {\n    ctx: Weak\u003cModuleContext\u003e,\n    handler: Weak\u003cRefCell\u003cProcessingElements\u003e\u003e,\n    // handler_ptr: *mut u8,\n}\n\nimpl ModuleRefWeak {\n    pub(crate) fn new(strong: \u0026ModuleRef) -\u003e Self {\n        Self {\n            ctx: Arc::downgrade(\u0026strong.ctx),\n            handler: Arc::downgrade(\u0026strong.processing),\n            // handler_ptr: strong.handler_ptr,\n        }\n    }\n\n    pub(crate) fn upgrade(\u0026self) -\u003e Option\u003cModuleRef\u003e {\n        Some(ModuleRef {\n            ctx: self.ctx.upgrade()?,\n            processing: self.handler.upgrade()?,\n            // handler_ptr: self.handler_ptr,\n        })\n    }\n}\n\nimpl Debug for ModuleRefWeak {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"ModuleRefWeak\").finish()\n    }\n}\n\n/// A reference to a module\n#[derive(Clone)]\npub struct ModuleRef {\n    pub(crate) ctx: Arc\u003cModuleContext\u003e,\n    pub(crate) processing: Arc\u003cRefCell\u003cProcessingElements\u003e\u003e,\n}\n\nimpl Deref for ModuleRef {\n    type Target = ModuleContext;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.ctx\n    }\n}\n\nimpl ModuleRef {\n    #[allow(clippy::explicit_deref_methods)]\n    pub(crate) fn new\u003cT: Module\u003e(ctx: Arc\u003cModuleContext\u003e, module: T) -\u003e Self {\n        let procesing = module.to_processing_chain();\n        let handler = Arc::new(RefCell::new(procesing));\n        Self {\n            ctx,\n            processing: handler,\n        }\n    }\n\n    #[allow(unused)]\n    pub(crate) fn dummy(ctx: Arc\u003cModuleContext\u003e) -\u003e Self {\n        // Create the dummy module explicitly not with ::new since\n        // all dyn Module calls would panic\n        Self::new(ctx, DummyModule {})\n    }\n\n    #[allow(unused)]\n    // Caller must ensure that handler is indeed a dummy\n    #[doc(hidden)]\n    pub fn upgrade_dummy(\u0026self, module: ProcessingElements) {\n        let celled = RefCell::new(module);\n        let celled: RefCell\u003cProcessingElements\u003e = celled;\n        self.processing.swap(\u0026celled);\n    }\n\n    // NOTE / TODO\n    // Once feature(trait_upcasting) is stabalized, use traitupcasting for\n    // safe interactions with the v-table.\n    // For now us raw pointer casts.\n\n    /// Borrows the referenced module as a readonly reference\n    /// to the provided type T.\n    ///\n    /// # Panics\n    ///\n    /// Panics if either the module is not of type T,\n    /// or the module is allready borrowed mutably.\n    #[must_use]\n    pub fn as_ref\u003cT: Any\u003e(\u0026self) -\u003e Ref\u003cT\u003e {\n        self.try_as_ref::\u003cT\u003e()\n            .expect(\"Failed to cast ModuleRef to readonly reference to type T\")\n    }\n\n    ///\n    /// Tries to borrow the referenced module as an readonly\n    /// reference to the provided type T.\n    ///\n    /// This function will return `None` is the contained module\n    /// is not of type T.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the contained module is allready borrowed\n    /// mutably. This may be the case if another borrow has allready occured\n    /// or the reference module is `self` and a module-specific function is called.\n    ///\n    #[must_use]\n    pub fn try_as_ref\u003cT: Any\u003e(\u0026self) -\u003e Option\u003cRef\u003cT\u003e\u003e {\n        let brw = self.processing.borrow();\n        let rf = \u0026*brw.handler;\n        let ty = rf.type_id();\n        if ty == TypeId::of::\u003cT\u003e() {\n            // SAFTEY:\n            // The pointer 'handler_ptr' will allways point to the object\n            // refered to by the 'handler': Since 'handler' is owned through\n            // an 'Arc' its memory position will NOT changed. Thus 'handler_ptr'\n            // allways points to valid memory. Pointer aligment is guranteed.\n            //\n            // Since the created \u0026T is encapluslated in a Ref\u003c\u0026T\u003e this functions acts as\n            // a call of 'RefCell::borrow' thus upholding the borrowing invariants.\n            //\n            // Should the type check fail, the Ref is dropped so the borrow is freed.\n            Some(Ref::map(brw, |brw| unsafe {\n                let hpt: *const dyn Module = \u0026*brw.handler;\n                // hpt.cast::\u003cT\u003e()\n                // \u0026*(hpt as *const T)\n                \u0026*(hpt.cast::\u003cT\u003e())\n            }))\n        } else {\n            None\n        }\n    }\n\n    /// Borrows the referenced module as a mutable reference\n    /// to the provided type T.\n    ///\n    /// # Panics\n    ///\n    /// Panics if either the module is not of type T,\n    /// or the module is allready borrowed on any way.\n    #[must_use]\n    pub fn as_mut\u003cT: Any\u003e(\u0026self) -\u003e RefMut\u003cT\u003e {\n        self.try_as_mut()\n            .expect(\"Failed to cast ModuleRef to mutable reference to type T\")\n    }\n\n    ///\n    /// Tries to borrow the referenced module as an mutable\n    /// reference to the provided type T.\n    ///\n    /// This function will return `None` is the contained module\n    /// is not of type T.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the contained module is allready borrowed\n    /// in any way. This may be the case if another borrow has allready occured\n    /// or the reference module is `self` and a module-specific function is called.\n    ///\n    #[must_use]\n    pub fn try_as_mut\u003cT: Any\u003e(\u0026self) -\u003e Option\u003cRefMut\u003cT\u003e\u003e {\n        let brw = self.processing.borrow_mut();\n        let rf = \u0026*brw.handler;\n        let ty = rf.type_id();\n        if ty == TypeId::of::\u003cT\u003e() {\n            // SAFTEY:\n            // The pointer 'handler_ptr' will allways point to the object\n            // refered to by the 'handler': Since 'handler' is owned through\n            // an 'Arc' its memory position will NOT changed. Thus 'handler_ptr'\n            // allways points to valid memory. Pointer aligment is guranteed.\n            //\n            // Since the created \u0026T is encapluslated in a Ref\u003c\u0026T\u003e this functions acts as\n            // a call of 'RefCell::borrow' thus upholding the borrowing invariants.\n            //\n            // Should the type check fail, the Ref is dropped so the borrow is freed.\n            Some(RefMut::map(brw, |brw| unsafe {\n                let hpt: *mut dyn Module = \u0026mut *brw.handler;\n                \u0026mut *(hpt.cast::\u003cT\u003e())\n            }))\n        } else {\n            None\n        }\n    }\n}\n\nimpl ModuleRef {\n    pub(crate) fn is_active(\u0026self) -\u003e bool {\n        self.ctx.active.load(std::sync::atomic::Ordering::SeqCst)\n    }\n\n    pub(crate) fn as_str(\u0026self) -\u003e \u0026str {\n        self.ctx.path.as_str()\n    }\n\n    pub(crate) fn scope_token(\u0026self) -\u003e crate::tracing::ScopeToken {\n        self.ctx.scope_token\n    }\n\n    /// INTERNAL\n    #[doc(hidden)]\n    #[allow(unused)]\n    pub fn activate(\u0026self) {\n        enter_scope(self.scope_token());\n        let prev = ModuleContext::place(Arc::clone(\u0026self.ctx));\n\n        #[cfg(feature = \"async\")]\n        {\n            use crate::time::{Driver, SimTime, TimerSlot};\n\n            if let Some(prev) = prev {\n                prev.async_ext.write().driver = Driver::unset();\n            }\n\n            let driver = self.ctx.async_ext.write().driver.take();\n            if let Some(mut d) = driver {\n                let bumpable = d.bump();\n                if d.next_wakeup \u003c= SimTime::now() {\n                    d.next_wakeup = SimTime::MAX;\n                }\n                bumpable.into_iter().for_each(TimerSlot::wake_all);\n                d.set();\n            }\n        }\n    }\n\n    /// INTERNAL\n    #[doc(hidden)]\n    #[allow(unused)]\n    pub(crate) fn deactivate(\u0026self, rt: \u0026mut impl EventSink\u003cNetEvents\u003e) {\n        #[cfg(feature = \"async\")]\n        {\n            use crate::net::AsyncWakeupEvent;\n            use crate::time::Driver;\n\n            let mut ext = self.ctx.async_ext.write();\n            let Some(mut driver) = Driver::unset() else {\n                // Somebody stole our driver\n                #[cfg(feature = \"tracing\")]\n                tracing::error!(\"IO time driver missing after event execution\");\n\n                ext.driver = Some(Driver::new());\n                return;\n            };\n            if let Some(next_wakeup) = driver.next() {\n                if next_wakeup \u003c driver.next_wakeup {\n                    #[cfg(feature = \"tracing\")]\n                    tracing::trace!(\n                        \"scheduling new wakeup at {} (prev {})\",\n                        next_wakeup,\n                        driver.next_wakeup\n                    );\n\n                    println!(\"\u003e scheduling wakeup at {}\", next_wakeup);\n\n                    driver.next_wakeup = next_wakeup;\n                    rt.add(\n                        NetEvents::AsyncWakeupEvent(AsyncWakeupEvent {\n                            module: self.clone(),\n                        }),\n                        next_wakeup,\n                    );\n                }\n            }\n            ext.driver = Some(driver);\n        }\n\n        let _ = ModuleContext::take();\n        leave_scope();\n    }\n\n    /// Creates a gate on the current module, returning its ID.\n    ///\n    #[must_use]\n    pub fn create_gate(\u0026self, name: \u0026str) -\u003e GateRef {\n        self.create_gate_cluster(name, 1).remove(0)\n    }\n\n    ///\n    /// Createas a cluster of gates on the current module returning their IDs.\n    ///\n    #[must_use]\n    pub fn create_gate_cluster(\u0026self, name: \u0026str, size: usize) -\u003e Vec\u003cGateRef\u003e {\n        (0..size)\n            .map(|id| self.create_raw_gate(name, size, id))\n            .collect()\n    }\n\n    /// Creates a gate on the current module, returning its ID.\n    ///\n    #[must_use]\n    pub fn create_raw_gate(\u0026self, name: \u0026str, size: usize, pos: usize) -\u003e GateRef {\n        let gate = Gate::new(self, name, size, pos);\n        self.ctx.gates.write().push(gate.clone());\n        gate\n    }\n}\n\nimpl PartialEq for ModuleRef {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        Arc::ptr_eq(\u0026self.ctx, \u0026other.ctx)\n    }\n}\n\nimpl Debug for ModuleRef {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\u0026format!(\n            \"ModuleRef {{ name: {}, handler: {}, ctx: {} }}\",\n            self.ctx.path,\n            Arc::strong_count(\u0026self.processing),\n            Arc::strong_count(\u0026self.ctx),\n        ))\n        .finish()\n    }\n}\n\nunsafe impl Send for ModuleRef {}\nunsafe impl Send for ModuleRefWeak {}\n\nunsafe impl Sync for ModuleRef {}\nunsafe impl Sync for ModuleRefWeak {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn fmt() {\n        let module = ModuleContext::standalone(\"root.a.b\".into());\n        let m2 = module.clone();\n        let weak = ModuleRefWeak::new(\u0026module);\n\n        assert_eq!(module.as_str(), \"root.a.b\");\n        assert_eq!(\n            format!(\"{module:?}\"),\n            \"ModuleRef { name: root.a.b, handler: 2, ctx: 2 }\"\n        );\n        assert_eq!(format!(\"{weak:?}\"), \"ModuleRefWeak\");\n\n        assert_eq!(module, m2);\n    }\n\n    #[test]\n    fn as_typed_ref() {\n        #[derive(Debug, PartialEq)]\n        struct A {\n            inner: i32,\n        }\n        impl Module for A {}\n\n        let module = ModuleContext::standalone(\"root\".into());\n        module.upgrade_dummy(ProcessingElements::new(Vec::new(), A { inner: 42 }));\n\n        assert!(module.try_as_ref::\u003ci32\u003e().is_none());\n        assert!(module.try_as_mut::\u003ci32\u003e().is_none());\n\n        module.as_mut::\u003cA\u003e().inner += 1;\n        assert_eq!(*module.as_ref::\u003cA\u003e(), A { inner: 43 });\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":10868},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":10868},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":10868},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":10868},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1246},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1246},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":2195},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2195},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":14852},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":14852},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":4931},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":8952},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":267},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":420},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":93,"coverable":95},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","tests.rs"],"content":"use super::*;\n\n#[test]\n#[should_panic = \"cannot retrieve current module context, no module currently in scope\"]\nfn current_panic_outside_module_ctx() {\n    let _ = current();\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","net","par","api.rs"],"content":"use std::io;\n\nuse super::{Par, ParMap};\nuse crate::net::module::current;\n\n/// Retrieves a simulation parameter attached to the current node.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// The retrieved [`Par`] object points to a potentially existent parameter\n/// assigned to the current node. If non-existent the `Par` object can be\n/// used to set a the parametern for the first time. Parameters are stored\n/// as strings internally.\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// struct MyModule;\n/// impl Module for MyModule {\n///     fn at_sim_start(\u0026mut self, stage: usize) {\n///         let hostname = par(\"hostname\");\n///         assert!(hostname.is_some());\n///     }\n/// }\n///\n/// let mut sim = Sim::new(());\n/// sim.node(\"alice\", MyModule);\n/// ```\n#[must_use]\npub fn par(key: impl AsRef\u003cstr\u003e) -\u003e Par {\n    Par::new(key.as_ref(), current().path().as_str())\n}\n\n/// Retrieves a simulation parameter from some node in the simulation.\n///\n/// \u003e *This function should only be called while the simulation is active*\n///\n/// The retrieved [`Par`] object behaves, as if retrived by [`par`] on the given\n/// node. See [`par`] for more information.\n#[must_use]\npub fn par_for(key: impl AsRef\u003cstr\u003e, module: impl AsRef\u003cstr\u003e) -\u003e Par {\n    Par::new(key.as_ref(), module.as_ref())\n}\n\n/// Exports the current simulation parameter tree to some output device.\n///\n/// The output will be encoded as a key-value list where each key-value\n/// pair is one line, sperated by a '='.\n///\n/// # Errors\n///\n/// This function may fail if write operations to the output\n/// fails.\npub fn par_export(mut into: impl io::Write) -\u003e io::Result\u003c()\u003e {\n    ParMap::shared().export(\u0026mut into)\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","Users","mk","Developer","rust","des","des","src","net","par","mod.rs"],"content":"use std::fmt::Display;\nuse std::io;\nuse std::marker::PhantomData;\nuse std::ops::Deref;\nuse std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nuse std::sync::{Arc, RwLock};\n\nmod api;\nuse fxhash::{FxBuildHasher, FxHashMap};\n\npub use self::api::*;\n\nuse super::globals;\n\n// # Internal mappings\n\n/// A storage for all parameters associated with a simulation.\n#[derive(Debug)]\npub struct ParMap {\n    tree: RwLock\u003cParTree\u003e,\n}\n\n#[derive(Debug)]\nstruct ParTree {\n    branches: Vec\u003cParTreeBranch\u003e,\n    pars: FxHashMap\u003cString, (String, AtomicUsize)\u003e,\n}\n\n#[derive(Debug)]\nstruct ParTreeBranch {\n    matching: ParTreePathMatching,\n    node: ParTree,\n}\n\n#[derive(Debug)]\nenum ParTreePathMatching {\n    Any,\n    Path(String),\n}\n\nimpl ParMap {\n    fn shared() -\u003e Arc\u003cParMap\u003e {\n        globals().parameters.clone()\n    }\n\n    /// Creates new entries from a raw input text.\n    ///\n    /// See [`Sim::include_par`](crate::net::Sim) for more infomation.\n    pub fn build(\u0026self, raw_text: \u0026str) {\n        for line in raw_text.lines() {\n            if let Some((key, value)) = line.split_once('=') {\n                self.insert(key.trim(), value.trim().to_string());\n            }\n        }\n    }\n\n    fn get_rlock(\u0026self, key: \u0026str, inc: usize) -\u003e Option\u003cString\u003e {\n        self.tree.read().unwrap().get_rlock(key, inc)\n    }\n\n    fn release_rlock(\u0026self, key: \u0026str) {\n        let done = self.tree.read().unwrap().release_rlock(key);\n        assert!(done);\n    }\n\n    fn insert(\u0026self, key: \u0026str, value: String) -\u003e bool {\n        self.tree.write().unwrap().insert(key, value)\n    }\n\n    fn remove(\u0026self, key: \u0026str) {\n        self.tree.write().unwrap().remove(key);\n    }\n\n    fn export(\u0026self, writer: \u0026mut impl io::Write) -\u003e io::Result\u003c()\u003e {\n        self.tree.read().unwrap().export(writer, \"\")\n    }\n}\n\nimpl ParTree {\n    fn new() -\u003e ParTree {\n        ParTree {\n            branches: Vec::new(),\n            pars: FxHashMap::with_hasher(FxBuildHasher::default()),\n        }\n    }\n\n    fn get_rlock(\u0026self, key: \u0026str, inc: usize) -\u003e Option\u003cString\u003e {\n        match key.split_once('.') {\n            Some((comp, remainder)) =\u003e {\n                for branch in self.branches.iter().filter(|b| b.matching.matches_r(comp)) {\n                    let Some(ret) = branch.node.get_rlock(remainder, inc) else {\n                        continue;\n                    };\n                    return Some(ret);\n                }\n                None\n            }\n            None =\u003e {\n                if let Some((value, lock)) = self.pars.get(key) {\n                    lock.fetch_add(inc, SeqCst);\n                    Some(value.clone())\n                } else {\n                    None\n                }\n            }\n        }\n    }\n\n    fn release_rlock(\u0026self, key: \u0026str) -\u003e bool {\n        match key.split_once('.') {\n            Some((comp, rem)) =\u003e {\n                for branch in self.branches.iter().filter(|b| b.matching.matches_r(comp)) {\n                    if branch.node.release_rlock(rem) {\n                        return true;\n                    }\n                }\n                false\n            }\n            None =\u003e {\n                if let Some((_, lock)) = self.pars.get(key) {\n                    lock.fetch_sub(1, SeqCst);\n                    true\n                } else {\n                    false\n                }\n            }\n        }\n    }\n\n    fn insert(\u0026mut self, key: \u0026str, value: String) -\u003e bool {\n        if let Some((comp, remainder)) = key.split_once('.') {\n            if let Some(branch) = self\n                .branches\n                .iter_mut()\n                .find(|b| b.matching.matches_w(comp))\n            {\n                branch.node.insert(remainder, value)\n            } else {\n                let mut node = ParTree::new();\n                let ret = node.insert(remainder, value);\n                if comp == \"*\" {\n                    self.branches.push(ParTreeBranch {\n                        matching: ParTreePathMatching::Any,\n                        node,\n                    });\n                } else {\n                    self.branches.push(ParTreeBranch {\n                        matching: ParTreePathMatching::Path(comp.to_string()),\n                        node,\n                    });\n                }\n                ret\n            }\n        } else {\n            // (0) Fetch the entry\n            let entry = self\n                .pars\n                .entry(key.to_string())\n                .or_insert((String::new(), AtomicUsize::new(0)));\n\n            // (1) try an inplace update (requires not readers)\n            if entry.1.load(SeqCst) == 0 {\n                entry.0 = value;\n                true\n            } else {\n                false\n            }\n        }\n    }\n\n    fn remove(\u0026mut self, key: \u0026str) -\u003e bool {\n        match key.split_once('.') {\n            Some((comp, rem)) =\u003e self\n                .branches\n                .iter_mut()\n                .find(|b| b.matching.matches_w(comp))\n                .is_some_and(|b| b.node.remove(rem)),\n            None =\u003e self.pars.remove(key).is_some(),\n        }\n    }\n\n    fn export(\u0026self, writer: \u0026mut impl io::Write, path: \u0026str) -\u003e io::Result\u003c()\u003e {\n        // Write pars directly\n        for (key, (value, _)) in \u0026self.pars {\n            writeln!(writer, \"{path}.{key} = {value}\")?;\n        }\n\n        // Recurse branches\n        for branch in \u0026self.branches {\n            let new_path = if path.is_empty() {\n                branch.matching.to_string()\n            } else {\n                format!(\"{path}.{}\", branch.matching)\n            };\n            branch.node.export(writer, \u0026new_path)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl ParTreePathMatching {\n    fn matches_w(\u0026self, key: \u0026str) -\u003e bool {\n        match self {\n            Self::Any =\u003e key == \"*\",\n            Self::Path(ref path) =\u003e path == key,\n        }\n    }\n\n    fn matches_r(\u0026self, key: \u0026str) -\u003e bool {\n        // dbg!(self, key);\n        match self {\n            Self::Any =\u003e true,\n            Self::Path(ref path) =\u003e path == key,\n        }\n    }\n}\n\nimpl Display for ParTreePathMatching {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Any =\u003e write!(f, \"*\"),\n            Self::Path(path) =\u003e write!(f, \"{path}\"),\n        }\n    }\n}\n\nimpl Default for ParMap {\n    fn default() -\u003e Self {\n        ParMap {\n            tree: RwLock::new(ParTree::new()),\n        }\n    }\n}\n\n// # External API\n\n/// A handle to a parameter associated to a node within the simulation.\n///\n/// This type is parameterized by a type-state parameter `S`.\n/// This parameter indicates whether the parameter is guaranteed to\n/// exist `S = Exists` or this remains in question `S = Optional`.\n///\n/// This type provides methods to read an write parameters, based on the\n/// type state. `Par\u003cExists\u003e` implement `Deref\u003cTarget = str\u003e` so parameters\n/// can be extracted and perhaps parsed, as soon as the existence of the parameter\n/// is confirmed.\n#[derive(Debug, PartialEq, Eq, Hash)]\npub struct Par\u003cS = Optional\u003e\nwhere\n    S: private::ParState,\n{\n    key: String,\n    value: Option\u003cString\u003e,\n\n    _phantom: PhantomData\u003cS\u003e,\n}\n\n/// The state of a [`Par`] where its not decided\n/// whether data is contained or not. Useful for writing data\n/// to not yet initalized parameters.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct Optional;\nimpl private::ParState for Optional {}\n\n/// The state of a [`Par`] where the contents are guaranteed\n/// to be there, thus allowing derefs on the handle.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct Exists;\nimpl private::ParState for Exists {}\n\n/// Errors that can occur in combination with [`Par`] objects.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum ParError {\n    /// This error occures if a write operation failed, since a write lock could\n    /// not be aquired.\n    CouldNotAquireWriteLock,\n}\n\nmod private {\n    pub trait ParState {}\n}\n\nimpl Par\u003cOptional\u003e {\n    fn new(key: \u0026str, module: \u0026str) -\u003e Par {\n        if module.is_empty() {\n            Par {\n                key: key.to_string(),\n                value: None,\n                _phantom: PhantomData,\n            }\n        } else {\n            Par {\n                key: format!(\"{module}.{key}\"),\n                value: None,\n                _phantom: PhantomData,\n            }\n        }\n    }\n}\n\nimpl\u003cS\u003e Par\u003cS\u003e\nwhere\n    S: private::ParState,\n{\n    /// Returns a handle allowing [`Deref`] on the contained\n    /// value, consuming self.\n    ///\n    /// # Examples\n    ///\n    /// This example would succeed:\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::net::*;\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", ModuleFn::new(\n    ///     || {\n    ///         let par = par(\"addr\")\n    ///             .expect(\"parameter 'addr' does not exist\")\n    ///             .parse::\u003cIpAddr\u003e()\n    ///             .expect(\"parameter 'addr' failed to be parsed\");\n    ///     },\n    ///     |_, _| {}\n    /// ));\n    /// sim.include_par(\"alice.addr = 198.168.2.1\\n\");\n    /// /* ... */\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    ///\n    /// While this would panic:\n    ///\n    /// ```should_panic\n    /// # use des::prelude::*;\n    /// # use des::net::*;\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", ModuleFn::new(\n    ///     || {\n    ///         let par = par(\"addr\")\n    ///             .expect(\"parameter 'addr' does not exist\")\n    ///             .parse::\u003cIpAddr\u003e()\n    ///             .expect(\"parameter 'addr' failed to be parsed\");\n    ///     },\n    ///     |_, _| {}\n    /// ));\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// This function panics of the Par points to no data.\n    ///\n    #[must_use]\n    pub fn expect(self, msg: \u0026str) -\u003e Par\u003cExists\u003e {\n        let map = ParMap::shared();\n        if let Some(value) = map.get_rlock(\u0026self.key, 1) {\n            Par {\n                key: self.key.clone(),\n                value: Some(value),\n                _phantom: PhantomData,\n            }\n        } else {\n            panic!(\"{msg}\");\n        }\n    }\n\n    /// Returns a handle allowing [`Deref`] on the contained\n    /// value, consuming self.\n    ///\n    /// See [`Par::expect`] for more information.\n    #[must_use]\n    pub fn unwrap(self) -\u003e Par\u003cExists\u003e {\n        self.expect(\"called `Par::unwrap` on a parameter that does not exist\")\n    }\n\n    /// Indicates whether the handle contains a value.\n    #[must_use]\n    pub fn is_some(\u0026self) -\u003e bool {\n        // (0) Shortciruit\n        if self.value.is_some() {\n            return true;\n        }\n\n        // (1) Long way around\n        let map = ParMap::shared();\n        map.get_rlock(\u0026self.key, 0).is_some()\n    }\n\n    /// Indicates whether the handle contains a value.\n    #[must_use]\n    pub fn is_none(\u0026self) -\u003e bool {\n        !self.is_some()\n    }\n\n    /// Returns the contained value optionaly, thereby losing the\n    /// ability to set the par. This does not create a permantent\n    /// read lock.\n    #[must_use]\n    pub fn as_option(self) -\u003e Option\u003cString\u003e {\n        let map = ParMap::shared();\n        map.get_rlock(\u0026self.key, 0)\n    }\n\n    /// Sets the parameter to the given value.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if other active locks exist for the datapoint.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::net::*;\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", ModuleFn::new(\n    ///     || {\n    ///         assert!(par(\"addr\").is_none());\n    ///         par(\"addr\").set(IpAddr::V4(Ipv4Addr::new(192, 168, 2, 110)));\n    ///         assert!(par(\"addr\").is_some());\n    ///         assert_eq!(\u0026*par(\"addr\").unwrap(), \"192.168.2.110\");\n    ///     },\n    ///     |_, _| {}\n    /// ));\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    #[allow(clippy::needless_pass_by_value)]\n    pub fn set(self, value: impl ToString) -\u003e Result\u003cPar\u003cExists\u003e, ParError\u003e {\n        let map = ParMap::shared();\n        let value = value.to_string();\n        if map.insert(\u0026self.key, value) {\n            Ok(Par {\n                key: self.key.clone(),\n                value: map.get_rlock(\u0026self.key, 1),\n                _phantom: PhantomData,\n            })\n        } else {\n            Err(ParError::CouldNotAquireWriteLock)\n        }\n    }\n\n    /// Remove the entry from the par storage.\n    ///\n    /// Returns a `Par` object with optional (in this case None) content.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::net::*;\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", ModuleFn::new(\n    ///     || {\n    ///         assert!(par(\"addr\").is_some());\n    ///         par(\"addr\").unset();\n    ///         assert!(par(\"addr\").is_none());\n    ///     },\n    ///     |_, _| {}\n    /// ));\n    /// sim.include_par(\"alice.addr = 192.168.2.110\");\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    #[must_use]\n    pub fn unset(self) -\u003e Par\u003cOptional\u003e {\n        let map = ParMap::shared();\n        map.remove(\u0026self.key);\n        Par {\n            value: None,\n            key: self.key.clone(),\n            _phantom: PhantomData,\n        }\n    }\n}\n\nimpl Par\u003cExists\u003e {\n    /// Uses a custom string parser to parse a string, timming\n    /// quotation marks in the process.\n    #[allow(clippy::missing_panics_doc)]\n    #[must_use]\n    pub fn into_inner(\u0026self) -\u003e String {\n        let mut parsed = self.value.clone().unwrap();\n        // Trim marks\n        let mut chars = parsed.chars();\n        let mut is_marked = parsed.len() \u003e= 2;\n        is_marked \u0026= chars.next() == Some('\"');\n        is_marked \u0026= chars.next_back() == Some('\"');\n\n        if is_marked {\n            parsed.pop();\n            parsed.remove(0);\n            parsed\n        } else {\n            parsed\n        }\n    }\n}\n\nimpl Deref for Par\u003cExists\u003e {\n    type Target = str;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        self.value.as_ref().unwrap()\n    }\n}\n\nimpl\u003cS\u003e Clone for Par\u003cS\u003e\nwhere\n    S: private::ParState,\n{\n    fn clone(\u0026self) -\u003e Self {\n        if self.value.is_some() {\n            ParMap::shared().get_rlock(\u0026self.key, 1);\n        }\n\n        Self {\n            key: self.key.clone(),\n            value: self.value.clone(),\n            _phantom: PhantomData,\n        }\n    }\n}\n\nimpl\u003cS\u003e Drop for Par\u003cS\u003e\nwhere\n    S: private::ParState,\n{\n    fn drop(\u0026mut self) {\n        // (0) Only if Par\u003cExists\u003e\n        if self.value.is_some() {\n            let map = ParMap::shared();\n            map.release_rlock(\u0026self.key);\n        }\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":151},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":151},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":107},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":219},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":219},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":121,"coverable":147},{"path":["/","Users","mk","Developer","rust","des","des","src","net","path.rs"],"content":"use core::fmt;\nuse std::sync::Arc;\n\n///\n/// A unqiue identifier for a object, indicating its parental inheritance.\n///\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct ObjectPath {\n    data: Arc\u003cstr\u003e,\n    last_element_offset: usize,\n    len: usize,\n    is_gate: bool,\n}\n\nimpl ObjectPath {\n    /// Indicates whether the path points to the simulation root.\n    #[must_use]\n    pub fn is_root(\u0026self) -\u003e bool {\n        self.len == 0\n    }\n\n    /// Indicates whether the path points to a module.\n    #[must_use]\n    pub fn is_module(\u0026self) -\u003e bool {\n        !self.is_gate\n    }\n\n    /// Returns the depth of the referenced object.\n    ///\n    /// Note that depth 0 indicates the root of the simulation.\n    #[must_use]\n    #[allow(clippy::len_without_is_empty)]\n    pub fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    /// Returns the last path component, the name of the current module.\n    #[must_use]\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.data[self.last_element_offset..]\n    }\n\n    /// Returns the entrie path as a \u0026str.\n    #[must_use]\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        \u0026self.data\n    }\n\n    /// Returns the entrie path as a \u0026str for declaring a logger scope\n    #[must_use]\n    pub fn as_logger_scope(\u0026self) -\u003e \u0026str {\n        if self.is_root() {\n            \"@root\"\n        } else {\n            self.as_str()\n        }\n    }\n\n    /// Returns the entrie path as a \u0026str.\n    #[must_use]\n    pub fn as_parent_str(\u0026self) -\u003e \u0026str {\n        \u0026self.data[..self.last_element_offset.saturating_sub(1)]\n    }\n\n    /// Constructs the path to the parent element, if there is any.\n    #[must_use]\n    pub fn parent(\u0026self) -\u003e Option\u003cObjectPath\u003e {\n        if self.len == 0 {\n            return None;\n        }\n\n        let mut data = self.data.to_string();\n        let mut last_element_offset = self.last_element_offset;\n        let mut len = self.len;\n\n        data.truncate(last_element_offset.saturating_sub(1));\n\n        if let Some(i) = data.rfind('.') {\n            last_element_offset = i + 1;\n        } else {\n            last_element_offset = 0;\n        }\n        len -= 1;\n\n        Some(Self {\n            data: data.into(),\n            last_element_offset,\n            len,\n            is_gate: false,\n        })\n    }\n\n    /// Returns a parent that is not root.\n    #[must_use]\n    pub fn nonzero_parent(\u0026self) -\u003e Option\u003cObjectPath\u003e {\n        let parent = self.parent()?;\n        if parent.is_root() {\n            None\n        } else {\n            Some(parent)\n        }\n    }\n\n    /// Returns a new instance with another module appended to the path.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the current path points to a gate.\n    #[must_use]\n    pub fn appended(\u0026self, module: impl AsRef\u003cstr\u003e) -\u003e Self {\n        let mut data = self.data.to_string();\n        let mut last_element_offset = self.last_element_offset;\n        let mut len = self.len;\n\n        assert!(\n            !self.is_gate,\n            \"cannot append to a path that points to a gate\"\n        );\n\n        let suffix = module.as_ref();\n        if !suffix.is_empty() {\n            if self.len != 0 {\n                last_element_offset = data.len() + 1;\n                data.push('.');\n            }\n            data.push_str(suffix);\n            len += 1;\n        }\n\n        Self {\n            data: data.into(),\n            last_element_offset,\n            len,\n            is_gate: false,\n        }\n    }\n\n    /// Retruns a new object path pointing to the gate on the current module.\n    #[must_use]\n    pub fn appended_gate(\u0026self, gate: impl AsRef\u003cstr\u003e) -\u003e Self {\n        let mut appended = self.appended(gate);\n        appended.is_gate = true;\n        appended\n    }\n}\n\nimpl fmt::Display for ObjectPath {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        self.data.fmt(f)\n    }\n}\n\nimpl AsRef\u003cstr\u003e for ObjectPath {\n    fn as_ref(\u0026self) -\u003e \u0026str {\n        self.as_str()\n    }\n}\n\nimpl From\u003c\u0026str\u003e for ObjectPath {\n    fn from(s: \u0026str) -\u003e Self {\n        let mut o = 0;\n        let mut last_element_offset = 0;\n        let mut len = 0;\n        for c in s.chars() {\n            if c == '.' {\n                last_element_offset = o + c.len_utf8();\n                len += 1;\n            }\n            o += c.len_utf8();\n        }\n        if o != last_element_offset {\n            len += 1;\n        }\n\n        Self {\n            data: s.to_string().into(),\n            last_element_offset,\n            len,\n            is_gate: false,\n        }\n    }\n}\n\nimpl From\u003c\u0026String\u003e for ObjectPath {\n    fn from(value: \u0026String) -\u003e Self {\n        Self::from(value.as_str())\n    }\n}\n\nimpl From\u003cString\u003e for ObjectPath {\n    fn from(value: String) -\u003e Self {\n        Self::from(value.as_str())\n    }\n}\n\nimpl Default for ObjectPath {\n    fn default() -\u003e Self {\n        Self {\n            data: String::new().into(),\n            last_element_offset: 0,\n            len: 0,\n            is_gate: false,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn manual_appending() {\n        let path = ObjectPath::default().appended(\"top\").appended(\"mid\");\n\n        assert_eq!(path.name(), \"mid\");\n        assert_eq!(path.as_parent_str(), \"top\");\n        assert_eq!(\n            path,\n            ObjectPath {\n                data: \"top.mid\".to_string().into(),\n                len: 2,\n                last_element_offset: 4,\n                is_gate: false,\n            }\n        );\n\n        let path = ObjectPath::default()\n            .appended(\"top\")\n            .appended(\"mid\")\n            .appended(\"low\");\n\n        assert_eq!(path.name(), \"low\");\n        assert_eq!(path.as_parent_str(), \"top.mid\");\n        assert_eq!(\n            path,\n            ObjectPath {\n                data: \"top.mid.low\".to_string().into(),\n                len: 3,\n                last_element_offset: 8,\n                is_gate: false,\n            }\n        );\n\n        let path = ObjectPath::default().appended(\"top\");\n        assert_eq!(path.name(), \"top\");\n        assert_eq!(path.as_parent_str(), \"\");\n        assert_eq!(\n            path,\n            ObjectPath {\n                data: \"top\".to_string().into(),\n                len: 1,\n                last_element_offset: 0,\n                is_gate: false,\n            }\n        );\n\n        let path = ObjectPath::default();\n        assert_eq!(path.name(), \"\");\n        assert_eq!(path.as_parent_str(), \"\");\n        assert!(path.is_root());\n        assert_eq!(\n            path,\n            ObjectPath {\n                data: \"\".to_string().into(),\n                len: 0,\n                last_element_offset: 0,\n                is_gate: false,\n            }\n        );\n    }\n\n    #[test]\n    fn parent_creation() {\n        let path = ObjectPath::default().appended(\"top\").appended(\"mid\");\n        let parent = path.parent();\n        assert_eq!(\n            parent,\n            Some(ObjectPath {\n                data: \"top\".to_string().into(),\n                len: 1,\n                last_element_offset: 0,\n                is_gate: false,\n            })\n        );\n\n        let path = ObjectPath::default()\n            .appended(\"top\")\n            .appended(\"mid\")\n            .appended(\"low\");\n\n        let parent = path.parent();\n        assert_eq!(\n            parent,\n            Some(ObjectPath {\n                data: \"top.mid\".to_string().into(),\n                len: 2,\n                last_element_offset: 4,\n                is_gate: false,\n            })\n        );\n\n        let path = ObjectPath::default().appended(\"top\");\n\n        let parent = path.parent();\n        assert_eq!(\n            parent,\n            Some(ObjectPath {\n                data: \"\".to_string().into(),\n                len: 0,\n                last_element_offset: 0,\n                is_gate: false,\n            })\n        );\n\n        let path = ObjectPath::default();\n\n        let parent = path.parent();\n        assert_eq!(parent, None);\n    }\n\n    #[test]\n    fn parsing() {\n        assert_eq!(\n            ObjectPath::from(\"top.mid\"),\n            ObjectPath {\n                data: \"top.mid\".to_string().into(),\n                len: 2,\n                last_element_offset: 4,\n                is_gate: false,\n            }\n        );\n\n        assert_eq!(\n            ObjectPath::from(\"top.mid.low\"),\n            ObjectPath {\n                data: \"top.mid.low\".to_string().into(),\n                len: 3,\n                last_element_offset: 8,\n                is_gate: false,\n            }\n        );\n\n        assert_eq!(\n            ObjectPath::from(\"top\"),\n            ObjectPath {\n                data: \"top\".to_string().into(),\n                len: 1,\n                last_element_offset: 0,\n                is_gate: false,\n            }\n        );\n\n        assert_eq!(\n            ObjectPath::from(\"\"),\n            ObjectPath {\n                data: \"\".to_string().into(),\n                len: 0,\n                last_element_offset: 0,\n                is_gate: false,\n            }\n        );\n\n        // emoji is a 4 byte character thus 7 + 4\n        assert_eq!(\n            ObjectPath::from(\"top.ab.low\"),\n            ObjectPath {\n                data: \"top.ab.low\".to_string().into(),\n                len: 3,\n                last_element_offset: 11,\n                is_gate: false,\n            }\n        );\n\n        assert!(ObjectPath::default().is_root());\n        assert!(ObjectPath::from(String::new()).is_module());\n        assert_eq!(ObjectPath::from(\u0026String::new()).as_logger_scope(), \"@root\");\n        assert_eq!(ObjectPath::from(\"abc\").as_logger_scope(), \"abc\");\n        assert!(!ObjectPath::from(\"a\").appended_gate(\"gate\").is_module());\n        assert!(ObjectPath::from(\"root.a.b.c\").as_ref().starts_with(\"root\"));\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":423},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":423},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":4724},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":4724},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":470},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":470},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":440},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":388},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":176},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1469},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1236},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1199},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":534},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":17},"fn_name":null}],"covered":76,"coverable":76},{"path":["/","Users","mk","Developer","rust","des","des","src","net","processing.rs"],"content":"//! Module-specific plugins.\n//!\n//! Plugins act as message stream manipulators between the\n//! main application and the network layer. They can be used\n//! to add shared behaviour (like Routing) to all modules,\n//! independent of the modules defined state and behaviour.\n//!\n//! All plugins must implement the `Plugin` trait. To install\n//! them on a module, use the `add_plugin`\n//! function and assign them a priority. The\n//! lower the priority value, the closer the plugin is to the network\n//! layer. Plugins can then be controlled and observed using the\n//! `PluginHandle` return by the install functions.\n//!\n//! # Stream manipulation \u0026 event lifecycle\n//!\n//! Plugins are intrinsicly linked to the event lifecycle of an\n//! arriving message. Accordingly they provide an API do react\n//! to lifecycle events like `Plugin::event_start` and `Plugin::event_end`.\n//!\n//! When a message arrives at a module, the `Plugin::event_start` method\n//! is called on all active plugins, in the order defined by the priorities\n//! (close to networklayer first). Then the incoming message is passed\n//! through the plugins in the same order. Plugins can capture messages\n//! using the `Plugin::capture_incoming` method. Using this method\n//! plugins can **modify**, **delete** or **pass through** messages.\n//! Should they delete a message, no further plugins will be called\n//! using `Plugin::capture_incoming`. Additionally no message will be\n//! passed to the main application (defined by the module).\n//!\n//! If the message still exist after passing all plugins, then\n//! it will be passed to the main application though `Module::handle_message`\n//!\n//! In the process of handeling an incoming message, each plugin and the main application\n//! may send new messages to the networklayer using `send`\n//! or `schedule_in`. This messages must pass through\n//! all plugins (in reverse priority order). In this process they can be\n//! captured and thus **modified** or **deleted** by all plugins, closer\n//! to the network layer, than the message origin. This is done\n//! using the `Plugin::capture_outgoing` method. If messages\n//! make it through all plugins they will be added to the networklayer,\n//! if not then not.\n//!\n//! After the main application has finished the message processing\n//! the plugins are going to be deactivated in reverse order.\n//! by calling `Plugin::event_end`. Sending messages at this stage will\n//! still create new output-streams through all plugins closer to the networklayer\n//! than the origin.\n//!\n//! # Plugin creation and removal\n//!  \n//! When plugins are created using e.g. `add_plugin` they are not active\n//! right away. Plugins only become active when the next event arrives.\n//! This is the case, because some plugins may depend on some action\n//! they should have performed in the incoming stream, when working on the\n//! outgoing stream. However plugins may be created in a position, where their place\n//! in the incoming stream should have allready been processed, but was not,\n//! since they were not existent back then. Accordingly plugins only become active once they\n//! can ensure that they existed at all relevent points in the event-lifecycle.\n//!\n//! Accordingly plugins the are removed using `PluginHandle::remove`\n//! still exists for the rest of the event cycle, and are only deleted\n//! once the next event arrives.\n//!  \n\nuse std::{any::Any, sync::RwLock};\n\nuse super::module::Module;\nuse crate::prelude::Message;\n\n/// A subprogramm between the module application and the network layer.\n///\n/// Processing elements can follow different patterns based on the provided\n/// API. Common patterns are:\n///\n/// - **Observer**: The element does not modifiy the message stream, it just observes it.\n///    This plugin can be used to get statistics over message streams or to log\n///    debug output.\n/// - **Scope-Provider**: This element provides some kind of scope to all items further\n///    from the network layer than itself. A scope can be defined using a static variable\n///    or just consist of a time meassurement between [`event_start`] / [`event_end`].\n/// - **Capture**: This kind of processing element captures parts of the input stream and redirects\n///     it in some abitraty way, using other APIs. This pattern can be used to implement buffering\n///     or mergeing of frameneted IP packets.\n/// - **Meta-Provider**: This kind of processing element attaches / modifies part of the incoming or\n///    outgoing message stream to provide some new level of abstraction e.g. a VPN\n///    or simulated network Interfaces.\n///\n/// [`event_start`]: ProcessingElement::event_start\n/// [`event_end`]: ProcessingElement::event_end\npub trait ProcessingElement: Any {\n    /// Defines the requires stack for this processing element.\n    ///\n    ///\n    fn stack(\u0026self) -\u003e impl IntoProcessingElements\n    where\n        Self: Sized,\n    {\n        BaseLoader\n    }\n\n    /// A handler for when an the event processing of a message starts.\n    ///\n    /// This function is called only once per event. If this function is called\n    /// this means all plugins closer to the network layer have allready been called\n    /// while all plugins further from the network layer are not yet called.\n    ///\n    /// Use this function to set up actions, required at the start of\n    /// a generic event.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use des::prelude::*;\n    /// struct LoggerPlugin {\n    ///     counter: usize,\n    /// }\n    ///\n    /// impl ProcessingElement for LoggerPlugin {\n    ///     fn event_start(\u0026mut self) {\n    ///         tracing::trace!(\"receiving {}th message\", self.counter);\n    ///         self.counter += 1;   \n    ///     }\n    /// }\n    /// ```\n    fn event_start(\u0026mut self) {}\n\n    /// A handler for when an the event processing of a message ends.\n    ///\n    /// This function is called only once per event. The call order\n    /// is the reverse to the call order of [`event_start`].\n    ///\n    /// Use this function to set up actions, associated\n    /// with the end of an event\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use des::prelude::*;\n    /// # use des::time::*;\n    /// struct Timer {\n    ///     started: SimTime,    \n    /// }\n    ///\n    /// impl ProcessingElement for Timer {\n    ///     fn event_start(\u0026mut self) {\n    ///        self.started = SimTime::now();\n    ///     }\n    ///     fn event_end(\u0026mut self) {\n    ///        let t = SimTime::now().duration_since(self.started);\n    ///        tracing::trace!(\"took {:?}\", t);   \n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`event_start`]: ProcessingElement::event_start\n    fn event_end(\u0026mut self) {}\n\n    /// A capture clause that can modify an incoming message.\n    ///\n    /// This function is called at most once per event, after all\n    /// plugins have called [`event_start`],\n    /// but before all the main application has processed its message.\n    ///\n    /// This function receives an incoming message, and can\n    /// modify, pass-through or delete a message.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// struct Filter {\n    ///    filter: Box\u003cdyn Fn(\u0026Message) -\u003e bool\u003e,    \n    /// }\n    ///\n    /// impl ProcessingElement for Filter {\n    ///     fn incoming(\u0026mut self, msg: Message) -\u003e Option\u003cMessage\u003e {\n    ///        let f = \u0026self.filter;\n    ///        if f(\u0026msg) {\n    ///            Some(msg)    \n    ///        } else {\n    ///            None\n    ///        }\n    ///     }    \n    /// }\n    /// ```\n    ///\n    /// [`event_start`]: ProcessingElement::event_start\n    fn incoming(\u0026mut self, msg: Message) -\u003e Option\u003cMessage\u003e {\n        Some(msg)\n    }\n}\n\n/// A type that can be interprested as a processing element chain.\npub trait IntoProcessingElements: 'static {\n    /// Convertes into processing elements\n    fn to_processing_elements(self) -\u003e Vec\u003cProcessorElement\u003e;\n}\n\nimpl\u003cP: ProcessingElement + 'static\u003e IntoProcessingElements for P {\n    fn to_processing_elements(self) -\u003e Vec\u003cProcessorElement\u003e {\n        let mut stack = self.stack().to_processing_elements();\n        stack.push(ProcessorElement::new(self));\n        stack\n    }\n}\n\nimpl\u003cT: Module\u003e ProcessingElement for T {\n    fn stack(\u0026self) -\u003e impl IntoProcessingElements {\n        \u003cSelf as Module\u003e::stack(self)\n    }\n\n    fn incoming(\u0026mut self, msg: Message) -\u003e Option\u003cMessage\u003e {\n        self.handle_message(msg);\n        None\n    }\n}\n\n/// A base module that is used to load the default processing elements\n/// onto a module.\n///\n/// It's common for simulations to share a set of basic processing elements\n/// accross all nodes. The baseLoader is a maker type, that attaches all default\n/// plugins to a node, that relies on `BaseLoader` in its processing stack.\n///\n/// Use [`set_default_processing_elements`] to set the default processing\n/// elements.\n#[derive(Debug)]\npub struct BaseLoader;\n\npub(crate) static SETUP_PROCESSING: RwLock\u003cfn() -\u003e Vec\u003cProcessorElement\u003e\u003e =\n    RwLock::new(_default_processing);\n\nfn _default_processing() -\u003e Vec\u003cProcessorElement\u003e {\n    Vec::new()\n}\n\nimpl IntoProcessingElements for BaseLoader {\n    fn to_processing_elements(self) -\u003e Vec\u003cProcessorElement\u003e {\n        SETUP_PROCESSING.try_read().expect(\"Cannot access fn\")()\n    }\n}\n\n/// Sets a handler to create the default processing element of a module\n///\n/// # Panics\n///\n/// May panic at interal misconfiguration\npub fn set_default_processing_elements(f: fn() -\u003e Vec\u003cProcessorElement\u003e) {\n    *SETUP_PROCESSING.try_write().expect(\"no lock\") = f;\n}\n\n/// A untyped set of processing elements, effectivly a processing stack.\n#[doc(hidden)]\n#[allow(missing_debug_implementations)]\npub struct ProcessingElements {\n    // last element is module\n    state: ProcessingState,\n    stack: Vec\u003cProcessorElement\u003e,\n    pub(super) handler: Box\u003cdyn Module\u003e,\n}\n\n/// A untyped processing element, using dynamic dispatch.\n#[allow(missing_debug_implementations)]\npub struct ProcessorElement {\n    inner: Box\u003cdyn ProcessingElement\u003e,\n}\n\nimpl ProcessorElement {\n    /// Creates a new type-erased wrapper around a concrete processing element.\n    pub fn new\u003cT: ProcessingElement\u003e(inner: T) -\u003e Self {\n        Self {\n            inner: Box::new(inner),\n        }\n    }\n}\n\nenum ProcessingState {\n    Upstream(usize), // next processing index\n    Peek,\n    Downstream(usize), // last processing index\n}\n\nimpl ProcessingState {\n    fn bump_upstream(\u0026mut self) {\n        match self {\n            ProcessingState::Upstream(ref mut idx) =\u003e *idx += 1,\n            _ =\u003e unreachable!(),\n        }\n    }\n\n    fn bump_downstream(\u0026mut self) {\n        match self {\n            ProcessingState::Downstream(ref mut idx) =\u003e *idx -= 1,\n            _ =\u003e unreachable!(),\n        }\n    }\n}\n\nimpl ProcessingElements {\n    pub(super) fn new(stack: Vec\u003cProcessorElement\u003e, handler: impl Module) -\u003e Self {\n        ProcessingElements {\n            state: ProcessingState::Upstream(0),\n            stack,\n            handler: Box::new(handler),\n        }\n    }\n\n    pub(super) fn incoming_upstream(\u0026mut self, msg: Option\u003cMessage\u003e) -\u003e Option\u003cMessage\u003e {\n        self.state = ProcessingState::Upstream(0);\n\n        let mut msg = msg;\n        for i in 0..self.stack.len() {\n            self.stack[i].inner.event_start();\n            if let Some(existing_msg) = msg {\n                msg = self.stack[i].inner.incoming(existing_msg);\n            }\n            self.state.bump_upstream();\n        }\n        msg\n    }\n\n    pub(super) fn incoming_downstream(\u0026mut self) {\n        self.state = ProcessingState::Downstream(self.stack.len());\n        for i in (0..self.stack.len()).rev() {\n            self.stack[i].inner.event_end();\n            self.state.bump_downstream();\n        }\n    }\n\n    pub(super) fn incoming(\u0026mut self, msg: Option\u003cMessage\u003e) {\n        // Upstream\n        let msg = self.incoming_upstream(msg);\n\n        // Peek\n        self.state = ProcessingState::Peek;\n        if let Some(msg) = msg {\n            self.handler.handle_message(msg);\n        } else {\n            #[cfg(feature = \"async\")]\n            if self.handler.__indicate_async() {\n                self.run_without_event();\n            }\n        }\n\n        // Downstream\n        self.incoming_downstream();\n    }\n\n    #[cfg(feature = \"async\")]\n    #[allow(clippy::unused_self)]\n    pub(super) fn run_without_event(\u0026self) {\n        use crate::net::module::async_get_rt;\n        use tokio::task::yield_now;\n        let Some(rt) = async_get_rt() else { return };\n        rt.1.block_on(\u0026rt.0, yield_now());\n    }\n}\n\nimpl IntoProcessingElements for () {\n    fn to_processing_elements(self) -\u003e Vec\u003cProcessorElement\u003e {\n        Vec::new()\n    }\n}\n\nmacro_rules! for_tuples {\n    (\n        $($i:ident),*\n    ) =\u003e {\n        impl\u003c$($i: ProcessingElement + 'static),*\u003e IntoProcessingElements for ($($i),*) {\n            #[allow(non_snake_case)]\n            fn to_processing_elements(self) -\u003e Vec\u003cProcessorElement\u003e {\n                let mut stack = self.0.stack().to_processing_elements();\n                let ($($i),*) = self;\n                $(\n                    stack.push(ProcessorElement::new($i));\n                )*\n                stack\n            }\n        }\n    };\n}\n\nfor_tuples!(A, B);\nfor_tuples!(A, B, C);\nfor_tuples!(A, B, C, D);\nfor_tuples!(A, B, C, D, E);\nfor_tuples!(A, B, C, D, E, F);\nfor_tuples!(A, B, C, D, E, F, G);\nfor_tuples!(A, B, C, D, E, F, G, H);\nfor_tuples!(A, B, C, D, E, F, G, H, I);\nfor_tuples!(A, B, C, D, E, F, G, H, I, J);\n","traces":[{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":131},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":131},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":451},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":451},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":457},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":457},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":470},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":470},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":470},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":4305},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":4305},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":4305},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":4742},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":859},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":4305},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":4301},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":4301},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":5175},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":3351},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":3351},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":3351},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":6700},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":3351},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":448},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":448},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":62,"coverable":63},{"path":["/","Users","mk","Developer","rust","des","des","src","net","runtime","api.rs"],"content":"use super::Globals;\nuse std::sync::Arc;\n\n/// Returns the globals of the runtime.\n///\n/// \u003e *This function should only be called within the simulation*\n///\n/// # Panics\n///\n/// This function panics if the no runtime is currently active.\n/// Note that a runtime is active if a instance of [`Sim`](super::Sim) exists.\n///\n#[must_use]\npub fn globals() -\u003e Arc\u003cGlobals\u003e {\n    Globals::current()\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":72},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","Users","mk","Developer","rust","des","des","src","net","runtime","blocks.rs"],"content":"use std::{error::Error, fmt::Formatter, pin::Pin, time::Duration};\n\nuse crate::{\n    net::{message::Message, module::Module},\n    prelude::{current, shutdow_and_restart_in},\n};\n\nuse super::ScopedSim;\n\n/// A trait that descibes that an object can be build into a block of modules\n/// at a given scope within the simulation.\n///\n/// Types that implement `ModuleBlock` should be treated as builders for the actual\n/// block of modules. They can contain abitrary information that may be relevent to the\n/// build process of the actual modules within the block.\n///\n/// A module block can consist of either:\n/// - no module at all\n/// - on module specifically at the position defined by the scope\n/// - on module at the scope position, an more as direct or indirect children of the first module.\n///\n/// See [`ScopedSim`] for more information.\npub trait ModuleBlock {\n    /// Build the described module block within the context of scoped part of\n    /// a simulation.\n    fn build\u003cA\u003e(self, sim: ScopedSim\u003c'_, A\u003e);\n}\n\nimpl\u003cM: Module\u003e ModuleBlock for M {\n    fn build\u003cA\u003e(self, sim: ScopedSim\u003c'_, A\u003e) {\n        sim.base.raw(sim.scope, self);\n    }\n}\n\n/// The policy that descibes how a module should proceeed, if a\n/// handler function returns an error.\n#[derive(Debug, Clone, Copy)]\npub enum FailabilityPolicy {\n    /// This option causes the module to panic with the error.\n    ///\n    /// Only use this option if errors indicate that something went so wrong,\n    /// the entire simulation should fail.\n    Panic,\n    /// This option causes the module to just continue as is. The error will be logged.\n    ///\n    /// Only use this option if you can ensure that the error has not caused an invalid\n    /// state, should the node be statefull.\n    Continue,\n    /// This option triggers a node restart as a result of an error.\n    ///\n    /// If set on a node without restart semantics this is equivalent to `Continue`\n    Restart,\n}\n\n/// A wrapper for treating a handler functions as a module.\n///\n/// This wrapper takes an `FnMut(Message) -\u003e ?` as input at uses this function\n/// as message handler, called by [`Module::handle_message`]. Use this wrapper\n/// if a node software is stateless, an can be simply described by a handler function\n/// alone.\n///\n/// Since this wrapper is stateless, restarting it will have no effect on the\n/// internals.\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// # use des::net::HandlerFn;\n/// let mut sim = Sim::new(());\n/// sim.node(\"alice\", HandlerFn::new(|msg| {\n///     /* Do something stateless (e.g. random routing) */\n/// }));\n///\n/// let _ = Builder::new().build(sim).run();\n/// ```\n#[derive(Debug)]\npub struct HandlerFn\u003cHandler\u003e {\n    inner: Handler,\n}\n\nimpl\u003cHandler\u003e HandlerFn\u003cHandler\u003e\nwhere\n    Handler: FnMut(Message),\n{\n    /// Creates a new wrapper for a function returning the unit type.\n    pub fn new(handler: Handler) -\u003e Self {\n        Self { inner: handler }\n    }\n}\n\nimpl\u003cHandler, Err\u003e HandlerFn\u003cHandler\u003e\nwhere\n    Handler: FnMut(Message) -\u003e Result\u003c(), Err\u003e,\n    Err: Error,\n{\n    /// Creates a new wrapper for a function returning some `Result`.\n    ///\n    /// The parameter `policy` defines how an error will be processed, should\n    /// one occur during the execution of the handler.\n    #[allow(clippy::missing_panics_doc)]\n    pub fn failable(\n        mut handler: Handler,\n        policy: FailabilityPolicy,\n    ) -\u003e HandlerFn\u003cimpl FnMut(Message)\u003e {\n        HandlerFn {\n            inner: move |msg| match handler(msg) {\n                Ok(()) =\u003e {}\n                Err(e) =\u003e match policy {\n                    FailabilityPolicy::Panic =\u003e panic!(\n                        \"node '{}' failed to process message, handler fn failed with: {e} \",\n                        current().path\n                    ),\n                    FailabilityPolicy::Continue | FailabilityPolicy::Restart =\u003e {\n                        tracing::error!(\"failed to process message, handler fn failed with: {e}\");\n                    }\n                },\n            },\n        }\n    }\n}\n\nimpl\u003cHandler\u003e Module for HandlerFn\u003cHandler\u003e\nwhere\n    Handler: FnMut(Message) + 'static,\n{\n    fn handle_message(\u0026mut self, msg: Message) {\n        (self.inner)(msg);\n    }\n}\n\n/// A wrapper for creating handler functions with state, treatable as a module.\n///\n/// This wrapper takes two functions, one to create some state `FnMut() -\u003e State` and\n/// a handler function that accepts the state as an additional parameter `FnMut(\u0026mut State, Message)`\n/// to create a module. The generator function will be executed once the simulation has been started,\n/// within module-scope. When a module is shut down, the generator function can be used to reinitalize the\n/// state. Note that `gen` can be used for other things than just initalizing the state.\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// # use des::net::ModuleFn;\n/// struct State {\n///     /* ...data */\n/// }\n///\n/// let mut sim = Sim::new(());\n/// sim.node(\"alice\", ModuleFn::new(\n///     || {\n///         /* Treat this as at_sim_start() */\n///         State { /* ...data */ }\n///     },\n///     |state, msg| {\n///         /* Do some message processing here */\n///     }\n/// ));\n///\n/// let _ = Builder::new().build(sim).run();\n/// ```\n#[derive(Debug)]\npub struct ModuleFn\u003cGen, State, Handler\u003e {\n    gen: Gen,\n    current: Option\u003cState\u003e,\n    handler: Handler,\n}\n\nimpl\u003cGen, State, Handler\u003e ModuleFn\u003cGen, State, Handler\u003e\nwhere\n    Gen: FnMut() -\u003e State,\n    Handler: FnMut(\u0026mut State, Message),\n{\n    /// Creates a wrapper over a function that returns the unit type.\n    pub fn new(gen: Gen, handler: Handler) -\u003e Self {\n        Self {\n            handler,\n            current: None,\n            gen,\n        }\n    }\n}\n\nimpl\u003cGen, State, Handler, Err\u003e ModuleFn\u003cGen, State, Handler\u003e\nwhere\n    Gen: FnMut() -\u003e State,\n    Handler: FnMut(\u0026mut State, Message) -\u003e Result\u003c(), Err\u003e + 'static,\n    Err: Error,\n{\n    /// Creates a new wrapper for a function returning some `Result`.\n    ///\n    /// The parameter `policy` defines how an error will be processed, should\n    /// one occur during the execution of the handler.\n    #[allow(clippy::missing_panics_doc)]\n    #[allow(clippy::complexity)]\n    pub fn failable(\n        gen: Gen,\n        mut handler: Handler,\n        policy: FailabilityPolicy,\n    ) -\u003e ModuleFn\u003cGen, State, Box\u003cdyn FnMut(\u0026mut State, Message)\u003e\u003e {\n        ModuleFn {\n            current: None,\n            gen,\n            handler: Box::new(move |state, msg| match handler(state, msg) {\n                Ok(()) =\u003e {}\n                Err(e) =\u003e match policy {\n                    FailabilityPolicy::Panic =\u003e panic!(\n                        \"node '{}' failed to process message, handler fn failed with: {e} \",\n                        current().path\n                    ),\n                    FailabilityPolicy::Continue =\u003e {\n                        tracing::error!(\"failed to process message, handler fn failed with: {e}\");\n                    }\n                    FailabilityPolicy::Restart =\u003e {\n                        tracing::error!(\"failed to process message, handler fn failed with: {e}\");\n                        shutdow_and_restart_in(Duration::ZERO);\n                    }\n                },\n            }),\n        }\n    }\n}\n\nimpl\u003cGen, State, Handler\u003e Module for ModuleFn\u003cGen, State, Handler\u003e\nwhere\n    Gen: FnMut() -\u003e State + 'static,\n    State: 'static,\n    Handler: FnMut(\u0026mut State, Message) + 'static,\n{\n    fn reset(\u0026mut self) {\n        self.current = None;\n    }\n\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        self.current = Some((self.gen)());\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        let Some(state) = \u0026mut self.current else {\n            unreachable!(\"handle_message cannot be called before at_sim_start\")\n        };\n        (self.handler)(state, msg);\n    }\n}\n\ncfg_async! {\n    use tokio::{\n        sync::mpsc::{self, Receiver, Sender},\n        task::JoinHandle,\n    };\n    use std::future::Future;\n    use crate::net::module::AsyncModule;\n\n\n    /// A helper that enables user to treat a module as a async stream of messages,\n    /// with state attached.\n    ///\n    /// This helper enables user to use `async FnMut(Receiver\u003cMessage\u003e)` as a\n    /// module. The provided function is called at the start of the simulation, within\n    /// module context. The provided receiver will stream incoming message to the\n    /// async clousure. Any user code should saturate the mpsc channel asap, since\n    /// it is bounded. Message buffering should be implemented manually.\n    ///\n    /// On module restarts, the generator function will be called again with a new\n    /// receiver.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::net::AsyncFn;\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", AsyncFn::new(|mut rx| {\n    ///     /* Do some setup / sim_start_stuff here */\n    ///     async move {\n    ///         while let Some(msg) = rx.recv().await {\n    ///             /* Message processing */\n    ///         }\n    ///     }\n    /// }));\n    /// /* ... */\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    pub struct AsyncFn\n    {\n        gen: BoxedGen,\n\n        join: Option\u003cJoinHandle\u003c()\u003e\u003e,\n        tx: Sender\u003cMessage\u003e,\n        rx: Option\u003cReceiver\u003cMessage\u003e\u003e,\n\n        require_join: bool,\n    }\n\n    type BoxedGen = Box\u003cdyn FnMut(Receiver\u003cMessage\u003e) -\u003e BoxedFuture + Send\u003e;\n    type BoxedFuture = Pin\u003cBox\u003cdyn Future\u003cOutput = ()\u003e + Send\u003e\u003e;\n\n    impl AsyncFn {\n        /// Sets the handler to require a join\n        #[must_use]\n        pub fn require_join(mut self) -\u003e Self {\n            self.require_join = true;\n            self\n        }\n\n        /// Creates a new instance using the generator function.\n        pub fn new\u003cGen, Fut\u003e(mut gen: Gen) -\u003e Self\n        where\n            Gen: FnMut(Receiver\u003cMessage\u003e) -\u003e Fut,\n            Gen: Send + 'static,\n            Fut: Future\u003cOutput = ()\u003e,\n            Fut: Send + 'static,\n        {\n            let (tx, rx) = mpsc::channel(8);\n            Self { gen: Box::new(move |rx| Box::pin(gen(rx))), join: None, tx, rx: Some(rx), require_join: false }\n        }\n\n        /// Creates a new instance using the generator function.\n        #[allow(clippy::missing_panics_doc)]\n        pub fn failable\u003cFailable, Fut, Err\u003e(mut gen: Failable) -\u003e Self\n        where\n            Failable: FnMut(Receiver\u003cMessage\u003e) -\u003e Fut,\n            Failable: Send + 'static,\n            Fut: Future\u003cOutput = Result\u003c(), Err\u003e\u003e,\n            Fut: Send + 'static,\n            Err: Error\n        {\n            let (tx, rx) = mpsc::channel(8);\n            Self {\n                gen: Box::new(move |rx| {\n                    let fut = gen(rx);\n                    Box::pin(async move {\n                        match fut.await {\n                            Ok(()) =\u003e {},\n                            Err(e) =\u003e {\n                                panic!(\"node {} paniced at failable operation: {e}\", current().path());\n                            },\n                        }\n                    })\n                }),\n                join: None,\n                tx,\n                rx: Some(rx),\n                require_join: false\n            }\n        }\n\n        /// Makes an io::error exepctor\n        pub fn io\u003cGen, Fut\u003e(gen: Gen) -\u003e Self\n        where\n            Gen: FnMut(Receiver\u003cMessage\u003e) -\u003e Fut,\n            Gen: Send + 'static,\n            Fut: Future\u003cOutput = std::io::Result\u003c()\u003e\u003e,\n            Fut: Send + 'static,\n        {\n            Self::failable(gen)\n        }\n    }\n\n    impl AsyncModule for AsyncFn {\n        fn reset(\u0026mut self) {\n            if let Some(ref join) = self.join { join.abort() }\n        }\n\n        async fn at_sim_start(\u0026mut self, _: usize) {\n            let rx = self.rx.take().unwrap_or_else(|| {\n                let (tx, rx) = mpsc::channel(8);\n                self.tx = tx;\n                rx\n            });\n\n            let fut = (self.gen)(rx);\n            self.join = Some(tokio::task::spawn(fut));\n        }\n\n        async fn handle_message(\u0026mut self, msg: Message) {\n            self.tx.try_send(msg).expect(\"async module blocked\");\n        }\n\n        async fn at_sim_end(\u0026mut self) {\n            if let Some(join) = self.join.take() {\n                if join.is_finished() || self.require_join {\n                    match join.await {\n                        Ok(_) =\u003e {},\n                        Err(e) if e.is_cancelled() =\u003e {}\n                        Err(e) =\u003e panic!(\"{e}\"),\n                    }\n                }\n            }\n        }\n    }\n\n    impl std::fmt::Debug for AsyncFn {\n        fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e std::fmt::Result {\n            write!(f, \"AsyncFn\")\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":74,"coverable":76},{"path":["/","Users","mk","Developer","rust","des","des","src","net","runtime","ctx.rs"],"content":"#![allow(missing_docs)]\n\nuse super::{Globals, HandleMessageEvent, MessageExitingConnection, Sim};\nuse crate::net::gate::Connection;\nuse crate::net::module::{current, with_mod_ctx, MOD_CTX, SETUP_FN};\nuse crate::net::ModuleRestartEvent;\nuse crate::net::{gate::GateRef, message::Message, NetEvents};\nuse crate::prelude::{EventLifecycle, ModuleRef};\nuse crate::runtime::Runtime;\nuse crate::sync::Mutex;\nuse crate::time::SimTime;\nuse std::sync::{Arc, Weak};\n\nstatic BUF_CTX: Mutex\u003cBufferContext\u003e = Mutex::new(BufferContext::new());\n\ntype LoopbackBuffer = Vec\u003c(Message, SimTime)\u003e;\n\nstruct BufferContext {\n    // All new events that will be scheduled\n    events: Vec\u003c(NetEvents, SimTime)\u003e,\n\n    // (Message, SendTime)\n    loopback: LoopbackBuffer,\n    // shudown,\n    #[allow(clippy::option_option)]\n    shutdown: Option\u003cOption\u003cSimTime\u003e\u003e,\n    // globals\n    globals: Option\u003cWeak\u003cGlobals\u003e\u003e,\n}\n\nimpl BufferContext {\n    const fn new() -\u003e Self {\n        Self {\n            events: Vec::new(),\n            loopback: Vec::new(),\n            shutdown: None,\n            globals: None,\n        }\n    }\n}\n\nunsafe impl Send for BufferContext {}\nunsafe impl Sync for BufferContext {}\n\nimpl Globals {\n    pub(crate) fn current() -\u003e Arc\u003cSelf\u003e {\n        let ctx = BUF_CTX.lock();\n        ctx.globals\n            .as_ref()\n            .expect(\"no globals attached to this event\")\n            .upgrade()\n            .expect(\"globals allready dropped: simulation shutting down\")\n    }\n}\n\npub(crate) fn buf_init(globals: Weak\u003cGlobals\u003e) {\n    let mut ctx = BUF_CTX.lock();\n    ctx.globals = Some(globals);\n\n    // TODO: remove ?\n    // SAFTEY:\n    // reseting the MOD_CTX is safe, since simulation lock is aquired.\n    unsafe {\n        MOD_CTX.reset(None);\n    }\n}\n\npub(crate) fn buf_drop() {\n    let mut ctx = BUF_CTX.lock();\n    *ctx = BufferContext::new();\n}\n\npub(crate) fn buf_send_at(mut msg: Message, gate: GateRef, send_time: SimTime) {\n    let mut ctx = BUF_CTX.lock();\n    msg.header.sender_module_id = current().id();\n\n    crate::tracing::enter_scope(gate.owner().scope_token());\n\n    // (0) If delayed send is active, dont skip gate_refs\n    if send_time \u003e SimTime::now() {\n        ctx.events.push((\n            NetEvents::MessageExitingConnection(MessageExitingConnection {\n                con: Connection::new(gate),\n                msg,\n            }),\n            send_time,\n        ));\n        return;\n    }\n\n    // (0) Else handle the event inlined, for instant effects on the associated\n    // channels.\n    let event = MessageExitingConnection {\n        con: Connection::new(gate),\n        msg,\n    };\n    event.handle_with_sink(\u0026mut ctx.events);\n\n    crate::tracing::enter_scope(with_mod_ctx(|ctx| ctx.scope_token));\n}\n\npub(crate) fn buf_schedule_at(msg: Message, arrival_time: SimTime) {\n    // continue to delay the delivery of event, since non other components are\n    // used, and we dont block any channels. additionally this ensures that\n    // timeouts are allways ordered later than packets, which is good\n    let mut ctx = BUF_CTX.lock();\n    ctx.loopback.push((msg, arrival_time));\n}\n\npub(crate) fn buf_schedule_shutdown(restart: Option\u003cSimTime\u003e) {\n    assert!(\n        restart.map_or(true, |r| r \u003e= SimTime::now()),\n        \"Restart point cannot be in the past\"\n    );\n\n    let mut ctx = BUF_CTX.lock();\n    ctx.shutdown = Some(restart);\n}\n\npub(crate) fn buf_process\u003cA\u003e(module: \u0026ModuleRef, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e)\nwhere\n    A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n{\n    let mut ctx = BUF_CTX.lock();\n\n    // (0) Add delayed events from 'send'\n    for (event, time) in ctx.events.drain(..) {\n        rt.add_event(event, time);\n    }\n\n    // (1) Send loopback events from 'scheduleAt'\n    for (message, time) in ctx.loopback.drain(..) {\n        rt.add_event(\n            NetEvents::HandleMessageEvent(HandleMessageEvent {\n                module: module.clone(),\n                message,\n            }),\n            time,\n        );\n    }\n\n    // (2) Handle shutdown if indicated\n    if let Some(restart) = ctx.shutdown.take() {\n        // Mark the modules state\n        #[cfg(feature = \"tracing\")]\n        tracing::debug!(\"Shuttind down module and restaring at {:?}\", restart);\n        module\n            .ctx\n            .active\n            .store(false, std::sync::atomic::Ordering::SeqCst);\n\n        // drop the rt, to prevent all async activity from happening.\n        #[cfg(feature = \"async\")]\n        module.ctx.async_ext.write().rt.shutdown();\n\n        // drop all hooks to ensure all messages reach the async impl\n        // module.ctx.hooks.borrow_mut().clear(); TODO: Plugin clean\n        SETUP_FN.read()(\u0026module.ctx);\n\n        // Reset the internal state\n        // Note that the module is not active, so it must be manually reactivated\n        module.activate();\n        module.reset();\n        module.deactivate(rt);\n\n        // Reschedule wakeup\n        if let Some(restart) = restart {\n            rt.add_event(\n                NetEvents::ModuleRestartEvent(ModuleRestartEvent {\n                    module: module.clone(),\n                }),\n                restart,\n            );\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":4152},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":4031},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":4031},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":12267},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":4118},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":6499},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":4048},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":11},"fn_name":null}],"covered":51,"coverable":62},{"path":["/","Users","mk","Developer","rust","des","des","src","net","runtime","events.rs"],"content":"use std::sync::atomic::Ordering::SeqCst;\n\nuse crate::{\n    net::{\n        channel::ChannelRef, gate::Connection, message::Message, module::ModuleRef,\n        runtime::buf_process, Sim,\n    },\n    runtime::{EventLifecycle, EventSet, EventSink, Runtime},\n    time::SimTime,\n    tracing::enter_scope,\n};\n\n///\n/// The event set for a [`NetworkApplication`].\n///\n/// * This type is only available of DES is build with the `\"net\"` feature.\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\n#[derive(Debug)]\npub enum NetEvents {\n    MessageExitingConnection(MessageExitingConnection),\n    HandleMessageEvent(HandleMessageEvent),\n    ChannelUnbusyNotif(ChannelUnbusyNotif),\n    ModuleRestartEvent(ModuleRestartEvent),\n    #[cfg(feature = \"async\")]\n    AsyncWakeupEvent(AsyncWakeupEvent),\n}\n\nimpl\u003cA\u003e EventSet\u003cSim\u003cA\u003e\u003e for NetEvents\nwhere\n    A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n{\n    fn handle(self, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e) {\n        match self {\n            Self::MessageExitingConnection(event) =\u003e event.handle(rt),\n            Self::HandleMessageEvent(event) =\u003e event.handle(rt),\n            Self::ChannelUnbusyNotif(event) =\u003e event.handle(rt),\n            Self::ModuleRestartEvent(event) =\u003e event.handle(rt),\n            #[cfg(feature = \"async\")]\n            Self::AsyncWakeupEvent(event) =\u003e event.handle(rt),\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct MessageExitingConnection {\n    pub(crate) con: Connection, // exiting the following connecrtion\n    pub(crate) msg: Message,    // with this message\n}\n\nimpl MessageExitingConnection {\n    // This function executes an event with a sink not a runtime as an parameter.\n    // That allows for the executing of events not handles by the runtime itself\n    // aka. the calling with an abitrary event sink.\n    pub(crate) fn handle_with_sink(self, sink: \u0026mut impl EventSink\u003cNetEvents\u003e) {\n        let mut msg = self.msg;\n        msg.header.last_gate = Some(self.con.endpoint.clone());\n\n        // The connection that was exited.\n        // Current packet position: `cur.endpoint`\n        let mut cur = self.con;\n        while let Some(next) = cur.next_hop() {\n            enter_scope(cur.endpoint.owner().scope_token());\n\n            // Since a next gate exists log the current gate as\n            // transit complete. (do this before drop check to allow for better debugging at drop)\n            msg.header.last_gate = Some(next.endpoint.clone());\n\n            // Drop message is owner is not active, but notfiy since this is an irregularity.\n            if !cur.endpoint.owner().is_active() {\n                #[cfg(feature = \"tracing\")]\n                tracing::warn!(\n                    \"Gate '{}' dropped message [{}] since owner module {} is inactive\",\n                    cur.endpoint.name(),\n                    msg.str(),\n                    cur.endpoint.owner().path()\n                );\n\n                drop(msg);\n                return;\n            }\n\n            // Log the current transition to the internal log stream.\n            #[cfg(feature = \"tracing\")]\n            tracing::info!(\n                \"Gate '{}' forwarding message [{}] to next gate delayed: {}\",\n                cur.endpoint.name(),\n                msg.str(),\n                cur.channel().is_some()\n            );\n\n            if let Some(ch) = next.channel() {\n                ch.send_message(msg, next, sink);\n                return;\n            }\n\n            // No channel means next hop is on the same time slot,\n            // so continue.\n            cur = next;\n        }\n\n        // The loop has ended. This means we are at the end of a gate chain\n        // cur has not been checked for anything\n        enter_scope(cur.endpoint.owner().scope_token());\n\n        #[cfg(feature = \"tracing\")]\n        tracing::info!(\n            \"Gate '{}' forwarding message [{}] to module #{}\",\n            cur.endpoint.name(),\n            msg.str(),\n            cur.endpoint.owner().id()\n        );\n\n        let module = cur.endpoint.owner();\n        sink.add(\n            NetEvents::HandleMessageEvent(HandleMessageEvent {\n                module,\n                message: msg,\n            }),\n            SimTime::now(),\n        );\n    }\n}\n\nimpl MessageExitingConnection {\n    fn handle\u003cA\u003e(self, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e)\n    where\n        A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n    {\n        self.handle_with_sink(rt);\n    }\n}\n\n#[derive(Debug)]\npub struct HandleMessageEvent {\n    pub(crate) module: ModuleRef,\n    pub(crate) message: Message,\n}\n\nimpl HandleMessageEvent {\n    fn handle\u003cA\u003e(self, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e)\n    where\n        A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n    {\n        enter_scope(self.module.scope_token());\n\n        let mut message = self.message;\n        message.header.receiver_module_id = self.module.ctx.id;\n\n        #[cfg(feature = \"tracing\")]\n        tracing::info!(\"Handling message {:?}\", message.str());\n\n        let module = \u0026self.module;\n\n        module.activate();\n        module.handle_message(message);\n        module.deactivate(rt);\n\n        buf_process(module, rt);\n    }\n}\n\n#[derive(Debug)]\npub struct ModuleRestartEvent {\n    pub(crate) module: ModuleRef,\n}\n\nimpl ModuleRestartEvent {\n    fn handle\u003cA\u003e(self, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e)\n    where\n        A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n    {\n        enter_scope(self.module.scope_token());\n\n        #[cfg(feature = \"tracing\")]\n        tracing::info!(\"ModuleRestartEvent\");\n\n        let module = \u0026self.module;\n        module.activate();\n        module.module_restart();\n        module.deactivate(rt);\n\n        buf_process(module, rt);\n    }\n}\n\n#[cfg(feature = \"async\")]\n#[derive(Debug)]\npub struct AsyncWakeupEvent {\n    pub(crate) module: ModuleRef,\n}\n\n#[cfg(feature = \"async\")]\nimpl AsyncWakeupEvent {\n    fn handle\u003cA\u003e(self, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e)\n    where\n        A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n    {\n        enter_scope(self.module.scope_token());\n\n        #[cfg(feature = \"tracing\")]\n        tracing::info!(\"async wakeup\");\n\n        let module = \u0026self.module;\n        module.activate();\n        module.async_wakeup();\n        module.deactivate(rt);\n\n        buf_process(module, rt);\n    }\n}\n\n#[derive(Debug)]\npub struct ChannelUnbusyNotif {\n    pub(crate) channel: ChannelRef,\n}\n\nimpl ChannelUnbusyNotif {\n    fn handle\u003cA\u003e(self, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e)\n    where\n        A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n    {\n        self.channel.unbusy(rt);\n    }\n}\n\nimpl ModuleRef {\n    pub(crate) fn num_sim_start_stages(\u0026self) -\u003e usize {\n        self.processing.borrow().handler.num_sim_start_stages()\n    }\n\n    pub(crate) fn reset(\u0026self) {\n        let mut brw = self.processing.borrow_mut();\n        brw.handler.reset();\n    }\n\n    #[cfg(feature = \"async\")]\n    pub(crate) fn async_wakeup(\u0026self) {\n        if self.ctx.active.load(SeqCst) {\n            self.processing.borrow_mut().incoming_upstream(None);\n            if self.processing.borrow().handler.__indicate_async() {\n                self.processing.borrow().run_without_event();\n            }\n            self.processing.borrow_mut().incoming_downstream();\n        } else {\n            #[cfg(feature = \"tracing\")]\n            tracing::debug!(\"Ignoring message since module is inactive\");\n        }\n    }\n\n    pub(crate) fn module_restart(\u0026self) {\n        #[cfg(feature = \"tracing\")]\n        tracing::debug!(\"Restarting module\");\n        // restart the module itself.\n        self.ctx.active.store(true, SeqCst);\n\n        // Do sim start procedure\n        let stages = self.num_sim_start_stages();\n        for stage in 0..stages {\n            self.at_sim_start(stage);\n        }\n\n        #[cfg(feature = \"async\")]\n        self.finish_sim_start();\n    }\n\n    pub(crate) fn handle_message(\u0026self, msg: Message) {\n        if self.ctx.active.load(SeqCst) {\n            // (0) Run upstream plugins.\n            self.processing.borrow_mut().incoming(Some(msg));\n        } else {\n            #[cfg(feature = \"tracing\")]\n            tracing::debug!(\"Ignoring message since module is inactive\");\n        }\n    }\n\n    pub(crate) fn at_sim_start(\u0026self, stage: usize) {\n        self.processing.borrow_mut().incoming_upstream(None);\n        self.processing.borrow_mut().handler.at_sim_start(stage);\n        self.processing.borrow_mut().incoming_downstream();\n    }\n\n    #[cfg(feature = \"async\")]\n    pub(crate) fn finish_sim_start(\u0026self) {\n        if self.processing.borrow().handler.__indicate_async() {\n            self.processing.borrow_mut().incoming_upstream(None);\n            self.processing.borrow_mut().handler.finish_sim_start();\n            self.processing.borrow_mut().incoming_downstream();\n        }\n    }\n\n    pub(crate) fn at_sim_end(\u0026self) {\n        self.processing.borrow_mut().incoming_upstream(None);\n        self.processing.borrow_mut().handler.at_sim_end();\n        self.processing.borrow_mut().incoming_downstream();\n    }\n\n    #[cfg(feature = \"async\")]\n    pub(crate) fn finish_sim_end(\u0026self) {\n        if self.processing.borrow().handler.__indicate_async() {\n            self.processing.borrow_mut().incoming_upstream(None);\n            self.processing.borrow_mut().handler.finish_sim_end();\n            self.processing.borrow_mut().incoming_downstream();\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":7799},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":7799},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4209},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4209},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":4209},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4209},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6369},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":444},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":444},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":448},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":6704},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":3351},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":227},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":227},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":227},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":227},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":357},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":142},"fn_name":null}],"covered":107,"coverable":107},{"path":["/","Users","mk","Developer","rust","des","des","src","net","runtime","mod.rs"],"content":"use super::module::module_ctx_drop;\nuse super::Topology;\nuse super::{module::MOD_CTX, par::ParMap};\nuse crate::{\n    net::module::ModuleContext,\n    prelude::{Application, EventLifecycle, GateRef, Module, ModuleRef, ObjectPath, Runtime},\n    tracing::{enter_scope, leave_scope},\n};\nuse std::sync::{MutexGuard, TryLockError, Weak};\nuse std::{\n    fs, io, ops,\n    path::Path,\n    sync::{Arc, Mutex},\n};\n\nmod api;\npub use self::api::*;\n\nmod events;\npub(crate) use self::events::*;\n\nmod ctx;\npub(crate) use self::ctx::*;\n\nmod blocks;\npub use self::blocks::*;\n\nstatic GUARD: Mutex\u003c()\u003e = Mutex::new(());\n\n/// A networking simulation.\n///\n/// This type acts as both a builder for simulations, as well as the application object\n/// used in the [`Runtime`].\n///\n/// A networking simulation can internally contain an application `A`,\n/// that implements [`EventLifecycle`]. This type can be used attach\n/// custom global behaviour at the simulation launch and shutdown. The\n/// lifetime events will be applied after the simulation has started itself\n/// and before the simulation itself will shut down.\n///\n/// However networking simulations allways use events of type `NetEvents`,\n/// internally. These events do not interact with the inner application `A`.\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// # use des::net::HandlerFn;\n/// struct Inner;\n/// impl EventLifecycle\u003cSim\u003cInner\u003e\u003e for Inner {\n///     fn at_sim_start(rt: \u0026mut Runtime\u003cSim\u003cInner\u003e\u003e) {\n///         println!(\"Hello simulation\");\n///         /* Do something */\n///     }\n/// }\n///\n/// let mut sim = Sim::new(Inner);\n/// sim.node(\"alice\", HandlerFn::new(|msg| {\n///     /* Message processing */\n/// }));\n///\n/// let _ = Builder::new().build(sim).run(); // prints 'Hello simulation'\n/// ```\n#[derive(Debug)]\npub struct Sim\u003cA\u003e {\n    modules: ModuleTree,\n    globals: Arc\u003cGlobals\u003e,\n    /// A inner field of a network simulation that can be used to attach\n    /// custom lifetime handlers to a simulation\n    pub inner: A,\n\n    #[allow(unused)]\n    guard: SimStaticsGuard,\n}\n\n#[derive(Debug)]\nstruct SimStaticsGuard {\n    #[allow(unused)]\n    guard: MutexGuard\u003c'static, ()\u003e,\n}\n\nimpl SimStaticsGuard {\n    fn new(globals: Weak\u003cGlobals\u003e) -\u003e Self {\n        let guard = GUARD.try_lock();\n        let guard = match guard {\n            Ok(guard) =\u003e guard,\n            Err(e) =\u003e match e {\n                TryLockError::WouldBlock =\u003e GUARD.lock().unwrap_or_else(|e| {\n                    eprintln!(\"net-sim lock poisnoed: rebuilding lock\");\n                    e.into_inner()\n                }),\n                TryLockError::Poisoned(poisoned) =\u003e {\n                    eprintln!(\"net-sim lock poisoned: rebuilding lock\");\n                    poisoned.into_inner()\n                }\n            },\n        };\n\n        buf_init(globals);\n        Self { guard }\n    }\n}\n\nimpl Drop for SimStaticsGuard {\n    fn drop(\u0026mut self) {\n        buf_drop();\n        module_ctx_drop();\n    }\n}\n\n/// A helper to manage a scoped part of a networking simulation,\n/// exclusivly used when building the simulation.\n///\n/// This type is helpful in combination with the trait [`ModuleBlock`]\n/// to create reproducable blocks of modules at different\n/// locations within the simulation.\n///\n/// This builder acts comparable to [`Sim`], but with an automatically\n/// applied path prefix, the `scope`.\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// # use des::net::{ModuleBlock, ModuleFn, HandlerFn};\n/// struct LAN {}\n/// impl ModuleBlock for LAN {\n///     fn build\u003cA\u003e(self, mut sim: ScopedSim\u003c'_, A\u003e) {\n///         sim.root(HandlerFn::new(|_| {}));\n///         let gates = sim.gates(\"\", \"port\", 5);\n///         for i in 0..5 {\n///             let host = format!(\"host-{i}\");\n///             sim.node(\u0026host, ModuleFn::new(\n///                 /* ... */\n///                 # || 123, |_, _| {}    \n///             ));\n///             let gate = sim.gate(\u0026host, \"port\");\n///             gate.connect(gates[i].clone(), None);\n///         }\n///     }\n/// }\n///\n/// let mut sim = Sim::new(());\n/// sim.node(\"google\", LAN {});\n/// sim.node(\"microsoft\", LAN {});\n/// sim.node(\"aws\", HandlerFn::new(|_| {}));\n/// sim.node(\"aws.us-east\", LAN {});\n///\n/// let _ = Builder::new().build(sim).run();\n/// ```\n#[derive(Debug)]\npub struct ScopedSim\u003c'a, A\u003e {\n    pub(crate) base: \u0026'a mut Sim\u003cA\u003e,\n    pub(crate) scope: ObjectPath,\n}\n\nimpl\u003cA\u003e Sim\u003cA\u003e {\n    #[inline]\n    pub(crate) fn modules(\u0026self) -\u003e \u0026ModuleTree {\n        \u0026self.modules\n    }\n\n    #[inline]\n    pub(crate) fn modules_mut(\u0026mut self) -\u003e \u0026mut ModuleTree {\n        \u0026mut self.modules\n    }\n\n    /// Creates a new network simulation, with an inner application `A`.\n    ///\n    /// This allready binds the simulation globals to this instance.\n    pub fn new(inner: A) -\u003e Self {\n        let globals = Arc::new(Globals::default());\n        let guard = SimStaticsGuard::new(Arc::downgrade(\u0026globals));\n        Self {\n            guard,\n            modules: ModuleTree::default(),\n            globals,\n            inner,\n        }\n    }\n\n    /// Includes raw parameter defintions in the simulation.\n    ///\n    /// If a parsing error is encountered, it will be silently\n    /// ignored. Only successful parses will be applied to the\n    /// module parameters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::net::ModuleFn;\n    /// use std::net::IpAddr;\n    ///\n    /// let mut sim = Sim::new(());\n    /// sim.include_par(\"alice.addr = 198.2.1.45\\nalice.role = host\");\n    /// sim.node(\"alice\", ModuleFn::new(\n    ///     || {\n    ///         let addr = par(\"addr\").unwrap().parse::\u003cIpAddr\u003e().unwrap();\n    ///         let role = par(\"role\").unwrap().to_string();\n    ///     },\n    ///     |_, _| {}\n    /// ));\n    /// /*\n    ///     Note that the order of the previous operations does not matter,\n    ///     since the setup code will only be executed when the simulation\n    ///     is startin, so on `Runtime::run`.\n    /// */\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    pub fn include_par(\u0026mut self, raw: \u0026str) {\n        self.globals.parameters.build(raw);\n    }\n\n    /// Tries to read and include parameters from a file into the simulation.\n    ///\n    /// See [`Sim::include_par`] for more infomation.\n    ///\n    /// # Errors\n    ///\n    /// This function may fail if the reading from a file fails.\n    pub fn include_par_file(\u0026mut self, path: impl AsRef\u003cPath\u003e) -\u003e io::Result\u003c()\u003e {\n        self.include_par(\u0026fs::read_to_string(path)?);\n        Ok(())\n    }\n\n    /// Returns a handle to the simulation globals.\n    pub fn globals(\u0026self) -\u003e Arc\u003cGlobals\u003e {\n        self.globals.clone()\n    }\n\n    /// Creates a new module block within the simulation.\n    ///\n    /// A \"node\" is a block of modules at a given `path`. This may include:\n    /// - no modules at all\n    /// - just one module exactly at the given `path`\n    /// - multiple modules, one at `path`, the others as direct or indirect children of this root module.\n    ///\n    /// The provided parameter `module_block` must be some type that implements the trait `ModuleBlock`.\n    /// This trait can be used to create all components of the required block, within the local scope\n    /// defined by `path`. Modules themself also implement `ModuleBlock` so modules themselfs can be\n    /// build into a block of size 1.\n    ///\n    /// Custom implementations of `ModuleBlock` can not only create modules based\n    /// on config data, but also gates and connections between these modules. Note\n    /// that `ModuleBlock::build` is confined to the scope defined by `path`, since\n    /// it uses a [`ScopedSim`] builder.\n    ///\n    /// See [`ScopedSim`] for more information.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// struct MyModule {\n    ///     state: i32,\n    /// }\n    /// impl Module for MyModule {\n    ///     fn handle_message(\u0026mut self, msg: Message) {\n    ///         /* Do something */\n    ///     }\n    /// }\n    ///\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", MyModule { state: 42 });\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    pub fn node(\u0026mut self, path: impl Into\u003cObjectPath\u003e, module_block: impl ModuleBlock) {\n        let scoped = ScopedSim::new(self, path.into());\n        module_block.build(scoped);\n    }\n\n    /// Retrieves a module by reference from the simulation.\n    pub fn get(\u0026self, path: \u0026ObjectPath) -\u003e Option\u003cModuleRef\u003e {\n        self.modules.get(path)\n    }\n\n    /// Creates a gate on a allready created module.\n    ///\n    /// The module will be defined `path` and the gate will be named `gate`.\n    /// Should such a gate allready exist, the allready existing gate will be\n    /// returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # struct SomeModule;\n    /// # impl Module for SomeModule {}\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", SomeModule);\n    /// sim.node(\"bob\", SomeModule);\n    ///\n    /// let a = sim.gate(\"alice\", \"in\");\n    /// let b = sim.gate(\"bob\", \"out\");\n    ///\n    /// b.connect(a, None);\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// This function panic if node modules exists at `path`.\n    pub fn gate(\u0026mut self, path: impl Into\u003cObjectPath\u003e, gate: \u0026str) -\u003e GateRef {\n        let path = path.into();\n        let Some(module) = self.get(\u0026path) else {\n            panic!(\"cannot create gate '{path}.{gate}', because node '{path}' does not exist\")\n        };\n        if let Some(gate) = module.gate(gate, 0) {\n            gate\n        } else {\n            module.create_gate(gate)\n        }\n    }\n\n    /// Creates a clust of gate gate on a allready created module.\n    ///\n    /// The module will be defined `path` and the gate cluster will be named `gate`.\n    /// Should such a gate cluster allready exist, the allready existing gate will be\n    /// returned.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if either, not module exists at `path`, or\n    /// some parts of the gate cluster allready exist, but others do not.\n    pub fn gates(\u0026mut self, path: impl Into\u003cObjectPath\u003e, gate: \u0026str, size: usize) -\u003e Vec\u003cGateRef\u003e {\n        let path = path.into();\n        let Some(module) = self.get(\u0026path) else {\n            panic!(\"cannot create gate '{path}.{gate}', because node '{path}' does not exist\")\n        };\n        let mut gates = Vec::new();\n        for k in 0..size {\n            if let Some(gate) = module.gate(gate, k) {\n                gates.push(gate);\n            } else {\n                break;\n            }\n        }\n        if gates.len() == size {\n            gates\n        } else {\n            assert!(\n                gates.is_empty(),\n                \"cannot create gate cluster from partial gate cluster\"\n            );\n            module.create_gate_cluster(gate, size)\n        }\n    }\n\n    fn raw(\u0026mut self, path: ObjectPath, module: impl Module) -\u003e ModuleRef {\n        // Check dup\n        assert!(\n            self.modules.get(\u0026path).is_none(),\n            \"cannot create node '{path}', node allready exists\"\n        );\n\n        // Check node path location\n        let ctx = if let Some(parent) = path.nonzero_parent() {\n            // (a) Check that the parent exists\n            let Some(parent) = self.get(\u0026parent) else {\n                panic!(\"cannot create node '{path}', since parent node '{parent}' is required, but does not exist\");\n            };\n\n            ModuleContext::child_of(path.name(), parent)\n        } else {\n            ModuleContext::standalone(path)\n        };\n        ctx.activate();\n\n        let pe = module.to_processing_chain();\n        ctx.upgrade_dummy(pe);\n\n        // TODO: deactivate module\n        self.modules.add(ctx.clone());\n        ctx\n    }\n}\n\nimpl\u003cA\u003e Drop for Sim\u003cA\u003e {\n    fn drop(\u0026mut self) {\n        // SAFETY: Remove ctxs, since the next use of a `Sim` may occur on\n        // a different thread\n        unsafe {\n            MOD_CTX.reset(None);\n        }\n    }\n}\n\nimpl\u003c'a, A\u003e ScopedSim\u003c'a, A\u003e {\n    pub(crate) fn new(base: \u0026'a mut Sim\u003cA\u003e, scope: ObjectPath) -\u003e Self {\n        Self { base, scope }\n    }\n\n    #[allow(unused)]\n    pub(crate) fn subscope(\u0026mut self, path: impl AsRef\u003cstr\u003e) -\u003e ScopedSim\u003c'_, A\u003e {\n        ScopedSim {\n            base: \u0026mut *self.base,\n            scope: self.scope.appended(path),\n        }\n    }\n\n    /// The current scope from an absoute prespective.\n    #[must_use]\n    pub fn scope(\u0026self) -\u003e \u0026ObjectPath {\n        \u0026self.scope\n    }\n\n    /// The inner application of the simulation `Sim\u003cA\u003e`.\n    #[must_use]\n    pub fn inner(\u0026self) -\u003e \u0026A {\n        \u0026self.base.inner\n    }\n\n    /// Sets the current scope module.\n    ///\n    /// This call is equivalent to `sim.node(scope, \u003cmodule_block\u003e)` on [`Sim`].\n    pub fn root(\u0026mut self, module_block: impl Module) {\n        self.base.raw(self.scope.clone(), module_block);\n    }\n\n    /// Creates a module block within the current scope.\n    ///\n    /// See [`Sim::node`] for more information.\n    pub fn node(\u0026mut self, path: impl Into\u003cObjectPath\u003e, module_block: impl ModuleBlock) {\n        self.base\n            .node(self.scope.appended(path.into().as_str()), module_block);\n    }\n\n    /// Creates a gate on an existing node within the current scope.\n    ///\n    /// See [`Sim::gate`] for more information.\n    pub fn gate(\u0026mut self, path: impl Into\u003cObjectPath\u003e, gate: \u0026str) -\u003e GateRef {\n        self.base.gate(self.scope.appended(path.into()), gate)\n    }\n\n    /// Creates a cluster gate on an existing node within the current scope.\n    ///\n    /// See [`Sim::gates`] for more information.\n    pub fn gates(\u0026mut self, path: impl Into\u003cObjectPath\u003e, gate: \u0026str, size: usize) -\u003e Vec\u003cGateRef\u003e {\n        self.base\n            .gates(self.scope.appended(path.into()), gate, size)\n    }\n}\n\nimpl\u003cA\u003e Application for Sim\u003cA\u003e\nwhere\n    A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n{\n    type EventSet = NetEvents;\n    type Lifecycle = SimLifecycle;\n}\n\n#[doc(hidden)]\n#[derive(Debug)]\npub struct SimLifecycle;\nimpl\u003cA\u003e EventLifecycle\u003cSim\u003cA\u003e\u003e for SimLifecycle\nwhere\n    A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n{\n    fn at_sim_start(rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e) {\n        rt.app\n            .globals\n            .topology\n            .lock()\n            .expect(\"could not get topology lock\")\n            .build(\u0026rt.app.modules);\n\n        // (2) Run network-node sim_starting stages\n        // - inline this to ensure this is run before any possible events\n\n        // This is a explicit for loop to prevent borrow rt only in the inner block\n        // allowing preemtive dropping of 'module' so that rt can be used in\n        // 'module_handle_jobs'.\n        let max_stage = rt\n            .app\n            .modules\n            .iter()\n            .fold(1, |acc, module| acc.max(module.num_sim_start_stages()));\n\n        // (2.1) Call the stages in order, parallel over all modules\n        for stage in 0..max_stage {\n            // Direct indexing since rt must be borrowed mutably in handle_buffers.\n            for module in rt.app.modules.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e() {\n                // Use cloned handles to appease the brwchk\n                if stage \u003c module.num_sim_start_stages() {\n                    module.activate();\n\n                    #[cfg(feature = \"tracing\")]\n                    tracing::info!(\"Calling at_sim_start({}).\", stage);\n\n                    module.at_sim_start(stage);\n                    module.deactivate(rt);\n\n                    super::buf_process(\u0026module, rt);\n                }\n            }\n        }\n\n        // (2.2) Ensure all sim_start stages have finished, in an async context\n        #[cfg(feature = \"async\")]\n        {\n            for module in rt.app.modules.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e() {\n                module.activate();\n                module.finish_sim_start();\n                module.deactivate(rt);\n\n                super::buf_process(\u0026module, rt);\n            }\n        }\n\n        leave_scope();\n\n        A::at_sim_start(rt);\n    }\n\n    fn at_sim_end(rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e) {\n        A::at_sim_end(rt);\n\n        for module in rt.app.modules.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e() {\n            enter_scope(module.scope_token());\n\n            #[cfg(feature = \"tracing\")]\n            tracing::info!(\"Calling 'at_sim_end'\");\n            module.activate();\n            module.at_sim_end();\n            module.deactivate(rt);\n\n            // NOTE: no buf_process since no furthe events will be processed.\n        }\n\n        #[cfg(feature = \"async\")]\n        {\n            // Ensure all sim_start stages have finished\n            for module in rt.app.modules.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e() {\n                // enter_scope(module.scope_token());\n\n                module.activate();\n                module.finish_sim_end();\n                module.deactivate(rt);\n            }\n        }\n\n        leave_scope();\n    }\n}\n\n///\n/// The global parameters about a [`Sim`] that are publicly\n/// exposed.\n///\n#[derive(Debug)]\npub struct Globals {\n    ///\n    /// The current state of the parameter tree, derived from *.par\n    /// files and parameter changes at runtime.\n    ///\n    pub parameters: Arc\u003cParMap\u003e,\n\n    ///\n    /// The topology of the network from a module viewpoint.\n    ///\n    pub topology: Mutex\u003cTopology\u003e,\n}\n\nimpl Default for Globals {\n    fn default() -\u003e Self {\n        Self {\n            parameters: Arc::new(ParMap::default()),\n            topology: Mutex::new(Topology::new()),\n        }\n    }\n}\n\n#[derive(Debug, Default)]\npub(crate) struct ModuleTree {\n    modules: Vec\u003cModuleRef\u003e,\n}\n\nimpl ModuleTree {\n    pub(crate) fn get(\u0026self, path: \u0026ObjectPath) -\u003e Option\u003cModuleRef\u003e {\n        self.modules\n            .iter()\n            .find(|module| module.path == *path)\n            .cloned()\n    }\n\n    pub(crate) fn add(\u0026mut self, module: ModuleRef) {\n        if let Some(parent) = module.path.parent() {\n            if parent.is_root() {\n                // root either non existen or at index 0\n                self.modules.push(module);\n            } else {\n                let parent_depth = parent.len();\n\n                // search for parent insert at last possible position\n                let Some(mut pos) = self.modules.iter().rposition(|m| m.path == parent) else {\n                    panic!(\"cannot create node '{}', since parent node '{parent}' is required, but does not exist\", module.path)\n                };\n                pos += 1;\n\n                // (iter as long as we stay at path lengths \u003e parent)\n                while pos \u003c self.modules.len() \u0026\u0026 self.modules[pos].path.len() \u003e parent_depth {\n                    pos += 1;\n                }\n                self.modules.insert(pos, module);\n            }\n        } else {\n            // No parent\n            self.modules.push(module);\n        }\n    }\n}\n\nimpl ops::Deref for ModuleTree {\n    type Target = [ModuleRef];\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.modules\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn module_tree() {\n        let mut tree = ModuleTree::default();\n        fn module(path: \u0026str) -\u003e ModuleRef {\n            ModuleContext::standalone(path.into())\n        }\n\n        tree.add(module(\"alice\"));\n        tree.add(module(\"alice.alicent\"));\n        tree.add(module(\"alice.john\"));\n        tree.add(module(\"alice.john.previous\"));\n        tree.add(module(\"bob\"));\n        tree.add(module(\"eve\"));\n        tree.add(module(\"eve.trevor\"));\n        tree.add(module(\"eve.trevor.list\"));\n        tree.add(module(\"eve.mark\"));\n\n        assert_eq!(\n            tree.iter().map(|v| v.path.as_str()).collect::\u003cVec\u003c_\u003e\u003e(),\n            [\n                \"alice\",\n                \"alice.alicent\",\n                \"alice.john\",\n                \"alice.john.previous\",\n                \"bob\",\n                \"eve\",\n                \"eve.trevor\",\n                \"eve.trevor.list\",\n                \"eve.mark\"\n            ]\n        );\n    }\n}\n","traces":[{"line":83,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":356},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":166},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":195},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":195},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":195},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":195},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":195},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":195},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":403},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":203},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":555},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":386},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":434},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":600},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":167},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":167},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":597},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":597},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":165},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":320},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":320},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":873},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":464},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":1010},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":1010},"fn_name":null}],"covered":132,"coverable":146},{"path":["/","Users","mk","Developer","rust","des","des","src","net","topology.rs"],"content":"use super::{globals, ObjectPath};\nuse crate::{net::module::ModuleRef, prelude::GateRef};\nuse fxhash::{FxBuildHasher, FxHashMap};\n\n///\n/// A mapping of all connections in a module connection graph.\n///\n#[derive(Debug, Clone)]\npub struct Topology {\n    nodes: Vec\u003cTopoNode\u003e,\n    edges: Vec\u003cVec\u003cTopoEdge\u003e\u003e,\n}\n\n///\n/// A node in the module connection graph, representing a module and its\n/// connection state.\n///\n#[derive(Debug, Clone)]\npub struct TopoNode {\n    /// A reference to the module itself, including its custom state.\n    pub module: ModuleRef,\n    /// The number of connections. (not nessecarily the number of gates)\n    pub degree: usize,\n    /// An indicate whether the module is at all connected to the rest of of the network.\n    pub alive: bool,\n}\n\n///\n/// A connection in the module connection graph.\n///\n#[derive(Debug, Clone)]\n\npub struct TopoEdge {\n    ///\n    pub src: (GateRef, usize), //\n    ///\n    pub dst: (GateRef, usize),\n    ///\n    pub cost: f64,\n}\n\nimpl Topology {\n    /// Creates a new empty instance.\n    #[must_use]\n    pub const fn new() -\u003e Topology {\n        Self {\n            nodes: Vec::new(),\n            edges: Vec::new(),\n        }\n    }\n\n    /// Gets the current topology.\n    ///\n    /// # Panics\n    ///\n    /// Panics when called from outside a module context,\n    /// or when globals dont exist.\n    #[must_use]\n    pub fn current() -\u003e Topology {\n        globals()\n            .topology\n            .lock()\n            .expect(\"could not retrive current topology: simulation paniced and poisoned locks\")\n            .clone()\n    }\n\n    /// All nodes if the current topology.\n    #[must_use]\n    pub fn nodes(\u0026self) -\u003e \u0026[TopoNode] {\n        \u0026self.nodes\n    }\n\n    /// An iterator over all edges in the entries network, annotated with the\n    /// node-id of the starting node.\n    #[must_use]\n    pub fn edges(\u0026self) -\u003e usize {\n        self.edges\n            .iter()\n            .enumerate()\n            .flat_map(|(i, edges)| edges.iter().map(move |e| (i, e)))\n            .count()\n            / 2\n    }\n\n    /// All outgoing edges associated with a single\n    /// module.\n    #[must_use]\n    pub fn edges_for(\u0026self, i: usize) -\u003e \u0026[TopoEdge] {\n        \u0026self.edges[i]\n    }\n\n    /// Adds the given modules and their connections to the connection graph.\n    ///\n    /// Note that this only adds connections withing the new conenction set,\n    /// or from the new set to the old set.\n    /// To add connections from the old set to the new one, recreate\n    /// the topology from the ground up using the `ModuleRef` stored in the\n    /// node information.\n    #[allow(clippy::missing_panics_doc)]\n    pub fn build(\u0026mut self, modules: \u0026[ModuleRef]) {\n        for module in modules {\n            self.nodes.push(TopoNode {\n                module: module.clone(),\n                degree: 0,\n                alive: false,\n            });\n            self.edges.push(Vec::new());\n        }\n\n        for module in modules {\n            let gates = module.ctx.gates();\n            'outer: for gate in gates {\n                let mut cost = 0.0;\n                let mut dst = gate.clone();\n\n                let Some(iter) = gate.path_iter() else {\n                    // its a transit gate\n                    continue;\n                };\n                for con in iter.take(16) {\n                    if con.channel().is_some() {\n                        cost += 1.0;\n                    }\n\n                    let transit_id = con.endpoint.owner().id();\n                    let Some(transit) = self\n                        .nodes\n                        .iter_mut()\n                        .find(|k| k.module.ctx.id() == transit_id)\n                    else {\n                        break 'outer;\n                    };\n                    transit.alive |= true;\n\n                    dst = con.endpoint.clone();\n                }\n\n                let src_id = gate.owner().id();\n                let dst_id = dst.owner().id();\n                let (src_idx, src_node) = self\n                    .nodes\n                    .iter_mut()\n                    .enumerate()\n                    .find(|(_, m)| m.module.ctx.id() == src_id)\n                    .expect(\"failed to generate topology: corrupted module tree\");\n                src_node.degree += 1;\n                src_node.alive |= true;\n\n                let (dst_idx, dst_node) = self\n                    .nodes\n                    .iter_mut()\n                    .enumerate()\n                    .find(|(_, m)| m.module.ctx.id() == dst_id)\n                    .expect(\"failed to generate topology: corrupted module tree\");\n                dst_node.degree += 1;\n                dst_node.alive |= true;\n\n                let edge = TopoEdge {\n                    src: (gate, src_idx),\n                    dst: (dst, dst_idx),\n                    cost,\n                };\n\n                self.edges[src_idx].push(edge);\n            }\n        }\n\n        // Divide bc each connection was counted twice\n        self.nodes.iter_mut().for_each(|node| node.degree /= 2);\n    }\n\n    ///\n    /// Filters out nodes that do not comply with the given predicate.\n    ///\n    /// Note that this may change node-ids so all previouisly\n    /// compiled information that relies on node-ids is to be considered\n    /// invalid.\n    ///\n    pub fn filter_nodes\u003cP\u003e(\u0026mut self, predicate: P)\n    where\n        P: FnMut(\u0026TopoNode) -\u003e bool,\n    {\n        let keeps = self.nodes.iter().map(predicate).collect::\u003cVec\u003c_\u003e\u003e();\n        let n = keeps.len();\n\n        for (i, \u0026keep) in keeps.iter().enumerate() {\n            if keep {\n                // Do nothing this node will be kept so no links must be pruned\n            } else {\n                // Fix degrees\n\n                for edge in self.edges[i].drain(..) {\n                    self.nodes[edge.src.1].degree = self.nodes[edge.src.1].degree.saturating_sub(1);\n                    self.nodes[edge.dst.1].degree = self.nodes[edge.dst.1].degree.saturating_sub(1);\n                }\n\n                for j in 0..n {\n                    if j == i {\n                        continue;\n                    }\n                    self.edges[j].retain(|edge| edge.dst.1 != i);\n                }\n                debug_assert_eq!(self.nodes[i].degree, 0);\n            }\n        }\n\n        // Remove elements\n        let mut ptr = 0;\n        let mut mapping = (0..n).collect::\u003cVec\u003c_\u003e\u003e();\n        for (i, keep) in keeps.into_iter().enumerate() {\n            if keep {\n                mapping[i] = ptr;\n                ptr += 1;\n            } else {\n                self.nodes.remove(ptr);\n                self.edges.remove(ptr);\n                mapping[i] = usize::MAX;\n            }\n        }\n\n        // Update edge ids\n        for edges in \u0026mut self.edges {\n            for edge in edges {\n                edge.src.1 = mapping[edge.src.1];\n                edge.dst.1 = mapping[edge.dst.1];\n            }\n        }\n\n        assert_eq!(self.nodes.len(), self.edges.len())\n    }\n\n    ///\n    /// Filters out edges that do not comply with the given predicate.\n    ///\n    /// Note that this does NOT change node-ids, but may change the\n    /// alive-flag on nodes, as well as in-/outcounts.\n    ///\n    pub fn filter_edges\u003cP\u003e(\u0026mut self, mut predicate: P)\n    where\n        P: FnMut(\u0026TopoEdge) -\u003e bool,\n    {\n        for i in 0..self.edges.len() {\n            let mut j = 0;\n            while j \u003c self.edges[i].len() {\n                let keep = predicate(\u0026self.edges[i][j]);\n                if keep {\n                    j += 1;\n                } else {\n                    self.edges[i].remove(j);\n                    self.nodes[i].degree -= 1;\n                    self.nodes[self.edges[i][j].dst.1].degree -= 1;\n                }\n            }\n        }\n\n        for node in \u0026mut self.nodes {\n            if node.degree == 0 {\n                node.alive = false;\n            }\n        }\n    }\n\n    ///\n    /// Changes the costs of edges according to a given mapping.\n    ///\n    pub fn map_costs\u003cM\u003e(\u0026mut self, mut mapping: M)\n    where\n        M: FnMut(\u0026TopoEdge) -\u003e f64,\n    {\n        for edges in \u0026mut self.edges {\n            for edge in edges {\n                edge.cost = mapping(edge);\n            }\n        }\n    }\n\n    /// Generates a disjktra tree\n    ///\n    /// # Panics\n    ///\n    /// Panics when the specified nodes does not exist.\n    #[allow(clippy::needless_pass_by_value)]\n    #[must_use]\n    pub fn dijkstra(\u0026self, node: ObjectPath) -\u003e FxHashMap\u003cObjectPath, GateRef\u003e {\n        struct QE {\n            node: usize,\n            distance: usize,\n            next_hop: Option\u003cGateRef\u003e,\n        }\n\n        let mut visited = Vec::new();\n        let mut queue = Vec::new();\n        queue.push(QE {\n            node: self\n                .nodes\n                .iter()\n                .position(|n| n.module.path() == node)\n                .expect(\"no such node exists\"),\n            distance: 0,\n            next_hop: None,\n        });\n\n        let mut mapping = FxHashMap::with_hasher(FxBuildHasher::default());\n        while let Some(cur) = queue.pop() {\n            if visited.contains(\u0026cur.node) {\n                continue;\n            }\n\n            // travel along the edges\n            visited.push(cur.node);\n            if let Some(ref nh) = cur.next_hop {\n                mapping.insert(self.nodes[cur.node].module.path(), nh.clone());\n            }\n\n            for edge in self.edges_for(cur.node) {\n                if !visited.contains(\u0026edge.dst.1) {\n                    queue.push(QE {\n                        node: edge.dst.1,\n                        distance: cur.distance + 1,\n                        next_hop: Some(cur.next_hop.clone().unwrap_or(edge.src.0.clone())),\n                    });\n                }\n            }\n\n            // rev\n            queue.sort_by(|l, r| r.distance.cmp(\u0026l.distance));\n        }\n\n        mapping\n    }\n\n    /// Creates a .dot output for visualizing the module graph.\n    #[must_use]\n    pub fn as_dot(\u0026self) -\u003e String {\n        let mut output = String::from(\"digraph D {{\\n\");\n\n        for def in \u0026self.nodes {\n            if def.degree \u003e 0 {\n                output.push_str(\u0026format!(\"    \\\"{}\\\" [shape=box]\\n\", def.module.as_str()));\n            }\n        }\n\n        output.push('\\n');\n\n        for (src, edges) in self.edges.iter().enumerate() {\n            let from_node = self.nodes[src].module.as_str();\n            for TopoEdge { src, dst, cost } in edges {\n                let to_node = self.nodes[src.1].module.as_str();\n                let label = if *cost == 0.0 {\n                    String::new()\n                } else {\n                    format!(\"label=\\\"{cost}\\\"\")\n                };\n\n                output.push_str(\u0026format!(\n                    \"    \\\"{}\\\" - \\\"{}\\\" [ headlabel=\\\"{}\\\" {} taillabel=\\\"{}\\\" ]\\n\",\n                    from_node,\n                    to_node,\n                    dst.0.name(),\n                    label,\n                    src.0.name(),\n                ));\n            }\n        }\n\n        output.push_str(\"\\n}}\");\n        output\n    }\n\n    ///\n    /// Writes the dot output to a *.dot file\n    /// and converts this file into a svg.\n    ///\n    /// # Note\n    ///\n    /// Be aware that this command relies on the 'dot' command line\n    /// programm to generate the svg.\n    ///\n    /// # Errors\n    ///\n    /// This operation will return an IO Error if\n    /// either the file cannot be created or the operations\n    /// using the dot engine wont work.\n    ///\n    pub fn write_to_svg(\u0026self, path: \u0026str) -\u003e std::io::Result\u003c()\u003e {\n        use std::fs::File;\n        use std::io::Write;\n        use std::process::Command;\n        let dot_output = self.as_dot();\n        let mut file = File::create(format!(\"{path}.dot\"))?;\n        write!(file, \"{dot_output}\")?;\n\n        let svg_output = Command::new(\"dot\")\n            .arg(\"-Tsvg\")\n            .arg(format!(\"{path}.dot\"))\n            .output()?;\n\n        let mut file = File::create(format!(\"{path}.svg\"))?;\n        write!(file, \"{}\", String::from_utf8_lossy(\u0026svg_output.stdout))?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":820},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":603},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":427},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":152},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":337},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":559},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":559},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":555},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":133,"coverable":142},{"path":["/","Users","mk","Developer","rust","des","des","src","prelude.rs"],"content":"//!\n//! Convenience re-export of common members.\n//!\n\n//\n// # Generic core exports\n//\n\npub use crate::runtime::Builder;\npub use crate::runtime::Runtime;\npub use crate::runtime::RuntimeResult;\n\npub use crate::time::Duration;\npub use crate::time::SimTime;\n\npub use crate::runtime::Application;\npub use crate::runtime::Event;\npub use crate::runtime::EventLifecycle;\npub use crate::runtime::EventSet;\n\npub use crate::runtime::random;\npub use crate::runtime::sample;\n\n//\n// # feature = \"net\"\n//\n\ncfg_net! {\n    pub use crate::net::message::CustomSizeBody;\n    pub use crate::net::message::Message;\n    pub use crate::net::message::MessageBody;\n    pub use crate::net::message::MessageId;\n    pub use crate::net::message::MessageKind;\n    pub use crate::net::message::MessageHeader;\n\n    pub use crate::net::message::{send, send_in, send_at, schedule_in, schedule_at};\n\n    pub use crate::net::Sim;\n    pub use crate::net::ScopedSim;\n    pub use crate::net::Globals;\n\n    pub use crate::net::channel::Channel;\n    pub use crate::net::channel::ChannelMetrics;\n    pub use crate::net::channel::ChannelRef;\n    pub use crate::net::channel::ChannelDropBehaviour;\n\n    pub use crate::net::gate::Gate;\n    pub use crate::net::gate::GateRef;\n\n    pub use crate::net::module::Module;\n    pub use crate::net::module::ModuleId;\n    pub use crate::net::module::ModuleRef;\n    pub use crate::net::module::ModuleReferencingError;\n\n    pub use crate::net::module::{\n        current, shutdow_and_restart_at, shutdow_and_restart_in, shutdown\n    };\n    pub use crate::net::{par, par_for};\n\n    pub use crate::net::ObjectPath;\n    pub use crate::net::ParMap;\n\n    pub use crate::net::TopoEdge;\n    pub use crate::net::TopoNode;\n    pub use crate::net::Topology;\n\n    pub use crate::net::processing::ProcessingElement;\n\n    cfg_ndl! {\n        pub use crate::ndl::Registry;\n        pub use crate::ndl::RegistryCreatable;\n    }\n\n    cfg_async! {\n        pub use crate::net::module::AsyncModule;\n    }\n\n    pub use std::net::IpAddr;\n    pub use std::net::Ipv4Addr;\n    pub use std::net::Ipv6Addr;\n    pub use std::net::SocketAddr;\n    pub use std::net::SocketAddrV4;\n    pub use std::net::SocketAddrV6;\n\n    //\n    // Export the derives if net\n    //\n\n    pub use des_macros::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","bench.rs"],"content":"use std::{\n    io::Write,\n    path::PathBuf,\n    sync::Arc,\n    time::{Duration, Instant, SystemTime},\n};\n\nuse sysinfo::{CpuExt, SystemExt};\n\nuse super::{FT_ASYNC, FT_CQUEUE, FT_INTERNAL_METRICS, FT_NET};\n\n/// A run profiler\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Profiler {\n    /// The target executable.\n    pub target: PathBuf,\n    exec: String,\n\n    /// Whether the target is in release mode or not.\n    pub target_is_release: bool,\n    /// The hardware enviroment of the execution.\n    pub env: ProfilerEnv,\n\n    /// The time point where the simulation started.\n    pub simulation_start: SystemTime,\n\n    time_start: Instant,\n    /// The duration of the simulation.\n    pub duration: Duration,\n\n    /// The number of events that where executed.\n    pub event_count: usize,\n    /// The active features.\n    pub features: Vec\u003cString\u003e,\n}\n\nimpl Profiler {\n    /// Returns the ident str for the profiler\n    #[allow(unused)]\n    pub(super) fn ident(\u0026self) -\u003e String {\n        format!(\n            \"{}--{}-{}-{}\",\n            self.exec, self.env.arch, self.env.os_family, self.env.os\n        )\n    }\n\n    /// Starts the profile.\n    pub(super) fn start(\u0026mut self) {\n        self.time_start = Instant::now();\n    }\n\n    /// Finishes the profile.\n    pub(super) fn finish(\u0026mut self, event_count: usize) {\n        self.event_count = event_count;\n        let now = Instant::now();\n        self.duration = now - self.time_start;\n    }\n}\n\n#[cfg(debug_assertions)]\nfn is_release() -\u003e bool {\n    false\n}\n\n#[cfg(not(debug_assertions))]\nfn is_release() -\u003e bool {\n    true\n}\n\nimpl Default for Profiler {\n    fn default() -\u003e Self {\n        let target = std::env::current_exe().unwrap_or_default();\n        let target_is_release = is_release();\n\n        let mut exec = target\n            .file_name()\n            .expect(\"Failed to find binary\")\n            .to_string_lossy()\n            .to_string();\n        if target_is_release {\n            exec.push_str(\"-release\");\n        }\n\n        let mut features = Vec::with_capacity(5);\n        if FT_CQUEUE {\n            features.push(\"cqueue\".into());\n        }\n        if FT_NET {\n            features.push(\"net\".into());\n        }\n        if FT_ASYNC {\n            features.push(\"async\".into());\n        }\n        if FT_INTERNAL_METRICS {\n            features.push(\"metrics\".into());\n        }\n\n        Self {\n            target,\n            exec,\n            target_is_release,\n\n            env: ProfilerEnv::default(),\n\n            simulation_start: SystemTime::now(),\n            time_start: Instant::now(),\n            duration: Duration::ZERO,\n\n            event_count: 0,\n            features,\n        }\n    }\n}\n\n/// A description of the runtime enviroment.\n#[derive(Debug, Clone)]\npub struct ProfilerEnv {\n    /// The target arch.\n    pub arch: String,\n    /// The target os.\n    pub os: String,\n    /// The target os family.\n    pub os_family: String,\n\n    #[allow(unused)]\n    system: Arc\u003csysinfo::System\u003e,\n}\n\nimpl ProfilerEnv {\n    #[allow(unused)]\n    fn write_to(\u0026self, f: \u0026mut impl Write) -\u003e std::io::Result\u003c()\u003e {\n        writeln!(\n            f,\n            \"\\t{} / {}\",\n            self.system\n                .host_name()\n                .unwrap_or_else(|| \"Unknown-System\".into()),\n            self.system\n                .long_os_version()\n                .unwrap_or_else(|| self.os.clone())\n        )?;\n        writeln!(f, \"\\t{}-{}-{}\", self.arch, self.os_family, self.os)?;\n        if let Some(cpu) = self.system.cpus().first() {\n            writeln!(\n                f,\n                \"\\t{} ({} / {}) @ {}MHz\",\n                cpu.name(),\n                cpu.brand(),\n                cpu.vendor_id(),\n                cpu.frequency()\n            )?;\n        }\n        writeln!(\n            f,\n            \"\\tmem: {} total {} swap\",\n            self.system.total_memory(),\n            self.system.total_swap()\n        )?;\n\n        Ok(())\n    }\n}\n\nimpl PartialEq for ProfilerEnv {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.arch == other.arch \u0026\u0026 self.os == other.os \u0026\u0026 self.os_family == other.os_family\n    }\n}\n\nimpl Eq for ProfilerEnv {}\n\nimpl Default for ProfilerEnv {\n    fn default() -\u003e Self {\n        let mut system = sysinfo::System::new();\n        system.refresh_cpu();\n        system.refresh_memory();\n\n        Self {\n            arch: std::env::consts::ARCH.to_string(),\n            os: std::env::consts::OS.to_string(),\n            os_family: std::env::consts::FAMILY.to_string(),\n\n            system: Arc::new(system),\n        }\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":171},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":171},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":171},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":171},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":350},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":350},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":350},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":175},"fn_name":null}],"covered":32,"coverable":61},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","builder.rs"],"content":"use std::{\n    fmt::Debug,\n    sync::{Mutex, TryLockError},\n};\n\n#[cfg(feature = \"cqueue\")]\nuse std::time::Duration;\n\nuse rand::{\n    rngs::{OsRng, StdRng},\n    RngCore, SeedableRng,\n};\n\nuse crate::prelude::SimTime;\n\nuse super::{Application, FutureEventSet, Profiler, Runtime, RuntimeLimit, RNG};\n\n/// A lock the ensures only one runtime exits at a time.\nstatic SIMULATION_LOCK: Mutex\u003c()\u003e = Mutex::new(());\n\n/// A builder for a runtime instance.\n#[must_use]\npub struct Builder {\n    pub(super) quiet: bool,\n    pub(super) rng: Box\u003cdyn RngCore\u003e,\n    pub(super) limit: RuntimeLimit,\n    pub(super) start_time: SimTime,\n\n    #[cfg(feature = \"cqueue\")]\n    pub(super) cqueue_num_buckets: usize,\n    #[cfg(feature = \"cqueue\")]\n    pub(super) cqueue_bucket_timespan: Duration,\n}\n\nimpl Builder {\n    /// Creates a new unconfigured builder.\n    ///\n    /// # Panics\n    ///\n    /// Panics if no RNG can be build.\n    pub fn new() -\u003e Builder {\n        Builder {\n            quiet: false,\n            rng: Box::new(StdRng::from_rng(OsRng).expect(\"Failed to create RNG\")),\n            limit: RuntimeLimit::None,\n\n            start_time: SimTime::MIN,\n\n            #[cfg(feature = \"cqueue\")]\n            cqueue_num_buckets: 1028,\n\n            #[cfg(feature = \"cqueue\")]\n            cqueue_bucket_timespan: Duration::from_secs_f64(0.0025),\n        }\n    }\n\n    /// Creates a `Builder` with a static seeded RNG.\n    pub fn seeded(seed: u64) -\u003e Builder {\n        Builder {\n            quiet: false,\n            rng: Box::new(StdRng::seed_from_u64(seed)),\n            limit: RuntimeLimit::None,\n\n            start_time: SimTime::MIN,\n\n            #[cfg(feature = \"cqueue\")]\n            cqueue_num_buckets: 1028,\n\n            #[cfg(feature = \"cqueue\")]\n            cqueue_bucket_timespan: Duration::from_secs_f64(0.0025),\n        }\n    }\n\n    ///\n    /// Sets the cqueue options if this runtime uses a cqueue.\n    /// NOP otherwise.\n    ///\n    #[cfg(feature = \"cqueue\")]\n    pub fn cqueue_options(mut self, n: usize, t: Duration) -\u003e Self {\n        self.cqueue_num_buckets = n;\n        self.cqueue_bucket_timespan = t;\n\n        self\n    }\n\n    ///\n    /// Suppressed runtime messages from the simulation framework.\n    ///\n    pub fn quiet(mut self) -\u003e Self {\n        self.quiet = true;\n        self\n    }\n\n    ///\n    /// Changes the maximum iteration number of a runtime.\n    ///\n    pub fn start_time(mut self, time: SimTime) -\u003e Self {\n        self.start_time = time;\n        self\n    }\n\n    ///\n    /// Changes the maximum iteration number of a runtime.\n    ///\n    pub fn max_itr(mut self, max_itr: usize) -\u003e Self {\n        self.limit.add(RuntimeLimit::EventCount(max_itr));\n        self\n    }\n\n    ///\n    /// Changes the maximum time of the runtime (default: inf).\n    ///\n    pub fn max_time(mut self, max_time: SimTime) -\u003e Self {\n        self.limit.add(RuntimeLimit::SimTime(max_time));\n        self\n    }\n\n    ///\n    /// Sets a custom limit to the end of the runtime, overwriting\n    /// all `max_itr` and `max_time` options.\n    ///\n    pub fn limit(mut self, limit: RuntimeLimit) -\u003e Self {\n        self.limit.add(limit);\n        self\n    }\n\n    ///\n    /// Builds a new [`Runtime`] instance, using an application as core,\n    /// and accepting events of type [`Event\u003cA\u003e`](crate::runtime::Event).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// // Assumme Application is implemented for App.\n    /// #[derive(Debug)]\n    /// struct App(usize,  String);\n    /// # impl Application for App {\n    /// #   type EventSet = Events;\n    /// #   type Lifecycle = ();\n    /// # }\n    /// # enum Events {}\n    /// # impl EventSet\u003cApp\u003e for Events {\n    /// #   fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {}\n    /// # }\n    ///\n    /// let app = App(42, String::from(\"Hello there!\"));\n    /// let rt = Builder::new().build(app);\n    /// ```\n    pub fn build\u003cA: Application\u003e(self, app: A) -\u003e Runtime\u003cA\u003e {\n        let permit = {\n            let lock = SIMULATION_LOCK.try_lock();\n            match lock {\n                Ok(permit) =\u003e permit,\n                Err(err) =\u003e {\n                    match err {\n                        TryLockError::WouldBlock =\u003e {\n                            eprintln!(\"des::warning ** another runtime allready exists ... waiting for simlock\");\n                            let lock = SIMULATION_LOCK.lock();\n                            match lock {\n                                Ok(lock) =\u003e lock,\n                                Err(p) =\u003e {\n                                    eprintln!(\"des::error ** another runtime poisoned the simlock ... cleaning up\");\n                                    Runtime::\u003cA\u003e::poison_cleanup();\n                                    p.into_inner()\n                                }\n                            }\n                        }\n                        TryLockError::Poisoned(p) =\u003e {\n                            eprintln!(\"des::error ** another runtime poisoned the simlock ... cleaning up\");\n                            Runtime::\u003cA\u003e::poison_cleanup();\n                            p.into_inner()\n                        }\n                    }\n                }\n            }\n        };\n\n        // Log prep\n        // StandardLogger::setup().expect(\"Failed to create logger\");\n        #[cfg(feature = \"cqueue\")]\n        if std::mem::size_of::\u003cA::EventSet\u003e() \u003e 128 {\n            eprintln!(\"des::warning ** creating runtime with event-set bigger that 128 bytes * this may lead to performance losses\");\n        }\n\n        let future_event_set = FutureEventSet::new_with(\u0026self);\n\n        // Set SimTime\n        SimTime::set_now(self.start_time);\n\n        // Set RNG\n        *unsafe { \u0026mut *RNG.get() } = Some(self.rng);\n\n        Runtime {\n            future_event_set,\n\n            event_id: 0,\n            itr: 0,\n            permit,\n\n            limit: self.limit,\n\n            quiet: self.quiet,\n            profiler: Profiler::default(),\n\n            app,\n        }\n    }\n}\n\nimpl Default for Builder {\n    fn default() -\u003e Self {\n        Builder::new()\n    }\n}\n\nimpl Debug for Builder {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"Builder\").finish()\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":170},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":170},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":170},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":38,"coverable":58},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","event","event_set.rs"],"content":"cfg_not_cqueue! {\n    mod default_impl {\n        use crate::{runtime::{Application, EventNode}, time::SimTime};\n        use std::collections::{BinaryHeap, VecDeque};\n        use crate::runtime::Builder;\n\n\n\n        pub(crate) struct FutureEventSet\u003cA\u003e\n        where\n            A: Application,\n        {\n            heap: BinaryHeap\u003cEventNode\u003cA\u003e\u003e,\n            zero_queue: VecDeque\u003cEventNode\u003cA\u003e\u003e,\n\n            last_event_simtime: SimTime,\n        }\n\n        impl\u003cA\u003e FutureEventSet\u003cA\u003e\n        where\n            A: Application,\n        {\n            #[allow(clippy::unused_self)]\n            pub(crate) fn descriptor(\u0026self) -\u003e String {\n                \"FutureEventSet::BinaryHeap()\".to_string()\n            }\n\n            pub(crate) fn len(\u0026self) -\u003e usize {\n                self.len_zero() + self.len_nonzero()\n            }\n\n            pub(crate) fn is_empty(\u0026self) -\u003e bool {\n                self.heap.is_empty() \u0026\u0026 self.zero_queue.is_empty()\n            }\n\n            pub(crate) fn len_zero(\u0026self) -\u003e usize {\n                self.zero_queue.len()\n            }\n\n            pub(crate) fn len_nonzero(\u0026self) -\u003e usize {\n                self.heap.len()\n            }\n\n            pub(crate) fn new_with(options: \u0026Builder) -\u003e Self {\n                Self {\n                    heap: BinaryHeap::with_capacity(64),\n                    zero_queue: VecDeque::with_capacity(32),\n\n                    last_event_simtime: options.start_time,\n                }\n            }\n\n            //\n            // clippy::let_and_return occures on not(feature = \"metrics\")\n            // but would produce invalid code with feature \"metrics\"\n            //\n            #[allow(clippy::let_and_return)]\n            #[allow(clippy::needless_pass_by_value)]\n            #[allow(clippy::cast_precision_loss)]\n            pub(crate) fn fetch_next(\n                \u0026mut self,\n            ) -\u003e (A::EventSet, SimTime) {\n\n                let event = if let Some(event) = self.zero_queue.pop_front() {\n                    self.last_event_simtime = event.time;\n                    event\n                } else {\n                    let event = self.heap.pop().expect(\"unreachable: fetch_next shall only be called with the guarantee that an event exists\");\n                    self.last_event_simtime = event.time;\n                    event\n                };\n\n                (event.event, event.time)\n            }\n\n            #[allow(clippy::needless_pass_by_value)]\n            pub(crate) fn add(\n                \u0026mut self,\n                time: SimTime,\n                event: impl Into\u003cA::EventSet\u003e,\n            ) {\n                assert!(\n                    time \u003e= self.last_event_simtime,\n                    \"Sorry we cannot timetravel yet\"\n                );\n\n                let node = EventNode {\n                    id: 0,\n                    event: event.into(),\n                    time,\n\n                    _phantom: std::marker::PhantomData,\n                };\n\n                if self.last_event_simtime == time {\n                    self.zero_queue.push_back(node);\n                } else {\n                    self.heap.push(node);\n                }\n            }\n        }\n    }\n\n    pub(crate) use default_impl::*;\n}\n\ncfg_cqueue! {\n    mod cqueue_impl {\n        use crate::{runtime::{Application, Builder}, time::SimTime};\n        use des_cqueue::CQueue;\n\n        pub(crate) struct FutureEventSet\u003cA\u003e\n        where\n            A: Application,\n        {\n            inner: CQueue\u003cA::EventSet\u003e,\n        }\n\n        impl\u003cA\u003e FutureEventSet\u003cA\u003e\n        where\n            A: Application,\n        {\n            #[allow(clippy::unused_self)]\n            pub(crate) fn descriptor(\u0026self) -\u003e String {\n                format!(\"FutureEventSet::CQueue::{}\", self.inner.descriptor())\n            }\n\n            pub(crate) fn len(\u0026self) -\u003e usize {\n                self.inner.len()\n            }\n\n            pub(crate) fn is_empty(\u0026self) -\u003e bool {\n                self.inner.is_empty()\n            }\n\n            pub(crate) fn new_with(options: \u0026Builder) -\u003e Self {\n                Self {\n                    inner: CQueue::new(options.cqueue_num_buckets, options.cqueue_bucket_timespan),\n                }\n            }\n\n            #[allow(clippy::needless_pass_by_value)]\n            pub(crate) fn fetch_next(\n                \u0026mut self,\n            ) -\u003e (A::EventSet, SimTime) {\n\n                let (event, time) = self.inner.fetch_next();\n                (event, SimTime::from_duration(time))\n            }\n\n            #[allow(clippy::needless_pass_by_value)]\n            pub(crate) fn add(\n                \u0026mut self,\n                time: SimTime,\n                event: impl Into\u003cA::EventSet\u003e,\n            ) {\n                self.inner.add(*time, event.into());\n            }\n        }\n    }\n\n    pub(crate) use self::cqueue_impl::*;\n\n}\n","traces":[{"line":124,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":236402},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":236402},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":118007},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":118007},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":118007},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":118007},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":118007},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","event","mod.rs"],"content":"use crate::time::SimTime;\n\nmod event_set;\npub(crate) use event_set::*;\n\npub(crate) trait EventSink\u003cE\u003e {\n    fn add(\u0026mut self, event: E, time: SimTime);\n}\n\nimpl\u003cA: Application\u003e EventSink\u003cA::EventSet\u003e for Runtime\u003cA\u003e {\n    fn add(\u0026mut self, event: A::EventSet, time: SimTime) {\n        self.add_event(event, time);\n    }\n}\n\nimpl\u003cE\u003e EventSink\u003cE\u003e for Vec\u003c(E, SimTime)\u003e {\n    fn add(\u0026mut self, event: E, time: SimTime) {\n        self.push((event, time));\n    }\n}\n\nmod types;\npub use types::*;\n\nuse super::Runtime;\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2390},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":2390},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":4109},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":4109},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","event","types.rs"],"content":"use std::cmp;\nuse std::fmt::{Debug, Display};\nuse std::marker::PhantomData;\n\nuse crate::runtime::Runtime;\nuse crate::time::SimTime;\n\n///\n/// A trait that defines an runtime application\n/// that depends on a event set to be processed by the\n/// runtime and a lifecylce managment.\n///\npub trait Application: Sized {\n    ///\n    /// The set of events used in the simulation.\n    ///\n    type EventSet: EventSet\u003cSelf\u003e;\n    ///\n    /// A global type, defining the behavior at sim start / sim end\n    ///\n    type Lifecycle: EventLifecycle\u003cSelf\u003e;\n}\n\n///\n/// A type that can be used as a wrapper around all events\n/// handled by an application A.\n///\n/// Note that ther is a cyclic dependecy between the event set\n/// and the application.\n/// This is due to the fact that Events allways defined those two parameters\n/// to be related (since specific events of the event set require runtime params),\n/// but this type information is willingly elided, to fit into the rust generics system.\n///\npub trait EventSet\u003cA\u003e\nwhere\n    A: Application,\n{\n    ///\n    /// A function to handle an upcoming event represented as a instance\n    /// of the event set.\n    ///\n    /// Since events sets are usually macro-generated this is just a match statement that calls\n    /// the handle function on the given variant, as defined by the trait [Event].\n    ///\n    fn handle(self, runtime: \u0026mut Runtime\u003cA\u003e);\n}\n\n///\n/// A type that can handle an event, specific to the given aplication,\n/// and associated event set.\n///\n/// Note that events in an event set dont need to implement this trait,\n/// unless the event set is derived using the [`event_set`](crate::event_set)\n/// macros. Nonetheless is it advised to use this trait to better isolate different events\n/// and their associated data.\n///\npub trait Event\u003cApp\u003e\nwhere\n    App: Application,\n{\n    ///\n    /// A function to handle an upcoming event represented as a specific\n    /// instance of a event type.\n    ///\n    /// There is an implicit type bound that the Apps event set must contain\n    /// the Self type as a variant. This is usually guaranteed by macro-generting event sets,\n    /// but could lead to unexpected behaviour if not done properly in custom\n    /// event set implementations.\n    ///\n    fn handle(self, runtime: \u0026mut Runtime\u003cApp\u003e);\n}\n\n///\n/// A type that defines the lifecycle behaviour of an application A.\n///\npub trait EventLifecycle\u003cA = Self\u003e {\n    ///\n    /// A function that is called only once at the start of the simulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # struct Worker;\n    /// # impl Worker { fn initalize(\u0026mut self) {}}\n    /// # enum MyEventSet { EventA, EventB }\n    /// # impl EventSet\u003cMyApp\u003e for MyEventSet {\n    /// #   fn handle(self, rt: \u0026mut Runtime\u003cMyApp\u003e) {}\n    /// # }\n    /// struct MyApp { workers: Vec\u003cWorker\u003e };\n    /// impl Application for MyApp {\n    ///     type EventSet = MyEventSet;\n    ///     type Lifecycle = Self;\n    /// }\n    /// impl EventLifecycle for MyApp {\n    ///     fn at_sim_start(runtime: \u0026mut Runtime\u003cSelf\u003e) {\n    ///         runtime.app.workers.iter_mut().for_each(|w| w.initalize());\n    ///     }\n    /// }\n    /// ```\n    ///\n    #[allow(unused_variables)]\n    fn at_sim_start(runtime: \u0026mut Runtime\u003cA\u003e)\n    where\n        A: Application,\n    {\n    }\n\n    ///\n    /// A function that is called once the simulation reachted its limit.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # struct Worker;\n    /// # impl Worker { fn finish(\u0026mut self) {}}\n    /// # enum MyEventSet { EventA, EventB }\n    /// # impl EventSet\u003cMyApp\u003e for MyEventSet {\n    /// #   fn handle(self, rt: \u0026mut Runtime\u003cMyApp\u003e) {}\n    /// # }\n    /// struct MyApp { workers: Vec\u003cWorker\u003e };\n    /// impl Application for MyApp {\n    ///     type EventSet = MyEventSet;\n    ///     type Lifecycle = Self;\n    /// }\n    /// impl EventLifecycle for MyApp {\n    ///     fn at_sim_end(rt: \u0026mut Runtime\u003cSelf\u003e) {\n    ///         rt.app.workers.iter_mut().for_each(|w| w.finish());\n    ///     }\n    /// }\n    /// ```\n    ///\n    #[allow(unused_variables)]\n    fn at_sim_end(runtime: \u0026mut Runtime\u003cA\u003e)\n    where\n        A: Application,\n    {\n    }\n}\n\nimpl\u003cA\u003e EventLifecycle\u003cA\u003e for () {}\n\n///\n/// A runtime unqiue identifier for a event.\n///\npub(crate) type EventId = usize;\n\n///\n/// A bin-heap node of a event from the applicaitons event set.\n///\n/// # Allocation\n///\n/// This node does not contain nested heap allocations by default,\n/// only if the generic event itself requires heap allocations.\n/// Nonetheless this node will be stored on the heap as it is\n/// only used inside a [`std::collections::BinaryHeap`].\n///\npub(crate) struct EventNode\u003cA\u003e\nwhere\n    A: Application,\n{\n    /// The deadline timestamp for the event.\n    pub(crate) time: SimTime,\n    /// A runtime-specific unique identifier.\n    pub(crate) id: EventId,\n    /// The actual event.\n    pub(crate) event: A::EventSet,\n\n    /// A marker to preserve the type information concerning the application\n    /// not only the Event set.\n    pub(crate) _phantom: PhantomData\u003cA\u003e,\n}\n\nimpl\u003cA\u003e cmp::PartialEq for EventNode\u003cA\u003e\nwhere\n    A: Application,\n{\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.id == other.id\n    }\n}\n\nimpl\u003cA\u003e cmp::Eq for EventNode\u003cA\u003e where A: Application {}\n\nimpl\u003cA\u003e cmp::PartialOrd for EventNode\u003cA\u003e\nwhere\n    A: Application,\n{\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003ccmp::Ordering\u003e {\n        Some(self.cmp(other))\n    }\n\n    fn lt(\u0026self, other: \u0026Self) -\u003e bool {\n        other.time \u003c self.time\n    }\n\n    fn le(\u0026self, other: \u0026Self) -\u003e bool {\n        other.time \u003c= self.time\n    }\n\n    fn gt(\u0026self, other: \u0026Self) -\u003e bool {\n        other.time \u003e self.time\n    }\n\n    fn ge(\u0026self, other: \u0026Self) -\u003e bool {\n        other.time \u003e= self.time\n    }\n}\n\nimpl\u003cA\u003e cmp::Ord for EventNode\u003cA\u003e\nwhere\n    A: Application,\n{\n    fn cmp(\u0026self, other: \u0026Self) -\u003e cmp::Ordering {\n        // Inverted call should act as reverse\n        other.time.cmp(\u0026self.time)\n    }\n}\n\nimpl\u003cA\u003e Debug for EventNode\u003cA\u003e\nwhere\n    A: Application,\n    A::EventSet: Debug,\n{\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"EventNode {{ id: {} time: {} event: {:?} }}\",\n            self.id, self.time, self.event\n        )\n    }\n}\n\nimpl\u003cA\u003e Display for EventNode\u003cA\u003e\nwhere\n    A: Application,\n    A::EventSet: Display,\n{\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"EventNode {{ id: {} time: {} event: {} }}\",\n            self.id, self.time, self.event\n        )\n    }\n}\n","traces":[{"line":103,"address":[],"length":0,"stats":{"Line":172},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":172},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":24},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","limit.rs"],"content":"use crate::time::SimTime;\nuse std::{fmt::Display, mem};\n\n///\n/// A composed limit that terminates the event execution of\n/// a runtime.\n///\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum RuntimeLimit {\n    /// A unbounded runtime. A runtime with this limit will\n    /// only finish if the all events are handled and no new\n    /// events have been created.\n    None,\n\n    /// A bound based on the number of executed events.\n    /// A runtime with this limit will terminated prematurly after the\n    /// given bound is exceeded, but will finish normally if the bound-th event\n    /// is the last one.\n    EventCount(usize),\n\n    /// A bound based on the simulation time.\n    /// A runtime with this bound will terminate after no events\n    /// scheduled before the given simulation time are left.\n    SimTime(SimTime),\n\n    /// This bound combines two other bounds with a logical AND.\n    /// This will only terminated the simulation if both given\n    /// limits are fulfilled.\n    CombinedAnd(Box\u003cRuntimeLimit\u003e, Box\u003cRuntimeLimit\u003e),\n\n    /// This bound combines two other bounds with a logical OR.\n    /// This will terminated the simulation if one of given\n    /// limits is fulfilled.\n    CombinedOr(Box\u003cRuntimeLimit\u003e, Box\u003cRuntimeLimit\u003e),\n}\n\nimpl RuntimeLimit {\n    pub(crate) fn applies(\u0026self, itr_count: usize, time: SimTime) -\u003e bool {\n        match self {\n            Self::None =\u003e false,\n\n            Self::EventCount(e) =\u003e itr_count \u003e *e,\n            Self::SimTime(t) =\u003e time \u003e *t,\n\n            Self::CombinedAnd(lhs, rhs) =\u003e {\n                lhs.applies(itr_count, time) \u0026\u0026 rhs.applies(itr_count, time)\n            }\n            Self::CombinedOr(lhs, rhs) =\u003e {\n                lhs.applies(itr_count, time) || rhs.applies(itr_count, time)\n            }\n        }\n    }\n\n    pub(crate) fn add(\u0026mut self, limit: RuntimeLimit) {\n        if matches!(self, Self::None) {\n            *self = limit;\n        } else {\n            let mut other = Self::None;\n            mem::swap(\u0026mut other, self);\n            *self = Self::CombinedOr(Box::new(other), Box::new(limit));\n        }\n    }\n}\n\nimpl Display for RuntimeLimit {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::None =\u003e write!(f, \"None\"),\n\n            Self::EventCount(e) =\u003e write!(f, \"MaxEventCount({e})\"),\n            Self::SimTime(t) =\u003e write!(f, \"MaxSimTime({t})\"),\n\n            Self::CombinedAnd(lhs, rhs) =\u003e write!(f, \"{lhs} and {rhs}\"),\n            Self::CombinedOr(lhs, rhs) =\u003e write!(f, \"{lhs} or {rhs}\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn raw_limits() {\n        let limit = RuntimeLimit::None;\n        assert_eq!(limit.to_string(), \"None\");\n        assert!(!limit.applies(123, 100.0.into()));\n        assert!(!limit.applies(0, 0.0.into()));\n        assert!(!limit.applies(usize::MAX, SimTime::MAX));\n\n        let limit = RuntimeLimit::EventCount(100);\n        assert_eq!(limit.to_string(), \"MaxEventCount(100)\");\n        assert!(!limit.applies(23, 100.0.into()));\n        assert!(limit.applies(101, 0.0.into()));\n        assert!(limit.applies(101, SimTime::MAX));\n        assert!(limit.applies(230, 23.0.into()));\n\n        let limit = RuntimeLimit::SimTime(100.0.into());\n        assert_eq!(limit.to_string(), \"MaxSimTime(100s)\");\n        assert!(!limit.applies(0, 10.0.into()));\n        assert!(!limit.applies(0, 100.0.into()));\n        assert!(limit.applies(0, 100.000001.into()));\n        assert!(limit.applies(0, SimTime::MAX));\n    }\n\n    #[test]\n    fn combined_limits() {\n        use RuntimeLimit::*;\n\n        let limit = CombinedAnd(Box::new(EventCount(100)), Box::new(SimTime(100.0.into())));\n        assert_eq!(limit.to_string(), \"MaxEventCount(100) and MaxSimTime(100s)\");\n        assert!(!limit.applies(200, 10.0.into()));\n        assert!(!limit.applies(0, 200.0.into()));\n        assert!(limit.applies(101, 100.000001.into()));\n\n        let limit = CombinedOr(Box::new(EventCount(100)), Box::new(SimTime(100.0.into())));\n        assert_eq!(limit.to_string(), \"MaxEventCount(100) or MaxSimTime(100s)\");\n        assert!(!limit.applies(20, 10.0.into()));\n        assert!(limit.applies(0, 200.0.into()));\n        assert!(limit.applies(101, 10.0.into()));\n\n        let mut other = RuntimeLimit::EventCount(100);\n        other.add(SimTime(100.0.into()));\n        assert_eq!(limit, other);\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":118032},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":118032},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":110794},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":154},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":7078},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":184},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":184},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":22,"coverable":22},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","metrics","mod.rs"],"content":"//! Future impl for runtime metrics\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","mod.rs"],"content":"//!\n//! Central primitives for running a discrete event simulation.\n//!\n\nuse crate::{\n    macros::support::SyncWrap,\n    time::{Duration, SimTime},\n};\nuse rand::{distributions::Standard, prelude::Distribution, Rng, RngCore};\nuse std::{\n    any::type_name,\n    cell::UnsafeCell,\n    fmt::{Debug, Display},\n    sync::MutexGuard,\n};\n\nmod event;\npub use self::event::*;\n\nmod limit;\npub use self::limit::*;\n\nmod bench;\npub use bench::*;\n\nmod builder;\npub use builder::*;\n\nmod metrics;\n\npub(crate) const FT_NET: bool = cfg!(feature = \"net\");\npub(crate) const FT_NDL: bool = cfg!(feature = \"ndl\");\npub(crate) const FT_CQUEUE: bool = cfg!(feature = \"cqueue\");\npub(crate) const FT_INTERNAL_METRICS: bool = cfg!(feature = \"metrics\");\npub(crate) const FT_ASYNC: bool = cfg!(feature = \"async\");\n\npub(crate) const SYM_CHECKMARK: char = '\\u{2713}';\npub(crate) const SYM_CROSSMARK: char = '\\u{02df}';\n\npub(crate) static RNG: SyncWrap\u003cUnsafeCell\u003cOption\u003cBox\u003cdyn RngCore\u003e\u003e\u003e\u003e =\n    SyncWrap::new(UnsafeCell::new(None));\n\n///\n/// Returns a reference to a given rng.\n///\n/// # Panics\n///\n/// This function will panic if the RNG has not been initalized.\n/// This will be done once the `Runtime` was created.\n///\n#[must_use]\npub fn rng() -\u003e \u0026'static mut dyn RngCore {\n    unsafe { \u0026mut *RNG.get() }\n        .as_mut()\n        .expect(\"RNG not yet initalized\")\n}\n\n///\n/// Generates a random instance of type T with a Standard distribution.\n///\n#[must_use]\npub fn random\u003cT\u003e() -\u003e T\nwhere\n    Standard: Distribution\u003cT\u003e,\n{\n    rng().gen::\u003cT\u003e()\n}\n\n///\n/// Generates a random instance of type T with a distribution\n/// of type D.\n///\npub fn sample\u003cT, D\u003e(distr: D) -\u003e T\nwhere\n    D: Distribution\u003cT\u003e,\n{\n    rng().sample::\u003cT, D\u003e(distr)\n}\n\n///\n/// The central managment point for a generic\n/// instance of a discrete event based simulation.\n///\n/// # Generic usage\n///\n/// If you want to create a generic simulation you are requied to provide a 'app'\n/// parameter with an associated event set yourself. To do this follow this steps:\n///\n/// - Create an 'App' struct that implements the trait [`Application`].\n/// This struct will hold the systems state and define the event set used in the simulation.\n/// - Create your events that handle the logic of you simulation. They must implement [`Event`] with the generic\n/// parameter A, where A is your 'App' struct.\n/// - To bind those two together create a enum that implements [`EventSet`] that holds all your events.\n/// This can be done via a macro. The use this event set as the associated event set in 'App'.\n///\n/// # Usage with module system\n///\n/// If you want to use the module system for network-like simulations\n/// than you must create a [`Sim\u003cA\u003e`] as app parameter for the core [`Runtime`].\n/// This network runtime comes preconfigured with an event set and all managment\n/// event nessecary for the simulation. All you have to do is to pass the app into [`Builder::build`]\n/// to create a runnable instance and the run it.\n///\n/// [`Event`]: crate::runtime::Event\n/// [`EventSet`]: crate::runtime::EventSet\npub struct Runtime\u003cApp\u003e\nwhere\n    App: Application,\n{\n    /// The contained runtime application, defining globals and the used event set.\n    pub app: App,\n\n    // Rt limits\n    limit: RuntimeLimit,\n\n    event_id: EventId,\n    itr: usize,\n\n    // Misc\n    quiet: bool,\n    profiler: Profiler,\n\n    #[allow(dead_code)]\n    permit: MutexGuard\u003c'static, ()\u003e,\n\n    future_event_set: FutureEventSet\u003cApp\u003e,\n}\n\nimpl\u003cA\u003e Runtime\u003cA\u003e\nwhere\n    A: Application,\n{\n    // ///\n    // /// Returns the current number of events on enqueud.\n    // ///\n    // pub(crate) fn num_non_zero_events_queued(\u0026self) -\u003e usize {\n    //     self.future_event_set.len_nonzero()\n    // }\n\n    // ///\n    // /// Returns the current number of events on enqueud.\n    // ///\n    // pub(crate) fn num_zero_events_queued(\u0026self) -\u003e usize {\n    //     self.future_event_set.len_zero()\n    // }\n\n    ///\n    /// Returns the number of events that were dispatched on this [`Runtime`] instance.\n    ///\n    #[inline]\n    pub fn num_events_dispatched(\u0026self) -\u003e usize {\n        self.event_id\n    }\n\n    ///\n    /// Returns the number of events that were recieved \u0026 handled on this [`Runtime`] instance.\n    ///\n    pub fn num_events_received(\u0026self) -\u003e usize {\n        self.itr\n    }\n\n    ///\n    /// Returns the current simulation time.\n    ///\n    #[allow(clippy::unused_self)]\n    pub fn sim_time(\u0026self) -\u003e SimTime {\n        SimTime::now()\n    }\n\n    // ///\n    // /// Returns the random number generator by mutable refernce\n    // ///\n    // pub(crate) fn rng(\u0026mut self) -\u003e *mut StdRng {\n    //     self::rng()\n    // }\n\n    ///\n    /// Returns the rng.\n    ///\n    #[allow(clippy::unused_self)]\n    pub fn random\u003cT\u003e(\u0026mut self) -\u003e T\n    where\n        Standard: Distribution\u003cT\u003e,\n    {\n        self::random()\n    }\n\n    ///\n    /// Returns the rng.\n    ///\n    #[allow(clippy::unused_self)]\n    pub fn rng_sample\u003cT, D\u003e(\u0026mut self, distr: D) -\u003e T\n    where\n        D: Distribution\u003cT\u003e,\n    {\n        self::sample(distr)\n    }\n}\n\nimpl\u003cA\u003e Runtime\u003cA\u003e\nwhere\n    A: Application,\n{\n    ///\n    /// Creates a new [`Runtime`] Instance using an application as core,\n    /// and accepting events of type [`Event\u003cA\u003e`](crate::runtime::Event).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// // Assumme Application is implemented for App.\n    /// #[derive(Debug)]\n    /// struct App(usize,  String);\n    /// # impl Application for App {\n    /// #   type EventSet = Events;\n    /// #   type Lifecycle = ();\n    /// # }\n    /// # enum Events {}\n    /// # impl EventSet\u003cApp\u003e for Events {\n    /// #   fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {}\n    /// # }\n    ///\n    /// let app = App(42, String::from(\"Hello there!\"));\n    /// let rt = Builder::new().build(app);\n    /// ```\n    ///\n    // #[must_use]\n    // pub fn new(app: A) -\u003e Self {\n    //     Self::new_with(app, RuntimeOptions::default())\n    // }\n\n    ///\n    /// Creates a new [`Runtime`] Instance using an application as core,\n    /// and accepting events of type [`Event\u003cA\u003e`](crate::runtime::Event), using a custom set of\n    /// [`RuntimeOptions`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// // Assumme Application is implemented for App.\n    /// #[derive(Debug)]\n    /// struct App(usize,  String);\n    /// # impl Application for App {\n    /// #   type EventSet = Events;\n    /// #   type Lifecycle = ();\n    /// # }\n    /// # enum Events {}\n    /// # impl EventSet\u003cApp\u003e for Events {\n    /// #   fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {}\n    /// # }\n    ///\n    /// let app = App(42, String::from(\"Hello there!\"));\n    /// let rt = Builder::seeded(42).max_itr(69).build(app);\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// Panics if no RNG can be created from the OS-RNG.\n    ///\n    // #[must_use]\n    // pub fn new_with(app: A, mut options: RuntimeOptions) -\u003e Self {\n    //     todo!()\n    // }\n\n    fn poison_cleanup() {\n        // NOP\n    }\n\n    /// Runs the application until it terminates or a breaking condition\n    /// is reached.\n    ///\n    /// ### Examples\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// struct MyApp();\n    /// impl Application for MyApp {\n    ///     type EventSet = MyEventSet;\n    ///     type Lifecycle = Self;\n    /// }\n    /// impl EventLifecycle for MyApp {\n    ///     fn at_sim_start(rt: \u0026mut Runtime\u003cSelf\u003e) {\n    ///         rt.add_event(MyEventSet::EventA, SimTime::from(1.0));\n    ///         rt.add_event(MyEventSet::EventB, SimTime::from(2.0));\n    ///         rt.add_event(MyEventSet::EventA, SimTime::from(3.0));\n    ///     }\n    /// }\n    ///\n    /// #[derive(Debug)]\n    /// enum MyEventSet {\n    ///     EventA,\n    ///     EventB\n    /// }\n    /// impl EventSet\u003cMyApp\u003e for MyEventSet {\n    ///     fn handle(self, rt: \u0026mut Runtime\u003cMyApp\u003e) {\n    ///         dbg!(self, SimTime::now());\n    ///     }\n    /// }\n    ///\n    ///\n    /// let runtime = Builder::new().build(MyApp());\n    /// let result = runtime.run();\n    ///\n    /// match result {\n    ///     RuntimeResult::Finished { time, profiler, .. } =\u003e {\n    ///         assert_eq!(time, SimTime::from(3.0));\n    ///         assert_eq!(profiler.event_count, 3);\n    ///     },\n    ///     _ =\u003e panic!(\"They can't do that! Shoot them or something!\")\n    /// }\n    ///\n    /// ```\n    #[must_use]\n    pub fn run(mut self) -\u003e RuntimeResult\u003cA\u003e {\n        // (0) Start sim-start\n        self.start();\n\n        // (1) Event main loop\n        if !self.future_event_set.is_empty() {\n            while self.next() {}\n        }\n\n        // (2) Finish sim-end\n        self.finish()\n    }\n\n    fn start(\u0026mut self) {\n        macro_rules! symbol {\n            ($i:ident) =\u003e {\n                if $i {\n                    SYM_CHECKMARK\n                } else {\n                    SYM_CROSSMARK\n                }\n            };\n        }\n\n        // (0) Publish sim-start message\n        println!(\"\\u{23A1}\");\n        println!(\"\\u{23A2} Simulation starting\");\n        println!(\n            \"\\u{23A2}  net [{}] metrics [{}] cqueue [{}] ndl[{}] async[{}]\",\n            symbol!(FT_NET),\n            symbol!(FT_INTERNAL_METRICS),\n            symbol!(FT_CQUEUE),\n            symbol!(FT_NDL),\n            symbol!(FT_ASYNC),\n        );\n        println!(\n            \"\\u{23A2}  Executor := {}\",\n            self.future_event_set.descriptor()\n        );\n        println!(\"\\u{23A2}  Event limit := {}\", self.limit);\n        println!(\"\\u{23A3}\");\n\n        // (1) Start profiler\n        self.profiler.start();\n\n        // (2) sim-starting on application object\n        A::Lifecycle::at_sim_start(self);\n    }\n\n    /// Processes the next event in the future event list by calling its handler.\n    /// Returns `true` if there is another event in queue, false if not.\n    ///\n    /// This function requires the caller to guarantee that at least one\n    /// event exists in the future event set.\n    #[allow(clippy::should_implement_trait)]\n    fn next(\u0026mut self) -\u003e bool {\n        debug_assert!(!self.future_event_set.is_empty());\n\n        let (event, time) = self.future_event_set.fetch_next();\n\n        self.itr += 1;\n\n        if self.limit.applies(self.itr, time) {\n            self.future_event_set.add(time, event);\n            return false;\n        }\n\n        // Let this be the only position where SimTime is changed\n        SimTime::set_now(time);\n\n        // {\n        //     #[cfg(feature = \"tracing\")]\n        //     let span = tracing::span!(tracing::Level::TRACE, \"event\", id = self.itr);\n        //     #[cfg(feature = \"tracing\")]\n        //     let _g = span.enter();\n\n        event.handle(self);\n        // }\n\n        !self.future_event_set.is_empty()\n    }\n\n    /// Decontructs the runtime and returns the application and the final `sim_time`.\n    ///\n    /// This funtions should only be used when running the simulation with manual calls\n    /// to [`next`](Runtime::next).\n    #[allow(unused_mut)]\n    #[must_use]\n    fn finish(mut self) -\u003e RuntimeResult\u003cA\u003e {\n        // Call the fin-handler on the allocated application\n        A::Lifecycle::at_sim_end(\u0026mut self);\n        self.profiler.finish(self.itr);\n\n        if self.future_event_set.is_empty() \u0026\u0026 self.itr == 0 {\n            if !self.quiet {\n                println!(\"\\u{23A1}\");\n                println!(\"\\u{23A2} Empty simulation\");\n                println!(\"\\u{23A2}  Ended at event #0 after 0s\");\n                println!(\"\\u{23A3}\");\n            }\n\n            return RuntimeResult::EmptySimulation { app: self.app };\n        }\n\n        if self.future_event_set.is_empty() {\n            let time = self.sim_time();\n\n            if !self.quiet {\n                println!(\"\\u{23A1}\");\n                println!(\"\\u{23A2} Simulation ended\");\n                println!(\"\\u{23A2}  Ended at event #{} after {}\", self.itr, time);\n                println!(\"\\u{23A3}\");\n            }\n\n            RuntimeResult::Finished {\n                app: self.app,\n                profiler: self.profiler,\n                time,\n            }\n        } else {\n            let time = self.sim_time();\n\n            if !self.quiet {\n                println!(\"\\u{23A1}\");\n                println!(\"\\u{23A2} Simulation ended prematurly\");\n                println!(\n                    \"\\u{23A2}  Ended at event #{} with {} active events after {}\",\n                    self.itr,\n                    self.future_event_set.len(),\n                    time\n                );\n                println!(\"\\u{23A3}\");\n            }\n\n            RuntimeResult::PrematureAbort {\n                profiler: self.profiler,\n                active_events: self.future_event_set.len(),\n                app: self.app,\n                time,\n            }\n        }\n    }\n\n    ///\n    /// Adds and event to the future event heap, that will be handled in 'duration'\n    /// time units.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// # struct MyApp();\n    /// # impl Application for MyApp {\n    /// #     type EventSet = MyEventSet;\n    /// #     type Lifecycle = ();\n    /// # }\n    /// #\n    /// # enum MyEventSet {\n    /// #     EventA,\n    /// #     EventB\n    /// # }\n    /// # impl EventSet\u003cMyApp\u003e for MyEventSet {\n    /// #     fn handle(self, rt: \u0026mut Runtime\u003cMyApp\u003e) {}\n    /// # }\n    /// #\n    /// fn main() {\n    ///     let mut runtime = Builder::seeded(1)\n    ///         .start_time(10.0.into())\n    ///         .build(MyApp());\n    ///     runtime.add_event_in(MyEventSet::EventA, Duration::new(12, 0));\n    ///\n    ///     match runtime.run() {\n    ///         RuntimeResult::Finished { time, profiler, .. } =\u003e {\n    ///             assert_eq!(time, SimTime::from(22.0));\n    ///             assert_eq!(profiler.event_count, 1);\n    ///         },\n    ///         _ =\u003e panic!(\"They can't do that! Shoot them or something!\")\n    ///     }\n    /// }\n    /// ```\n    ///\n    pub fn add_event_in(\u0026mut self, event: impl Into\u003cA::EventSet\u003e, duration: impl Into\u003cDuration\u003e) {\n        self.add_event(event, self.sim_time() + duration.into());\n    }\n\n    ///\n    /// Adds and event to the furtue event heap that will be handled at the given time.\n    /// Note that this time must be in the future i.e. greated that `sim_time`, or this\n    /// function will panic.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// # struct MyApp();\n    /// # impl Application for MyApp {\n    /// #     type EventSet = MyEventSet;\n    /// #     type Lifecycle = ();\n    /// # }\n    /// #\n    /// # enum MyEventSet {\n    /// #     EventA,\n    /// #     EventB\n    /// # }\n    /// # impl EventSet\u003cMyApp\u003e for MyEventSet {\n    /// #     fn handle(self, rt: \u0026mut Runtime\u003cMyApp\u003e) {}\n    /// # }\n    /// #\n    /// fn main() {\n    ///     let mut runtime = Builder::seeded(1)\n    ///         .start_time(10.0.into())\n    ///         .build(MyApp());\n    ///     runtime.add_event(MyEventSet::EventA, SimTime::from(12.0));\n    ///\n    ///     match runtime.run() {\n    ///         RuntimeResult::Finished { time, profiler, .. } =\u003e {\n    ///             assert_eq!(time, SimTime::from(12.0)); // 12 not 10+12 = 22\n    ///             assert_eq!(profiler.event_count, 1);\n    ///         },\n    ///         _ =\u003e panic!(\"They can't do that! Shoot them or something!\")\n    ///     }\n    /// }\n    /// ```\n    ///\n    pub fn add_event(\u0026mut self, event: impl Into\u003cA::EventSet\u003e, time: SimTime) {\n        self.future_event_set.add(time, event);\n    }\n}\n\n///\n/// The result of an full execution of a runtime object.\n///\n#[derive(Debug, Clone, Eq, PartialEq)]\npub enum RuntimeResult\u003cA\u003e {\n    /// The simulation has finished with an event count of `1`.\n    /// This ususally inidcates that some parameter was invalid,\n    /// or the user forgot to insert a startup event. However a\n    /// at_sim_start event has been called.\n    EmptySimulation {\n        /// The application provided upon runtime creation, only changed through\n        /// the `at_sim_start` method of modules.\n        app: A,\n    },\n    /// The simulation has fully depleted its event pool with an event count\n    /// greater than `1`. The function `at_sim_end` has been called.\n    Finished {\n        /// The application after the simulation was executed.\n        app: A,\n        /// The time of the final event in the simulation.\n        time: SimTime,\n        /// The runtime profile of the simulation\n        profiler: Profiler,\n    },\n    /// The simulation has not fully deleted its event pool. but a `RuntimeLimit`\n    /// has been reached.\n    PrematureAbort {\n        /// The application in the intermediary state of premature abort,\n        /// but `at_sim_end` has been called.\n        app: A,\n        /// The time of the last event valid withing the limits of the runtime.\n        time: SimTime,\n        /// The size of the current event pool.\n        active_events: usize,\n        /// The runtime profile of the simulation\n        profiler: Profiler,\n    },\n}\n\nimpl\u003cA\u003e RuntimeResult\u003cA\u003e {\n    /// Gets the contained application from the runtime result.\n    ///\n    /// An application is contained in each variant of a runtime result.\n    pub fn into_app(self) -\u003e A {\n        match self {\n            Self::EmptySimulation { app }\n            | Self::Finished { app, .. }\n            | Self::PrematureAbort { app, .. } =\u003e app,\n        }\n    }\n\n    ///\n    /// Returns the contained [`PrematureAbort`](Self::PrematureAbort) variant\n    /// consuming the `self`value.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if self contains another variant that [`PrematureAbort`](Self::PrematureAbort).\n    ///\n    pub fn unwrap_premature_abort(self) -\u003e (A, SimTime, Profiler, usize) {\n        match self {\n            Self::PrematureAbort { app, time,profiler, active_events} =\u003e (app, time, profiler, active_events),\n            _ =\u003e panic!(\"called `RuntimeResult::unwrap_premature_abort` on a value that is not `PrematureAbort`\")\n        }\n    }\n\n    ///\n    /// Returns the contained [`Finished`](Self::Finished) variant consuming the `self` value.\n    ///\n    /// # Panics\n    ///\n    /// This function panics should the `self` value contain another variant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::runtime::Profiler;\n    /// # #[derive(Debug, PartialEq, Eq)]\n    /// # struct MyApp;\n    /// # fn main() {\n    /// let p = Profiler::default();\n    /// let result = RuntimeResult::Finished { app: MyApp, time: 1.0.into(), profiler: p.clone() };\n    /// assert_eq!(result.unwrap(), (MyApp, SimTime::from(1.0), p));\n    /// # }\n    /// ```\n    ///\n    /// ```should_panic\n    /// # use des::prelude::*;\n    /// # #[derive(Debug, PartialEq, Eq)]\n    /// # struct MyApp;\n    /// # fn main() {\n    /// let result = RuntimeResult::EmptySimulation { app: MyApp };\n    /// result.unwrap();\n    /// # }\n    /// ```\n    pub fn unwrap(self) -\u003e (A, SimTime, Profiler) {\n        match self {\n            Self::Finished {\n                app,\n                time,\n                profiler,\n            } =\u003e (app, time, profiler),\n            _ =\u003e panic!(\"called `RuntimeResult::unwrap` on value that is not 'Finished'\"),\n        }\n    }\n\n    ///\n    /// Returns the contained [`Finished`](Self::Finished) variant or\n    /// the provided default.\n    ///\n    /// The argument `default` is eagerly evaulated, for lazy evaluation use\n    /// [`unwrap_or_else`](Self::unwrap_or_else).\n    ///\n    pub fn unwrap_or(self, default: (A, SimTime, Profiler)) -\u003e (A, SimTime, Profiler) {\n        match self {\n            Self::Finished {\n                app,\n                time,\n                profiler,\n            } =\u003e (app, time, profiler),\n            _ =\u003e default,\n        }\n    }\n\n    ///\n    /// Returns the contained [`Finished`](Self::Finished) variant or lazily\n    /// computes a fallback value from the given closure.\n    ///\n    pub fn unwrap_or_else\u003cF\u003e(self, f: F) -\u003e (A, SimTime, Profiler)\n    where\n        F: FnOnce() -\u003e (A, SimTime, Profiler),\n    {\n        match self {\n            Self::Finished {\n                app,\n                time,\n                profiler,\n            } =\u003e (app, time, profiler),\n            _ =\u003e f(),\n        }\n    }\n\n    ///\n    /// Maps the `app` property that is contained in all variants to a new\n    /// value of type T, using the given closure.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # #[derive(Debug, PartialEq, Eq)]\n    /// struct InnerResult { value: usize }\n    /// # #[derive(Debug, PartialEq, Eq)]\n    /// struct OuterResult { inner: InnerResult }\n    ///\n    /// # fn main() {\n    /// let result = RuntimeResult::EmptySimulation {\n    ///     app: OuterResult { inner: InnerResult { value: 42 } }\n    /// };\n    /// let result = result.map_app(|outer| outer.inner);\n    /// assert_eq!(result, RuntimeResult::EmptySimulation { app: InnerResult { value: 42 } });\n    /// # }\n    /// ```\n    ///\n    pub fn map_app\u003cF, T\u003e(self, f: F) -\u003e RuntimeResult\u003cT\u003e\n    where\n        F: FnOnce(A) -\u003e T,\n    {\n        match self {\n            Self::EmptySimulation { app } =\u003e RuntimeResult::EmptySimulation { app: f(app) },\n            Self::Finished {\n                app,\n                time,\n                profiler,\n            } =\u003e RuntimeResult::Finished {\n                app: f(app),\n                time,\n                profiler,\n            },\n            Self::PrematureAbort {\n                app,\n                time,\n                profiler,\n                active_events,\n            } =\u003e RuntimeResult::PrematureAbort {\n                app: f(app),\n                time,\n                profiler,\n                active_events,\n            },\n        }\n    }\n}\n\ncfg_net! {\n    use crate::net::{gate::{GateRef, Connection},  HandleMessageEvent, message::Message, MessageExitingConnection, module::ModuleRef, NetEvents, Sim};\n\n    impl\u003cA\u003e Runtime\u003cSim\u003cA\u003e\u003e where\n        A: EventLifecycle\u003cSim\u003cA\u003e\u003e,{\n        ///\n        /// Adds a message event into a [`Runtime\u003cNetworkApplication\u003cA\u003e\u003e`] onto a gate.\n        ///\n        pub fn add_message_onto(\n            \u0026mut self,\n            gate: GateRef,\n            message: impl Into\u003cMessage\u003e,\n            time: SimTime,\n        ) {\n            let event = MessageExitingConnection {\n                con: Connection::new(gate),\n                msg: message.into(),\n            };\n\n            self.add_event(NetEvents::MessageExitingConnection(event), time);\n        }\n\n        ///\n        /// Adds a message event into a [`Runtime\u003cNetworkApplication\u003cA\u003e\u003e`] onto a module.\n        ///\n        pub fn handle_message_on(\n            \u0026mut self,\n            module: impl Into\u003cModuleRef\u003e,\n            message: impl Into\u003cMessage\u003e,\n            time: SimTime,\n        ) {\n            let event = HandleMessageEvent {\n                module: module.into(),\n                message: message.into(),\n            };\n\n            self.add_event(NetEvents::HandleMessageEvent(event), time);\n        }\n    }\n}\n\nimpl\u003cA\u003e Debug for Runtime\u003cA\u003e\nwhere\n    A: Application,\n{\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"Runtime\u003c{}\u003e {{ sim_time: {} (itr {} / {}) dispached: {} enqueued: {} }}\",\n            type_name::\u003cA\u003e(),\n            self.sim_time(),\n            self.num_events_received(),\n            self.limit,\n            self.num_events_dispatched(),\n            self.future_event_set.len()\n        )\n    }\n}\n\nimpl\u003cA\u003e Display for Runtime\u003cA\u003e\nwhere\n    A: Application,\n{\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"Runtime\u003c{}\u003e {{ sim_time: {} (itr {} / {}) dispached: {} enqueued: {} }}\",\n            type_name::\u003cA\u003e(),\n            self.sim_time(),\n            self.num_events_received(),\n            self.limit,\n            self.num_events_dispatched(),\n            self.future_event_set.len()\n        )\n    }\n}\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":422349},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":422349},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":420270},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":420270},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":420118},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":420118},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":235960},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":236010},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":118003},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":118003},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":118003},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":342},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":121},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":97,"coverable":170},{"path":["/","Users","mk","Developer","rust","des","des","src","sync","atomic.rs"],"content":"//! A wrapper around atomics.\n//!\n//! While still cheap, atomic operations are more expensive than primitive integer\n//! operations. This difference matters, since some lock use atomics to share state.\n//! In single-threaded contexts this is not nessecary. Accordingly there are\n//! wrappers around a not-really atomic implementation of Atomics for single-thread use.\n//!\n//! Not that this implemation results in 2-3 % performance increase since\n//! atomic based locks are used in every event.\n\nuse std::{cell::UnsafeCell, sync::atomic::Ordering};\n\ncfg_not_multi_threaded! {\n    pub(crate) struct AtomicUsize {\n        v: UnsafeCell\u003cusize\u003e,\n    }\n\n    impl AtomicUsize {\n        pub(crate) const fn new(v: usize) -\u003e Self {\n            Self {\n                v: UnsafeCell::new(v),\n            }\n        }\n\n        #[allow(clippy::mut_from_ref)]\n        fn get_v(\u0026self) -\u003e \u0026mut usize {\n            unsafe { \u0026mut *self.v.get() }\n        }\n\n        pub(crate) fn get_mut(\u0026mut self) -\u003e \u0026mut usize {\n            self.get_v()\n        }\n\n        pub(crate) fn into_inner(self) -\u003e usize {\n            *self.get_v()\n        }\n\n        pub(crate) fn load(\u0026self, _order: Ordering) -\u003e usize {\n            *self.get_v()\n        }\n\n        pub(crate) fn store(\u0026self, val: usize, _order: Ordering) {\n            *self.get_v() = val;\n        }\n\n        pub(crate) fn swap(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v = val;\n            ret\n        }\n\n        pub(crate) fn compare_exchange(\n            \u0026self,\n            cur: usize,\n            new: usize,\n            suc: Ordering,\n            fail: Ordering,\n        ) -\u003e Result\u003cusize, usize\u003e {\n            let v = self.get_v();\n            if *v != cur {\n                return Err(*v);\n            }\n            Ok(self.swap(new, suc))\n        }\n\n        pub(crate) fn fetch_add(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v = v.wrapping_add(val);\n            ret\n        }\n\n        pub(crate) fn fetch_sub(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v = v.wrapping_sub(val);\n            ret\n        }\n\n        pub(crate) fn fetch_and(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v \u0026= val;\n            ret\n        }\n\n        pub(crate) fn fetch_nand(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v = !(*v \u0026 val);\n            ret\n        }\n\n        pub(crate) fn fetch_or(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v |= val;\n            ret\n        }\n\n        pub(crate) fn fetch_xor(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v ^= val;\n            ret\n        }\n    }\n\n    unsafe impl Send for AtomicUsize {}\n    unsafe impl Sync for AtomicUsize {}\n}\n\ncfg_multi_threaded! {\n    pub(crate) use std::sync::atomic::AtomicUsize;\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":36984},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":36984},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":356},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":356},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":59},{"path":["/","Users","mk","Developer","rust","des","des","src","sync","mod.rs"],"content":"#![allow(unused)]\n//! Synchronisation primitives for internal use\n//!\n//! The primitives defined here provide either specialised capabilities\n//! or a more efficient implementation if the feature multi-threaded is not\n//! set. As an example, the `RwLock` that is implemented here uses a `RefCell` inspired\n//! implementation in single-threaded contexts, which is significantly more performant.\n\nmod swaplock;\npub(crate) use self::swaplock::*;\n\nmod atomic;\npub(crate) use self::atomic::*;\n\nmod rwlock;\npub(crate) use self::rwlock::*;\n\nmod mutex;\npub(crate) use self::mutex::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","sync","mutex.rs"],"content":"cfg_not_multi_threaded! {\n    use std::{\n        cell::UnsafeCell,\n        sync::atomic::{AtomicBool, Ordering},\n        ops::{Deref, DerefMut},\n    };\n\n    #[derive(Debug)]\n    pub(crate) struct Mutex\u003cT\u003e {\n        value: UnsafeCell\u003cT\u003e,\n        locked: AtomicBool,\n    }\n\n    impl\u003cT\u003e Mutex\u003cT\u003e {\n        pub(crate) const fn new(value: T) -\u003e Self {\n            Self {\n                value: UnsafeCell::new(value),\n                locked: AtomicBool::new(false),\n            }\n        }\n\n        pub(crate) fn into_inner(self) -\u003e T {\n            self.value.into_inner()\n        }\n\n        pub(crate) fn is_locked(\u0026self) -\u003e bool {\n            self.locked.load(Ordering::SeqCst)\n        }\n\n\n        pub(crate) fn lock(\u0026self) -\u003e MutexGuard\u003c'_, T\u003e {\n            MutexGuard::new(self)\n        }\n    }\n\n    unsafe impl\u003cT: Send\u003e Send for Mutex\u003cT\u003e {}\n    unsafe impl\u003cT: Send\u003e Sync for Mutex\u003cT\u003e {}\n\n    pub(crate) struct MutexGuard\u003c'a, T\u003e {\n        inner: \u0026'a Mutex\u003cT\u003e,\n    }\n\n    impl\u003c'a, T\u003e MutexGuard\u003c'a, T\u003e {\n        fn new(inner: \u0026'a Mutex\u003cT\u003e) -\u003e Self {\n            let lock_failed = inner.locked.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed).is_err();\n            assert!(!lock_failed, \"Could not lock mutex on single thread\");\n            Self { inner }\n        }\n    }\n\n    impl\u003cT\u003e Deref for MutexGuard\u003c'_, T\u003e{\n        type Target = T;\n        fn deref(\u0026self) -\u003e \u0026T {\n            // SAFTEY lock gurantees exclusive access.\n            unsafe { \u0026*self.inner.value.get() }\n        }\n    }\n\n    impl\u003cT\u003e DerefMut for MutexGuard\u003c'_, T\u003e{\n        fn deref_mut(\u0026mut self) -\u003e \u0026mut T {\n            // SAFTEY lock gurantees exclusive access.\n            unsafe { \u0026mut *self.inner.value.get() }\n        }\n    }\n\n    impl\u003cT\u003e Drop for MutexGuard\u003c'_, T\u003e {\n        fn drop(\u0026mut self) {\n            self.inner.locked.store(false, Ordering::Release);\n        }\n    }\n}\n\ncfg_multi_threaded! {\n    pub(crate) use ::spin::mutex::*;\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":15785},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":15785},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null}],"covered":16,"coverable":20},{"path":["/","Users","mk","Developer","rust","des","des","src","sync","rwlock.rs"],"content":"//! Implements are classic non-poisonable Read-Write-Lock with an\n//! API inspired by `spin::RwLock`.\n//!\n//! In single-threaded contexts this will be implemented using a `RefCell`\n//! like structure (with appropiate API).\n//! In multi-threaded contexts, `spin::RwLock` is used.\n\ncfg_not_multi_threaded! {\n    use std::{\n        cell::{Cell, UnsafeCell},\n        marker::PhantomData,\n        ops::{Deref, DerefMut},\n        ptr::NonNull,\n    };\n\n    type BorrowFlag = isize;\n    const UNUSED: BorrowFlag = 0;\n\n    #[inline]\n    fn is_writing(x: BorrowFlag) -\u003e bool {\n        x \u003c UNUSED\n    }\n\n    #[inline]\n    fn is_reading(x: BorrowFlag) -\u003e bool {\n        x \u003e UNUSED\n    }\n\n    #[derive(Debug)]\n    pub(crate) struct RwLock\u003cT\u003e {\n        flag: Cell\u003cBorrowFlag\u003e,\n        value: UnsafeCell\u003cT\u003e,\n    }\n\n    impl\u003cT\u003e RwLock\u003cT\u003e {\n        pub(crate) const fn new(value: T) -\u003e Self {\n            Self {\n                flag: Cell::new(0),\n                value: UnsafeCell::new(value),\n            }\n        }\n\n        pub(crate) fn into_inner(self) -\u003e T {\n            self.value.into_inner()\n        }\n\n        pub(crate) fn read(\u0026self) -\u003e RwLockReadGuard\u003c'_, T\u003e {\n            self.try_read()\n                .expect(\"Failed to get read lock on single thread\")\n        }\n\n        pub(crate) fn try_read(\u0026self) -\u003e Option\u003cRwLockReadGuard\u003c'_, T\u003e\u003e {\n            let permit = ReadBorrow::new(\u0026self.flag)?;\n            let value = unsafe { NonNull::new_unchecked(self.value.get()) };\n            Some(RwLockReadGuard { permit, value })\n        }\n\n        pub(crate) fn write(\u0026self) -\u003e RwLockWriteGuard\u003c'_, T\u003e {\n            self.try_write()\n                .expect(\"Failed to get read lock on single thread\")\n        }\n\n        pub(crate) fn try_write(\u0026self) -\u003e Option\u003cRwLockWriteGuard\u003c'_, T\u003e\u003e {\n            let permit = WriteBorrow::new(\u0026self.flag)?;\n            let value = unsafe { NonNull::new_unchecked(self.value.get()) };\n            Some(RwLockWriteGuard {\n                permit,\n                value,\n                marker: PhantomData,\n            })\n        }\n    }\n\n    unsafe impl\u003cT: Send\u003e Send for RwLock\u003cT\u003e {}\n    unsafe impl\u003cT: Send + Sync\u003e Sync for RwLock\u003cT\u003e {}\n\n    pub(crate) struct RwLockReadGuard\u003c'a, T\u003e {\n        permit: ReadBorrow\u003c'a\u003e,\n        value: NonNull\u003cT\u003e,\n    }\n\n    impl\u003cT\u003e Deref for RwLockReadGuard\u003c'_, T\u003e {\n        type Target = T;\n        fn deref(\u0026self) -\u003e \u0026Self::Target {\n            unsafe { self.value.as_ref() }\n        }\n    }\n\n    impl\u003c'a, T\u003e RwLockReadGuard\u003c'a, T\u003e {\n        pub(crate) fn leak(self) -\u003e \u0026'a T {\n            std::mem::forget(self.permit);\n            unsafe { self.value.as_ref() }\n        }\n    }\n\n    unsafe impl\u003cT: Send\u003e Send for RwLockReadGuard\u003c'_, T\u003e {}\n    unsafe impl\u003cT: Send + Sync\u003e Sync for RwLockReadGuard\u003c'_, T\u003e {}\n\n    struct ReadBorrow\u003c'b\u003e {\n        cell: \u0026'b Cell\u003cBorrowFlag\u003e,\n    }\n\n    impl\u003c'b\u003e ReadBorrow\u003c'b\u003e {\n        fn new(cell: \u0026'b Cell\u003cBorrowFlag\u003e) -\u003e Option\u003cSelf\u003e {\n            let b = cell.get().wrapping_add(1);\n            if is_reading(b) {\n                cell.set(b);\n                Some(Self { cell })\n            } else {\n               None\n            }\n        }\n    }\n\n    impl Drop for ReadBorrow\u003c'_\u003e {\n        fn drop(\u0026mut self) {\n            let b = self.cell.get();\n            self.cell.set(b - 1);\n        }\n    }\n\n    impl Clone for ReadBorrow\u003c'_\u003e {\n        fn clone(\u0026self) -\u003e Self {\n            let b = self.cell.get();\n            self.cell.set(b + 1);\n            Self { cell: self.cell }\n        }\n    }\n\n    pub(crate) struct RwLockWriteGuard\u003c'a, T\u003e {\n        permit: WriteBorrow\u003c'a\u003e,\n        value: NonNull\u003cT\u003e,\n\n        marker: PhantomData\u003c\u0026'a mut T\u003e,\n    }\n\n    impl\u003cT\u003e Deref for RwLockWriteGuard\u003c'_, T\u003e {\n        type Target = T;\n        fn deref(\u0026self) -\u003e \u0026T {\n            // SAFETY: the value is accessible as long as we hold our borrow.\n            unsafe { self.value.as_ref() }\n        }\n    }\n\n    impl\u003cT\u003e DerefMut for RwLockWriteGuard\u003c'_, T\u003e {\n        fn deref_mut(\u0026mut self) -\u003e \u0026mut T {\n            // SAFETY: the value is accessible as long as we hold our borrow.\n            unsafe { self.value.as_mut() }\n        }\n    }\n\n    unsafe impl\u003cT: Send + Sync\u003e Send for RwLockWriteGuard\u003c'_, T\u003e {}\n    unsafe impl\u003cT: Send + Sync\u003e Sync for RwLockWriteGuard\u003c'_, T\u003e {}\n\n    struct WriteBorrow\u003c'b\u003e {\n        cell: \u0026'b Cell\u003cBorrowFlag\u003e,\n    }\n\n    impl\u003c'b\u003e WriteBorrow\u003c'b\u003e {\n        fn new(cell: \u0026'b Cell\u003cBorrowFlag\u003e) -\u003e Option\u003cSelf\u003e {\n            // NOTE: Unlike BorrowRefMut::clone, new is called to create the initial\n            // mutable reference, and so there must currently be no existing\n            // references. Thus, while clone increments the mutable refcount, here\n            // we explicitly only allow going from UNUSED to UNUSED - 1.\n            match cell.get() {\n                UNUSED =\u003e {\n                    cell.set(UNUSED - 1);\n                    Some(Self { cell })\n                }\n                _ =\u003e None,\n            }\n        }\n    }\n\n    impl Drop for WriteBorrow\u003c'_\u003e {\n        fn drop(\u0026mut self) {\n            let b = self.cell.get();\n            self.cell.set(b + 1);\n        }\n    }\n}\n\ncfg_multi_threaded! {\n    pub(crate) use spin::rwlock::*;\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":275982},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":236380},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":137991},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":118187},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":118187},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null}],"covered":35,"coverable":50},{"path":["/","Users","mk","Developer","rust","des","des","src","sync","swaplock.rs"],"content":"//! Implements a lock, that only provides write access using the swap\n//! method.\n//!\n//! This ensures that writes will not leak any \u0026mut T accordingly W-W conflicts cannot appear.\n//!\n//! # Contract\n//!\n//! All swap operations must be coordianted from a single thread.\n//! -\u003e simulation core runs on only one thread.\n//!\n//! All read handles must be closed when a swap is performed.\n//! -\u003e Swaps happen inbetween events, while read handles are only handed out in\n//! the event processing itself. Additionaly read handles are not leaked to the user\n//! so we can ensure all are closed at event end.\n\nuse std::sync::atomic::Ordering::SeqCst;\nuse std::{cell::UnsafeCell, marker::PhantomData, ops::Deref, rc::Rc};\n\nuse super::AtomicUsize;\n\n/// A lock that can only be accessed mutably by swapping the contents.\npub(crate) struct SwapLock\u003cT\u003e {\n    inner: UnsafeCell\u003cT\u003e,\n    read_count: AtomicUsize,\n}\n\nimpl\u003cT\u003e SwapLock\u003cT\u003e {\n    pub(crate) const fn new(inner: T) -\u003e Self {\n        Self {\n            inner: UnsafeCell::new(inner),\n            read_count: AtomicUsize::new(0),\n        }\n    }\n\n    pub(crate) unsafe fn reset(\u0026self, inner: T) {\n        *self.inner.get() = inner;\n        self.read_count.store(0, SeqCst);\n    }\n\n    pub(crate) fn swap(\u0026self, other: \u0026mut T) {\n        // SAFTEY REASONS\n        assert!(\n            self.read_count.load(SeqCst) == 0,\n            \"SwapLock cannot swap, since {} read handles are still alive\",\n            self.read_count.load(SeqCst)\n        );\n\n        let inner = unsafe { \u0026mut *self.inner.get() };\n        std::mem::swap(inner, other);\n    }\n\n    pub(crate) fn read(\u0026self) -\u003e SwapLockReadGuard\u003c'_, T\u003e {\n        SwapLockReadGuard::new(self)\n    }\n}\n\nunsafe impl\u003cT: Send\u003e Send for SwapLock\u003cT\u003e {}\nunsafe impl\u003cT: Sync\u003e Sync for SwapLock\u003cT\u003e {}\n\npub(crate) struct SwapLockReadGuard\u003c'a, T\u003e {\n    lock: \u0026'a SwapLock\u003cT\u003e,\n    _phantom: PhantomData\u003cRc\u003cT\u003e\u003e,\n}\n\nimpl\u003c'a, T\u003e SwapLockReadGuard\u003c'a, T\u003e {\n    fn new(lock: \u0026'a SwapLock\u003cT\u003e) -\u003e Self {\n        let ptr: *const SwapLock\u003cT\u003e = lock;\n        lock.read_count.fetch_add(1, SeqCst);\n        Self {\n            lock,\n            _phantom: PhantomData,\n        }\n    }\n\n    pub(crate) fn as_real_inner(\u0026self) -\u003e \u0026T {\n        unsafe { \u0026(*self.lock.inner.get()) }\n    }\n}\n\nimpl\u003c'a, T\u003e Deref for SwapLockReadGuard\u003c'a, T\u003e {\n    type Target = T;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        unsafe {\n            \u0026(*self.lock.inner.get())\n        }\n    }\n}\n\nimpl\u003c'a, T\u003e Drop for SwapLockReadGuard\u003c'a, T\u003e {\n    fn drop(\u0026mut self) {\n        let ptr: *const SwapLock\u003cT\u003e = self.lock;\n        self.lock.read_count.fetch_sub(1, SeqCst);\n    }\n}\n\nunsafe impl\u003cT: Sync\u003e Sync for SwapLockReadGuard\u003c'_, T\u003e {}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":356},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":356},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":356},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":7268},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":7268},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null}],"covered":20,"coverable":24},{"path":["/","Users","mk","Developer","rust","des","des","src","time","driver.rs"],"content":"use super::SimTime;\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::sync::{Arc, Weak};\nuse std::task::Waker;\n\nthread_local! {\n    static TIME_CTX: RefCell\u003cOption\u003cDriver\u003e\u003e = const { RefCell::new(None)}\n}\n\n#[derive(Debug)]\npub(crate) struct Driver {\n    pub(crate) next_wakeup: SimTime,\n    pub(super) queue: Arc\u003cTimerQueue\u003e,\n}\n\n#[derive(Debug)]\npub(super) struct TimerQueue {\n    cur: RefCell\u003cSimTime\u003e,\n    pending: RefCell\u003cVecDeque\u003cArc\u003cTimerSlot\u003e\u003e\u003e,\n}\n\n#[derive(Debug)]\npub(crate) struct TimerSlot {\n    time: SimTime,\n    entrys: RefCell\u003cVec\u003cTimerSlotEntry\u003e\u003e,\n    queue: Arc\u003cTimerQueue\u003e,\n}\n\n#[derive(Debug)]\npub(super) struct TimerSlotEntry {\n    pub(super) waker: Waker,\n    pub(super) id: usize,\n}\n\n#[derive(Debug)]\npub(super) struct TimerSlotEntryHandle {\n    id: usize,\n    resolved: bool,\n    handle: Weak\u003cTimerSlot\u003e,\n}\n\nimpl Drop for TimerSlotEntryHandle {\n    fn drop(\u0026mut self) {\n        if !self.resolved {\n            let Some(handle) = self.handle.upgrade() else {\n                Driver::with_current(|driver| println!(\"[{}] {:?}\", SimTime::now(), driver.queue));\n                return;\n            };\n            let _ = handle.remove(self.id);\n        }\n    }\n}\n\nimpl Driver {\n    pub(crate) fn new() -\u003e Self {\n        Self {\n            next_wakeup: SimTime::MAX,\n            queue: Arc::new(TimerQueue::new()),\n        }\n    }\n\n    pub(crate) fn set(self) -\u003e Option\u003cDriver\u003e {\n        TIME_CTX.with(|ctx| ctx.borrow_mut().replace(self))\n    }\n\n    pub(crate) fn unset() -\u003e Option\u003cDriver\u003e {\n        TIME_CTX.with(|ctx| ctx.borrow_mut().take())\n    }\n\n    pub(crate) fn next(\u0026self) -\u003e Option\u003cSimTime\u003e {\n        self.queue.next()\n    }\n\n    pub(crate) fn bump(\u0026self) -\u003e Vec\u003cTimerSlot\u003e {\n        self.queue.bump()\n    }\n\n    pub(super) fn with_current\u003cR\u003e(f: impl FnOnce(\u0026mut Driver) -\u003e R) -\u003e R {\n        TIME_CTX.with(|ctx| {\n            f(ctx\n                .borrow_mut()\n                .as_mut()\n                .expect(\"no IO time driver provided\"))\n        })\n    }\n}\n\nimpl TimerQueue {\n    fn new() -\u003e Self {\n        Self {\n            cur: RefCell::new(SimTime::ZERO),\n            pending: RefCell::new(VecDeque::new()),\n        }\n    }\n\n    pub(super) fn add(\n        self: \u0026Arc\u003cTimerQueue\u003e,\n        entry: TimerSlotEntry,\n        time: SimTime,\n    ) -\u003e TimerSlotEntryHandle {\n        let mut pending = self.pending.borrow_mut();\n        let id = entry.id;\n\n        match pending.binary_search_by(|slot| slot.time.cmp(\u0026time)) {\n            Ok(found) =\u003e {\n                pending[found].add(entry);\n                TimerSlotEntryHandle {\n                    id,\n                    handle: Arc::downgrade(\u0026pending[found]),\n                    resolved: false,\n                }\n            }\n            Err(insert_at) =\u003e {\n                let slot = TimerSlot::new(time, self.clone());\n                slot.add(entry);\n\n                pending.insert(insert_at, Arc::new(slot));\n                TimerSlotEntryHandle {\n                    id,\n                    handle: Arc::downgrade(\u0026pending[insert_at]),\n                    resolved: false,\n                }\n            }\n        }\n    }\n\n    pub(super) fn next(\u0026self) -\u003e Option\u003cSimTime\u003e {\n        self.pending\n            .borrow()\n            .front()\n            .filter(|slot| !slot.entrys.borrow().is_empty())\n            .map(|s| s.time)\n    }\n\n    pub(crate) fn bump(\u0026self) -\u003e Vec\u003cTimerSlot\u003e {\n        let cur = SimTime::now();\n        *self.cur.borrow_mut() = cur;\n        if self\n            .pending\n            .borrow()\n            .front()\n            .map_or(false, |slot| slot.time \u003c= cur)\n        {\n            let mut buffer = Vec::new();\n            let mut pending = self.pending.borrow_mut();\n            while pending\n                .front()\n                .map(|slot| slot.time \u003c= cur)\n                .unwrap_or(false)\n            {\n                let Ok(slot) = Arc::try_unwrap(pending.pop_front().expect(\"unreachable\")) else {\n                    continue;\n                };\n                buffer.push(slot)\n            }\n            buffer\n        } else {\n            Vec::new()\n        }\n    }\n}\n\nimpl TimerSlot {\n    fn new(time: SimTime, queue: Arc\u003cTimerQueue\u003e) -\u003e Self {\n        Self {\n            time,\n            queue,\n            entrys: RefCell::new(Vec::with_capacity(2)),\n        }\n    }\n\n    fn add(\u0026self, entry: TimerSlotEntry) {\n        println!(\"\u003e\u003e adding to timer slot {}\", self.time);\n        self.entrys.borrow_mut().push(entry);\n    }\n\n    fn remove(\u0026self, id: usize) -\u003e Option\u003cTimerSlotEntry\u003e {\n        println!(\"\u003e\u003e removing from timer slot {}\", self.time);\n        let mut entries = self.entrys.borrow_mut();\n        for i in 0..entries.len() {\n            if entries[i].id == id {\n                return Some(entries.remove(i));\n            }\n        }\n\n        None\n    }\n\n    pub(crate) fn wake_all(self) {\n        self.entrys\n            .into_inner()\n            .into_iter()\n            .for_each(|entry| entry.waker.wake());\n    }\n}\n\nimpl TimerSlotEntryHandle {\n    pub(super) fn resolve(\u0026mut self) {\n        self.resolved = true;\n    }\n\n    pub(super) fn reset(self, new_deadline: SimTime) -\u003e Option\u003cTimerSlotEntryHandle\u003e {\n        let handle = self.handle.upgrade()?;\n        let entry = handle.remove(self.id)?;\n        Some(handle.queue.add(entry, new_deadline))\n    }\n}\n\nunsafe impl Send for TimerSlotEntry {}\nunsafe impl Send for TimerSlotEntryHandle {}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":14124},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":4699},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":14097},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":484},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":494},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":9238},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":9219},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":9697},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":474},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":474},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":721},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":474},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":4471},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":703},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":69,"coverable":80},{"path":["/","Users","mk","Developer","rust","des","des","src","time","duration.rs"],"content":"/// A Duration type to represent a span of time.\npub use std::time::Duration;\n\nuse super::SimTime;\nuse std::ops::{Add, AddAssign};\n\nimpl Add\u003cDuration\u003e for SimTime {\n    type Output = SimTime;\n\n    fn add(self, rhs: Duration) -\u003e Self::Output {\n        self.checked_add(rhs)\n            .expect(\"Overflow when adding Duration to SimTime\")\n    }\n}\n\nimpl AddAssign\u003cDuration\u003e for SimTime {\n    fn add_assign(\u0026mut self, rhs: Duration) {\n        self.0.add_assign(rhs);\n    }\n}\n\n// f64\n\nimpl Add\u003cf64\u003e for SimTime {\n    type Output = SimTime;\n\n    fn add(self, rhs: f64) -\u003e Self::Output {\n        self.checked_add(Duration::from_secs_f64(rhs))\n            .expect(\"Overflow when adding Duration to SimTime\")\n    }\n}\n\nimpl AddAssign\u003cf64\u003e for SimTime {\n    fn add_assign(\u0026mut self, rhs: f64) {\n        self.0.add_assign(Duration::from_secs_f64(rhs));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn addition() {\n        let mut time = SimTime::from(14.2);\n        let duration = 3.4;\n\n        assert_eq!(time + duration, SimTime::from(17.6));\n        time += duration;\n        assert_eq!(time, SimTime::from(17.6));\n\n        let mut time = SimTime::from(14.2);\n        let duration = Duration::from_secs_f64(3.4);\n\n        assert_eq!(time + duration, SimTime::from(17.6));\n        time += duration;\n        assert_eq!(time, SimTime::from(17.6));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":5635},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":5635},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":100129},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":100129},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","Users","mk","Developer","rust","des","des","src","time","error.rs"],"content":"//! Time error types.\nuse std::fmt;\n\n/// Errors returned by `Timeout`.\n///\n/// This error is returned when a timeout expires before the function was able\n/// to finish.\n#[derive(Debug, PartialEq, Eq)]\npub struct Elapsed(());\n\n// ===== impl Elapsed =====\n\nimpl Elapsed {\n    pub(crate) fn new() -\u003e Self {\n        Elapsed(())\n    }\n}\n\nimpl fmt::Display for Elapsed {\n    fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        \"deadline has elapsed\".fmt(fmt)\n    }\n}\n\nimpl std::error::Error for Elapsed {}\n\nimpl From\u003cElapsed\u003e for std::io::Error {\n    fn from(_err: Elapsed) -\u003e std::io::Error {\n        std::io::ErrorKind::TimedOut.into()\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":6},{"path":["/","Users","mk","Developer","rust","des","des","src","time","interval.rs"],"content":"use super::{sleep_until, SimTime, Sleep};\nuse std::convert::TryInto;\nuse std::future::{poll_fn, Future};\nuse std::pin::Pin;\nuse std::task::{ready, Context, Poll};\nuse std::time::Duration;\n\n/// Creates new [`Interval`] that yields with interval of `period`. The first\n/// tick completes immediately. The default [`MissedTickBehavior`] is\n/// [`Burst`](MissedTickBehavior::Burst), but this can be configured\n/// by calling [`set_missed_tick_behavior`](Interval::set_missed_tick_behavior).\n///\n/// An interval will tick indefinitely. At any time, the [`Interval`] value can\n/// be dropped. This cancels the interval.\n///\n/// This function is equivalent to\n/// [`interval_at(Instant::now(), period)`](interval_at).\n///\n/// # Panics\n///\n/// This function panics if `period` is zero.\n///\n/// A simple example using `interval` to execute a task every two seconds.\n///\n/// The difference between `interval` and [`sleep`] is that an [`Interval`]\n/// measures the time since the last tick, which means that [`.tick().await`]\n/// may wait for a shorter time than the duration specified for the interval\n/// if some time has passed between calls to [`.tick().await`].\n///\n/// If the tick in the example below was replaced with [`sleep`], the task\n/// would only be executed once every three seconds, and not every two\n/// seconds.\n///\n/// [`sleep`]: crate::time::sleep()\n/// [`.tick().await`]: Interval::tick\n#[track_caller]\npub fn interval(period: Duration) -\u003e Interval {\n    assert!(period \u003e Duration::new(0, 0), \"`period` must be non-zero.\");\n    internal_interval_at(SimTime::now(), period)\n}\n\n/// Creates new [`Interval`] that yields with interval of `period` with the\n/// first tick completing at `start`. The default [`MissedTickBehavior`] is\n/// [`Burst`](MissedTickBehavior::Burst), but this can be configured\n/// by calling [`set_missed_tick_behavior`](Interval::set_missed_tick_behavior).\n///\n/// An interval will tick indefinitely. At any time, the [`Interval`] value can\n/// be dropped. This cancels the interval.\n///\n/// # Panics\n///\n/// This function panics if `period` is zero.\n///\n#[track_caller]\npub fn interval_at(start: SimTime, period: Duration) -\u003e Interval {\n    assert!(period \u003e Duration::new(0, 0), \"`period` must be non-zero.\");\n    internal_interval_at(start, period)\n}\n\n#[cfg_attr(not(all(tokio_unstable, feature = \"tracing\")), allow(unused_variables))]\nfn internal_interval_at(start: SimTime, period: Duration) -\u003e Interval {\n    let delay = Box::pin(sleep_until(start));\n\n    Interval {\n        delay,\n        period,\n        missed_tick_behavior: MissedTickBehavior::default(),\n    }\n}\n\n/// Defines the behavior of an [`Interval`] when it misses a tick.\n///\n/// Generally, a tick is missed if too much time is spent without calling\n/// [`Interval::tick()`].\n///\n/// By default, when a tick is missed, [`Interval`] fires ticks as quickly as it\n/// can until it is \"caught up\" in time to where it should be.\n/// `MissedTickBehavior` can be used to specify a different behavior for\n/// [`Interval`] to exhibit. Each variant represents a different strategy.\n///\n/// Note that because the executor cannot guarantee exact precision with timers,\n/// these strategies will only apply when the delay is greater than 5\n/// milliseconds.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum MissedTickBehavior {\n    /// Ticks as fast as possible until caught up.\n    ///\n    /// When this strategy is used, [`Interval`] schedules ticks \"normally\" (the\n    /// same as it would have if the ticks hadn't been delayed), which results\n    /// in it firing ticks as fast as possible until it is caught up in time to\n    /// where it should be. Unlike [`Delay`] and [`Skip`], the ticks yielded\n    /// when `Burst` is used (the [`SimTime`](crate::time::SimTime)s that [`tick`](Interval::tick)\n    /// yields) aren't different than they would have been if a tick had not\n    /// been missed. Like [`Skip`], and unlike [`Delay`], the ticks may be\n    /// shortened.\n    ///\n    /// This looks something like this:\n    /// ```text\n    /// Expected ticks: |     1     |     2     |     3     |     4     |     5     |     6     |\n    /// Actual ticks:   | work -----|          delay          | work | work | work -| work -----|\n    /// ```\n    ///\n    /// This is the default behavior when [`Interval`] is created with\n    /// [`interval`] and [`interval_at`].\n    ///\n    /// [`Delay`]: MissedTickBehavior::Delay\n    /// [`Skip`]: MissedTickBehavior::Skip\n    Burst,\n\n    /// Tick at multiples of `period` from when [`tick`] was called, rather than\n    /// from `start`.\n    ///\n    /// When this strategy is used and [`Interval`] has missed a tick, instead\n    /// of scheduling ticks to fire at multiples of `period` from `start` (the\n    /// time when the first tick was fired), it schedules all future ticks to\n    /// happen at a regular `period` from the point when [`tick`] was called.\n    /// Unlike [`Burst`] and [`Skip`], ticks are not shortened, and they aren't\n    /// guaranteed to happen at a multiple of `period` from `start` any longer.\n    ///\n    /// This looks something like this:\n    /// ```text\n    /// Expected ticks: |     1     |     2     |     3     |     4     |     5     |     6     |\n    /// Actual ticks:   | work -----|          delay          | work -----| work -----| work -----|\n    /// ```\n    ///\n    /// [`Burst`]: MissedTickBehavior::Burst\n    /// [`Skip`]: MissedTickBehavior::Skip\n    /// [`tick`]: Interval::tick\n    Delay,\n\n    /// Skips missed ticks and tick on the next multiple of `period` from\n    /// `start`.\n    ///\n    /// When this strategy is used, [`Interval`] schedules the next tick to fire\n    /// at the next-closest tick that is a multiple of `period` away from\n    /// `start` (the point where [`Interval`] first ticked). Like [`Burst`], all\n    /// ticks remain multiples of `period` away from `start`, but unlike\n    /// [`Burst`], the ticks may not be *one* multiple of `period` away from the\n    /// last tick. Like [`Delay`], the ticks are no longer the same as they\n    /// would have been if ticks had not been missed, but unlike [`Delay`], and\n    /// like [`Burst`], the ticks may be shortened to be less than one `period`\n    /// away from each other.\n    ///\n    /// This looks something like this:\n    /// ```text\n    /// Expected ticks: |     1     |     2     |     3     |     4     |     5     |     6     |\n    /// Actual ticks:   | work -----|          delay          | work ---| work -----| work -----|\n    /// ```\n    ///\n    /// [`Burst`]: MissedTickBehavior::Burst\n    /// [`Delay`]: MissedTickBehavior::Delay\n    Skip,\n}\n\nimpl MissedTickBehavior {\n    /// If a tick is missed, this method is called to determine when the next tick should happen.\n    fn next_timeout(self, timeout: SimTime, now: SimTime, period: Duration) -\u003e SimTime {\n        match self {\n            Self::Burst =\u003e timeout + period,\n            Self::Delay =\u003e now + period,\n            Self::Skip =\u003e {\n                now + period\n                    - Duration::from_nanos(\n                        ((now - timeout).as_nanos() % period.as_nanos())\n                            .try_into()\n                            // This operation is practically guaranteed not to\n                            // fail, as in order for it to fail, `period` would\n                            // have to be longer than `now - timeout`, and both\n                            // would have to be longer than 584 years.\n                            //\n                            // If it did fail, there's not a good way to pass\n                            // the error along to the user, so we just panic.\n                            .expect(\n                                \"too much time has elapsed since the interval was supposed to tick\",\n                            ),\n                    )\n            }\n        }\n    }\n}\n\nimpl Default for MissedTickBehavior {\n    /// Returns [`MissedTickBehavior::Burst`].\n    ///\n    /// For most usecases, the [`Burst`] strategy is what is desired.\n    /// Additionally, to preserve backwards compatibility, the [`Burst`]\n    /// strategy must be the default. For these reasons,\n    /// [`MissedTickBehavior::Burst`] is the default for [`MissedTickBehavior`].\n    /// See [`Burst`] for more details.\n    ///\n    /// [`Burst`]: MissedTickBehavior::Burst\n    fn default() -\u003e Self {\n        Self::Burst\n    }\n}\n\n/// Interval returned by [`interval`] and [`interval_at`].\n///\n/// This type allows you to wait on a sequence of instants with a certain\n/// duration between each instant. Unlike calling [`sleep`] in a loop, this lets\n/// you count the time spent between the calls to [`sleep`] as well.\n///\n/// An `Interval` can be turned into a `Stream` with [`IntervalStream`].\n///\n/// [`IntervalStream`]: https://docs.rs/tokio-stream/latest/tokio_stream/wrappers/struct.IntervalStream.html\n/// [`sleep`]: crate::time::sleep()\n#[derive(Debug)]\n#[must_use = \"futures do nothing unless you `.await` or poll them\"]\npub struct Interval {\n    /// Future that completes the next time the `Interval` yields a value.\n    delay: Pin\u003cBox\u003cSleep\u003e\u003e,\n\n    /// The duration between values yielded by `Interval`.\n    period: Duration,\n\n    /// The strategy `Interval` should use when a tick is missed.\n    missed_tick_behavior: MissedTickBehavior,\n}\n\nimpl Interval {\n    /// Completes when the next instant in the interval has been reached.\n    ///\n    /// # Cancel safety\n    ///\n    /// This method is cancellation safe. If `tick` is used as the branch in a `tokio::select!` and\n    /// another branch completes first, then no tick has been consumed.\n    pub async fn tick(\u0026mut self) -\u003e SimTime {\n        let instant = poll_fn(|cx| self.poll_tick(cx));\n        instant.await\n    }\n\n    /// Polls for the next instant in the interval to be reached.\n    ///\n    /// This method can return the following values:\n    ///\n    ///  * `Poll::Pending` if the next instant has not yet been reached.\n    ///  * `Poll::Ready(instant)` if the next instant has been reached.\n    ///\n    /// When this method returns `Poll::Pending`, the current task is scheduled\n    /// to receive a wakeup when the instant has elapsed. Note that on multiple\n    /// calls to `poll_tick`, only the [`Waker`](std::task::Waker) from the\n    /// [`Context`] passed to the most recent call is scheduled to receive a\n    /// wakeup.\n    pub fn poll_tick(\u0026mut self, cx: \u0026mut Context\u003c'_\u003e) -\u003e Poll\u003cSimTime\u003e {\n        // Wait for the delay to be done\n        ready!(Pin::new(\u0026mut self.delay).poll(cx));\n\n        // Get the time when we were scheduled to tick\n        let timeout = self.delay.deadline();\n\n        let now = SimTime::now();\n\n        // If a tick was not missed, and thus we are being called before the\n        // next tick is due, just schedule the next tick normally, one `period`\n        // after `timeout`\n        //\n        // However, if a tick took excessively long and we are now behind,\n        // schedule the next tick according to how the user specified with\n        // `MissedTickBehavior`\n        let next = if now \u003e timeout + Duration::from_millis(5) {\n            self.missed_tick_behavior\n                .next_timeout(timeout, now, self.period)\n        } else {\n            timeout + self.period\n        };\n\n        self.delay.as_mut().reset(next);\n\n        // Return the time when we were scheduled to tick\n        Poll::Ready(timeout)\n    }\n\n    /// Resets the interval to complete one period after the current time.\n    ///\n    /// This method ignores [`MissedTickBehavior`] strategy.\n    pub fn reset(\u0026mut self) {\n        self.delay.as_mut().reset(SimTime::now() + self.period);\n    }\n\n    /// Returns the [`MissedTickBehavior`] strategy currently being used.\n    #[must_use]\n    pub fn missed_tick_behavior(\u0026self) -\u003e MissedTickBehavior {\n        self.missed_tick_behavior\n    }\n\n    /// Sets the [`MissedTickBehavior`] strategy that should be used.\n    pub fn set_missed_tick_behavior(\u0026mut self, behavior: MissedTickBehavior) {\n        self.missed_tick_behavior = behavior;\n    }\n\n    /// Returns the period of the interval.\n    #[must_use]\n    pub fn period(\u0026self) -\u003e Duration {\n        self.period\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":471},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":343},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":38,"coverable":40},{"path":["/","Users","mk","Developer","rust","des","des","src","time","mod.rs"],"content":"//!\n//! Temporal quantification in a simulation context.\n//!\n//! Note that the implementation of [`SimTime`] depends on the features that\n//! are active. If features \"async\" is active, tokio provides an implementation\n//! for [`SimTime`] based on its internal feature \"sim\". If not a drop-in replacement\n//! is provided by des.\n//!\n//! # Examples\n//!\n//! A [`Duration`] describes a span of time, either in the context of\n//! real [`SystemTime`](std::time::SystemTime) or provided [`SimTime`].\n//! There are mutiple ways to create a new [`Duration`].\n//!\n//! ```rust\n//! # use des::time::*;\n//! let five_seconds = Duration::from_secs(5);\n//! assert_eq!(five_seconds, Duration::from_millis(5_000));\n//! assert_eq!(five_seconds, Duration::from_micros(5_000_000));\n//! assert_eq!(five_seconds, Duration::from_nanos(5_000_000_000));\n//!\n//! let ten_seconds = Duration::from_secs(10);\n//! let seven_nanos = Duration::from_nanos(7);\n//! let total = ten_seconds + seven_nanos;\n//! assert_eq!(total, Duration::new(10, 7));\n//! ```\n\nmod duration;\npub use duration::*;\n\nuse crate::sync::RwLock;\nuse std::f64::EPSILON;\nuse std::fmt::{Debug, Display};\nuse std::ops::{Deref, Div, Sub, SubAssign};\n\ncfg_async! {\n    pub mod error;\n\n    mod driver;\n    pub(crate) use driver::*;\n\n    mod sleep;\n    pub use sleep::*;\n\n    mod timeout;\n    pub use timeout::*;\n\n    mod interval;\n    pub use interval::*;\n}\n\nstatic SIMTIME: RwLock\u003cSimTime\u003e = RwLock::new(SimTime::ZERO);\n\n///\n/// A specific point of time in the simulation.\n///\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct SimTime(Duration);\n\nimpl SimTime {\n    /// Returns an instant corresponding to \"now\" in the simulation context.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use des::prelude::SimTime;\n    ///\n    /// let now = SimTime::now();\n    /// ```\n    #[must_use]\n    pub fn now() -\u003e Self {\n        *SIMTIME.read()\n    }\n\n    ///\n    /// Sets the sim time\n    ///\n    pub(crate) fn set_now(time: SimTime) {\n        *SIMTIME.write() = time;\n    }\n\n    ///\n    /// Constructs an instance of `SimTime` from a give duration since `SimTime::ZERO`.\n    ///\n    #[must_use]\n    pub const fn from_duration(duration: Duration) -\u003e Self {\n        Self(duration)\n    }\n\n    ///\n    /// Makes an equallity check with an error margin.\n    ///\n    #[must_use]\n    pub fn eq_approx(\u0026self, other: SimTime, error: Duration) -\u003e bool {\n        let dur = self.duration_diff(other);\n        dur \u003c error\n    }\n\n    /// Retursn the amount of time elapsed from the earlier of the two values\n    /// to the higher.\n    #[must_use]\n    pub fn duration_diff(\u0026self, other: SimTime) -\u003e Duration {\n        if *self \u003e other {\n            self.duration_since(other)\n        } else {\n            other.duration_since(*self)\n        }\n    }\n\n    /// Returns the amount of time elapsed from another instant to this one,\n    /// or zero duration if that instant is later than this one.\n    ///\n    /// # Panics\n    ///\n    /// This function  panics of the checked operation fails.\n    #[must_use]\n    pub fn duration_since(\u0026self, earlier: SimTime) -\u003e Duration {\n        self.checked_duration_since(earlier)\n            .expect(\"duration subtraction invalid\")\n    }\n\n    /// Returns the amount of time elapsed from another instant to this one,\n    /// or None if that instant is later than this one.\n    #[must_use]\n    pub fn checked_duration_since(\u0026self, earlier: SimTime) -\u003e Option\u003cDuration\u003e {\n        self.0.checked_sub(earlier.0)\n    }\n\n    /// Returns the amount of time elapsed from another instant to this one,\n    /// or zero duration if that instant is later than this one.\n    #[must_use]\n    pub fn saturating_duration_since(\u0026self, earlier: SimTime) -\u003e Duration {\n        self.checked_duration_since(earlier).unwrap_or_default()\n    }\n\n    /// Returns the amount of time elapsed since this instant was created.\n    #[must_use]\n    pub fn elapsed(\u0026self) -\u003e Duration {\n        Self::now() - *self\n    }\n\n    /// Returns `Some(t)` where `t` is the time `self + duration` if `t` can be represented as\n    /// `Instant` (which means it's inside the bounds of the underlying data structure), `None`\n    /// otherwise.\n    #[must_use]\n    pub fn checked_add(\u0026self, duration: Duration) -\u003e Option\u003cSimTime\u003e {\n        self.0.checked_add(duration).map(SimTime)\n    }\n\n    /// Returns `Some(t)` where `t` is the time `self - duration` if `t` can be represented as\n    /// `Instant` (which means it's inside the bounds of the underlying data structure), `None`\n    /// otherwise.\n    #[must_use]\n    pub fn checked_sub(\u0026self, duration: Duration) -\u003e Option\u003cSimTime\u003e {\n        self.0.checked_sub(duration).map(SimTime)\n    }\n}\n\n// # Custom Additions\nimpl SimTime {\n    /// The smallest instance of a [`SimTime`].\n    pub const ZERO: SimTime = SimTime(Duration::ZERO);\n    /// The smallest valid instance of a [`SimTime`].\n    pub const MIN: SimTime = SimTime(Duration::ZERO);\n    /// The greatest instance of a [`SimTime`].\n    pub const MAX: SimTime = SimTime(Duration::MAX);\n}\n\n// CMP\n\nimpl PartialEq\u003cf64\u003e for SimTime {\n    fn eq(\u0026self, other: \u0026f64) -\u003e bool {\n        let diff = (self.0.as_secs_f64() - *other).abs();\n        diff \u003c EPSILON\n    }\n}\n\n// OPS\n\nimpl Sub\u003cDuration\u003e for SimTime {\n    type Output = SimTime;\n\n    fn sub(self, rhs: Duration) -\u003e Self::Output {\n        self.checked_sub(rhs)\n            .expect(\"Overflow when substracting Duration from SimTime\")\n    }\n}\n\nimpl SubAssign\u003cDuration\u003e for SimTime {\n    fn sub_assign(\u0026mut self, rhs: Duration) {\n        *self = *self - rhs;\n    }\n}\n\nimpl Sub\u003cSimTime\u003e for SimTime {\n    type Output = Duration;\n\n    fn sub(self, rhs: SimTime) -\u003e Self::Output {\n        self.duration_since(rhs)\n    }\n}\n\nimpl Div\u003cSimTime\u003e for SimTime {\n    type Output = f64;\n\n    fn div(self, rhs: SimTime) -\u003e Self::Output {\n        self.0.as_secs_f64() / rhs.0.as_secs_f64()\n    }\n}\n\nimpl Div\u003cf64\u003e for SimTime {\n    type Output = SimTime;\n\n    fn div(self, rhs: f64) -\u003e Self::Output {\n        Self::from(self.0.as_secs_f64() / rhs)\n    }\n}\n\n// DEREF\n\nimpl Deref for SimTime {\n    type Target = Duration;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\n// FMT\n\nimpl Debug for SimTime {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        Debug::fmt(\u0026self.0, f)\n    }\n}\n\nimpl Display for SimTime {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        Debug::fmt(\u0026self.0, f)\n    }\n}\n\n// FROM\n\nimpl From\u003cSimTime\u003e for f64 {\n    fn from(this: SimTime) -\u003e Self {\n        this.0.as_secs_f64()\n    }\n}\n\nimpl From\u003cf64\u003e for SimTime {\n    fn from(value: f64) -\u003e Self {\n        SimTime(Duration::from_secs_f64(value))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ops() {\n        assert_eq!(\n            f64::from(SimTime::from_duration(Duration::from_millis(300))),\n            0.3\n        );\n\n        assert_eq!(SimTime::from(60.0) / 3.0, SimTime::from(20.0));\n        assert_eq!(SimTime::from(60.0) / SimTime::from(3.0), 20.0);\n\n        assert_eq!(\n            SimTime::from(30.0) - SimTime::from(10.0),\n            Duration::from_secs(20)\n        );\n        assert_eq!(SimTime::from(30.0) - Duration::from_secs(10), 20.0);\n        let mut time = SimTime::from(30.0);\n        time -= Duration::from_secs(10);\n        assert_eq!(time, 20.0);\n    }\n}\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":137979},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":137979},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":118178},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":118178},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":118050},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":118050},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":5770},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":5770},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":118191},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":118191},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":555},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":555},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":73},"fn_name":null}],"covered":39,"coverable":48},{"path":["/","Users","mk","Developer","rust","des","des","src","time","sleep.rs"],"content":"use super::{\n    driver::{Driver, TimerSlotEntry, TimerSlotEntryHandle},\n    SimTime,\n};\nuse pin_project_lite::pin_project;\nuse std::{\n    cmp::Ordering, future::Future, pin::Pin, sync::atomic::AtomicUsize, task::Poll, time::Duration,\n};\n\n/// Waits until `duration` has elapsed.\n///\n/// Equivalent to `sleep_until(Instant::now() + duration)`. An asynchronous\n/// analog to `std::thread::sleep`.\n///\n/// No work is performed while awaiting on the sleep future to complete. `Sleep`\n/// operates at millisecond granularity and should not be used for tasks that\n/// require high-resolution timers. The implementation is platform specific,\n/// and some platforms (specifically Windows) will provide timers with a\n/// larger resolution than 1 ms.\n///\n/// To run something regularly on a schedule, see [`interval`].\n///\n/// The maximum duration for a sleep is 68719476734 milliseconds (approximately 2.2 years).\n///\n/// # Cancellation\n///\n/// Canceling a sleep instance is done by dropping the returned future. No additional\n/// cleanup work is required.\n///\n/// # Panics\n///\n/// This function panics whenever a timer is created outside of a\n/// Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,\n/// since the function is executed outside of the runtime.\n/// Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.\n/// And this is because wrapping the function on an async makes it lazy,\n/// and so gets executed inside the runtime successfully without\n/// panicking.\n///\n/// [`Sleep`]: struct@crate::time::Sleep\n/// [`interval`]: crate::time::interval()\n/// [`Builder::enable_time`]: crate::runtime::Builder::enable_time\n/// [`Builder::enable_all`]: crate::runtime::Builder::enable_all\npub fn sleep(duration: Duration) -\u003e Sleep {\n    match SimTime::now().checked_add(duration) {\n        Some(deadline) =\u003e Sleep::new(deadline),\n        None =\u003e Sleep::far_future(),\n    }\n}\n\n/// Waits until `deadline` is reached.\n///\n/// No work is performed while awaiting on the sleep future to complete. `Sleep`\n/// operates at millisecond granularity and should not be used for tasks that\n/// require high-resolution timers.\n///\n/// To run something regularly on a schedule, see [`interval`].\n///\n/// # Cancellation\n///\n/// Canceling a sleep instance is done by dropping the returned future. No additional\n/// cleanup work is required.\n///\n/// # Panics\n///\n/// This function panics whenever a timer is created outside of a\n/// Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,\n/// since the function is executed outside of the runtime.\n/// Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.\n/// And this is because wrapping the function on an async makes it lazy,\n/// and so gets executed inside the runtime successfully without\n/// panicking.\n///\n/// [`Sleep`]: struct@crate::time::Sleep\n/// [`interval`]: crate::time::interval()\n/// [`Builder::enable_time`]: crate::runtime::Builder::enable_time\n/// [`Builder::enable_all`]: crate::runtime::Builder::enable_all\npub fn sleep_until(deadline: SimTime) -\u003e Sleep {\n    Sleep::new(deadline)\n}\n\npin_project! {\n    /// Future returned by [`sleep`](sleep) and [`sleep_until`](sleep_until).\n    ///\n    /// This type does not implement the `Unpin` trait, which means that if you\n    /// use it with [`select!`] or by calling `poll`, you have to pin it first.\n    /// If you use it with `.await`, this does not apply.\n    ///\n    #[project(!Unpin)]\n    #[must_use  = \"futures do nothing unless you `.await` or poll them\"]\n    #[derive(Debug)]\n    pub struct Sleep {\n        deadline: SimTime,\n        id: usize,\n\n        #[pin]\n        handle: Option\u003cTimerSlotEntryHandle\u003e\n    }\n}\n\nstatic SLEEP_ID: AtomicUsize = AtomicUsize::new(0);\n\nimpl Sleep {\n    pub(super) fn new(deadline: SimTime) -\u003e Sleep {\n        let next = SLEEP_ID.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n        Sleep {\n            deadline,\n            id: next,\n            handle: None,\n        }\n    }\n\n    pub(super) fn far_future() -\u003e Sleep {\n        Self::new(SimTime::MAX)\n    }\n\n    /// Returns the instant at which the future will complete.\n    #[must_use]\n    pub fn deadline(\u0026self) -\u003e SimTime {\n        self.deadline\n    }\n\n    /// Returns `true` if `Sleep` has elapsed.\n    ///\n    /// A `Sleep` instance is elapsed when the requested duration has elapsed.\n    #[must_use]\n    pub fn is_elapsed(\u0026self) -\u003e bool {\n        self.deadline \u003c= SimTime::now()\n    }\n\n    /// Resets the `Sleep` instance to a new deadline.\n    ///\n    /// Calling this function allows changing the instant at which the `Sleep`\n    /// future completes without having to create new associated state.\n    ///\n    /// This function can be called both before and after the future has\n    /// completed.\n    ///\n    /// To call this method, you will usually combine the call with\n    /// [`Pin::as_mut`], which lets you call the method without consuming the\n    /// `Sleep` itself.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// use des::time::{Duration, Instant};\n    ///\n    /// # #[tokio::main(flavor = \"current_thread\")]\n    /// # async fn main() {\n    /// let sleep = des::time::sleep(Duration::from_millis(10));\n    /// tokio::pin!(sleep);\n    ///\n    /// sleep.as_mut().reset(Instant::now() + Duration::from_millis(20));\n    /// # }\n    /// ```\n    ///\n    /// See also the top-level examples.\n    ///\n    /// [`Pin::as_mut`]: fn@std::pin::Pin::as_mut\n    pub fn reset(self: Pin\u003c\u0026mut Self\u003e, deadline: SimTime) {\n        self.reset_inner(deadline);\n    }\n\n    fn reset_inner(self: Pin\u003c\u0026mut Self\u003e, deadline: SimTime) {\n        let mut me = self.project();\n        if let Some(handle) = me.handle.take() {\n            // Reogranize timer calls.\n            handle.reset(deadline);\n        }\n        *me.deadline = deadline;\n    }\n}\n\nimpl Future for Sleep {\n    type Output = ();\n    fn poll(\n        self: Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cSelf::Output\u003e {\n        // A poll might come from one of three sources\n        // a) inital poll\n        // b) poll at scheduled deadline\n        // c) spurious wakeup i.e. tokio::select\n\n        let scheduled = self.handle.is_some();\n\n        // Project initaly\n\n        let mut me = self.project();\n        match (*me.deadline).cmp(\u0026SimTime::now()) {\n            Ordering::Greater =\u003e {\n                if !scheduled {\n                    let handle = Driver::with_current(|ctx| {\n                        ctx.queue.add(\n                            TimerSlotEntry {\n                                id: *me.id,\n                                waker: cx.waker().clone(),\n                            },\n                            *me.deadline,\n                        )\n                    });\n                    *me.handle = Some(handle);\n                }\n                Poll::Pending\n            }\n            _ =\u003e {\n                if let Some(mut handle) = me.handle.take() {\n                    handle.resolve();\n                }\n                Poll::Ready(())\n            }\n        }\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":481},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":481},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":481},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":481},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":485},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":484},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":243},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":696},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":238},"fn_name":null}],"covered":35,"coverable":35},{"path":["/","Users","mk","Developer","rust","des","des","src","time","timeout.rs"],"content":"//! Allows a future to execute for a maximum amount of time.\n//!\n//! See [`Timeout`] documentation for more details.\n//!\n//! [`Timeout`]: struct@Timeout\n\nuse crate::time::{error::Elapsed, sleep_until, Sleep};\nuse pin_project_lite::pin_project;\nuse std::future::Future;\nuse std::pin::Pin;\nuse std::task::{self, Poll};\nuse std::time::Duration;\n\nuse super::SimTime;\n\n/// Requires a `Future` to complete before the specified duration has elapsed.\n///\n/// If the future completes before the duration has elapsed, then the completed\n/// value is returned. Otherwise, an error is returned and the future is\n/// canceled.\n///\n/// # Cancelation\n///\n/// Cancelling a timeout is done by dropping the future. No additional cleanup\n/// or other work is required.\n///\n/// The original future may be obtained by calling [`Timeout::into_inner`]. This\n/// consumes the `Timeout`.\n///\n/// # Examples\n///\n/// Create a new `Timeout` set to expire in 10 milliseconds.\n///\n/// ```rust\n/// use des::time::timeout;\n/// use tokio::sync::oneshot;\n///\n/// use std::time::Duration;\n///\n/// # async fn dox() {\n/// let (tx, rx) = oneshot::channel();\n/// # tx.send(()).unwrap();\n///\n/// // Wrap the future with a `Timeout` set to expire in 10 milliseconds.\n/// if let Err(_) = timeout(Duration::from_millis(10), rx).await {\n///     println!(\"did not receive value within 10 ms\");\n/// }\n/// # }\n/// ```\n///\n/// # Panics\n///\n/// This function panics whenever a timer is created outside of a\n/// Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,\n/// since the function is executed outside of the runtime.\n/// Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.\n/// And this is because wrapping the function on an async makes it lazy,\n/// and so gets executed inside the runtime successfully without\n/// panicking.\n#[track_caller]\npub fn timeout\u003cT\u003e(duration: Duration, future: T) -\u003e Timeout\u003cT\u003e\nwhere\n    T: Future,\n{\n    let deadline = SimTime::now().checked_add(duration);\n    let delay = match deadline {\n        Some(deadline) =\u003e Sleep::new(deadline),\n        None =\u003e Sleep::far_future(),\n    };\n    Timeout::new_with_delay(future, delay)\n}\n\n/// Requires a `Future` to complete before the specified instant in time.\n///\n/// If the future completes before the instant is reached, then the completed\n/// value is returned. Otherwise, an error is returned.\n///\n/// # Cancelation\n///\n/// Cancelling a timeout is done by dropping the future. No additional cleanup\n/// or other work is required.\n///\n/// The original future may be obtained by calling [`Timeout::into_inner`]. This\n/// consumes the `Timeout`.\n///\n/// # Examples\n///\n/// Create a new `Timeout` set to expire in 10 milliseconds.\n///\n/// ```rust\n/// use des::time::{SimTime, timeout_at};\n/// use tokio::sync::oneshot;\n///\n/// use std::time::Duration;\n///\n/// # async fn dox() {\n/// let (tx, rx) = oneshot::channel();\n/// # tx.send(()).unwrap();\n///\n/// // Wrap the future with a `Timeout` set to expire 10 milliseconds into the\n/// // future.\n/// if let Err(_) = timeout_at(SimTime::now() + Duration::from_millis(10), rx).await {\n///     println!(\"did not receive value within 10 ms\");\n/// }\n/// # }\n/// ```\npub fn timeout_at\u003cT\u003e(deadline: SimTime, future: T) -\u003e Timeout\u003cT\u003e\nwhere\n    T: Future,\n{\n    let delay = sleep_until(deadline);\n\n    Timeout {\n        value: future,\n        delay,\n    }\n}\n\npin_project! {\n    /// Future returned by [`timeout`](timeout) and [`timeout_at`](timeout_at).\n    #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n    pub struct Timeout\u003cT\u003e {\n        #[pin]\n        value: T,\n        #[pin]\n        delay: Sleep,\n    }\n}\n\nimpl\u003cT\u003e Timeout\u003cT\u003e {\n    pub(crate) fn new_with_delay(value: T, delay: Sleep) -\u003e Timeout\u003cT\u003e {\n        Timeout { value, delay }\n    }\n\n    /// Gets a reference to the underlying value in this timeout.\n    pub fn get_ref(\u0026self) -\u003e \u0026T {\n        \u0026self.value\n    }\n\n    /// Gets a mutable reference to the underlying value in this timeout.\n    pub fn get_mut(\u0026mut self) -\u003e \u0026mut T {\n        \u0026mut self.value\n    }\n\n    /// Consumes this timeout, returning the underlying value.\n    pub fn into_inner(self) -\u003e T {\n        self.value\n    }\n}\n\nimpl\u003cT\u003e Future for Timeout\u003cT\u003e\nwhere\n    T: Future,\n{\n    type Output = Result\u003cT::Output, Elapsed\u003e;\n\n    fn poll(self: Pin\u003c\u0026mut Self\u003e, cx: \u0026mut task::Context\u003c'_\u003e) -\u003e Poll\u003cSelf::Output\u003e {\n        let me = self.project();\n\n        // First, try polling the future\n        if let Poll::Ready(v) = me.value.poll(cx) {\n            return Poll::Ready(Ok(v));\n        }\n\n        let delay = me.delay;\n\n        let poll_delay = || -\u003e Poll\u003cSelf::Output\u003e {\n            match delay.poll(cx) {\n                Poll::Ready(()) =\u003e Poll::Ready(Err(Elapsed::new())),\n                Poll::Pending =\u003e Poll::Pending,\n            }\n        };\n\n        poll_delay()\n    }\n}\n","traces":[{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":21,"coverable":25},{"path":["/","Users","mk","Developer","rust","des","des","src","tracing.rs"],"content":"//! Alternative tracing impl\n\nuse std::sync::{\n    atomic::{AtomicU64, Ordering},\n    mpsc::{self, Receiver, Sender},\n};\n\nuse crate::{\n    prelude::{ObjectPath, SimTime},\n    sync::{Mutex, RwLock},\n};\nuse fxhash::{FxBuildHasher, FxHashMap};\nuse nu_ansi_term::{Color, Style};\nuse tracing::{Level, Subscriber};\nuse tracing_subscriber::{\n    filter::Directive,\n    fmt::{format::Writer, FormatEvent, FormatFields, FormattedFields},\n    registry::LookupSpan,\n    util::SubscriberInitExt,\n    EnvFilter,\n};\n\n/// A token describing a logger scope.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct ScopeToken(u64);\n\nstatic SCOPE_CURRENT_TOKEN: AtomicU64 = AtomicU64::new(u64::MAX);\nstatic SCOPE_TOKEN_NEXT: AtomicU64 = AtomicU64::new(0);\nstatic SCOPES: std::sync::Mutex\u003cOption\u003cSender\u003c(ScopeToken, ObjectPath)\u003e\u003e\u003e =\n    std::sync::Mutex::new(None);\n\n/// Creates a new scope attached to the tracing subscriber.\n///\n/// This function is intended for internal use, but remains\n/// public, since it may be usefull in rare scenarios\n#[doc(hidden)]\npub fn new_scope(obj_path: ObjectPath) -\u003e ScopeToken {\n    let token = ScopeToken(SCOPE_TOKEN_NEXT.fetch_add(1, Ordering::SeqCst));\n    let lock = SCOPES.lock().unwrap();\n    if let Some(scopes) = \u0026*lock {\n        scopes.send((token, obj_path)).expect(\"Failed to send\");\n    } else {\n        // WARNING MAYBE\n    }\n    token\n}\n\n/// Indicates that the begin of a scope, that was allread registerd.\n///\n/// This function is intended for internal use, but remains\n/// public, since it may be usefull in rare scenarios\n#[doc(hidden)]\npub fn enter_scope(token: ScopeToken) {\n    SCOPE_CURRENT_TOKEN.store(token.0, Ordering::SeqCst);\n}\n\n/// Indicates that no scope is currently active.\n///\n/// This function is intended for internal use, but remains\n/// public, since it may be usefull in rare scenarios\n#[doc(hidden)]\npub fn leave_scope() {\n    SCOPE_CURRENT_TOKEN.store(u64::MAX, Ordering::SeqCst);\n}\n\n/// The log level that will be used if `RUST_LOG` is not defined.\npub const FALLBACK_LOG_LEVEL: Level = Level::TRACE;\n\n/// Create a new tracing subscriber with a sim formatter.\n///\n/// # Panics\n///\n/// Panics when subscriber initilization fails.\npub fn init() {\n    let subscriber = tracing_subscriber::fmt();\n    let subscriber = subscriber.event_format(format());\n    let subscriber = subscriber.with_env_filter(\n        EnvFilter::builder()\n            .with_default_directive(Directive::from(FALLBACK_LOG_LEVEL))\n            .from_env_lossy(),\n    );\n    subscriber.finish().init();\n}\n\n/// An instance of a simulation formatter.\n#[must_use]\npub fn format() -\u003e SimFormat {\n    SimFormat::init()\n}\n\n/// A formatter that includes simulation specific information into the tracing messages.\n#[derive(Debug)]\npub struct SimFormat {\n    scopes: RwLock\u003cFxHashMap\u003cu64, Scope\u003e\u003e,\n    rx: Mutex\u003cReceiver\u003c(ScopeToken, ObjectPath)\u003e\u003e,\n}\n\nunsafe impl Sync for SimFormat {}\n\n#[derive(Debug)]\nstruct Scope {\n    path: ObjectPath,\n}\n\nimpl SimFormat {\n    fn init() -\u003e SimFormat {\n        let (tx, rx) = mpsc::channel();\n        SCOPES.lock().unwrap().replace(tx);\n        SimFormat {\n            scopes: RwLock::new(FxHashMap::with_hasher(FxBuildHasher::default())),\n            rx: Mutex::new(rx),\n        }\n    }\n\n    fn fetch_scopes(\u0026self) {\n        let rx = self.rx.lock();\n        let mut scopes = self.scopes.write();\n        while let Ok((new_token, new_scope)) = rx.try_recv() {\n            scopes.insert(new_token.0, Scope { path: new_scope });\n        }\n    }\n}\n\nmacro_rules! maybe_ansi {\n    ($style:ident, $ansi:ident, $writer:ident: $($t:tt)*) =\u003e {\n        MaybeAnsi(format!($($t)*), $style, $ansi).write(\u0026mut $writer)\n    };\n}\n\nimpl\u003cS, N\u003e FormatEvent\u003cS, N\u003e for SimFormat\nwhere\n    S: Subscriber + for\u003c'a\u003e LookupSpan\u003c'a\u003e,\n    N: for\u003c'a\u003e FormatFields\u003c'a\u003e + 'static,\n{\n    fn format_event(\n        \u0026self,\n        ctx: \u0026tracing_subscriber::fmt::FmtContext\u003c'_, S, N\u003e,\n        mut writer: tracing_subscriber::fmt::format::Writer\u003c'_\u003e,\n        event: \u0026tracing::Event\u003c'_\u003e,\n    ) -\u003e std::fmt::Result {\n        let meta = event.metadata();\n        let ansi = writer.has_ansi_escapes();\n\n        let dimmed = Style::new().dimmed();\n        let bold = Style::new().bold();\n\n        maybe_ansi!(dimmed, ansi, writer: \"[ {:?} ] \", SimTime::now())?;\n\n        let style = match *meta.level() {\n            Level::TRACE =\u003e Style::new().fg(Color::Cyan),\n            Level::DEBUG =\u003e Style::new().fg(Color::Purple),\n            Level::INFO =\u003e Style::new().fg(Color::Green),\n            Level::WARN =\u003e Style::new().fg(Color::Yellow),\n            Level::ERROR =\u003e Style::new().fg(Color::Red),\n        };\n\n        self.fetch_scopes();\n        let scope_id = SCOPE_CURRENT_TOKEN.load(Ordering::SeqCst);\n        let scopes = self.scopes.read();\n\n        if let Some(scope) = scopes.get(\u0026scope_id) {\n            if !ansi {\n                write!(writer, \"{} \", meta.level().as_str())?;\n            }\n            maybe_ansi!(style, ansi, writer: \"{} \", scope.path)?;\n        } else {\n            maybe_ansi!(style, ansi, writer: \"{} \", meta.level().as_str())?;\n        }\n\n        if let Some(scope) = ctx.event_scope() {\n            let mut seen = false;\n            for span in scope.from_root() {\n                maybe_ansi!(bold, ansi, writer: \"{}\", span.metadata().name())?;\n                seen = true;\n                let ext = span.extensions();\n                if let Some(fields) = \u0026ext.get::\u003cFormattedFields\u003cN\u003e\u003e() {\n                    if !fields.is_empty() {\n                        maybe_ansi!(bold, ansi, writer: \"{{\")?;\n                        write!(writer, \"{fields}\")?;\n                        maybe_ansi!(bold, ansi, writer: \"}}\")?;\n                    }\n                }\n                maybe_ansi!(dimmed, ansi, writer: \":\")?;\n            }\n\n            if seen {\n                writer.write_char(' ')?;\n            }\n        }\n\n        maybe_ansi!(dimmed, ansi, writer: \"{}: \", meta.target())?;\n\n        ctx.format_fields(writer.by_ref(), event)?;\n        writeln!(writer)\n    }\n}\n\nstruct MaybeAnsi(String, Style, bool);\n\nimpl MaybeAnsi {\n    fn write(self, writer: \u0026mut Writer\u003c'_\u003e) -\u003e std::fmt::Result {\n        if self.2 {\n            write!(writer, \"{}\", self.1.prefix())?;\n            write!(writer, \"{}\", self.0)?;\n            write!(writer, \"{}\", self.1.suffix())\n        } else {\n            write!(writer, \"{}\", self.0)\n        }\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":253},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":16928},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":16928},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4809},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4809},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":45},"fn_name":null}],"covered":64,"coverable":72},{"path":["/","Users","mk","Developer","rust","des","des","tests","_require_full.rs"],"content":"#![cfg(not(feature = \"full\"))]\ncompile_error!(\"des main tests required cfg(feature = full)\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","tests","async.rs"],"content":"#![cfg(feature = \"async\")]\n#![allow(unused_variables)]\n\nuse des::{\n    net::AsyncFn,\n    prelude::*,\n    time::{self, sleep, timeout, timeout_at, MissedTickBehavior},\n};\nuse std::sync::{\n    atomic::{AtomicBool, AtomicUsize, Ordering},\n    Arc,\n};\nuse tokio::{\n    sync::{\n        mpsc::{self, channel, Sender},\n        Semaphore,\n    },\n    task::JoinHandle,\n};\n\nuse serial_test::serial;\n\n// # Test case\n// The module behaves like a sync module, not creating any more\n// futures than the async call itself.\n\n#[derive(Default)]\nstruct QuasaiSyncModule {\n    counter: usize,\n}\n\nimpl AsyncModule for QuasaiSyncModule {\n    async fn handle_message(\u0026mut self, msg: Message) {\n        println!(\"[{}] Received msg: {}\", current().name(), msg.header().id);\n        self.counter += msg.header().id as usize;\n    }\n}\n\n#[test]\n#[serial]\nfn quasai_sync_non_blocking() {\n    let mut rt = Sim::new(());\n    rt.node(\"root\", QuasaiSyncModule::default());\n    rt.node(\"other\", QuasaiSyncModule::default());\n\n    let gate_a = rt.gate(\"root\", \"a\");\n    let gate_b = rt.gate(\"other\", \"b\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n\n    rt.add_message_onto(gate_a.clone(), Message::new().id(1).build(), SimTime::ZERO);\n    rt.add_message_onto(gate_a, Message::new().id(2).build(), SimTime::ZERO);\n\n    rt.add_message_onto(gate_b.clone(), Message::new().id(1).build(), SimTime::ZERO);\n    rt.add_message_onto(gate_b.clone(), Message::new().id(2).build(), SimTime::ZERO);\n    rt.add_message_onto(gate_b, Message::new().id(3).build(), SimTime::ZERO);\n\n    let result = rt.run();\n    match result {\n        RuntimeResult::Finished {\n            app,\n            time,\n            profiler,\n        } =\u003e {\n            assert_eq!(time, SimTime::ZERO);\n            assert_eq!(profiler.event_count, 10);\n        }\n        _ =\u003e panic!(\"Expected runtime to finish\"),\n    }\n}\n\n// # Test case\n// A module has 3 permantent tasks that each forward\n// the message, the final one incrementing a module bound\n// tracker\n// The tasks shutdown with a shutdown message\n\n#[derive(Default)]\nstruct MutipleTasksModule {\n    handles: Vec\u003cJoinHandle\u003c()\u003e\u003e,\n    sender: Option\u003cSender\u003cMessage\u003e\u003e,\n    result: Arc\u003cAtomicUsize\u003e,\n}\n\nimpl AsyncModule for MutipleTasksModule {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        let (txa, mut rxa) = channel::\u003cMessage\u003e(8);\n        let (txb, mut rxb) = channel(8);\n        let (txc, mut rxc) = channel(8);\n\n        let result = self.result.clone();\n\n        let ta = tokio::spawn(async move {\n            while let Some(v) = rxa.recv().await {\n                let k = v.header().kind;\n                txb.send(v).await.unwrap();\n\n                if k == 42 {\n                    rxa.close();\n                    txb.closed().await;\n                }\n            }\n        });\n\n        let tb = tokio::spawn(async move {\n            while let Some(v) = rxb.recv().await {\n                let k = v.header().kind;\n                txc.send(v).await.unwrap();\n\n                if k == 42 {\n                    rxb.close();\n                    txc.closed().await;\n                }\n            }\n        });\n\n        let tc = tokio::spawn(async move {\n            while let Some(v) = rxc.recv().await {\n                let k = v.header().kind;\n                result.fetch_add(v.header().id as usize, std::sync::atomic::Ordering::SeqCst);\n\n                if k == 42 {\n                    rxc.close();\n                }\n            }\n        });\n\n        self.sender = Some(txa);\n        self.handles.push(ta);\n        self.handles.push(tb);\n        self.handles.push(tc);\n    }\n\n    async fn at_sim_end(\u0026mut self) {\n        self.sender\n            .take()\n            .unwrap()\n            .send(Message::new().kind(42).build())\n            .await\n            .unwrap();\n\n        for join in self.handles.drain(..) {\n            join.await.unwrap()\n        }\n\n        self.result\n            .fetch_add(100, std::sync::atomic::Ordering::SeqCst);\n    }\n\n    async fn handle_message(\u0026mut self, msg: Message) {\n        self.sender.as_ref().unwrap().send(msg).await.unwrap()\n    }\n}\n\n#[test]\n#[serial]\nfn mutiple_active_tasks() {\n    let mut rt = Sim::new(());\n    rt.node(\"root\", MutipleTasksModule::default());\n\n    let gate_a = rt.gate(\"root\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n\n    rt.add_message_onto(gate_a.clone(), Message::new().id(1).build(), SimTime::ZERO);\n    rt.add_message_onto(gate_a, Message::new().id(2).build(), SimTime::ZERO);\n\n    let result = rt.run();\n    match result {\n        RuntimeResult::Finished {\n            app,\n            time,\n            profiler,\n        } =\u003e {\n            assert_eq!(time, SimTime::ZERO);\n\n            //  2 * (Gate + HandleMessage)\n            assert_eq!(profiler.event_count, 4);\n\n            // let m1 = app\n            //     .module(|m| m.module_core().name() == \"RootModule\")\n            //     .unwrap()\n            //     .self_as::\u003cMutipleTasksModule\u003e()\n            //     .unwrap();\n\n            // assert_eq!(m1.result.load(std::sync::atomic::Ordering::SeqCst), 100 + 3);\n        }\n        _ =\u003e panic!(\"Expected runtime to finish\"),\n    }\n}\n\n// # Test case\n// A module sleeps upon receiving a message,\n// This sleeps do NOT interfere with recv()\n\n#[derive(Default)]\nstruct TimeSleepModule {\n    counter: usize,\n}\n\nimpl AsyncModule for TimeSleepModule {\n    async fn handle_message(\u0026mut self, msg: Message) {\n        tracing::debug!(\"recv msg: {}\", msg.str());\n        let wait_time = msg.header().kind as u64;\n        tracing::info!(\n            \"\u003c{}\u003e [{}] Waiting for timer\",\n            current().name(),\n            SimTime::now()\n        );\n        sleep(Duration::from_secs(wait_time)).await;\n        tracing::info!(\n            \"\u003c{}\u003e [{}] Done waiting for id: {}\",\n            current().name(),\n            SimTime::now(),\n            msg.header().id\n        );\n        self.counter += msg.header().id as usize\n    }\n}\n\n#[test]\n#[serial]\nfn one_module_timers() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", TimeSleepModule::default());\n\n    let gate_a = rt.gate(\"root\", \"a\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n\n    rt.add_message_onto(\n        gate_a.clone(),\n        Message::new().id(1).kind(1).build(),\n        SimTime::ZERO,\n    );\n    rt.add_message_onto(\n        gate_a,\n        Message::new().id(2).kind(2).build(),\n        SimTime::from_duration(Duration::new(2, 0)),\n    );\n\n    let result = rt.run();\n    match result {\n        RuntimeResult::Finished {\n            app,\n            time,\n            profiler,\n        } =\u003e {\n            assert_eq!(time, 4.0);\n            assert_eq!(profiler.event_count, 6);\n        }\n        _ =\u003e panic!(\"Expected runtime to finish\"),\n    }\n}\n\n// # Test case\n// The module sleeps on message receival\n// The sleeps should delay the next recv.\n\n#[test]\n#[serial]\nfn one_module_delayed_recv() {\n    let mut rt = Sim::new(());\n    rt.node(\"root\", TimeSleepModule::default());\n\n    let gate_a = rt.gate(\"root\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n\n    rt.add_message_onto(\n        gate_a.clone(),\n        Message::new().id(1).kind(2).build(),\n        SimTime::ZERO,\n    );\n    rt.add_message_onto(\n        gate_a,\n        Message::new().id(2).kind(2).build(),\n        SimTime::from_duration(Duration::new(2, 0)),\n    );\n\n    let result = rt.run();\n    match result {\n        RuntimeResult::Finished {\n            app,\n            time,\n            profiler,\n        } =\u003e {\n            assert_eq!(time, 4.0);\n\n            // 1) Gate #1 (0s)\n            // 2) HandleMessage #1 (0s)\n            // 3) Gate #2 (2s)\n            // 4) HandleMessage #2 (2s) (will finish sleep but wakeup was added later)\n            // 5) Wakeup aka NOP (2s)\n            // 6) Wakeup - sleep reloved - send in '5 (4s)\n            assert_eq!(profiler.event_count, 6);\n\n            // let m1 = app\n            //     .module(|m| m.module_core().name() == \"RootModule\")\n            //     .unwrap()\n            //     .self_as::\u003cTimeSleepModule\u003e()\n            //     .unwrap();\n\n            // assert_eq!(m1.counter, 3);\n        }\n        _ =\u003e panic!(\"Expected runtime to finish\"),\n    }\n}\n\n// # Test case\n// Mutiple Modules delay themself with sleeps\n\n#[test]\n#[serial]\nfn mutiple_module_delayed_recv() {\n    let mut rt = Sim::new(());\n    rt.node(\"a\", TimeSleepModule::default());\n    rt.node(\"b\", TimeSleepModule::default());\n\n    let gate_a = rt.gate(\"a\", \"in\");\n    let gate_b = rt.gate(\"b\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n\n    // # Module 1\n    //  |0  |1  |2  |3  |4  |5  |6\n    //       \u003cID=1_\u003e\n    //          ....\u003cID=2_\u003e\n    rt.add_message_onto(\n        gate_a.clone(),\n        Message::new().id(1).kind(2).build(),\n        SimTime::from_duration(Duration::new(1, 0)),\n    );\n    rt.add_message_onto(\n        gate_a,\n        Message::new().id(2).kind(2).build(),\n        SimTime::from_duration(Duration::new(2, 0)),\n    );\n\n    // # Module 1\n    //  |0  |1  |2  |3  |4  |5  |6\n    //      \u003cID\u003e\n    //          \u003cID=20\u003e\n    rt.add_message_onto(\n        gate_b.clone(),\n        Message::new().id(10).kind(1).build(),\n        SimTime::from_duration(Duration::new(1, 0)),\n    );\n    rt.add_message_onto(\n        gate_b,\n        Message::new().id(20).kind(2).build(),\n        SimTime::from_duration(Duration::new(2, 0)),\n    );\n\n    let result = rt.run();\n    match result {\n        RuntimeResult::Finished {\n            app,\n            time,\n            profiler,\n        } =\u003e {\n            assert_eq!(time, 5.0);\n\n            assert_eq!(profiler.event_count, 12);\n\n            // let m1 = app\n            //     .module(|m| m.module_core().name() == \"RootModule\")\n            //     .unwrap()\n            //     .self_as::\u003cTimeSleepModule\u003e()\n            //     .unwrap();\n\n            // assert_eq!(m1.counter, 3);\n\n            // let m2 = app\n            //     .module(|m| m.module_core().name() == \"OtherRootModule\")\n            //     .unwrap()\n            //     .self_as::\u003cTimeSleepModule\u003e()\n            //     .unwrap();\n\n            // assert_eq!(m2.counter, 30);\n        }\n        _ =\u003e panic!(\"Expected runtime to finish\"),\n    }\n}\n\nstruct SemaphoreModule {\n    semaphore: Arc\u003cSemaphore\u003e,\n    handle: Option\u003cJoinHandle\u003c()\u003e\u003e,\n    result: Arc\u003cAtomicBool\u003e,\n}\n\nimpl Default for SemaphoreModule {\n    fn default() -\u003e Self {\n        Self {\n            semaphore: Arc::new(Semaphore::new(0)),\n            handle: None,\n            result: Arc::new(AtomicBool::new(false)),\n        }\n    }\n}\n\nimpl AsyncModule for SemaphoreModule {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        let sem = self.semaphore.clone();\n        let res = self.result.clone();\n        self.handle = Some(tokio::spawn(async move {\n            let premit = sem.acquire_many(5).await.unwrap();\n            println!(\"[{}] Aquired semaphore\", SimTime::now());\n            res.fetch_or(true, std::sync::atomic::Ordering::SeqCst);\n            drop(premit)\n        }));\n    }\n\n    async fn handle_message(\u0026mut self, msg: Message) {\n        self.semaphore.add_permits(msg.header().kind as usize);\n    }\n}\n\n#[test]\n#[serial]\nfn semaphore_in_waiting_task() {\n    let mut rt = Sim::new(());\n    rt.node(\"a\", SemaphoreModule::default());\n    rt.node(\"b\", SemaphoreModule::default());\n\n    let gate_a = rt.gate(\"a\", \"in\");\n    let gate_b = rt.gate(\"b\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n\n    rt.add_message_onto(\n        gate_a.clone(),\n        Message::new().id(1).kind(2).build(),\n        SimTime::from_duration(Duration::new(1, 0)),\n    );\n    rt.add_message_onto(\n        gate_a,\n        Message::new().id(2).kind(3).build(),\n        SimTime::from_duration(Duration::new(2, 0)),\n    );\n\n    rt.add_message_onto(\n        gate_b.clone(),\n        Message::new().id(10).kind(2).build(),\n        SimTime::from_duration(Duration::new(1, 0)),\n    );\n    rt.add_message_onto(\n        gate_b.clone(),\n        Message::new().id(20).kind(2).build(),\n        SimTime::from_duration(Duration::new(2, 0)),\n    );\n    rt.add_message_onto(\n        gate_b,\n        Message::new().id(20).kind(1).build(),\n        SimTime::from_duration(Duration::new(3, 0)),\n    );\n\n    let result = rt.run();\n    match result {\n        RuntimeResult::Finished {\n            app,\n            time,\n            profiler,\n        } =\u003e {\n            assert_eq!(time, 3.0);\n            assert_eq!(profiler.event_count, 10);\n        }\n        _ =\u003e panic!(\"Expected runtime to finish\"),\n    }\n}\n\n#[test]\n#[serial]\nfn async_time_sleep_far_future() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|rx| async move {\n            assert_eq!(SimTime::now(), 0.0);\n            time::sleep_until(10.0.into()).await;\n            assert_eq!(SimTime::now(), 10.0);\n            let sleep = time::sleep(Duration::MAX);\n            assert_eq!(sleep.deadline(), SimTime::MAX);\n            assert!(!sleep.is_elapsed());\n\n            sleep.await;\n            panic!(\"should never be reached\");\n        }),\n    );\n\n    let result = Builder::seeded(123).build(sim).run();\n    assert_eq!(result.unwrap().1, 10.0);\n}\n\n#[test]\n#[serial]\nfn async_time_sleep_select() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|rx| async move {\n            tokio::select! {\n                _ = time::sleep(Duration::from_secs(10)) =\u003e unreachable!(),\n                _ = time::sleep(Duration::from_secs(5)) =\u003e println!(\"resolved\"),\n            }\n        })\n        .require_join(),\n    );\n\n    let result = Builder::seeded(123).build(sim).run().unwrap();\n    assert_eq!(result.1, 5.0);\n    assert_eq!(result.2.event_count, 1); // Just async wakeup for 5s, 10s will never be scheduled\n}\n\n#[test]\n#[serial]\nfn async_time_sleep_reset() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|rx| async move {\n            let sleep = time::sleep(Duration::from_secs(5));\n            tokio::pin!(sleep);\n\n            sleep.as_mut().reset(10.0.into());\n            sleep.await\n        })\n        .require_join(),\n    );\n\n    let result = Builder::seeded(123).build(sim).run().unwrap();\n    assert_eq!(result.1, 10.0);\n    assert_eq!(result.2.event_count, 1); // Just async wakeup for 10s, 5s was not yet scheduled\n}\n\n#[test]\n#[serial]\nfn async_time_timeout() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|rx| async move {\n            let result: Result\u003ci32, time::error::Elapsed\u003e =\n                timeout(Duration::from_secs(10), std::future::pending()).await;\n            assert!(result.is_err());\n\n            let (tx, mut rx) = mpsc::channel(1);\n\n            let handle = tokio::spawn(async move {\n                time::sleep(Duration::from_secs(5)).await;\n                tx.send(42).await.unwrap();\n            });\n\n            let result: Result\u003cOption\u003ci32\u003e, time::error::Elapsed\u003e =\n                timeout_at(20.0.into(), rx.recv()).await;\n            assert_eq!(result, Ok(Some(42)));\n\n            handle.await.unwrap();\n        })\n        .require_join(),\n    );\n\n    let result = Builder::seeded(123).build(sim).run().unwrap();\n    assert_eq!(result.1, 15.0);\n    // why 15s?\n    // wakeup 20s will never be scheduled, since\n    // -\u003e wakeup 15s from tokio::task is allready scheduled\n    // -\u003e upon completion of 15s timeout 20s is allready removed\n}\n\n#[test]\n#[serial]\nfn async_time_timeout_far_future() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|rx| async move {\n            // add a sleep to get a nonempty sim\n            time::sleep(Duration::from_secs(42)).await;\n\n            let mut timeout = timeout(Duration::MAX, std::future::pending());\n            let _: \u0026std::future::Pending\u003ci32\u003e = timeout.get_ref();\n            let _: \u0026mut std::future::Pending\u003ci32\u003e = timeout.get_mut();\n\n            let result: Result\u003ci32, time::error::Elapsed\u003e = timeout.await;\n            panic!(\"will never be reached\")\n        }),\n    );\n\n    let result = Builder::seeded(123).build(sim).run().unwrap();\n    assert_eq!(result.1, 42.0);\n}\n\n#[test]\n#[serial]\nfn async_time_interval() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|rx| async move {\n            // (0) No missed ticks\n            let counter = Arc::new(AtomicUsize::new(0));\n\n            let c = counter.clone();\n            tokio::spawn(async move {\n                let mut interval = time::interval(Duration::from_secs(1));\n                assert_eq!(interval.period(), Duration::from_secs(1));\n                assert_eq!(\n                    interval.missed_tick_behavior(),\n                    MissedTickBehavior::default()\n                );\n\n                loop {\n                    interval.tick().await;\n                    c.fetch_add(1, Ordering::SeqCst);\n                }\n            });\n\n            time::sleep(Duration::from_secs_f64(7.5)).await;\n            assert_eq!(counter.load(Ordering::SeqCst), 1 + 7);\n        }),\n    );\n\n    let _ = Builder::seeded(123).max_time(100.0.into()).build(sim).run();\n}\n\n#[test]\n#[serial]\nfn async_time_interval_missed_tick_behaviour() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"burst\",\n        AsyncFn::new(|rx| async move {\n            // (0) No missed ticks\n            let mut interval = time::interval(Duration::from_secs(1));\n            interval.set_missed_tick_behavior(MissedTickBehavior::Burst);\n\n            time::sleep(Duration::from_secs_f64(4.5)).await;\n\n            for _ in 0..6 {\n                // expected ticks at 0, 1, 2, 3, 4, 5\n                // got at 4.5, ..., 4.5, 5\n                interval.tick().await;\n            }\n            assert_eq!(SimTime::now(), 5.0);\n        }),\n    );\n\n    sim.node(\n        \"delay\",\n        AsyncFn::new(|rx| async move {\n            // (0) No missed ticks\n            let mut interval = time::interval(Duration::from_secs(1));\n            interval.set_missed_tick_behavior(MissedTickBehavior::Delay);\n            let mut last = SimTime::now();\n\n            time::sleep(Duration::from_secs_f64(4.5)).await;\n\n            for i in 0..6 {\n                // expected ticks at 0, 1, 2, 3, 4, 5\n                // got at 4.5, ..., 4.5, 5\n                interval.tick().await;\n                if i != 0 {\n                    assert_eq!(SimTime::now(), last + 1.0);\n                }\n                last = SimTime::now();\n            }\n\n            assert_eq!(SimTime::now(), 4.5 + 5.0);\n        }),\n    );\n\n    sim.node(\n        \"skip\",\n        AsyncFn::new(|rx| async move {\n            // (0) No missed ticks\n            let mut interval = time::interval_at(0.0.into(), Duration::from_secs(1));\n            interval.set_missed_tick_behavior(MissedTickBehavior::Skip);\n\n            time::sleep(Duration::from_secs_f64(4.5)).await;\n\n            for i in 0..6 {\n                // expected ticks at 0, 1, 2, 3, 4, 5\n                // got at 4.5, ..., 4.5, 5\n                interval.tick().await;\n                if i != 0 {\n                    assert_eq!(SimTime::now().subsec_millis(), 0);\n                }\n            }\n\n            assert_eq!(SimTime::from(5.0).elapsed(), Duration::from_secs(4));\n            assert_eq!(SimTime::now(), 9.0);\n        }),\n    );\n\n    let _ = Builder::seeded(123).max_time(100.0.into()).build(sim).run();\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":61,"coverable":67},{"path":["/","Users","mk","Developer","rust","des","des","tests","basic-runtime.rs"],"content":"use des::{prelude::*, runtime::RuntimeLimit};\nuse rand::{distributions::Standard, prelude::SliceRandom, Rng};\nuse serial_test::serial;\n\n/// The Event ste\n#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\nenum MyEventSet {\n    RegisterToRtWithTime(RegisterToRtWithTime),\n    B(B),\n    RepeatWithDelay(RepeatWithDelay),\n}\n\nimpl EventSet\u003cApp\u003e for MyEventSet {\n    fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {\n        match self {\n            Self::RegisterToRtWithTime(a) =\u003e a.handle(rt),\n            Self::B(b) =\u003e b.handle(rt),\n            Self::RepeatWithDelay(rwd) =\u003e rwd.handle(rt),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\nstruct RegisterToRtWithTime {\n    id: usize,\n}\n\nimpl RegisterToRtWithTime {\n    fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {\n        rt.app\n            .event_list\n            .push((SimTime::now(), MyEventSet::RegisterToRtWithTime(self)))\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\nstruct B {\n    id: usize,\n}\n\nimpl B {\n    fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {\n        rt.app\n            .event_list\n            .push((SimTime::now(), MyEventSet::B(self)))\n    }\n}\n\n/// The application\nstruct App {\n    event_list: Vec\u003c(SimTime, MyEventSet)\u003e,\n}\n\nimpl Application for App {\n    type EventSet = MyEventSet;\n    type Lifecycle = ();\n}\n\n#[test]\n#[serial]\nfn zero_event_runtime() {\n    let rt = Builder::seeded(123).build(App {\n        event_list: Vec::new(),\n    });\n\n    let res = rt.run();\n    assert!(matches!(res, RuntimeResult::EmptySimulation { .. }))\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\nstruct RepeatWithDelay {\n    delay: Duration,\n    repeat: usize,\n    repeat_limit: usize,\n}\nimpl RepeatWithDelay {\n    fn handle(mut self, rt: \u0026mut Runtime\u003cApp\u003e) {\n        if self.repeat \u003c= self.repeat_limit {\n            let delay = self.delay;\n            self.repeat += 1;\n            rt.add_event_in(MyEventSet::RepeatWithDelay(self), delay)\n        }\n    }\n}\n\n#[test]\n#[serial]\nfn one_event_runtime() {\n    let mut rt = Builder::new().build(App {\n        event_list: Vec::new(),\n    });\n    rt.add_event(\n        MyEventSet::RepeatWithDelay(RepeatWithDelay {\n            delay: Duration::new(1, 0),\n            repeat: 0,\n            repeat_limit: 15,\n        }),\n        SimTime::ZERO,\n    );\n\n    // repeat i = i secs\n    // limit (\u003c=) is at 15s thus time limit 16s\n    // this means 17 events\n\n    let res = rt.run();\n    match res {\n        RuntimeResult::Finished { time, profiler, .. } =\u003e {\n            assert_eq!(time, SimTime::from_duration(Duration::new(16, 0)));\n            assert_eq!(profiler.event_count, 17);\n        }\n        _ =\u003e panic!(\"Runtime should have finished\"),\n    }\n}\n\n#[test]\n#[serial]\nfn ensure_event_order() {\n    use rand::{rngs::StdRng, SeedableRng};\n\n    let mut id = 0;\n    let mut events = Vec::with_capacity(128);\n    let mut time = SimTime::ZERO;\n\n    let mut rng = StdRng::seed_from_u64(123);\n\n    for _i in 0..128 {\n        time += rng.sample::\u003cf64, Standard\u003e(Standard);\n        id += 1;\n\n        events.push((\n            MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime { id }),\n            time,\n        ));\n    }\n\n    events.shuffle(\u0026mut rng);\n\n    let mut rt: Runtime\u003cApp\u003e = Builder::seeded(123).build(App {\n        event_list: Vec::with_capacity(128),\n    });\n\n    for (event, time) in events {\n        rt.add_event(event, time);\n    }\n\n    match rt.run() {\n        RuntimeResult::Finished {\n            app,\n            time: rt_fin_time,\n            profiler,\n        } =\u003e {\n            assert_eq!(rt_fin_time, time);\n            assert_eq!(profiler.event_count, 128);\n\n            let mut last_id = 0;\n            for (_, event) in app.event_list {\n                match event {\n                    MyEventSet::RegisterToRtWithTime(a) =\u003e {\n                        assert_eq!(last_id + 1, a.id);\n                        last_id += 1;\n                    }\n                    _ =\u003e panic!(\"Unexpected event\"),\n                }\n            }\n        }\n        _ =\u003e panic!(\"Expected runtime to finish after fininte non-replicating event set\"),\n    }\n}\n\n#[test]\n#[cfg(not(feature = \"cqueue\"))]\n#[serial]\nfn ensure_event_order_same_time() {\n    StandardLogger::active(false);\n\n    let one = SimTime::from_duration(Duration::new(1, 0));\n    let two = SimTime::from_duration(Duration::new(2, 0));\n\n    let events = vec![\n        (\n            MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime { id: 1 }),\n            SimTime::ZERO,\n        ),\n        (\n            MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime { id: 2 }),\n            one,\n        ),\n        (\n            MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime { id: 3 }),\n            one,\n        ),\n        (\n            MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime { id: 4 }),\n            one,\n        ),\n        (\n            MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime { id: 5 }),\n            two,\n        ),\n    ];\n\n    let mut rt: Runtime\u003cApp\u003e = Builder::seeded(123).build(App {\n        event_list: Vec::with_capacity(32),\n    });\n\n    for (event, time) in events {\n        rt.add_event(event, time);\n    }\n\n    match rt.run() {\n        RuntimeResult::Finished {\n            app,\n            time: rt_fin_time,\n            event_count,\n        } =\u003e {\n            assert_eq!(rt_fin_time, two);\n            assert_eq!(event_count, 5);\n\n            let mut last_id = 0;\n            for (_, event) in app.event_list {\n                match event {\n                    MyEventSet::RegisterToRtWithTime(a) =\u003e {\n                        assert_eq!(last_id + 1, a.id);\n                        last_id += 1;\n                    }\n                    _ =\u003e panic!(\"Unexpected event\"),\n                }\n            }\n        }\n        _ =\u003e panic!(\"Expected runtime to finish after fininte non-replicating event set\"),\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct EventBox {\n    time: SimTime,\n    events: Vec\u003cMyEventSet\u003e,\n}\n\nconst N: usize = 100_000;\n\n#[test]\n#[serial]\nfn full_test_n_100_000() {\n    let mut rt: Runtime\u003cApp\u003e = Builder::seeded(123).build(App {\n        event_list: Vec::with_capacity(N),\n    });\n\n    let mut events = Vec::with_capacity(N);\n\n    // create a event set\n    let mut t = SimTime::ZERO;\n    for _ in 0..N {\n        let num_box_elements = rt.random::\u003cusize\u003e() % 100;\n        let num_box_elements = if num_box_elements \u003c 5 {\n            num_box_elements + 1\n        } else {\n            1\n        };\n\n        let mut boxed = EventBox {\n            events: Vec::new(),\n            time: t,\n        };\n        for _ in 0..num_box_elements {\n            boxed.events.push(random_event(\u0026mut rt))\n        }\n\n        events.push(boxed);\n\n        t += (rt.random::\u003cf64\u003e()).min(0.001);\n    }\n\n    let mut dispatched = events.clone();\n    dispatched.shuffle(\u0026mut rand::thread_rng());\n\n    let mut c = 0;\n    for eventbox in dispatched {\n        let EventBox { time, events } = eventbox;\n        for event in events {\n            rt.add_event(event, time);\n            c += 1;\n        }\n    }\n\n    println!(\"c := {}\", c);\n\n    let (App { event_list }, _, _) = rt.run().unwrap();\n    let mut boxed_list = Vec::with_capacity(N);\n\n    let mut current_box = EventBox {\n        time: SimTime::ZERO,\n        events: Vec::new(),\n    };\n    for (time, event) in event_list {\n        if time == current_box.time {\n            current_box.events.push(event);\n        } else {\n            boxed_list.push(current_box);\n            current_box = EventBox {\n                time,\n                events: vec![event],\n            };\n        }\n    }\n\n    if !current_box.events.is_empty() {\n        boxed_list.push(current_box);\n    }\n\n    assert_eq!(events.len(), boxed_list.len());\n\n    for (lhs, rhs) in events.into_iter().zip(boxed_list) {\n        // assert eq\n        assert_eq!(lhs.time, rhs.time);\n        assert_eq!(lhs.events.len(), rhs.events.len());\n\n        for l in lhs.events {\n            assert!(rhs.events.iter().any(|r| l == *r))\n        }\n    }\n}\n\nfn random_event(rt: \u0026mut Runtime\u003cApp\u003e) -\u003e MyEventSet {\n    if rt.random::\u003cbool\u003e() {\n        MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime {\n            id: rt.random::\u003cusize\u003e(),\n        })\n    } else {\n        MyEventSet::B(B { id: rt.random() })\n    }\n}\n\nstruct DeferredApplication {\n    started: bool,\n    ended: bool,\n}\nimpl EventLifecycle for DeferredApplication {\n    fn at_sim_start(rt: \u0026mut Runtime\u003cSelf\u003e) {\n        rt.app.started = true;\n    }\n    fn at_sim_end(rt: \u0026mut Runtime\u003cSelf\u003e) {\n        rt.app.ended = true;\n    }\n}\nimpl Application for DeferredApplication {\n    type Lifecycle = Self;\n    type EventSet = DeferredES;\n}\n\nstruct DeferredES;\nimpl EventSet\u003cDeferredApplication\u003e for DeferredES {\n    fn handle(self, _rt: \u0026mut Runtime\u003cDeferredApplication\u003e) {}\n}\n\n#[test]\n#[serial]\nfn deferred_sim_start() {\n    let app = DeferredApplication {\n        started: false,\n        ended: false,\n    };\n    let rt = Builder::seeded(123).build(app);\n\n    assert_eq!(rt.app.started, false);\n    assert_eq!(rt.app.ended, false);\n\n    let app = match rt.run() {\n        RuntimeResult::EmptySimulation { app } =\u003e app,\n        _ =\u003e panic!(\"Which events?\"),\n    };\n\n    assert_eq!(app.started, true);\n    assert_eq!(app.ended, true);\n}\n\nstruct CustomStartApp;\nimpl Application for CustomStartApp {\n    type EventSet = CustomStartEvent;\n    type Lifecycle = Self;\n}\n\nstruct CustomStartEvent;\nimpl EventSet\u003cCustomStartApp\u003e for CustomStartEvent {\n    fn handle(self, _: \u0026mut Runtime\u003cCustomStartApp\u003e) {}\n}\n\nimpl EventLifecycle for CustomStartApp {\n    fn at_sim_start(_: \u0026mut Runtime\u003cSelf\u003e) {\n        assert_eq!(SimTime::now(), 42.0);\n    }\n}\n\n#[test]\n#[serial]\nfn custom_start_time() {\n    let _ = Builder::new()\n        .quiet()\n        .start_time(42.0.into())\n        .limit(RuntimeLimit::EventCount(10))\n        .build(CustomStartApp)\n        .run();\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":110204},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":110204},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":55014},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":55173},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":55014},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":55014},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":55014},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":55014},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":55173},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":55173},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":55173},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":55173},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":110059},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":110059},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":54886},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":54886},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":55173},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":29,"coverable":31},{"path":["/","Users","mk","Developer","rust","des","des","tests","builder-async.rs"],"content":"#![cfg(feature = \"async\")]\n\nuse std::{\n    io,\n    sync::{\n        atomic::{AtomicBool, AtomicU16, AtomicUsize, Ordering},\n        Arc,\n    },\n};\n\nuse des::{net::AsyncFn, prelude::*, time::sleep};\nuse serial_test::serial;\n\n#[test]\n#[serial]\nfn builder_async_fn_quasai_sync() {\n    let done = Arc::new(AtomicBool::new(false));\n    let d2 = done.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(move |_| {\n            let d2 = d2.clone();\n            async move {\n                d2.store(true, Ordering::SeqCst);\n            }\n        }),\n    );\n\n    assert_eq!(done.load(Ordering::SeqCst), false);\n    let _ = Builder::seeded(123).build(sim).run();\n    assert_eq!(done.load(Ordering::SeqCst), true);\n}\n\n#[test]\n#[serial]\nfn builder_async_fn_sleep() {\n    let time = Arc::new(AtomicU16::new(0));\n    let t2 = time.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(move |_| {\n            let t2 = t2.clone();\n            async move {\n                sleep(Duration::from_secs(10)).await;\n                t2.store(SimTime::now().as_secs() as u16, Ordering::SeqCst);\n            }\n        }),\n    );\n\n    assert_eq!(time.load(Ordering::SeqCst), 0);\n    let _ = Builder::seeded(123).build(sim).run();\n    assert_eq!(time.load(Ordering::SeqCst), 10);\n}\n\n#[test]\n#[serial]\nfn builder_async_fn_message_recv() {\n    let counter = Arc::new(AtomicU16::new(0));\n    let c2 = counter.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(move |mut rx| {\n            let c2 = c2.clone();\n            async move {\n                while let Some(msg) = rx.recv().await {\n                    c2.fetch_add(msg.header().id, Ordering::SeqCst);\n                }\n            }\n        }),\n    );\n    let gate = sim.gate(\"alice\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate.clone(), Message::new().id(1).build(), 1.0.into());\n    rt.add_message_onto(gate.clone(), Message::new().id(2).build(), 2.0.into());\n    rt.add_message_onto(gate.clone(), Message::new().id(3).build(), 3.0.into());\n\n    let _ = rt.run();\n    assert_eq!(counter.load(Ordering::SeqCst), 6);\n}\n\n#[test]\n#[serial]\nfn builder_async_fn_channeled() {\n    let counter = Arc::new(AtomicU16::new(0));\n    let c2 = counter.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"tx\",\n        AsyncFn::new(|_| async move {\n            for i in 0..16 {\n                sleep(Duration::from_secs(i)).await;\n                send(Message::new().id(i as u16).build(), \"port\");\n            }\n        }),\n    );\n    sim.node(\n        \"rx\",\n        AsyncFn::new(move |mut rx| {\n            let c2 = c2.clone();\n            async move {\n                while let Some(msg) = rx.recv().await {\n                    c2.fetch_add(msg.header().id, Ordering::SeqCst);\n                }\n            }\n        }),\n    );\n\n    let txg = sim.gate(\"tx\", \"port\");\n    let rxg = sim.gate(\"rx\", \"port\");\n\n    txg.connect(\n        rxg,\n        Some(Channel::new(ChannelMetrics {\n            bitrate: 10000,\n            latency: Duration::from_millis(20),\n            jitter: Duration::ZERO,\n            drop_behaviour: ChannelDropBehaviour::Queue(None),\n        })),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n    assert_eq!(counter.load(Ordering::SeqCst), (0..16).sum());\n}\n\n#[test]\n#[serial]\nfn builder_async_failable() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::failable(|_| async move {\n            if false {\n                return Err(io::Error::new(io::ErrorKind::Other, \"other\"));\n            }\n\n            Ok(())\n        }),\n    );\n    let _ = Builder::new().build(sim).run();\n}\n\n#[test]\n#[serial]\n#[should_panic]\nfn builder_async_failable_with_fail() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::failable(|_| async move {\n            if true {\n                return Err(io::Error::new(io::ErrorKind::Other, \"other\"));\n            }\n\n            Ok(())\n        }),\n    );\n    let _ = Builder::new().build(sim).run();\n}\n\n#[test]\n#[serial]\nfn builder_async_no_join() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|_| async move { std::future::pending().await }),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\n#[should_panic = \"at_sim_end() could not complete, since it is stuck at some await point\"]\nfn builder_async_require_join() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::io(|_| async move { std::future::pending().await }).require_join(),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\nfn builder_async_restart() {\n    static COUNTER: AtomicUsize = AtomicUsize::new(0);\n\n    let mut sim = Sim::new(());\n    let software = AsyncFn::io(|_| async move {\n        COUNTER.fetch_add(1, Ordering::SeqCst);\n\n        des::time::sleep(Duration::from_secs(10)).await;\n        shutdow_and_restart_in(Duration::from_secs(5));\n        std::future::pending().await\n    });\n    assert_eq!(format!(\"{software:?}\"), \"AsyncFn\");\n\n    sim.node(\"alice\", software);\n\n    let _ = Builder::seeded(123).max_time(25.0.into()).build(sim).run();\n\n    // once at 0, 15, next would be 30\n    assert_eq!(COUNTER.load(Ordering::SeqCst), 2);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","tests","builder.rs"],"content":"#![cfg(feature = \"net\")]\n\nuse des::{\n    net::{FailabilityPolicy, HandlerFn, ModuleBlock, ModuleFn},\n    prelude::*,\n};\nuse serial_test::serial;\nuse spin::Mutex;\nuse std::{\n    hint::black_box,\n    io,\n    sync::{\n        atomic::{AtomicU16, Ordering},\n        Arc,\n    },\n};\n\n#[test]\n#[serial]\nfn builder_builds_hierachie() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"parent\",\n        ModuleFn::new(\n            || {\n                assert!(current().parent().is_err());\n                assert!(current().child(\"child\").is_ok());\n            },\n            |_, _| {},\n        ),\n    );\n    sim.node(\n        \"parent.child\",\n        ModuleFn::new(\n            || {\n                assert!(current().parent().is_ok());\n                assert!(current().child(\"grandchild\").is_ok());\n            },\n            |_, _| {},\n        ),\n    );\n    sim.node(\n        \"parent.child.grandchild\",\n        ModuleFn::new(\n            || {\n                assert!(current().parent().is_ok());\n                assert!(current().child(\"some\").is_err());\n            },\n            |_, _| {},\n        ),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\n#[should_panic = \"cannot create node 'alice', node allready exists\"]\nfn builder_panic_node_duplicate() {\n    let mut sim = Sim::new(());\n    sim.node(\"alice\", HandlerFn::new(|_| {}));\n    sim.node(\"bob\", HandlerFn::new(|_| {}));\n    sim.node(\"alice\", HandlerFn::new(|_| {}));\n}\n\n#[test]\n#[serial]\n#[should_panic = \"cannot create node 'bob.bombardil', since parent node 'bob' is required, but does not exist\"]\nfn builder_panic_missing_parent() {\n    let mut sim = Sim::new(());\n    sim.node(\"alice\", HandlerFn::new(|_| {}));\n    sim.node(\"alice.alicent\", HandlerFn::new(|_| {}));\n    sim.node(\"bob.bombardil\", HandlerFn::new(|_| {}));\n}\n\n#[test]\n#[serial]\n#[should_panic = \"cannot create gate 'bob.port', because node 'bob' does not exist\"]\nfn builder_panic_gate_missing_node() {\n    let mut sim = Sim::new(());\n    sim.node(\"alice\", HandlerFn::new(|_| {}));\n    let _ = sim.gate(\"alice\", \"port\");\n\n    let _ = sim.gate(\"bob\", \"port\");\n}\n\n#[test]\n#[serial]\nfn builder_gate_cluster() {\n    struct Alice;\n    impl Module for Alice {\n        fn at_sim_start(\u0026mut self, _: usize) {\n            for i in 0..4 {\n                assert!(current().gate(\"cluster\", i).is_some());\n            }\n        }\n    }\n\n    let mut sim = Sim::new(());\n    sim.node(\"alice\", Alice);\n    let _ = sim.gates(\"alice\", \"cluster\", 4);\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\nfn builder_module_block() {\n    struct Def;\n    struct Block;\n    impl Module for Def {}\n    impl ModuleBlock for Block {\n        fn build\u003cA\u003e(self, mut sim: ScopedSim\u003c'_, A\u003e) {\n            sim.root(Def);\n            let _ = sim.gate(\"\", \u0026format!(\"port-{}\", sim.scope()));\n\n            sim.node(\"sub\", Def);\n            let _ = sim.gates(\"sub\", \"cluster\", 123);\n\n            let _ = sim.inner();\n        }\n    }\n\n    let mut sim = Sim::new(());\n    sim.node(\"alice\", Block);\n    assert!(sim.get(\u0026\"alice.sub\".into()).is_some());\n}\n\n#[test]\n#[serial]\nfn builder_handler_fn() {\n    let counter = Arc::new(AtomicU16::new(0));\n    let c2 = counter.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        HandlerFn::new(move |msg| {\n            c2.fetch_add(msg.header().id, Ordering::SeqCst);\n        }),\n    );\n    let gate = sim.gate(\"alice\", \"port\");\n    let other = sim.gate(\"alice\", \"port\");\n    assert!(Arc::ptr_eq(\u0026gate, \u0026other));\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate.clone(), Message::new().id(1).build(), 1.0.into());\n    rt.add_message_onto(gate.clone(), Message::new().id(2).build(), 2.0.into());\n    rt.add_message_onto(gate.clone(), Message::new().id(3).build(), 3.0.into());\n\n    let _ = rt.run();\n    assert_eq!(counter.load(Ordering::SeqCst), 6);\n}\n\n#[test]\n#[serial]\nfn builder_handler_fn_with_err() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        HandlerFn::failable(\n            |_| {\n                if black_box(false) {\n                    return Err(io::Error::new(io::ErrorKind::Other, \"other\"));\n                }\n\n                Ok(())\n            },\n            FailabilityPolicy::Panic,\n        ),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\n#[should_panic = \"node 'alice' failed to process message, handler fn failed with: other\"]\nfn builder_handler_fn_failure_panic() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        HandlerFn::failable(\n            |_| {\n                if black_box(true) {\n                    return Err(io::Error::new(io::ErrorKind::Other, \"other\"));\n                }\n\n                Ok(())\n            },\n            FailabilityPolicy::Panic,\n        ),\n    );\n    let gate = sim.gate(\"alice\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate, Message::new().build(), 1.0.into());\n\n    let _ = rt.run();\n}\n\n#[test]\n#[serial]\nfn builder_handler_fn_failure_no_panic() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        HandlerFn::failable(\n            |_| {\n                if black_box(true) {\n                    return Err(io::Error::new(io::ErrorKind::Other, \"other\"));\n                }\n\n                Ok(())\n            },\n            FailabilityPolicy::Continue,\n        ),\n    );\n    let gate = sim.gate(\"alice\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate, Message::new().build(), 1.0.into());\n\n    let _ = rt.run();\n}\n\n#[test]\n#[serial]\nfn builder_module_fn() {\n    let records = Arc::new(Mutex::new(Vec::new()));\n    let r2 = records.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        ModuleFn::new(\n            || 0,\n            move |state, _| {\n                *state += 1;\n                if *state \u003e 8 {\n                    r2.lock().push(*state);\n                }\n            },\n        ),\n    );\n    let gate = sim.gate(\"alice\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    for i in 0..10 {\n        rt.add_message_onto(\n            gate.clone(),\n            Message::new().id(i).build(),\n            (i as f64).into(),\n        );\n    }\n\n    let _ = rt.run();\n    assert_eq!(*records.lock(), [9, 10]);\n}\n\n#[test]\n#[serial]\nfn builder_module_fn_restart_at_failure() {\n    let starts = Arc::new(AtomicU16::new(0));\n    let s2 = starts.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        ModuleFn::failable(\n            move || {\n                s2.fetch_add(1, Ordering::SeqCst);\n                0\n            },\n            |_, msg| {\n                if msg.header().id == 1 {\n                    Err(io::Error::new(io::ErrorKind::Other, \"other\"))\n                } else {\n                    Ok(())\n                }\n            },\n            FailabilityPolicy::Restart,\n        ),\n    );\n    let gate = sim.gate(\"alice\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate.clone(), Message::new().id(1).build(), 1.0.into());\n    rt.add_message_onto(gate.clone(), Message::new().id(1).build(), 2.0.into());\n    rt.add_message_onto(gate.clone(), Message::new().id(2).build(), 3.0.into());\n\n    let _ = rt.run();\n    assert_eq!(starts.load(Ordering::SeqCst), 3);\n}\n\n#[test]\n#[serial]\nfn builder_module_fn_gen_in_module_scope() {\n    let stage = Arc::new(AtomicU16::new(0));\n    let s2 = stage.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        ModuleFn::new(\n            move || {\n                s2.store(1, Ordering::SeqCst);\n                assert_eq!(current().path().as_str(), \"alice\");\n\n                123\n            },\n            |_, _| {},\n        ),\n    );\n\n    assert_eq!(stage.load(Ordering::SeqCst), 0);\n    let _ = Builder::seeded(123).build(sim).run();\n    assert_eq!(stage.load(Ordering::SeqCst), 1);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","tests","channels.rs"],"content":"#![cfg(feature = \"net\")]\nuse std::sync::{\n    atomic::{AtomicUsize, Ordering},\n    Arc,\n};\n\nuse des::{\n    net::channel::{ChannelDropBehaviour, ChannelProbe},\n    prelude::*,\n};\nuse rand::{rngs::StdRng, SeedableRng};\nuse serial_test::serial;\n\n#[derive(Default)]\nstruct DropChanModule {\n    send: usize,\n    received: usize,\n}\n\nimpl Module for DropChanModule {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        send(Message::new().content([0u8; 512]).build(), \"out\");\n        send(Message::new().content([1u8; 512]).build(), \"out\");\n\n        self.send += 2;\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        self.received += 1;\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_ne!(self.send, self.received)\n    }\n}\n\n#[test]\n#[serial]\nfn channel_dropping_message() {\n    let mut rt = Sim::new(());\n    rt.node(\"root\", DropChanModule::default());\n\n    let g_in = rt.gate(\"root\", \"in\");\n    let g_out = rt.gate(\"root\", \"out\");\n\n    let channel = Channel::new(ChannelMetrics {\n        bitrate: 1000,\n        latency: Duration::from_millis(100),\n        jitter: Duration::ZERO,\n        drop_behaviour: ChannelDropBehaviour::default(),\n    });\n    g_in.connect(g_out, Some(channel));\n\n    let rt = Builder::seeded(123).build(rt);\n    let _ = rt.run();\n}\n\n#[derive(Debug, Default)]\nstruct BufferChanModule {\n    send: usize,\n    received: usize,\n}\n\nimpl Module for BufferChanModule {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        send(Message::new().content([0u8; 512]).build(), \"out\");\n        send(Message::new().content([1u8; 512]).build(), \"out\");\n        send(Message::new().content([1u8; 512]).build(), \"out\");\n\n        self.send += 3;\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        self.received += 1;\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.send, 3);\n        assert_eq!(self.received, 2);\n    }\n}\n\n#[test]\n#[serial]\nfn channel_buffering_message() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", BufferChanModule::default());\n\n    let g_in = rt.gate(\"root\", \"in\");\n    let g_out = rt.gate(\"root\", \"out\");\n\n    let channel = Channel::new(ChannelMetrics {\n        bitrate: 1000,\n        latency: Duration::from_millis(100),\n        jitter: Duration::ZERO,\n        drop_behaviour: ChannelDropBehaviour::Queue(Some(600)),\n    });\n    g_in.connect(g_out, Some(channel));\n\n    let rt = Builder::seeded(123).build(rt);\n    let _ = rt.run();\n}\n\nstruct SendMessageModule;\nimpl Module for SendMessageModule {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        schedule_in(Message::new().kind(10).build(), Duration::from_secs(1));\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        if msg.header().kind == 10 {\n            send(Message::new().content(\"Hello world\").build(), \"out\");\n            let gate = current().gate(\"out\", 0).unwrap();\n            let ch = gate.channel().unwrap();\n            assert!(ch.is_busy());\n        }\n    }\n}\n\n#[test]\n#[serial]\nfn channel_instant_busy() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", SendMessageModule);\n\n    let g_in = rt.gate(\"root\", \"in\");\n    let g_out = rt.gate(\"root\", \"out\");\n\n    let channel = Channel::new(ChannelMetrics::new(\n        1000,\n        Duration::from_millis(100),\n        Duration::ZERO,\n        ChannelDropBehaviour::default(),\n    ));\n\n    g_in.connect(g_out, Some(channel));\n\n    let rt = Builder::seeded(123).build(rt);\n    let _ = rt.run();\n}\n\n#[derive(Default)]\nstruct ChannelProbing(Arc\u003cAtomicUsize\u003e);\nimpl Module for ChannelProbing {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        let chan = current().gate(\"port\", 0).unwrap().channel().unwrap();\n\n        chan.attach_probe(Probe(self.0.clone()));\n        assert_eq!(chan.metrics().bitrate, 1234);\n\n        let msg = Message::new().build();\n        let busy_time = chan.calculate_busy(\u0026msg);\n        let tft = SimTime::now() + busy_time;\n        dbg!(busy_time);\n        assert_eq!(\n            tft + Duration::from_millis(100),\n            SimTime::from_duration(chan.calculate_duration(\u0026msg, \u0026mut StdRng::seed_from_u64(123)))\n        );\n\n        assert_eq!(chan.transmission_finish_time(), SimTime::MIN);\n        assert_eq!(format!(\"{chan:?}\"), format!(\"Channel {{ metrics: ChannelMetrics {{ bitrate: 1234, latency: 100ms, jitter: 0ns, drop_behaviour: Drop }}, state: Idle }}\"));\n\n        send(msg, \"port\");\n\n        assert_eq!(chan.transmission_finish_time(), tft);\n        assert_eq!(format!(\"{chan:?}\"), format!(\"Channel {{ metrics: ChannelMetrics {{ bitrate: 1234, latency: 100ms, jitter: 0ns, drop_behaviour: Drop }}, state: Busy {{ until: {tft}, bytes: 0, packets: 0 }} }}\"));\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.0.load(Ordering::SeqCst), 1);\n    }\n}\n\nstruct Probe(Arc\u003cAtomicUsize\u003e);\nimpl ChannelProbe for Probe {\n    fn on_message_transmit(\u0026mut self, _: \u0026ChannelMetrics, _: \u0026Message) {\n        self.0.fetch_add(1, Ordering::SeqCst);\n    }\n}\n\n#[test]\n#[serial]\nfn channel_probes() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut rt = Sim::new(());\n    rt.node(\"alice\", ChannelProbing::default());\n    rt.node(\"bob\", ChannelProbing::default());\n\n    let alice_port = rt.gate(\"alice\", \"port\");\n    let bob_port = rt.gate(\"bob\", \"port\");\n\n    let chan = Channel::new(ChannelMetrics {\n        bitrate: 1234,\n        latency: Duration::from_millis(100),\n        jitter: Duration::ZERO,\n        drop_behaviour: ChannelDropBehaviour::default(),\n    });\n\n    alice_port.connect(bob_port, Some(chan));\n\n    let rt = Builder::seeded(123).build(rt);\n    let _ = rt.run();\n}\n\nstruct LatencyOnly(usize);\n\nimpl Module for LatencyOnly {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        for _ in 0..10 {\n            send(Message::new().build(), \"out\");\n        }\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        self.0 += 1;\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.0, 10);\n    }\n}\n\n#[test]\n#[serial]\nfn latency_only_channel() {\n    let mut sim = Sim::new(());\n    sim.node(\"alice\", LatencyOnly(0));\n    let gout = sim.gate(\"alice\", \"out\");\n    let gin = sim.gate(\"alice\", \"in\");\n    gout.connect(\n        gin,\n        Some(Channel::new(ChannelMetrics::new(\n            0,\n            Duration::from_secs(1),\n            Duration::ZERO,\n            ChannelDropBehaviour::Drop,\n        ))),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":53,"coverable":53},{"path":["/","Users","mk","Developer","rust","des","des","tests","common","mock.rs"],"content":"#![allow(unused)]\n\nuse spin::Mutex;\nuse std::{io, sync::Arc};\nuse tracing_subscriber::fmt::MakeWriter;\n\n#[derive(Debug, Clone)]\npub struct MakeMockWriter {\n    lines: Arc\u003cMutex\u003cString\u003e\u003e,\n}\n\n#[derive(Debug, Clone)]\npub struct MockWriter {\n    lines: Arc\u003cMutex\u003cString\u003e\u003e,\n}\n\nimpl io::Write for MockWriter {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e io::Result\u003cusize\u003e {\n        let mut lines = self.lines.lock();\n        lines.push_str(\u0026String::from_utf8_lossy(buf));\n        Ok(buf.len())\n    }\n\n    fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        Ok(())\n    }\n}\n\nimpl MakeMockWriter {\n    pub fn new() -\u003e Self {\n        MakeMockWriter {\n            lines: Arc::new(Mutex::new(String::new())),\n        }\n    }\n\n    pub fn content(\u0026self) -\u003e String {\n        self.lines.lock().clone()\n    }\n}\n\nimpl\u003c'a\u003e MakeWriter\u003c'a\u003e for MakeMockWriter {\n    type Writer = MockWriter;\n    fn make_writer(\u0026'a self) -\u003e Self::Writer {\n        MockWriter {\n            lines: self.lines.clone(),\n        }\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":12},"fn_name":null}],"covered":10,"coverable":12},{"path":["/","Users","mk","Developer","rust","des","des","tests","load-order.rs"],"content":"#![cfg(feature = \"net\")]\n\nuse des::net::ModuleFn;\nuse des::prelude::*;\nuse std::sync::{atomic::AtomicU16, Arc};\n\n#[test]\nfn load_order() {\n    let state = Arc::new(AtomicU16::new(0));\n    let mut sim = Sim::new(());\n\n    macro_rules! stage {\n        ($i:ident == $l:literal) =\u003e {{\n            let old = $i.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n            assert_eq!(old, $l);\n        }};\n    }\n\n    let s2 = state.clone();\n    sim.node(\"alice\", ModuleFn::new(move || stage!(s2 == 0), |_, _| {}));\n    let s2 = state.clone();\n    sim.node(\n        \"alice.submodule\",\n        ModuleFn::new(move || stage!(s2 == 1), |_, _| {}),\n    );\n    let s2 = state.clone();\n    sim.node(\n        \"alice.bob\",\n        ModuleFn::new(move || stage!(s2 == 3), |_, _| {}),\n    );\n    let s2 = state.clone();\n    sim.node(\n        \"alice.submodule.sub\",\n        ModuleFn::new(move || stage!(s2 == 2), |_, _| {}),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","tests","message-body.rs"],"content":"use des::prelude::*;\n\nmacro_rules! test_primive {\n    ($ident:ident, $t:ty, $e:expr, $s:expr) =\u003e {\n        #[test]\n        fn $ident() {\n            let value: $t = $e;\n            assert_eq!(value.byte_len(), $s)\n        }\n    };\n}\ntest_primive!(test_void, (), (), 0);\n\ntest_primive!(test_u8, u8, 0, 1);\ntest_primive!(test_u16, u16, 0, 2);\ntest_primive!(test_u32, u32, 0, 4);\ntest_primive!(test_u64, u64, 0, 8);\ntest_primive!(test_u128, u128, 0, 16);\n\ntest_primive!(test_i8, i8, 0, 1);\ntest_primive!(test_i16, i16, 0, 2);\ntest_primive!(test_i32, i32, 0, 4);\ntest_primive!(test_i64, i64, 0, 8);\ntest_primive!(test_i128, i128, 0, 16);\n\ntest_primive!(test_f32, f32, 0.0, 4);\ntest_primive!(test_f64, f64, 0.0, 8);\n\ntest_primive!(test_bool, bool, true, 1);\ntest_primive!(test_char, char, 'a', 4);\n\n#[test]\nfn test_string() {\n    assert_eq!(String::new().byte_len(), 0);\n    assert_eq!(\"Hello World\".to_string().byte_len(), 11);\n    assert_eq!(\"Hello World\".to_string().byte_len(), 15);\n}\n\n#[test]\n#[allow(unused_allocation)]\nfn test_box() {\n    assert_eq!(Box::new(0u8).byte_len(), 1);\n    assert_eq!(Box::new(0i128).byte_len(), 16);\n    assert_eq!(Box::new(String::from(\"Hello World\")).byte_len(), 11);\n    assert_eq!(Box::new(()).byte_len(), 0);\n}\n\n#[test]\nfn test_option() {\n    assert_eq!(Some(0u8).byte_len(), 1);\n    let v: Option\u003cu8\u003e = None;\n    assert_eq!(v.byte_len(), 0);\n\n    assert_eq!(Some(\"Hello World\".to_string()).byte_len(), 11);\n    let v: Option\u003cString\u003e = None;\n    assert_eq!(v.byte_len(), 0);\n}\n\n#[test]\nfn test_result() {\n    type R = Result\u003cString, u8\u003e;\n    let v: R = Ok(\"Hello World\".to_string());\n    assert_eq!(v.byte_len(), 11);\n\n    let v: R = Ok(String::new());\n    assert_eq!(v.byte_len(), 0);\n\n    let v: R = Err(0);\n    assert_eq!(v.byte_len(), 1);\n\n    let v: R = Err(16);\n    assert_eq!(v.byte_len(), 1);\n}\n\n#[test]\nfn test_collections() {\n    let v = vec![1u8, 2, 3];\n    assert_eq!(v.byte_len(), 3);\n\n    let v = vec![String::new(), format!(\"Hello World\"), format!(\"ABC\")];\n    assert_eq!(v.byte_len(), 11 + 3);\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":15},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","Users","mk","Developer","rust","des","des","tests","meta.rs"],"content":"use des::prelude::*;\nuse serial_test::serial;\n\nstruct Parent;\n\nimpl Module for Parent {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        current().set_meta(32u64);\n        schedule_in(Message::new().build(), Duration::from_secs(1));\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        assert_eq!(current().meta::\u003cu64\u003e(), Some(32));\n        assert_eq!(current().meta::\u003cbool\u003e(), None);\n\n        assert_eq!(\n            current().child(\"a\").unwrap().meta::\u003cString\u003e(),\n            Some(\"a\".to_string())\n        );\n        assert_eq!(\n            current().child(\"b\").unwrap().meta::\u003cString\u003e(),\n            Some(\"b\".to_string())\n        );\n    }\n}\n\nstruct Child;\n\nimpl Module for Child {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        current().set_meta(current().name());\n        schedule_in(Message::new().build(), Duration::from_secs(1));\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        assert_eq!(current().parent().unwrap().meta::\u003cu64\u003e(), Some(32));\n    }\n}\n\n#[test]\n#[serial]\nfn read_meta_through_tree() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut rt = Sim::new(());\n\n    rt.node(\"root\", Parent);\n    rt.node(\"root.a\", Child);\n    rt.node(\"root.b\", Child);\n\n    let rt = Builder::seeded(123).build(rt);\n\n    let res = rt.run();\n    let _res = res.unwrap();\n}\n\nstruct Overrider;\nimpl Module for Overrider {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        current().set_meta(32u64);\n        schedule_in(Message::new().build(), Duration::from_secs(1));\n        current().set_meta(64u64);\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        assert_eq!(current().meta::\u003cu64\u003e(), Some(64));\n    }\n}\n\n#[test]\n#[serial]\nfn meta_override_previous_value() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", Overrider);\n\n    let rt = Builder::seeded(123).build(rt);\n\n    let res = rt.run();\n    let _res = res.unwrap();\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":23,"coverable":23},{"path":["/","Users","mk","Developer","rust","des","des","tests","ndl.rs"],"content":"#![cfg(feature = \"ndl\")]\n\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\nuse des::{prelude::*, registry};\nuse des_ndl::error::RootResult;\n\n#[path = \"common/mock.rs\"]\nmod mock;\n\nmod common {\n    use des::{net::module::current, prelude::*};\n\n    #[derive(Default)]\n    pub struct Main;\n    impl Module for Main {}\n\n    #[derive(Default)]\n    pub struct Node {\n        dst: usize,\n        rem: usize,\n        delay: Duration,\n        rcv: usize,\n    }\n    impl Module for Node {\n        fn at_sim_start(\u0026mut self, _stage: usize) {\n            self.dst = par(\"dst\")\n                .as_option()\n                .map(|s| s.parse::\u003cusize\u003e().unwrap())\n                .unwrap_or(0);\n            self.rem = par(\"c\")\n                .as_option()\n                .map(|s| s.parse::\u003cusize\u003e().unwrap())\n                .unwrap_or(0);\n            self.delay = Duration::from_secs_f64(\n                par(\"delay\")\n                    .as_option()\n                    .map(|s| s.parse::\u003cf64\u003e().unwrap())\n                    .unwrap_or(1.0),\n            );\n\n            tracing::info!(\n                \"sim_start(dst := {}, c := {}, delay := {})\",\n                self.dst,\n                self.rem,\n                self.delay.as_secs_f64()\n            );\n            if self.rem \u003e 0 {\n                schedule_in(Message::new().kind(1).build(), self.delay)\n            }\n        }\n\n        fn handle_message(\u0026mut self, msg: Message) {\n            match msg.header().kind {\n                1 =\u003e {\n                    self.rem -= 1;\n                    send(Message::new().kind(2).id(self.dst as u16).build(), \"out\");\n\n                    if self.rem \u003e 0 {\n                        schedule_in(Message::new().kind(1).build(), self.delay)\n                    }\n                }\n                2 =\u003e {\n                    if current().name().starts_with(\"node\") {\n                        assert_eq!(format!(\"node[{}]\", msg.header().id), current().name());\n                        self.rcv += 1;\n                    }\n                    if current().name().starts_with(\"ring\") {\n                        if format!(\"ring[{}]\", msg.header().id) == current().name() {\n                            self.rcv += 1;\n                        } else {\n                            send(msg, \"out\")\n                        }\n                    }\n                }\n                _ =\u003e unreachable!(),\n            }\n        }\n\n        fn at_sim_end(\u0026mut self) {\n            if let Some(v) = par(\"expected\")\n                .as_option()\n                .map(|v| v.parse::\u003cusize\u003e().unwrap())\n            {\n                assert_eq!(v, self.rcv, \"failed at module: {}\", current().path());\n            }\n        }\n    }\n\n    #[derive(Default)]\n    pub struct Debugger;\n    impl Module for Debugger {}\n\n    #[derive(Default)]\n    pub struct Router;\n    impl Module for Router {\n        fn handle_message(\u0026mut self, msg: Message) {\n            let g = current().gate(\"out\", msg.header().id as usize).unwrap();\n            send(msg, g);\n        }\n    }\n}\nuse common::*;\nuse serial_test::serial;\n\n#[test]\n#[serial]\nfn small_network() -\u003e RootResult\u003c()\u003e {\n    // Logger::new().set_logger();\n\n    let mut app = Sim::ndl(\n        \"tests/ndl/small_network/main.ndl\",\n        registry![Main, Node, Router, Debugger],\n    )?;\n    app.include_par_file(\"tests/ndl/small_network/main.par\")\n        .unwrap();\n\n    let r = Builder::seeded(123)\n        .max_time(1000.0.into())\n        .build(app)\n        .run()\n        .unwrap();\n\n    assert_eq!(r.1.as_secs(), 200);\n    Ok(())\n}\n\n#[test]\n#[serial]\nfn ring_topology() -\u003e RootResult\u003c()\u003e {\n    // Logger::new().set_logger();\n\n    let mut app = Sim::ndl(\n        \"tests/ndl/ring_topo/main.ndl\",\n        registry![Main, Node, Router, Debugger],\n    )?;\n    app.include_par_file(\"tests/ndl/ring_topo/main.par\")\n        .unwrap();\n\n    let r = Builder::seeded(123)\n        .max_time(1000.0.into())\n        .build(app)\n        .run()\n        .unwrap();\n\n    assert_eq!(r.1.as_secs(), 200);\n    Ok(())\n}\n\nstruct Single;\n\nimpl RegistryCreatable for Single {\n    fn create(path: \u0026ObjectPath, _: \u0026str) -\u003e Self {\n        println!(\"{path}\");\n        assert!(par(\"addr\").is_some());\n        Self\n    }\n}\n\nimpl Module for Single {}\n\n#[test]\n#[serial]\nfn build_with_preexisting_sim() -\u003e RootResult\u003c()\u003e {\n    let mut sim = Sim::new(());\n    sim.include_par(\"alice.addr = 1.1.1.1\\n\");\n    sim.build_ndl(\"tests/ndl/single.ndl\", registry![Single, else _])?;\n\n    let _ = Builder::seeded(123).build(sim).run();\n    Ok(())\n}\n\n#[test]\n#[serial]\nfn non_std_gate_connections() -\u003e RootResult\u003c()\u003e {\n    let sim = Sim::ndl(\n        \"tests/ndl/local-con.ndl\",\n        Registry::new().with_default_fallback(),\n    )?;\n    let _ = Builder::seeded(123).build(sim).run();\n    Ok(())\n}\n\n#[test]\n#[serial]\nfn registry_missing_symbol() {\n    let sim: Result\u003cSim\u003c()\u003e, des_ndl::error::RootError\u003e = Sim::ndl(\n        \"tests/ndl/ab-deep.ndl\",\n        Registry::new().symbol(\"Main\", |_| Debugger),\n    );\n    let errors = sim.unwrap_err().errors;\n    assert_eq!(errors.len(), 3);\n    assert_eq!(\n        errors.get(0).unwrap().internal.to_string(),\n        \"symbol 'A' at 'a' could not be resolved by the registry\",\n    );\n    assert_eq!(\n        errors.get(1).unwrap().internal.to_string(),\n        \"symbol 'B' at 'a.b' could not be resolved by the registry\",\n    );\n    assert_eq!(\n        errors.get(2).unwrap().internal.to_string(),\n        \"symbol 'B' at 'b' could not be resolved by the registry\",\n    );\n}\n\n#[test]\n#[serial]\nfn registry_fmt() {\n    assert_eq!(\n        format!(\"{:?}\", Registry::new().symbol(\"A\", |_| Debugger)),\n        \"Registry\"\n    );\n}\n\n#[test]\n#[serial]\nfn registry_custom_resolver() -\u003e RootResult\u003c()\u003e {\n    static COUNTER: AtomicUsize = AtomicUsize::new(0);\n\n    let registry = Registry::default()\n        .symbol(\"A\", |_| Debugger)\n        .symbol(\"Main\", |_| Debugger)\n        .custom(|_, symbol| {\n            if symbol == \"B\" {\n                COUNTER.fetch_add(1, Ordering::SeqCst);\n                Some(Debugger)\n            } else {\n                None\n            }\n        });\n\n    let sim = Sim::ndl(\"tests/ndl/ab.ndl\", registry)?;\n    let _ = Builder::seeded(123).build(sim).run();\n\n    assert_eq!(COUNTER.load(Ordering::SeqCst), 1);\n\n    Ok(())\n}\n\nstruct Sender;\nimpl Module for Sender {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        send(Message::new().build(), \"port\")\n    }\n}\n\n#[test]\n#[serial]\nfn registry_default_fallback_does_not_pani() -\u003e RootResult\u003c()\u003e {\n    let registry = Registry::default()\n        .symbol(\"A\", |_| Sender)\n        .with_default_fallback();\n\n    let sim = Sim::ndl(\"tests/ndl/ab.ndl\", registry)?;\n    let _ = Builder::seeded(123).build(sim).run();\n\n    Ok(())\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2500},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2500},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":950},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":950},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":950},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":941},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1550},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":450},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":450},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1550},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1600},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":500},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":600},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":450},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":450},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":450},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":42,"coverable":46},{"path":["/","Users","mk","Developer","rust","des","des","tests","net.rs"],"content":"use des::prelude::*;\n\n#[derive(Default)]\nstruct Receiver {\n    counter: usize,\n}\n\nimpl Module for Receiver {\n    fn handle_message(\u0026mut self, _msg: Message) {\n        self.counter += 1;\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.counter, 10);\n    }\n}\n\n#[derive(Default)]\nstruct Sender;\n\nimpl Module for Sender {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        for i in 0..10 {\n            send_in(\n                Message::new().id(i as u16).build(),\n                (\"port\", 0),\n                Duration::from_secs(i),\n            );\n        }\n    }\n}\n\n#[test]\nfn connectivity() {\n    let mut app = Sim::new(());\n\n    app.node(\"rx\", Receiver::default());\n    app.node(\"tx\", Sender::default());\n\n    let rx = app.gate(\"rx\", \"port\");\n    let tx = app.gate(\"tx\", \"port\");\n\n    rx.connect(\n        tx,\n        Some(Channel::new(ChannelMetrics {\n            bitrate: 10000,\n            latency: Duration::from_millis(100),\n            jitter: Duration::ZERO,\n            drop_behaviour: ChannelDropBehaviour::Queue(None),\n        })),\n    );\n\n    let app = Builder::seeded(123).build(app);\n    let _ = app.run().unwrap();\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":10},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","Users","mk","Developer","rust","des","des","tests","par.rs"],"content":"#![cfg(feature = \"net\")]\n\nuse std::io;\n\nuse des::net::{par_export, ModuleFn, Par};\nuse des::prelude::*;\nuse serial_test::serial;\n\nfn par_for_r(module: \u0026str, key: \u0026str) -\u003e Par {\n    par_for(key, module)\n}\n\nconst EXAMPLE_TYPES: \u0026str = \"\n    netA.*.text = \\\"My name\\\"\n    netA.s0.usize = 123\n    netA.s1.usize = 420\n    netA.s1.isize = -120\n\";\n\nconst EXAMPLE_NETWORK: \u0026str = \"\n    netA.*.dnsServer = 1.1.1.1\n    netA.s0.ip = 0.0.0.1\n    netA.s1.ip = 0.0.0.1\n    netA.s1.ipv6 = fe80\n\";\n\n#[test]\n#[serial]\nfn non_parse_read() {\n    let rt = Sim::new(());\n    let par = \u0026rt.globals().parameters;\n\n    par.build(EXAMPLE_NETWORK);\n\n    assert!(par_for_r(\"netB.s1\", \"dnsServer\").is_none());\n\n    // Case \"netA.s0\"\n    assert_eq!(\n        par_for_r(\"netA.s0\", \"dnsServer\").as_option(),\n        Some(\"1.1.1.1\".to_string())\n    );\n    assert_eq!(\n        par_for_r(\"netA.s0\", \"ip\").as_option(),\n        Some(\"0.0.0.1\".to_string())\n    );\n    assert_eq!(par_for_r(\"netA.s0\", \"ipv6\").as_option(), None);\n\n    // Case \"netA.s1\"\n    assert_eq!(\n        par_for_r(\"netA.s1\", \"dnsServer\").as_option(),\n        Some(\"1.1.1.1\".to_string())\n    );\n    assert_eq!(\n        par_for_r(\"netA.s1\", \"ip\").as_option(),\n        Some(\"0.0.0.1\".to_string())\n    );\n    assert_eq!(\n        par_for_r(\"netA.s1\", \"ipv6\").as_option(),\n        Some(\"fe80\".to_string())\n    );\n\n    // Case \"netA.other\"\n    assert_eq!(\n        par_for_r(\"netA.other\", \"dnsServer\").as_option(),\n        Some(\"1.1.1.1\".to_string())\n    );\n    assert_eq!(par_for_r(\"netA.other\", \"ip\").as_option(), None);\n    assert_eq!(par_for_r(\"netA.other\", \"ipv6\").as_option(), None);\n}\n\n#[test]\n#[serial]\nfn parse_integers() {\n    let rt = Sim::new(());\n    let par = \u0026rt.globals().parameters;\n\n    par.build(EXAMPLE_TYPES);\n\n    // Case \"netA.s0\"\n    assert_eq!(\n        *par_for_r(\"netA.s0\", \"text\").unwrap(),\n        \"\\\"My name\\\"\".to_string()\n    );\n    assert_eq!(\n        par_for_r(\"netA.s0\", \"usize\")\n            .unwrap()\n            .parse::\u003cusize\u003e()\n            .unwrap(),\n        123\n    );\n    assert_eq!(par_for_r(\"netA.s0\", \"isize\").as_option(), None);\n\n    // Case \"netA.s1\"\n    assert_eq!(\n        *par_for_r(\"netA.s1\", \"text\").unwrap(),\n        \"\\\"My name\\\"\".to_string()\n    );\n    assert_eq!(\n        par_for_r(\"netA.s1\", \"usize\")\n            .unwrap()\n            .parse::\u003cusize\u003e()\n            .unwrap(),\n        420\n    );\n    assert_eq!(\n        par_for_r(\"netA.s1\", \"isize\")\n            .unwrap()\n            .parse::\u003cisize\u003e()\n            .unwrap(),\n        -120\n    );\n\n    // Case \"netA.other\"\n    assert_eq!(\n        par_for_r(\"netA.other\", \"text\").as_option(),\n        Some(\"\\\"My name\\\"\".to_string())\n    );\n    assert_eq!(par_for_r(\"netA.other\", \"usize\").as_option(), None);\n    assert_eq!(par_for_r(\"netA.other\", \"isize\").as_option(), None);\n}\n\n#[test]\n#[serial]\nfn parse_strings() {\n    let rt = Sim::new(());\n    let par = \u0026rt.globals().parameters;\n    par.build(EXAMPLE_TYPES);\n\n    let handle = par_for_r(\"netA.other\", \"text\").unwrap();\n\n    assert_eq!(\u0026*handle, \"\\\"My name\\\"\");\n    assert_eq!(handle.into_inner(), \"My name\".to_string());\n}\n\n#[test]\n#[serial]\nfn par_remove() {\n    let mut sim = Sim::new(());\n    sim.globals().parameters.build(\"counter = 123\");\n    sim.node(\n        \"\",\n        ModuleFn::new(\n            || {\n                assert!(par(\"counter\").is_some());\n                let _ = par(\"counter\").unset();\n                assert!(par(\"counter\").is_none());\n            },\n            |_, _| {},\n        ),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\n#[should_panic = \"failed to unwrap addr\"]\nfn par_panic() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"\",\n        ModuleFn::new(\n            || {\n                let _ = par(\"addr\").expect(\"failed to unwrap addr\");\n            },\n            |_, _| {},\n        ),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\nfn par_export_test() -\u003e io::Result\u003c()\u003e {\n    let rt = Sim::new(());\n    rt.globals().parameters.build(EXAMPLE_NETWORK);\n\n    let mut str = Vec::new();\n    par_export(\u0026mut str)?;\n\n    let str = String::from_utf8_lossy(\u0026str);\n    assert_eq!(str, \"netA.*.dnsServer = 1.1.1.1\\nnetA.s0.ip = 0.0.0.1\\nnetA.s1.ipv6 = fe80\\nnetA.s1.ip = 0.0.0.1\\n\");\n\n    Ok(())\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":20},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","Users","mk","Developer","rust","des","des","tests","processing.rs"],"content":"#![cfg(feature = \"net\")]\nuse des::net::processing::*;\nuse des::prelude::*;\nuse serial_test::serial;\nuse std::sync::atomic::Ordering::SeqCst;\nuse std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\nuse std::sync::Arc;\n\nmod lcommon {\n    use des::net::processing::*;\n    use des::prelude::*;\n\n    pub struct ConsumeAllIncoming;\n    impl ProcessingElement for ConsumeAllIncoming {\n        fn incoming(\u0026mut self, _msg: Message) -\u003e Option\u003cMessage\u003e {\n            None\n        }\n    }\n\n    pub struct IncrementIncomingId;\n    impl ProcessingElement for IncrementIncomingId {\n        fn incoming(\u0026mut self, mut msg: Message) -\u003e Option\u003cMessage\u003e {\n            msg.header_mut().id += 1;\n            Some(msg)\n        }\n    }\n\n    pub struct PanicOnIncoming;\n    impl ProcessingElement for PanicOnIncoming {\n        fn incoming(\u0026mut self, _msg: Message) -\u003e Option\u003cMessage\u003e {\n            panic!(\"common::PanicOnIncoming\")\n        }\n    }\n}\n\n#[derive(Default)]\nstruct PluginCreation {\n    sum: usize,\n}\nimpl Module for PluginCreation {\n    fn stack(\u0026self) -\u003e impl ProcessingElement + 'static {\n        lcommon::IncrementIncomingId\n    }\n\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        for i in 0..100 {\n            schedule_at(\n                Message::new().id(i).build(),\n                SimTime::now() + Duration::from_secs(i as u64),\n            )\n        }\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        assert_eq!(SimTime::now().as_secs() + 1, msg.header().id as u64);\n        self.sum += msg.header().id as usize;\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.sum, (0..100).sum::\u003cusize\u003e() + 100);\n    }\n}\n\n#[test]\n#[serial]\nfn plugin_raw_creation() {\n    // Logger::new().set_logger();\n\n    let mut app = Sim::new(());\n    app.node(\"root\", PluginCreation::default());\n\n    let rt = Builder::seeded(123).build(app);\n    let result = rt.run().unwrap();\n\n    assert_eq!(result.1, SimTime::from_duration(Duration::from_secs(99)));\n    assert_eq!(result.2.event_count, 100);\n}\n\nstruct ActivitySensor {\n    pub expected: usize,\n    pub shared: Arc\u003cAtomicUsize\u003e,\n}\nimpl ProcessingElement for ActivitySensor {\n    fn event_start(\u0026mut self) {\n        let real = self.shared.fetch_add(1, SeqCst);\n        assert_eq!(real, self.expected);\n    }\n\n    fn event_end(\u0026mut self) {\n        let real = self.shared.fetch_sub(1, SeqCst);\n        assert_eq!(real - 1, self.expected);\n    }\n}\n\n#[derive(Default)]\nstruct PluginPriorityDefer {\n    arc: Arc\u003cAtomicUsize\u003e,\n}\nimpl Module for PluginPriorityDefer {\n    fn stack(\u0026self) -\u003e impl IntoProcessingElements {\n        (\n            ActivitySensor {\n                shared: self.arc.clone(),\n                expected: 0,\n            },\n            ActivitySensor {\n                shared: self.arc.clone(),\n                expected: 1,\n            },\n            ActivitySensor {\n                shared: self.arc.clone(),\n                expected: 2,\n            },\n        )\n    }\n\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        for i in 0..100 {\n            schedule_in(Message::new().build(), Duration::from_secs(i));\n        }\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {}\n}\n\n#[test]\n#[serial]\nfn plugin_priority_defer() {\n    // Logger::new().set_logger();\n\n    let mut app = Sim::new(());\n    app.node(\"root\", PluginPriorityDefer::default());\n\n    let rt = Builder::seeded(123).build(app);\n    let result = rt.run();\n\n    let RuntimeResult::Finished { time, profiler, .. } = result else {\n        panic!(\"Unexpected runtime result\")\n    };\n\n    assert_eq!(time, 99.0);\n    assert_eq!(profiler.event_count, 100);\n}\n\nstruct IncrementArcPlugin {\n    arc: Arc\u003cAtomicUsize\u003e,\n}\nimpl ProcessingElement for IncrementArcPlugin {\n    fn incoming(\u0026mut self, msg: Message) -\u003e Option\u003cMessage\u003e {\n        self.arc.fetch_add(1, SeqCst);\n        Some(msg)\n    }\n}\n\nimpl Drop for IncrementArcPlugin {\n    fn drop(\u0026mut self) {\n        assert_eq!(self.arc.load(SeqCst), 20)\n    }\n}\n\n#[derive(Default)]\nstruct PluginAtShutdown {\n    arc: Arc\u003cAtomicUsize\u003e,\n}\nimpl Module for PluginAtShutdown {\n    fn stack(\u0026self) -\u003e impl IntoProcessingElements {\n        IncrementArcPlugin {\n            arc: self.arc.clone(),\n        }\n    }\n\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        if SimTime::now().as_secs() == 0 {\n            // Schedule events at all time points 1..=20\n            for i in 1..=20 {\n                schedule_at(\n                    Message::new().build(),\n                    SimTime::from_duration(Duration::from_secs(i)),\n                )\n            }\n        }\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        if SimTime::now().as_secs() == 10 {\n            // will be back online at second 11\n            shutdow_and_restart_in(Duration::from_millis(500));\n        }\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.arc.load(SeqCst), 20);\n    }\n}\n\n#[test]\n#[serial]\nfn plugin_shutdown_non_persistent_data() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut app = Sim::new(());\n    app.node(\"root\", PluginAtShutdown::default());\n\n    let rt = Builder::seeded(123).build(app);\n\n    let res = rt.run();\n    let _res = res.unwrap();\n}\n\n#[test]\n#[serial]\nfn module_as_processing_element() {\n    static DONE: AtomicBool = AtomicBool::new(false);\n\n    struct A;\n    struct B;\n    impl Module for A {\n        fn handle_message(\u0026mut self, _: Message) {\n            DONE.store(true, Ordering::SeqCst);\n        }\n    }\n    impl Module for B {\n        fn stack(\u0026self) -\u003e impl IntoProcessingElements {\n            A\n        }\n\n        fn handle_message(\u0026mut self, _: Message) {\n            panic!(\"should never be called\");\n        }\n    }\n\n    let mut sim = Sim::new(());\n    sim.node(\"a\", B);\n    let gate = sim.gate(\"a\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate, Message::new().build(), 1.0.into());\n\n    let _ = rt.run();\n    assert!(DONE.load(Ordering::SeqCst));\n}\n\n#[test]\n#[serial]\nfn custom_default_pe() {\n    static DONE: AtomicBool = AtomicBool::new(false);\n\n    struct EatAllAndSayDone;\n    impl ProcessingElement for EatAllAndSayDone {\n        fn incoming(\u0026mut self, _: Message) -\u003e Option\u003cMessage\u003e {\n            DONE.store(true, Ordering::SeqCst);\n            None\n        }\n    }\n\n    fn custom() -\u003e Vec\u003cProcessorElement\u003e {\n        vec![ProcessorElement::new(EatAllAndSayDone)]\n    }\n\n    set_default_processing_elements(custom);\n\n    struct A;\n    impl Module for A {}\n\n    let mut sim = Sim::new(());\n    sim.node(\"a\", A);\n    let gate = sim.gate(\"a\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate, Message::new().build(), 1.0.into());\n\n    let _ = rt.run();\n    assert!(DONE.load(Ordering::SeqCst));\n\n    fn reset() -\u003e Vec\u003cProcessorElement\u003e {\n        Vec::new()\n    }\n\n    set_default_processing_elements(reset)\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":201},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":301},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":51,"coverable":55},{"path":["/","Users","mk","Developer","rust","des","des","tests","select.rs"],"content":"#![cfg(feature = \"macros\")]\nuse des::prelude::*;\nuse std::sync::atomic::AtomicUsize;\n\nstruct Main;\n\nstatic A: AtomicUsize = AtomicUsize::new(0);\nstatic B: AtomicUsize = AtomicUsize::new(0);\n\nimpl AsyncModule for Main {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        tokio::select! {\n            // Note that this test may change its result, if another call to the RNG\n            // is added before the simulation reaches this point.\n            // Thus this test may change, however, it should only change if RNG access changes\n            _ = std::future::ready(()) =\u003e {\n                A.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n            },\n            _ = std::future::ready(()) =\u003e {\n                B.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n            },\n        }\n    }\n}\n\n#[test]\nfn deterministic_branching() {\n    // Since the invalid behaviour is indetermistic.,\n    // check multiple iterations\n    for _ in 0..100 {\n        let mut rt = Sim::new(());\n        rt.node(\"root\", Main);\n\n        let rt = Builder::seeded(123).build(rt);\n        let v = rt.run();\n        assert!(matches!(v, RuntimeResult::EmptySimulation { .. }));\n    }\n\n    let a = A.load(std::sync::atomic::Ordering::SeqCst);\n    let b = B.load(std::sync::atomic::Ordering::SeqCst);\n\n    assert!((a == 100 \u0026\u0026 b == 0) || (a == 0 \u0026\u0026 b == 100));\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":200},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":100},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","Users","mk","Developer","rust","des","des","tests","shutdown.rs"],"content":"#![cfg(feature = \"async\")]\n\nuse des::{net::ModuleFn, prelude::*, time::sleep};\nuse serial_test::serial;\nuse std::sync::{\n    atomic::{AtomicUsize, Ordering},\n    Arc,\n};\n\nstruct DropTest {\n    heap: Vec\u003cusize\u003e,\n    dropper: \u0026'static AtomicUsize,\n}\n\nimpl DropTest {\n    fn new(dropper: \u0026'static AtomicUsize) -\u003e Self {\n        Self {\n            heap: vec![0],\n            dropper,\n        }\n    }\n\n    fn step(\u0026mut self) -\u003e usize {\n        let v = self.heap[self.heap.len() - 1];\n        self.heap.push(v + 1);\n        v + 1\n    }\n}\n\nimpl Drop for DropTest {\n    fn drop(\u0026mut self) {\n        println!(\"DROPPED\");\n        self.dropper.fetch_add(1, Ordering::SeqCst);\n    }\n}\n\nstruct StatelessModule;\n\nimpl AsyncModule for StatelessModule {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        tokio::spawn(async {\n            let mut drop_test = DropTest::new(\u0026DROPPED_STATELESS_SHUTDOWN);\n            loop {\n                sleep(Duration::from_secs(1)).await;\n                drop_test.step();\n            }\n        });\n    }\n\n    async fn handle_message(\u0026mut self, _msg: Message) {\n        shutdown();\n    }\n}\n\nstatic DROPPED_STATELESS_SHUTDOWN: AtomicUsize = AtomicUsize::new(0);\n\n#[test]\n#[serial]\nfn stateless_module_shudown() {\n    println!(\"0\");\n\n    DROPPED_STATELESS_SHUTDOWN.store(0, Ordering::SeqCst);\n    println!(\"1\");\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", StatelessModule);\n    let gate = rt.gate(\"root\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n    rt.add_message_onto(\n        gate,\n        Message::new().build(),\n        SimTime::from_duration(Duration::from_secs(10)),\n    );\n\n    let _ = rt.run().unwrap();\n    assert_eq!(DROPPED_STATELESS_SHUTDOWN.load(Ordering::SeqCst), 1)\n}\n\nstruct StatelessModuleRestart;\n\nimpl AsyncModule for StatelessModuleRestart {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        tokio::spawn(async {\n            let mut drop_test = DropTest::new(\u0026DROPPED_STATLESS_RESTART);\n            loop {\n                sleep(Duration::from_secs(1)).await;\n                drop_test.step();\n            }\n        });\n    }\n\n    async fn handle_message(\u0026mut self, msg: Message) {\n        match msg.header().id {\n            9 =\u003e shutdow_and_restart_at(SimTime::now() + Duration::from_secs(10)),\n            10 =\u003e shutdown(),\n            _ =\u003e unreachable!(),\n        }\n    }\n}\n\nstatic DROPPED_STATLESS_RESTART: AtomicUsize = AtomicUsize::new(0);\n\n#[test]\n#[serial]\nfn stateless_module_restart() {\n    DROPPED_STATLESS_RESTART.store(0, Ordering::SeqCst);\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", StatelessModuleRestart);\n    let gate = rt.gate(\"root\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n    rt.add_message_onto(\n        gate.clone(),\n        Message::new().id(9).build(),\n        SimTime::from_duration(Duration::from_secs(10)),\n    );\n    rt.add_message_onto(\n        gate,\n        Message::new().id(10).build(),\n        SimTime::from_duration(Duration::from_secs(30)),\n    );\n\n    let _ = rt.run().unwrap();\n    assert_eq!(DROPPED_STATLESS_RESTART.load(Ordering::SeqCst), 2)\n}\n\n#[derive(Default)]\nstruct StatefullModule {\n    state: usize,\n}\n\nimpl AsyncModule for StatefullModule {\n    fn reset(\u0026mut self) {\n        assert_eq!(self.state, 10);\n        self.state = 5;\n    }\n\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        self.state = 10;\n        tokio::spawn(async {\n            let mut drop_test = DropTest::new(\u0026DROPPED_STATFULL_RESTART);\n            loop {\n                sleep(Duration::from_secs(1)).await;\n                drop_test.step();\n            }\n        });\n    }\n\n    async fn handle_message(\u0026mut self, msg: Message) {\n        match msg.header().id {\n            9 =\u003e shutdow_and_restart_at(SimTime::now() + Duration::from_secs(10)),\n            10 =\u003e shutdown(),\n            _ =\u003e unreachable!(),\n        }\n    }\n\n    async fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.state, 5)\n    }\n}\n\nstatic DROPPED_STATFULL_RESTART: AtomicUsize = AtomicUsize::new(0);\n\n#[test]\n#[serial]\nfn statefull_module_restart() {\n    DROPPED_STATFULL_RESTART.store(0, Ordering::SeqCst);\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", StatefullModule::default());\n    let gate = rt.gate(\"root\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n    rt.add_message_onto(\n        gate.clone(),\n        Message::new().id(9).build(),\n        SimTime::from_duration(Duration::from_secs(10)),\n    );\n    rt.add_message_onto(\n        gate,\n        Message::new().id(10).build(),\n        SimTime::from_duration(Duration::from_secs(30)),\n    );\n\n    let _ = rt.run().unwrap();\n    assert_eq!(DROPPED_STATFULL_RESTART.load(Ordering::SeqCst), 2);\n}\n\nstruct ShutdownViaHandleModule;\n\nimpl AsyncModule for ShutdownViaHandleModule {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        tokio::spawn(async move {\n            let mut drop_test = DropTest::new(\u0026DROPPED_SHUTDOWN_VIA_HANDLE);\n            loop {\n                sleep(Duration::from_secs(1)).await;\n                if drop_test.step() \u003e 10 {\n                    shutdown()\n                }\n            }\n        });\n    }\n}\n\nstatic DROPPED_SHUTDOWN_VIA_HANDLE: AtomicUsize = AtomicUsize::new(0);\n\n#[test]\n#[serial]\nfn shutdown_via_async_handle() {\n    DROPPED_SHUTDOWN_VIA_HANDLE.store(0, Ordering::SeqCst);\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", ShutdownViaHandleModule);\n\n    let rt = Builder::seeded(123).build(rt);\n\n    let _ = rt.run().unwrap();\n    assert_eq!(DROPPED_SHUTDOWN_VIA_HANDLE.load(Ordering::SeqCst), 1)\n}\n\nstruct RestartViaHandleModule;\n\nimpl AsyncModule for RestartViaHandleModule {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        tokio::spawn(async move {\n            let mut drop_test = DropTest::new(\u0026DROPPED_RESTART_VIA_HANDLE);\n            loop {\n                sleep(Duration::from_secs(1)).await;\n                let v = drop_test.step();\n\n                if v == 10 {\n                    if SimTime::now() \u003c SimTime::from_duration(Duration::from_secs(20)) {\n                        shutdow_and_restart_at(SimTime::from_duration(Duration::from_secs(30)));\n                    } else {\n                        shutdown();\n                    }\n                }\n            }\n        });\n    }\n}\n\nstatic DROPPED_RESTART_VIA_HANDLE: AtomicUsize = AtomicUsize::new(0);\n\n#[test]\n#[serial]\nfn restart_via_async_handle() {\n    DROPPED_RESTART_VIA_HANDLE.store(0, Ordering::SeqCst);\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", RestartViaHandleModule);\n\n    let rt = Builder::seeded(123).build(rt);\n\n    let _ = rt.run().unwrap();\n    assert_eq!(DROPPED_RESTART_VIA_HANDLE.load(Ordering::SeqCst), 2)\n}\n\n#[derive(Clone)]\nstruct CountDropsMessage {\n    counter: Arc\u003cAtomicUsize\u003e,\n}\nimpl MessageBody for CountDropsMessage {\n    fn byte_len(\u0026self) -\u003e usize {\n        1\n    }\n}\nimpl Drop for CountDropsMessage {\n    fn drop(\u0026mut self) {\n        self.counter.fetch_add(1, Ordering::SeqCst);\n    }\n}\n\n#[derive(Default)]\nstruct WillIgnoreInncomingInDowntime {\n    received: Arc\u003cAtomicUsize\u003e,\n    drops: Arc\u003cAtomicUsize\u003e,\n}\n\nimpl Module for WillIgnoreInncomingInDowntime {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        if SimTime::now().as_secs() == 0 {\n            // schedule events for seconds 1..=10\n            for i in 1..=10 {\n                schedule_in(\n                    Message::new()\n                        .content(CountDropsMessage {\n                            counter: self.drops.clone(),\n                        })\n                        .build(),\n                    Duration::from_secs(i),\n                );\n            }\n        }\n    }\n\n    fn handle_message(\u0026mut self, mut msg: Message) {\n        self.received.fetch_add(1, Ordering::SeqCst);\n        if SimTime::now().as_secs() == 6 {\n            shutdow_and_restart_in(Duration::from_secs_f64(2.5));\n            // will miss incoming messages '7 and '8\n        }\n\n        // Forget the message, aka assign an temp counter\n        msg.content_mut::\u003cCountDropsMessage\u003e().counter = Arc::new(AtomicUsize::new(0));\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.received.load(Ordering::SeqCst), 8);\n        assert_eq!(self.drops.load(Ordering::SeqCst), 2);\n    }\n}\n\n#[test]\n#[serial]\nfn shutdown_will_ignore_incoming() {\n    let mut rt = Sim::new(());\n    rt.node(\"root\", WillIgnoreInncomingInDowntime::default());\n\n    let rt = Builder::seeded(123).build(rt);\n\n    let _ = rt.run().unwrap();\n}\n\n#[derive(Default)]\nstruct EndNode {\n    sent: usize,\n    recv: usize,\n    drops: Arc\u003cAtomicUsize\u003e,\n}\n\nimpl Module for EndNode {\n    fn at_sim_start(\u0026mut self, _: usize) {\n        schedule_in(Message::new().kind(1).build(), Duration::from_secs(1));\n    }\n\n    fn handle_message(\u0026mut self, mut msg: Message) {\n        match msg.header().kind {\n            1 =\u003e {\n                if SimTime::now().as_secs() \u003e 10 {\n                    return;\n                }\n\n                self.sent += 1;\n                send(\n                    Message::new()\n                        .kind(2)\n                        .content(CountDropsMessage {\n                            counter: self.drops.clone(),\n                        })\n                        .build(),\n                    \"port\",\n                );\n                schedule_in(Message::new().kind(1).build(), Duration::from_secs(1));\n            }\n            2 =\u003e {\n                self.recv += 1;\n\n                // forget the message drop counter;\n                msg.content_mut::\u003cCountDropsMessage\u003e().counter = Arc::new(AtomicUsize::new(0));\n            }\n            _ =\u003e unreachable!(),\n        }\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.sent, 10);\n        assert_eq!(self.recv, 7);\n\n        assert_eq!(self.drops.load(Ordering::SeqCst), 3);\n    }\n}\n\nstruct Transit;\n\nimpl Module for Transit {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        if SimTime::now() == SimTime::ZERO {\n            schedule_in(Message::new().build(), Duration::from_secs_f64(5.5));\n        }\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        // happens at 5.5 so '6 '7 '8 will be lost\n        shutdow_and_restart_in(Duration::from_secs(3));\n    }\n}\n\n#[test]\n#[serial]\nfn shutdown_will_drop_transiting() {\n    // Logger::new().set_logger();\n    let mut app = Sim::new(());\n    app.node(\"ping\", EndNode::default());\n    app.node(\"pong\", EndNode::default());\n    app.node(\"transit\", Transit);\n\n    let ping = app.gate(\"ping\", \"port\");\n    let pong = app.gate(\"pong\", \"port\");\n    let con = app.gate(\"transit\", \"connector\");\n\n    ping.connect(con.clone(), None);\n    con.connect(pong, None);\n\n    let rt = Builder::seeded(123).max_itr(500).build(app);\n    let _ = rt.run().unwrap();\n}\n\n#[test]\n#[serial]\nfn shutdown_will_drop_transiting_delayed_channels() {\n    // Logger::new().set_logger();\n    let mut app = Sim::new(());\n\n    app.node(\"ping\", EndNode::default());\n    app.node(\"pong\", EndNode::default());\n    app.node(\"transit\", Transit);\n\n    let ping = app.gate(\"ping\", \"port\");\n    let pong = app.gate(\"pong\", \"port\");\n    let con = app.gate(\"transit\", \"connector\");\n\n    ping.connect(\n        con.clone(),\n        Some(Channel::new(ChannelMetrics {\n            bitrate: 100_000,\n            latency: Duration::from_secs_f64(0.004),\n            jitter: Duration::ZERO,\n            drop_behaviour: ChannelDropBehaviour::default(),\n        })),\n    );\n    con.connect(\n        pong,\n        Some(Channel::new(ChannelMetrics {\n            bitrate: 100_000,\n            latency: Duration::from_secs_f64(0.004),\n            jitter: Duration::ZERO,\n            drop_behaviour: ChannelDropBehaviour::default(),\n        })),\n    );\n\n    let rt = Builder::seeded(123).max_itr(500).build(app);\n    let _ = rt.run().unwrap();\n}\n\n#[test]\n#[serial]\nfn shutdown_prevents_accessing_parents() {\n    let mut sim = Sim::new(());\n    sim.node(\"a\", ModuleFn::new(\n        || schedule_in(Message::new().build(), Duration::from_secs(10)),\n        |_, _| {\n            let err = current().child(\"b\").unwrap_err();\n            assert_eq!(err, ModuleReferencingError::CurrentlyInactive(\"The child module 'b' of 'a' is currently shut down, thus cannot be accessed\".to_string()));\n        }\n    ));\n    sim.node(\n        \"a.b\",\n        ModuleFn::new(\n            || schedule_in(Message::new().build(), Duration::from_secs(5)),\n            |_, _| {\n                shutdown();\n            },\n        ),\n    );\n    sim.node(\n        \"a.b.c\",\n        ModuleFn::new(\n            || schedule_in(Message::new().build(), Duration::from_secs(10)),\n            |_, _| {\n                let err = current().parent().unwrap_err();\n                assert_eq!(err, ModuleReferencingError::CurrentlyInactive(\"The parent module of 'a.b.c' is currently shut down, thus cannot be accessed\".to_string()));\n            },\n        ),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":100,"coverable":100},{"path":["/","Users","mk","Developer","rust","des","des","tests","topology.rs"],"content":"#![cfg(feature = \"ndl\")]\nuse des::prelude::*;\n\n#[test]\nfn main() {\n    let app = Sim::ndl(\n        \"tests/ndl/small_network/main.ndl\",\n        Registry::new().with_default_fallback(),\n    )\n    .map_err(|e| println!(\"{e}\"))\n    .unwrap();\n    let rt = Builder::new().build(app);\n    let app = rt.run().into_app();\n    let mut topo = app.globals().topology.lock().unwrap().clone();\n\n    let dj = topo.dijkstra(\"node[1]\".into());\n    assert_eq!(dj.get(\u0026\"node[1]\".into()), None);\n\n    topo.filter_nodes(|n| n.module.name() != \"node[2]\");\n    topo.map_costs(|edge| edge.cost * 2.0);\n    topo.filter_edges(|_| true);\n    assert_eq!(topo.edges(), 9);\n\n    // 4 nodes, router, debugger, main\n    assert_eq!(topo.nodes().len(), 7);\n    assert_eq!(topo.nodes().into_iter().filter(|n| n.alive).count(), 6);\n\n    let i = topo\n        .nodes()\n        .into_iter()\n        .position(|n| n.module.name() == \"router\")\n        .unwrap();\n\n    let j = topo\n        .nodes()\n        .into_iter()\n        .position(|n| n.module.name() == \"debugger\")\n        .unwrap();\n\n    assert!(topo\n        .edges_for(i)\n        .iter()\n        .any(|edge| edge.dst.1 == j \u0026\u0026 edge.src.0.name() == \"debug\"));\n\n    let _ = topo.write_to_svg(\"tests/topology\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","tests","tracing-init.rs"],"content":"#[test]\nfn init() {\n    des::tracing::init();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","tests","tracing.rs"],"content":"use des::{net::{Sim, AsyncFn}, runtime::Builder, tracing::format};\nuse tracing::{level_filters::LevelFilter, subscriber::with_default, Instrument, span, Level};\n\n#[path =\"common/mock.rs\"]\nmod mock;\n\n#[test]\n#[serial_test::serial]\nfn test_mock_output() {\n    let writer = mock::MakeMockWriter::new();\n    let subscriber = tracing_subscriber::fmt()\n        .with_ansi(false)\n        .with_max_level(LevelFilter::TRACE)\n        .event_format(format())\n        .with_writer(writer.clone())\n        .finish();\n\n    with_default(subscriber, || {\n        let sim = Sim::new(());\n        let _ = Builder::seeded(123).build(sim).run();\n\n        tracing::info!(GENERAL = \"Kenobi\", \"Hello there\");\n        assert_eq!(\n            writer.content(),\n            \"[ 0ns ] INFO tracing: Hello there GENERAL=\\\"Kenobi\\\"\\n\"\n        );\n    })\n}\n\n#[test]\n#[serial_test::serial]\nfn scope_regognition() {\n    let writer = mock::MakeMockWriter::new();\n    let subscriber = tracing_subscriber::fmt()\n        .with_ansi(false)\n        .with_max_level(LevelFilter::TRACE)\n        .event_format(format())\n        .with_writer(writer.clone())\n        .finish();\n\n    with_default(subscriber, || {\n        let mut sim = Sim::new(());\n        sim.node(\"a\", AsyncFn::new(|_| async {\n            tracing::info!(\"node(a) says(1) at(0s)\");\n            tracing::error!(\"node(a) says(2) at(0s)\");\n\n        }));\n        sim.node(\"a.b\", AsyncFn::new(|_| async {\n            tracing::trace!(\"node(b) says(1) at(0s)\");\n        }));\n\n        let _ = Builder::seeded(123).build(sim).run();\n        assert_eq!(\n            writer.content(), \n            \"[ 0ns ] INFO a tracing: node(a) says(1) at(0s)\\n[ 0ns ] ERROR a tracing: node(a) says(2) at(0s)\\n[ 0ns ] TRACE a.b tracing: node(b) says(1) at(0s)\\n\"\n        );\n    });\n}\n\n#[test]\n#[serial_test::serial]\nfn time_regognition() {\n    let writer = mock::MakeMockWriter::new();\n    let subscriber = tracing_subscriber::fmt()\n        .with_ansi(false)\n        .with_max_level(LevelFilter::TRACE)\n        .event_format(format())\n        .with_writer(writer.clone())\n        .finish();\n\n    with_default(subscriber, || {\n        let mut sim = Sim::new(());\n        sim.node(\"a\", AsyncFn::new(|_| async {\n            tracing::info!(\"node(a) says(1) at(0s)\");\n            des::time::sleep(std::time::Duration::from_secs(5)).await;\n            tracing::error!(\"node(a) says(2) at(5s)\");\n\n        }));\n        sim.node(\"a.b\", AsyncFn::new(|_| async {\n            tracing::trace!(\"node(b) says(1) at(0s)\");\n        }));\n\n        let _ = Builder::seeded(123).build(sim).run();\n        assert_eq!(\n            writer.content(), \n            \"[ 0ns ] INFO a tracing: node(a) says(1) at(0s)\\n[ 0ns ] TRACE a.b tracing: node(b) says(1) at(0s)\\n[ 5s ] ERROR a tracing: node(a) says(2) at(5s)\\n\"\n        );\n    });\n}\n\n#[test]\n#[serial_test::serial]\nfn span_regognition() {\n    let writer = mock::MakeMockWriter::new();\n    let subscriber = tracing_subscriber::fmt()\n        .with_ansi(false)\n        .with_max_level(LevelFilter::TRACE)\n        .event_format(format())\n        .with_writer(writer.clone())\n        .finish();\n\n    with_default(subscriber, || {\n        let mut sim = Sim::new(());\n        sim.node(\"a\", AsyncFn::new(|_| async {\n            tracing::info!(\"node(a) says(1) at(0s)\");\n        }.instrument(span!(Level::DEBUG, \"my-span\", key=123))));\n        sim.node(\"a.b\", AsyncFn::new(|_| async {\n            tracing::trace!(\"node(b) says(1) at(0s)\");\n        }));\n\n        let _ = Builder::seeded(123).build(sim).run();\n        assert_eq!(\n            writer.content(), \n            \"[ 0ns ] INFO a my-span{key=123}: tracing: node(a) says(1) at(0s)\\n[ 0ns ] TRACE a.b tracing: node(b) says(1) at(0s)\\n\"\n        );\n    });\n}\n\n#[test]\n#[serial_test::serial]\nfn multi_span_regognition() {\n    #[tracing::instrument]\n    async fn say_hello() {\n        tracing::info!(\"hello\")\n    }\n    \n    let writer = mock::MakeMockWriter::new();\n    let subscriber = tracing_subscriber::fmt()\n        .with_ansi(false)\n        .with_max_level(LevelFilter::TRACE)\n        .event_format(format())\n        .with_writer(writer.clone())\n        .finish();\n\n    with_default(subscriber, || {\n        let mut sim = Sim::new(());\n        sim.node(\"a\", AsyncFn::new(|_| async {\n            say_hello().await;\n        }.instrument(span!(Level::DEBUG, \"my-span\", key=123))));\n        sim.node(\"a.b\", AsyncFn::new(|_| async {\n            tracing::trace!(\"node(b) says(1) at(0s)\");\n        }.instrument(span!(Level::DEBUG, \"other-span\"))));\n\n        let _ = Builder::seeded(123).build(sim).run();\n        assert_eq!(\n            writer.content(), \n            \"[ 0ns ] INFO a my-span{key=123}:say_hello: tracing: hello\\n[ 0ns ] TRACE a.b other-span: tracing: node(b) says(1) at(0s)\\n\"\n        );\n    });\n}\n\n#[test]\n#[serial_test::serial]\nfn with_ansi() {\n    #[tracing::instrument]\n    async fn say_hello() {\n        tracing::info!(\"hello\")\n    }\n    \n    let writer = mock::MakeMockWriter::new();\n    let subscriber = tracing_subscriber::fmt()\n        .with_ansi(true)\n        .with_max_level(LevelFilter::TRACE)\n        .event_format(format())\n        .with_writer(writer.clone())\n        .finish();\n\n    with_default(subscriber, || {\n        let mut sim = Sim::new(());\n        sim.node(\"a\", AsyncFn::new(|_| async {\n            tracing::info!(\"Hello World!\")\n        }));\n       \n\n        let _ = Builder::seeded(123).build(sim).run();\n        assert_eq!(\n            writer.content(), \n            \"\\u{1b}[2m[ 0ns ] \\u{1b}[0m\\u{1b}[32ma \\u{1b}[0m\\u{1b}[2mtracing: \\u{1b}[0mHello World!\\n\"\n        );\n    });\n}\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","bin","cqueue-perf-irregular.rs"],"content":"use std::time::{Duration, Instant};\n\nuse des_cqueue::CQueue;\nuse rand::{distributions::Uniform, rngs::SmallRng, Rng, SeedableRng};\n\nfn main() {\n    let args = std::env::args().collect::\u003cVec\u003c_\u003e\u003e();\n    let n = args\n        .iter()\n        .find(|s| s.starts_with(\"--cfg-cqueue-n=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(1024);\n\n    let t = Duration::from_secs_f64(\n        args.iter()\n            .find(|s| s.starts_with(\"--cfg-cqueue-t=\"))\n            .map(|s| s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1].parse::\u003cf64\u003e().unwrap())\n            .unwrap_or(0.005),\n    );\n\n    let num = args\n        .iter()\n        .find(|s| s.starts_with(\"num=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(400);\n\n    let e_delay = args\n        .iter()\n        .find(|s| s.starts_with(\"delay=\"))\n        .map(|s| s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1].parse::\u003cf64\u003e().unwrap())\n        .unwrap_or(1.0);\n\n    let sample = args\n        .iter()\n        .find(|s| s.starts_with(\"sample=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(0x12345678);\n\n    let mut cqueue = CQueue::new(n, t);\n\n    // SETUP\n\n    let mut rng = SmallRng::seed_from_u64(sample as u64);\n\n    let mut delay = Duration::ZERO;\n    for e in 0..num {\n        cqueue.add(delay, e);\n        let rng = rng.sample(Uniform::new(0.0, 1.0));\n        let offset = rng * 4.0 * e_delay;\n        delay += Duration::from_secs_f64(offset);\n    }\n\n    // RUN\n    let e_delay = Duration::from_secs_f64(e_delay);\n\n    let rng_table: Vec\u003cusize\u003e =\n        std::iter::repeat_with(|| rng.sample(Uniform::new(usize::MIN, usize::MAX)))\n            .take(num)\n            .collect();\n\n    let t0 = Instant::now();\n    let mut time = Duration::ZERO;\n    let mut c = 0;\n    let mut pending_event = Vec::new();\n\n    while c \u003c 100_000_000 {\n        let (e, t) = cqueue.fetch_next();\n        time = t;\n\n        pending_event.push(e);\n        while !pending_event.is_empty() {\n            let rng_sample = rng_table[e] % num;\n            if rng_sample \u003c pending_event.len() {\n                cqueue.add(time + e_delay, pending_event.pop().unwrap());\n            } else {\n                break;\n            }\n        }\n\n        // cqueue.add(time + e_delay, e);\n        c += 1;\n    }\n\n    let _ = time;\n\n    println!(\"{}\", Instant::now().duration_since(t0).as_secs_f64());\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":55},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","bin","cqueue-perf.rs"],"content":"use std::time::{Duration, Instant};\n\nuse des_cqueue::CQueue;\nuse rand::{distributions::Uniform, rngs::SmallRng, Rng, SeedableRng};\n\nfn main() {\n    let args = std::env::args().collect::\u003cVec\u003c_\u003e\u003e();\n    let n = args\n        .iter()\n        .find(|s| s.starts_with(\"--cfg-cqueue-n=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(1024);\n\n    let t = Duration::from_secs_f64(\n        args.iter()\n            .find(|s| s.starts_with(\"--cfg-cqueue-t=\"))\n            .map(|s| s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1].parse::\u003cf64\u003e().unwrap())\n            .unwrap_or(0.005),\n    );\n\n    let num = args\n        .iter()\n        .find(|s| s.starts_with(\"num=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(400);\n\n    let e_delay = args\n        .iter()\n        .find(|s| s.starts_with(\"delay=\"))\n        .map(|s| s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1].parse::\u003cf64\u003e().unwrap())\n        .unwrap_or(1.0);\n\n    // let e_size = args\n    //     .iter()\n    //     .find(|s| s.starts_with(\"size=\"))\n    //     .map(|s| {\n    //         s.split(\"=\").collect::\u003cVec\u003c_\u003e\u003e()[1]\n    //             .parse::\u003cusize\u003e()\n    //             .unwrap()\n    //     })\n    //     .unwrap_or(4);\n\n    let sample = args\n        .iter()\n        .find(|s| s.starts_with(\"sample=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(0x12345678);\n\n    let mut cqueue = CQueue::new(n, t);\n\n    // SETUP\n\n    let mut rng = SmallRng::seed_from_u64(sample as u64);\n\n    let mut delay = Duration::ZERO;\n    for e in 0..num {\n        cqueue.add(delay, e);\n        let rng = rng.sample(Uniform::new(0.0, 1.0));\n        let offset = rng * 4.0 * e_delay;\n        delay += Duration::from_secs_f64(offset);\n    }\n\n    // RUN\n    let e_delay = Duration::from_secs_f64(e_delay);\n\n    let t0 = Instant::now();\n    let mut time = Duration::ZERO;\n    let mut c = 0;\n    while c \u003c 100_000_000 {\n        let (e, t) = cqueue.fetch_next();\n        time = t;\n        cqueue.add(time + e_delay, e);\n        c += 1;\n    }\n\n    let _ = time;\n\n    println!(\"{}\", Instant::now().duration_since(t0).as_secs_f64());\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":46},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","lib.rs"],"content":"#![warn(clippy::pedantic)]\n\n// mod nightly;\n// pub use nightly::*;\n\npub mod stable;\npub use stable::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","nightly","alloc.rs"],"content":"use std::{\n    alloc::{self, AllocError, Allocator, Layout},\n    fmt::Debug,\n    mem::{align_of, size_of},\n    ptr::NonNull,\n};\n\nstruct ListNode {\n    size: usize,\n    next: Option\u003c\u0026'static mut ListNode\u003e,\n}\n\nimpl ListNode {\n    const fn new(size: usize) -\u003e Self {\n        ListNode { size, next: None }\n    }\n\n    fn start_addr(\u0026self) -\u003e usize {\n        self as *const Self as usize\n    }\n\n    fn end_addr(\u0026self) -\u003e usize {\n        self.start_addr() + self.size\n    }\n}\n\npub struct CQueueLLAllocatorInner {\n    head: ListNode,\n    pages: Vec\u003c*mut u8\u003e,\n    page_size: usize,\n    allocated_mem: usize,\n}\n\nimpl CQueueLLAllocatorInner {\n    /// Creates an empty LinkedListAllocator.\n    pub fn new() -\u003e Self {\n        Self::with_page_size(page_size::get())\n    }\n\n    pub fn with_page_size(page_size: usize) -\u003e Self {\n        let mut this = Self {\n            head: ListNode::new(0),\n            pages: Vec::new(),\n            page_size,\n            allocated_mem: 0,\n        };\n\n        unsafe {\n            this.add_page();\n        }\n\n        this\n    }\n\n    pub(super) fn metrics(\u0026self) -\u003e (usize, usize) {\n        (self.allocated_mem, self.page_size * self.page_size)\n    }\n\n    #[cfg(test)]\n    pub(crate) fn info(\u0026self) {}\n\n    unsafe fn add_page(\u0026mut self) {\n        let block = alloc::alloc_zeroed(\n            Layout::from_size_align(self.page_size, self.page_size).expect(\"page layout invalid\"),\n        );\n        self.pages.push(block);\n        self.add_free_region(block as usize, self.page_size)\n    }\n\n    pub fn handle(\u0026self) -\u003e CQueueLLAllocator {\n        CQueueLLAllocator {\n            inner: self as *const CQueueLLAllocatorInner as *mut CQueueLLAllocatorInner,\n        }\n    }\n\n    #[cfg(test)]\n    pub(crate) fn dbg_alloc_total(\u0026self) -\u003e usize {\n        self.allocated_mem\n    }\n\n    #[cfg(test)]\n    pub(crate) fn dbg_is_empty(\u0026self) -\u003e bool {\n        self.allocated_mem == 0\n    }\n\n    #[cfg(test)]\n    pub(crate) fn dbg_pages(\u0026self) -\u003e usize {\n        self.pages.len()\n    }\n\n    /// Adds the given memory region to the front of the list.\n    unsafe fn add_free_region(\u0026mut self, addr: usize, size: usize) {\n        // ensure that the freed region is capable of holding ListNode\n        assert_eq!(align_up(addr, align_of::\u003cListNode\u003e()), addr);\n        assert!(size \u003e= size_of::\u003cListNode\u003e());\n\n        // create a new list node and append it at the start of the list\n        let mut node = ListNode::new(size);\n        node.next = self.head.next.take();\n        let node_ptr = addr as *mut ListNode;\n        node_ptr.write(node);\n        self.head.next = Some(\u0026mut *node_ptr)\n    }\n\n    /// Looks for a free region with the given size and alignment and removes\n    /// it from the list.\n    ///\n    /// Returns a tuple of the list node and the start address of the allocation.\n    fn find_region(\u0026mut self, size: usize, align: usize) -\u003e Option\u003c(\u0026'static mut ListNode, usize)\u003e {\n        // reference to current list node, updated for each iteration\n        let mut current = \u0026mut self.head;\n        // look for a large enough memory region in linked list\n        while let Some(ref mut region) = current.next {\n            if let Ok(alloc_start) = Self::alloc_from_region(region, size, align) {\n                // region suitable for allocation -\u003e remove node from list\n                let next = region.next.take();\n                let ret = Some((current.next.take().unwrap(), alloc_start));\n                current.next = next;\n                return ret;\n            } else {\n                // region not suitable -\u003e continue with next region\n                current = current.next.as_mut().unwrap();\n            }\n        }\n\n        // no suitable region found\n        // create new region\n        unsafe {\n            self.add_page();\n            self.find_region(size, align)\n        }\n    }\n\n    /// Try to use the given region for an allocation with given size and\n    /// alignment.\n    ///\n    /// Returns the allocation start address on success.\n    fn alloc_from_region(region: \u0026ListNode, size: usize, align: usize) -\u003e Result\u003cusize, ()\u003e {\n        let alloc_start = align_up(region.start_addr(), align);\n        let alloc_end = alloc_start.checked_add(size).ok_or(())?;\n\n        if alloc_end \u003e region.end_addr() {\n            // region too small\n            return Err(());\n        }\n\n        let excess_size = region.end_addr() - alloc_end;\n        if excess_size \u003e 0 \u0026\u0026 excess_size \u003c size_of::\u003cListNode\u003e() {\n            // rest of region too small to hold a ListNode (required because the\n            // allocation splits the region in a used and a free part)\n            return Err(());\n        }\n\n        // region suitable for allocation\n        Ok(alloc_start)\n    }\n\n    fn size_align(layout: Layout) -\u003e (usize, usize) {\n        let layout = layout\n            .align_to(align_of::\u003cListNode\u003e())\n            .expect(\"adjusting alignment failed\")\n            .pad_to_align();\n        let size = layout.size().max(size_of::\u003cListNode\u003e());\n        (size, layout.align())\n    }\n}\n\nimpl Debug for CQueueLLAllocatorInner {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"CQueueLLAllocatorInner\")\n            .field(\"allocated_memory\", \u0026self.allocated_mem)\n            .field(\"pages\", \u0026self.pages.len())\n            .finish()\n    }\n}\n\nimpl Drop for CQueueLLAllocatorInner {\n    fn drop(\u0026mut self) {\n        let layout = Layout::from_size_align(self.page_size, self.page_size)\n            .expect(\"failed to generate page layout\");\n        for page in self.pages.iter() {\n            unsafe { alloc::dealloc(*page, layout) }\n        }\n    }\n}\n\n// impl Allocator for LinkedListAllocator {}\n\nfn align_up(addr: usize, align: usize) -\u003e usize {\n    (addr + align - 1) \u0026 !(align - 1)\n}\n\n#[derive(Clone, Copy, PartialEq, Eq, Hash)]\npub struct CQueueLLAllocator {\n    inner: *mut CQueueLLAllocatorInner,\n}\n\nunsafe impl Allocator for CQueueLLAllocator {\n    fn allocate(\u0026self, layout: std::alloc::Layout) -\u003e Result\u003cNonNull\u003c[u8]\u003e, AllocError\u003e {\n        let (size, align) = CQueueLLAllocatorInner::size_align(layout);\n        let allocator = unsafe { \u0026mut *self.inner };\n\n        if size \u003e allocator.page_size {\n            return Err(AllocError);\n        }\n\n        if let Some((region, alloc_start)) = allocator.find_region(size, align) {\n            unsafe {\n                let alloc_end = alloc_start.checked_add(size).expect(\"overflow\");\n                let excess_size = region.end_addr() - alloc_end;\n                if excess_size \u003e 0 {\n                    if excess_size \u003c size {\n                        // println!(\"alloc: dropping {} bytes of memory\", excess_size);\n                        // alloc_end = alloc_end.checked_add(size).expect(\"overflow\");\n                    } else {\n                        allocator.add_free_region(alloc_end, excess_size);\n                    }\n                }\n                // println!(\n                //     \"alloc: Layout {{ size: {}, align: {} }} as Layout {{ size: {}, ptr: {} }}\",\n                //     layout.size(),\n                //     layout.align(),\n                //     size,\n                //     alloc_start\n                // );\n                allocator.allocated_mem += size;\n                Ok(NonNull::slice_from_raw_parts(\n                    NonNull::new_unchecked(alloc_start as *mut u8),\n                    size,\n                ))\n            }\n        } else {\n            Err(AllocError)\n        }\n    }\n\n    unsafe fn deallocate(\u0026self, ptr: NonNull\u003cu8\u003e, layout: Layout) {\n        let (size, _) = CQueueLLAllocatorInner::size_align(layout);\n        let allocator = unsafe { \u0026mut *self.inner };\n        allocator.allocated_mem -= size;\n        allocator.add_free_region(ptr.as_ptr() as usize, size)\n    }\n}\n\nimpl Debug for CQueueLLAllocator {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"CQueueLLAllocator\")\n            .field(\"ptr\", \u0026self.inner)\n            .finish()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","nightly","linked_list.rs"],"content":"use super::{alloc::CQueueLLAllocator, EventHandle};\nuse std::{fmt::Debug, hash::Hash, marker::PhantomData, time::Duration};\n\npub(crate) struct DualLinkedList\u003cE\u003e {\n    alloc: CQueueLLAllocator,\n    head: Box\u003cEventNode\u003cE\u003e, CQueueLLAllocator\u003e,\n    tail: Box\u003cEventNode\u003cE\u003e, CQueueLLAllocator\u003e,\n    len: usize,\n}\n\n#[derive(Clone)]\npub struct EventNode\u003cE\u003e {\n    pub(super) value: Option\u003cE\u003e,\n    pub(super) time: Duration,\n\n    pub(super) id: usize,\n\n    pub(super) prev: *mut EventNode\u003cE\u003e,\n    pub(super) next: *mut EventNode\u003cE\u003e,\n}\n\n// IMPL: DLL\n\nimpl\u003cT\u003e DualLinkedList\u003cT\u003e {\n    pub(super) fn new(alloc: CQueueLLAllocator) -\u003e Self {\n        let mut head = EventNode::empty(Duration::ZERO, alloc);\n        let mut tail = EventNode::empty(Duration::MAX, alloc);\n\n        let head_ptr: *mut EventNode\u003cT\u003e = \u0026mut *head;\n        let tail_ptr: *mut EventNode\u003cT\u003e = \u0026mut *tail;\n\n        head.next = tail_ptr;\n        tail.prev = head_ptr;\n\n        Self {\n            alloc,\n            head,\n            tail,\n            len: 0,\n        }\n    }\n\n    pub(super) fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    pub(super) fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    pub(super) fn cancel(\u0026mut self, handle: EventHandle\u003cT\u003e) -\u003e bool {\n        let mut cur = self.head.next;\n        unsafe {\n            while !(*cur).next.is_null() {\n                if (*cur).id == handle.id {\n                    // remove\n                    let cur = Box::from_raw_in(cur, self.alloc);\n                    (*cur.prev).next = cur.next;\n                    (*cur.next).prev = cur.prev;\n                    self.len -= 1;\n\n                    drop(cur);\n                    return true;\n                }\n                cur = (*cur).next;\n            }\n        }\n        false\n    }\n\n    pub(super) fn front_time(\u0026self) -\u003e Duration {\n        // SAFTEY:\n        // Value is guranteed to be valid since head-\u003enext is allways valid\n        let front = unsafe { \u0026mut *self.head.next };\n        if front.next.is_null() {\n            Duration::MAX\n        } else {\n            // SAFTEY:\n            // front is valid, and neither head nor tail so itt must contain a value\n            front.time\n        }\n    }\n\n    /// Inserts a new element into the queue, returing a Handle to\n    /// cancel the event at will\n    pub(super) fn add(\u0026mut self, event: T, time: Duration, event_id: usize) {\n        let mut node = EventNode::new(event, time, event_id, self.alloc);\n        self.len += 1;\n        let node_ptr: *mut EventNode\u003cT\u003e = \u0026mut *node;\n\n        // From back insert\n        let mut cur: *mut EventNode\u003cT\u003e = \u0026mut *self.tail;\n        loop {\n            // SAFTEY:\n            // There a two cases\n            // 1) cur is head -\u003e since head has Duration::MIN the loop will\n            //    break thus cur is a valid ptr.\n            // 2) cur is not head (maybe tail) -\u003e all such elements are guranteed to have\n            //    valid prev ptrs.\n            // Thus cur will be valid, non-null at the end of the loop.\n            // This loop will terminated if there are no circles in the DLL\n            unsafe {\n                if (*cur).time \u003e node.time {\n                    cur = (*cur).prev;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // SAFTEY: cur is valid after the end of the loop (see aboth)\n        let prev = cur;\n        let next = unsafe { (*cur).next };\n\n        node.prev = prev;\n        node.next = next;\n\n        // SAFTEY:\n        // If the ptr is non-null it is valid,\n        // since nodes are only dropped once they were removed from the DLL.\n        // At removal, they remove ptrs to themselfs from other nodes.\n        if !prev.is_null() {\n            unsafe { (*prev).next = node_ptr }\n        }\n\n        // SAFTEY: see prev\n        if !next.is_null() {\n            unsafe { (*next).prev = node_ptr }\n        }\n\n        // Forget the node to leak the memory.\n        std::mem::forget(node);\n    }\n\n    /// Removes the element with the earliest time from the queue.\n    pub(super) fn pop_min(\u0026mut self) -\u003e Option\u003c(T, Duration)\u003e {\n        let node = unsafe { Box::from_raw_in(self.head.next, self.alloc) };\n        if node.next.is_null() {\n            // The node that would have been returned is the tail.\n            // Thus forgett this Box, since the tail is allready owned by self.\n            std::mem::forget(node);\n            None\n        } else {\n            self.len -= 1;\n\n            // The node is not the tail (or the head),\n            // Thus the node has valid ptrs to prev and next.\n            // 1) This head.next will point to a valid node (may be tail)\n            // 2) node.next will be a valid node\n            // 3) node.next.prev will point ot a valid node (head)\n            self.head.next = node.next;\n            unsafe {\n                (*node.next).prev = \u0026mut *self.head;\n            }\n\n            // All references are removed from the DLL thus the node\n            // is only owned by this instance.\n            // Droping the node via into_inner is valid since the only remaining\n            // ref (the NodeHandle) will be invalidated by this operation,\n            // if nessecary\n            let v = node.into_inner();\n            Some(v)\n        }\n    }\n\n    pub(super) fn iter(\u0026self) -\u003e Iter\u003c'_, T\u003e {\n        self.into_iter()\n    }\n\n    #[allow(unused)]\n    pub(super) fn iter_mut(\u0026mut self) -\u003e IterMut\u003c'_, T\u003e {\n        self.into_iter()\n    }\n}\n\nimpl\u003cT\u003e Debug for DualLinkedList\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let head_ptr: *const EventNode\u003cT\u003e = \u0026*self.head;\n        let tail_ptr: *const EventNode\u003cT\u003e = \u0026*self.tail;\n\n        f.debug_struct(\"DLL\")\n            .field(\"head\", \u0026head_ptr)\n            .field(\"tail\", \u0026tail_ptr)\n            .finish()\n    }\n}\n\nimpl\u003cT\u003e Drop for DualLinkedList\u003cT\u003e {\n    fn drop(\u0026mut self) {\n        while self.pop_min().is_some() {}\n    }\n}\n\n// EQ\n\nimpl\u003cT: PartialEq\u003e PartialEq for DualLinkedList\u003cT\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        let mut lhs = self.iter();\n        let mut rhs = other.iter();\n\n        loop {\n            let l = lhs.next();\n            let r = rhs.next();\n            if let Some(l) = l {\n                if let Some(r) = r {\n                    if l.0 != r.0 {\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            } else if r.is_some() {\n                return false;\n            } else {\n                break;\n            }\n        }\n\n        true\n    }\n}\n\nimpl\u003cT: Eq\u003e Eq for DualLinkedList\u003cT\u003e {}\n\n// HASH\n\nimpl\u003cT: Hash\u003e Hash for DualLinkedList\u003cT\u003e {\n    fn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.iter().for_each(|v| v.hash(state))\n    }\n}\n\n// FROM\n\n// IMPL: DLL Into Iter\n\npub struct Iter\u003c'a, T\u003e {\n    marker: PhantomData\u003c\u0026'a DualLinkedList\u003cT\u003e\u003e,\n    cur: *mut EventNode\u003cT\u003e,\n    alloc: CQueueLLAllocator,\n}\n\nimpl\u003c'a, T\u003e Iterator for Iter\u003c'a, T\u003e {\n    type Item = (\u0026'a T, \u0026'a Duration);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        // SAFTEY:\n        // Will point to a valid node since:\n        // IA) head-\u003enext is a valid node\n        // IS) each time the next node is check to be non-null (thus valid)\n        let cur = unsafe { Box::from_raw_in(self.cur, self.alloc) };\n        let result: Option\u003c(*const T, *const Duration)\u003e = {\n            if cur.next.is_null() {\n                // is tail\n                None\n            } else {\n                self.cur = cur.next;\n                // SAFTEY:\n                // cur is allways valid + now non-tail\n                Some((unsafe { cur.value.as_ref().unwrap_unchecked() }, \u0026cur.time))\n            }\n        };\n        std::mem::forget(cur);\n        result.map(|(v, t)| unsafe { (\u0026*v, \u0026*t) })\n    }\n}\n\nimpl\u003c'a, T\u003e IntoIterator for \u0026'a DualLinkedList\u003cT\u003e {\n    type Item = (\u0026'a T, \u0026'a Duration);\n    type IntoIter = Iter\u003c'a, T\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        Iter {\n            marker: PhantomData,\n            cur: self.head.next,\n            alloc: self.alloc,\n        }\n    }\n}\n\npub struct IterMut\u003c'a, T\u003e {\n    marker: PhantomData\u003c\u0026'a mut DualLinkedList\u003cT\u003e\u003e,\n    cur: *mut EventNode\u003cT\u003e,\n    alloc: CQueueLLAllocator,\n}\n\nimpl\u003c'a, T\u003e Iterator for IterMut\u003c'a, T\u003e {\n    type Item = (\u0026'a mut T, \u0026'a Duration);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        // SAFTEY:\n        // Will point to a valid node since:\n        // IA) head-\u003enext is a valid node\n        // IS) each time the next node is check to be non-null (thus valid)\n        let mut cur = unsafe { Box::from_raw_in(self.cur, self.alloc) };\n        let result: Option\u003c(*mut T, *const Duration)\u003e = {\n            if cur.next.is_null() {\n                // is tail\n                None\n            } else {\n                self.cur = cur.next;\n                // SAFTEY:\n                // cur is allways valid + now non-tail\n                Some((unsafe { cur.value.as_mut().unwrap_unchecked() }, \u0026cur.time))\n            }\n        };\n        std::mem::forget(cur);\n        result.map(|(v, t)| unsafe { (\u0026mut *v, \u0026*t) })\n    }\n}\n\nimpl\u003c'a, T\u003e IntoIterator for \u0026'a mut DualLinkedList\u003cT\u003e {\n    type Item = (\u0026'a mut T, \u0026'a Duration);\n    type IntoIter = IterMut\u003c'a, T\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        IterMut {\n            marker: PhantomData,\n            cur: self.head.next,\n            alloc: self.alloc,\n        }\n    }\n}\n\npub struct IntoIter\u003cT\u003e {\n    dll: DualLinkedList\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Iterator for IntoIter\u003cT\u003e {\n    type Item = (T, Duration);\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.dll.pop_min()\n    }\n}\n\nimpl\u003cT\u003e IntoIterator for DualLinkedList\u003cT\u003e {\n    type Item = (T, Duration);\n    type IntoIter = IntoIter\u003cT\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        IntoIter { dll: self }\n    }\n}\n\n// IMPL: Node\n\nimpl\u003cT\u003e EventNode\u003cT\u003e {\n    pub(super) fn empty(\n        time: Duration,\n        alloc: CQueueLLAllocator,\n    ) -\u003e Box\u003cEventNode\u003cT\u003e, CQueueLLAllocator\u003e {\n        Box::new_in(\n            Self {\n                value: None,\n                id: 0,\n                time,\n                prev: std::ptr::null_mut(),\n                next: std::ptr::null_mut(),\n            },\n            alloc,\n        )\n    }\n\n    pub(super) fn new(\n        value: T,\n        time: Duration,\n        id: usize,\n        alloc: CQueueLLAllocator,\n    ) -\u003e Box\u003cEventNode\u003cT\u003e, CQueueLLAllocator\u003e {\n        Box::new_in(\n            Self {\n                value: Some(value),\n                time,\n                id,\n                prev: std::ptr::null_mut(),\n                next: std::ptr::null_mut(),\n            },\n            alloc,\n        )\n    }\n\n    #[allow(clippy::boxed_local)]\n    fn into_inner(mut self: Box\u003cSelf, CQueueLLAllocator\u003e) -\u003e (T, Duration) {\n        // SAFTEY:\n        // This function may only be applied to nodes that are\n        // neither head nor tail. Such notes allways contain a value\n        (unsafe { self.value.take().unwrap_unchecked() }, self.time)\n    }\n}\n\nimpl\u003cE\u003e Debug for EventNode\u003cE\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"EventNode\")\n            .field(\"prev\", \u0026self.prev)\n            .field(\"next\", \u0026self.next)\n            .field(\"time\", \u0026self.time)\n            .field(\"value\", \u0026self.value.is_some())\n            .finish()\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":134},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","nightly","mod.rs"],"content":"use std::{collections::VecDeque, marker::PhantomData, ops::Rem, time::Duration};\n\n// mod _alloc;\nmod alloc;\nmod linked_list;\n\npub(crate) use alloc::*;\nuse linked_list::DualLinkedList;\n\n/// A calender queue.\n///\n/// This type acts as a sorter for entries of type E\n/// that occure at a given point in time, represented by the\n/// Duration type. This means that the fetch_next\n/// method will allways return the entry with the smallest timestamp.\n/// In general, this can be compared to a BinaryHeap where the entries\n/// are a tupel (E, Duration) sorted by the Duration.\n///\n/// Note however that this datatype is optimized for use in a discrete\n/// event simulation. Thus is supports O(1) inserts and removals, as\n/// well as O(1) fetch_next. Note that this is a amorised analysis\n/// assuming that the parameters are optimal for the given distribution\n/// of event arrival times. Additionaly the CQueue does not allow for\n/// the insertion of entries with a timestamp smaller that entries\n/// that was last fetched (or Duration::ZERO initally).\n///\n#[derive(Debug)]\npub struct CQueue\u003cE\u003e {\n    #[allow(unused)]\n    pub(crate) alloc: Box\u003cCQueueLLAllocatorInner\u003e,\n\n    // Parameters\n    pub(crate) n: usize,\n    pub(crate) t: Duration,\n    pub(crate) t_nanos: u128,\n\n    // Buckets\n    pub(crate) zero_event_bucket: VecDeque\u003c(E, Duration, usize)\u003e,\n    pub(crate) buckets: Vec\u003cDualLinkedList\u003cE\u003e\u003e,\n\n    pub(crate) head: usize,\n\n    pub(crate) t_current: Duration,\n    pub(crate) t0: Duration,\n    pub(crate) t1: Duration,\n    pub(crate) t_all: u128,\n\n    // Misc\n    pub(crate) event_id: usize,\n    pub(crate) len: usize,\n}\n\n/// A handle that identifies a event.\n#[derive(Debug, PartialEq, Eq, Hash)]\npub struct EventHandle\u003cE\u003e {\n    _phantom: PhantomData\u003cE\u003e,\n    id: usize,\n    time: Duration,\n}\n\nimpl\u003cE\u003e CQueue\u003cE\u003e {\n    /// Returns a String describing the datatype and its parameters.\n    pub fn descriptor(\u0026self) -\u003e String {\n        format!(\"CTimeVDeque({}, {:?})\", self.n, self.t)\n    }\n\n    /// Returns the number of elements in the queue.\n    pub fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    /// Returns the number of element in the subset that is\n    /// manage by the zero-event-time optimization.\n    pub fn len_zero(\u0026self) -\u003e usize {\n        self.zero_event_bucket.len()\n    }\n\n    /// Returns the number of elements in the subset that is\n    /// not managed by the zero-event-time optimization.\n    pub fn len_nonzero(\u0026self) -\u003e usize {\n        self.len() - self.len_zero()\n    }\n\n    /// Indicates whether the queue is empty.\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    pub fn metrics(\u0026self) -\u003e (usize, usize) {\n        let (alloc, total) = self.alloc.metrics();\n        let additional = std::mem::size_of::\u003cSelf\u003e();\n        let additional = additional + std::mem::size_of::\u003c(E, Duration, usize)\u003e() * self.len_zero();\n        (alloc + additional, total + additional)\n    }\n\n    /// Returns the timestamp of the last emitted event.\n    /// This acts as a lower bound to the insertion of new events.\n    pub fn time(\u0026self) -\u003e Duration {\n        self.t_current\n    }\n\n    /// Creates a new parameteriszed CQueue.\n    pub fn new(n: usize, t: Duration) -\u003e Self {\n        // essentialy t*n\n        let t_all = t.as_nanos() * n as u128;\n\n        let alloc = Box::new(CQueueLLAllocatorInner::new());\n\n        Self {\n            n,\n            t_nanos: t.as_nanos(),\n            t,\n\n            zero_event_bucket: VecDeque::with_capacity(64),\n            buckets: std::iter::repeat_with(|| DualLinkedList::new(alloc.handle()))\n                .take(n)\n                .collect(),\n            head: 0,\n            t_current: Duration::ZERO,\n\n            t0: Duration::ZERO,\n            t1: t,\n\n            t_all,\n\n            alloc,\n            event_id: 0,\n            len: 0,\n        }\n    }\n\n    ///\n    /// Adds an event to the calenderqueue.\n    ///\n    /// Returns an event handle to cancel the event at will.\n    ///\n    /// # Panics\n    ///\n    /// This funtion panics if the timestamp violates the lower\n    /// bound, defined by the timestamp of the last emitted event.\n    ///\n    pub fn add(\u0026mut self, time: Duration, event: E) -\u003e EventHandle\u003cE\u003e {\n        assert!(\n            time \u003e= self.t_current,\n            \"Cannot add past event to calender queue\"\n        );\n\n        self.len += 1;\n        if time == self.t_current {\n            let id = self.event_id;\n            self.zero_event_bucket.push_back((event, time, id));\n            self.event_id = id.wrapping_add(1);\n\n            EventHandle {\n                _phantom: PhantomData,\n                id,\n                time,\n            }\n        } else {\n            // delta time ?\n\n            let time_mod = time.as_nanos().rem(self.t_all);\n\n            let index = time_mod / self.t_nanos;\n            let index: usize = index as usize;\n            let index = index % self.n;\n\n            // find insert pos\n\n            let id = self.event_id;\n            self.buckets[index].add(event, time, id);\n            self.event_id = id.wrapping_add(1);\n            EventHandle {\n                _phantom: PhantomData,\n                id,\n                time,\n            }\n        }\n    }\n\n    pub fn cancel(\u0026mut self, handle: EventHandle\u003cE\u003e) {\n        if handle.time \u003e= self.t_current {\n            if handle.time == self.t_current {\n                if let Some(i) = self\n                    .zero_event_bucket\n                    .iter()\n                    .position(|v| v.2 == handle.id)\n                {\n                    self.zero_event_bucket.remove(i);\n                    self.len -= 1;\n                }\n            } else {\n                let time_mod = handle.time.as_nanos().rem(self.t_all);\n\n                let index = time_mod / self.t_nanos;\n                let index: usize = index as usize;\n                let index = index % self.n;\n\n                if self.buckets[index].cancel(handle) {\n                    self.len -= 1;\n                }\n            }\n        }\n    }\n\n    ///\n    /// Fetches the smalles event from the calender queue.\n    ///\n    /// # Panics\n    ///\n    /// This function assummes that the queue is not empty.\n    /// If it is this function panics.\n    ///\n    pub fn fetch_next(\u0026mut self) -\u003e (E, Duration) {\n        assert!(!self.is_empty(), \"Cannot fetch from empty queue\");\n\n        if let Some((event, time, _)) = self.zero_event_bucket.pop_front() {\n            self.len -= 1;\n            return (event, time);\n        }\n\n        loop {\n            // Move until full bucket is found.\n            while self.buckets[self.head].is_empty() {\n                self.head = (self.head + 1) % self.n;\n                self.t0 += self.t;\n                self.t1 += self.t;\n            }\n\n            // Bucket with \u003e 0 elements found\n\n            let min = self.buckets[self.head].front_time();\n            if min \u003e self.t1 {\n                self.head = (self.head + 1) % self.n;\n                self.t0 += self.t;\n                self.t1 += self.t;\n                continue;\n            }\n\n            self.t_current = min;\n\n            // SAFTEY:\n            // Bucket is non-empty, thus pop-min returns a valid value.\n            self.len -= 1;\n            return unsafe { self.buckets[self.head].pop_min().unwrap_unchecked() };\n        }\n    }\n}\n\nimpl\u003cE\u003e Default for CQueue\u003cE\u003e {\n    fn default() -\u003e Self {\n        Self::new(1024, Duration::from_millis(5))\n    }\n}\n\nimpl\u003cE\u003e Drop for CQueue\u003cE\u003e {\n    fn drop(\u0026mut self) {\n        // Manually drop the DLL so that the alloc can be dropped last\n        for dll in self.buckets.drain(..) {\n            drop(dll)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":76},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","nightly","tests.rs"],"content":"use super::*;\nuse rand::distributions::Uniform;\nuse rand::rngs::SmallRng;\nuse rand::seq::SliceRandom;\nuse rand::*;\nuse std::alloc::{Allocator, Layout};\nuse std::mem::size_of;\nuse std::time::Duration;\n\n#[test]\nfn alloc_single_page_one_alloc_one_allocator() {\n    // Layout will allways be big enoght for a Free Node\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu32 = Box::new_in(42u32, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu32);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu64 = Box::new_in(42u64, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu64);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu128 = Box::new_in(42u128, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu128);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    // Now layout will grow\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let barray = Box::new_in([42u8; 55], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 56); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let barray = Box::new_in([42u8; 128], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 128); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n}\n\n#[test]\nfn alloc_single_page_one_alloc_shared_allocator() {\n    // Layout will allways be big enoght for a Free Node\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu32 = Box::new_in(42u32, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu32);\n    assert!(alloc.dbg_is_empty());\n\n    let bu64 = Box::new_in(42u64, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu64);\n    assert!(alloc.dbg_is_empty());\n\n    let bu128 = Box::new_in(42u128, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu128);\n    assert!(alloc.dbg_is_empty());\n\n    // Now layout will grow\n\n    let barray = Box::new_in([42u8; 55], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 56); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n\n    let barray = Box::new_in([42u8; 128], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 128); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n}\n\n#[test]\nfn alloc_single_page_alloc_exceeds_page_size() {\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    assert!(alloc\n        .handle()\n        .allocate(Layout::new::\u003c[u8; 8000]\u003e())\n        .is_err())\n    // let _ = Box::new_in([42u8; 8000], alloc.handle());\n}\n\n#[test]\nfn alloc_single_page_list_alloc() {\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let mut boxes = Vec::new();\n    for i in 0..10 {\n        boxes.push(Box::new_in([i as u8; 400], alloc.handle()))\n    }\n\n    // 4000 byte\n    assert_eq!(alloc.dbg_alloc_total(), 4000);\n    for i in 0..10 {\n        assert_eq!(boxes[i][0], i as u8);\n    }\n\n    // Drop the last 2000 byte\n    for _ in 0..5 {\n        boxes.pop();\n    }\n\n    assert_eq!(alloc.dbg_alloc_total(), 2000);\n\n    drop(boxes);\n\n    assert!(alloc.dbg_is_empty());\n}\n\n#[test]\nfn alloc_multiple_pages_same_size_allocation() {\n    #[allow(dead_code)]\n    struct A {\n        bytes: [u8; 32],\n        int: u128,\n        s: String,\n    }\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let mut boxes = Vec::new();\n    for _ in 0..100 {\n        boxes.push(Box::new_in(\n            A {\n                bytes: [0; 32],\n                int: 42,\n                s: String::from(\"Hallow str\"),\n            },\n            alloc.handle(),\n        ));\n    }\n\n    assert!(\n        alloc.dbg_alloc_total() \u003e= size_of::\u003cA\u003e() * 100,\n        \"alloc: {} expected: {} * 100\",\n        alloc.dbg_alloc_total(),\n        size_of::\u003cA\u003e()\n    )\n}\n\n#[test]\nfn alloc_multiple_pages_skip_to_small_elements() {\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let b1 = Box::new_in([0u8; 2500], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 2504); // align\n    assert_eq!(alloc.dbg_pages(), 1);\n\n    // remaining bytes of page 1 were skipped\n    // since elements are asssumed to be 2500 bytes big\n\n    let b2 = Box::new_in([0u8; 128], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 2504 + 128); // align\n    assert_eq!(alloc.dbg_pages(), 2);\n\n    drop(b1);\n    drop(b2);\n\n    assert_eq!(alloc.dbg_alloc_total(), 0);\n    assert_eq!(alloc.dbg_pages(), 2);\n\n    drop(alloc);\n}\n\n#[test]\nfn alloc_16_byteboxes() {\n    struct Word {\n        _opaque: [u8; 16],\n    }\n\n    impl Word {\n        fn new() -\u003e Self {\n            Self { _opaque: [42; 16] }\n        }\n    }\n\n    assert_eq!(std::mem::size_of::\u003cWord\u003e(), 16);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let mut list = Vec::new();\n    for _ in 1..10 {\n        let b = Box::new_in(Word::new(), alloc.handle());\n        list.push(b)\n    }\n    alloc.info();\n\n    list.remove(2);\n\n    alloc.info();\n\n    drop(list);\n\n    alloc.info();\n\n    for _ in 1..10 {\n        let b = Box::new_in(Word::new(), alloc.handle());\n        std::mem::forget(b);\n    }\n\n    alloc.info();\n}\n\n// #[test]\n// fn clinked_list() {\n//     let mut ls = CacheOptimizedLinkedList::with_capacity(4);\n//     ls.add(1, Duration::from_secs(1), 1);\n//     println!(\"{:?}\", ls);\n//     ls.add(2, Duration::from_secs(2), 2);\n//     println!(\"{:?}\", ls);\n//     ls.add(3, Duration::from_secs(3), 3);\n//     println!(\"{:?}\", ls);\n\n//     while let Some((event, time, _)) = ls.pop_min() {\n//         println!(\"popped {} at {:?}\", event, time);\n//         println!(\"{:?}\", ls)\n//     }\n\n//     ls.add(4, Duration::from_secs(4), 4);\n//     println!(\"{:?}\", ls);\n// }\n\n// #[test]\n// fn linked_list_ordered_in_ordered_out() {\n//     let events = [\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (5, Duration::from_secs_f64(5.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ];\n\n//     let dll = DLL::from_iter(events.clone());\n//     let event = dll.into_iter().collect::\u003cVec\u003c_\u003e\u003e();\n\n//     assert_eq!(\u0026events[..], \u0026event);\n// }\n\n// #[test]\n// fn linked_list_unordered_in_ordered_out() {\n//     let mut events = [\n//         (5, Duration::from_secs_f64(5.0)),\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//     ];\n\n//     let dll = CacheOptimizedLinkedList::from_iter(events.clone());\n//     let event = dll.into_iter().collect::\u003cVec\u003c_\u003e\u003e();\n\n//     events.sort();\n\n//     assert_eq!(\u0026events[..], \u0026event);\n// }\n\n// #[test]\n// fn linked_list_ordered_collision_in_retain() {\n//     let events = [\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (3, Duration::from_secs_f64(4.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (5, Duration::from_secs_f64(5.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ];\n\n//     let dll = CacheOptimizedLinkedList::from_iter(events.clone());\n//     let event = dll.into_iter().collect::\u003cVec\u003c_\u003e\u003e();\n\n//     assert_eq!(\u0026events[..], \u0026event);\n// }\n\n// #[test]\n// fn linked_list_unordered_collision_in_retain() {\n//     let mut events = [\n//         (5, Duration::from_secs_f64(5.0)),\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//         (4, Duration::from_secs_f64(1.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//     ];\n\n//     let dll = CacheOptimizedLinkedList::from_iter(events.clone());\n//     let event = dll.into_iter().collect::\u003cVec\u003c_\u003e\u003e();\n\n//     events.sort_by(|l, r| l.1.cmp(\u0026r.1));\n\n//     assert_eq!(\u0026events[..], \u0026event);\n// }\n\n// #[test]\n// fn linked_list_iter_and_iter_mut() {\n//     let events = [\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (5, Duration::from_secs_f64(5.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ];\n\n//     let mut dll = CacheOptimizedLinkedList::from_iter(events.clone());\n\n//     let mut c = 1;\n//     for item in dll.iter() {\n//         assert_eq!(*item.0, c);\n//         assert_eq!(item.1.as_secs(), c);\n//         c += 1;\n//     }\n\n//     for item in dll.iter_mut() {\n//         *item.0 += 1;\n//     }\n\n//     let mut c = 1;\n//     for item in dll.iter() {\n//         assert_eq!(*item.0, c + 1);\n//         assert_eq!(item.1.as_secs(), c);\n//         c += 1;\n//     }\n// }\n\n// #[test]\n// fn linked_list_ordered_in_eq() {\n//     let events = [\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (5, Duration::from_secs_f64(5.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ];\n\n//     let dll = CacheOptimizedLinkedList::from(events);\n//     let dll2 = CacheOptimizedLinkedList::from(events);\n\n//     assert_eq!(dll, dll2)\n// }\n\n// #[test]\n// fn linked_list_unordered_in_eq() {\n//     let dll = CacheOptimizedLinkedList::from([\n//         (4, Duration::from_secs_f64(4.0)),\n//         (5, Duration::from_secs_f64(5.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//         (1, Duration::from_secs_f64(1.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//     ]);\n\n//     let dll2 = CacheOptimizedLinkedList::from([\n//         (5, Duration::from_secs_f64(5.0)),\n//         (1, Duration::from_secs_f64(1.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ]);\n\n//     assert_eq!(dll, dll2)\n// }\n\n// #[test]\n// fn linked_list_same_time_in_order() {\n//     let dll = CacheOptimizedLinkedList::from([\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(3.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(3.0)),\n//         (5, Duration::from_secs_f64(3.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ]);\n//     let mut c = 1;\n//     for item in dll {\n//         assert_eq!(item.0, c);\n//         c += 1;\n//     }\n//     assert_eq!(c, 7);\n\n//     let dll = CacheOptimizedLinkedList::from([\n//         // (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(3.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(3.0)),\n//         (5, Duration::from_secs_f64(3.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ]);\n//     let mut c = 2;\n//     for item in dll {\n//         assert_eq!(item.0, c);\n//         c += 1;\n//     }\n//     assert_eq!(c, 7);\n\n//     let dll = CacheOptimizedLinkedList::from([\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(3.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(3.0)),\n//         (5, Duration::from_secs_f64(3.0)),\n//         // (6, Duration::from_secs_f64(6.0)),\n//     ]);\n//     let mut c = 1;\n//     for item in dll {\n//         assert_eq!(item.0, c);\n//         c += 1;\n//     }\n//     assert_eq!(c, 6);\n// }\n\n// #[test]\n// fn linked_list_remove_min() {\n//     let mut CacheOptimizedLinkedList = CacheOptimizedLinkedList::from([\n//         // (1, Duration::from_secs_f64(1.0)),\n//         // (2, Duration::from_secs_f64(2.0)),\n//         // (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (5, Duration::from_secs_f64(5.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ]);\n\n//     let e1 = CacheOptimizedLinkedList.add(1, Duration::from_secs_f64(1.0));\n//     let e2 = CacheOptimizedLinkedList.add(2, Duration::from_secs_f64(2.0));\n//     let e3 = CacheOptimizedLinkedList.add(3, Duration::from_secs_f64(3.0));\n\n//     assert_eq!(CacheOptimizedLinkedList.len(), 6);\n//     e1.cancel();\n//     assert_eq!(CacheOptimizedLinkedList.len(), 5);\n//     e3.cancel();\n//     assert_eq!(CacheOptimizedLinkedList.len(), 4);\n//     e2.cancel();\n//     assert_eq!(CacheOptimizedLinkedList.len(), 3);\n\n//     assert_eq!(\n//         CacheOptimizedLinkedList.into_iter().collect::\u003cVec\u003c_\u003e\u003e(),\n//         vec![\n//             (4, Duration::from_secs_f64(4.0)),\n//             (5, Duration::from_secs_f64(5.0)),\n//             (6, Duration::from_secs_f64(6.0)),\n//         ]\n//     )\n// }\n\n// #[test]\n// fn linked_list_remove_back() {\n//     let mut CacheOptimizedLinkedList = CacheOptimizedLinkedList::from([\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         // (4, Duration::from_secs_f64(4.0)),\n//         // (5, Duration::from_secs_f64(5.0)),\n//         // (6, Duration::from_secs_f64(6.0)),\n//     ]);\n\n//     let e1 = CacheOptimizedLinkedList.add(4, Duration::from_secs_f64(4.0));\n//     let e2 = CacheOptimizedLinkedList.add(5, Duration::from_secs_f64(5.0));\n//     let e3 = CacheOptimizedLinkedList.add(6, Duration::from_secs_f64(6.0));\n\n//     assert_eq!(CacheOptimizedLinkedList.len(), 6);\n//     e3.cancel();\n//     assert_eq!(CacheOptimizedLinkedList.len(), 5);\n//     e1.cancel();\n//     assert_eq!(CacheOptimizedLinkedList.len(), 4);\n//     e2.cancel();\n//     assert_eq!(CacheOptimizedLinkedList.len(), 3);\n\n//     assert_eq!(\n//         CacheOptimizedLinkedList.into_iter().collect::\u003cVec\u003c_\u003e\u003e(),\n//         vec![\n//             (1, Duration::from_secs_f64(1.0)),\n//             (2, Duration::from_secs_f64(2.0)),\n//             (3, Duration::from_secs_f64(3.0)),\n//         ]\n//     )\n// }\n\n#[test]\nfn cqueue_simple_event_order_nonoverlapping() {\n    let mut cqueue = CQueue::new(100, Duration::from_secs(1));\n    let events = (0..=100).map(|e| (e, Duration::from_secs(e)));\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    assert_eq!(cqueue.len(), 101);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        println!(\"Itr: {}\", c);\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_simple_event_order_wrap_around() {\n    // This test is identicall to 'cqueue_simple_event_order_nonoverlapping'\n    // but with other config options for the cqueue.\n    let mut cqueue = CQueue::new(20, Duration::from_secs(1));\n    let events = (0..=100).map(|e| (e, Duration::from_secs(e)));\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_simple_event_out_of_order_nonoverlapping() {\n    let mut cqueue = CQueue::new(100, Duration::from_secs(1));\n    let mut events = (0..=100)\n        .map(|e| (e, Duration::from_secs(e)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    let mut rng = SmallRng::seed_from_u64(123);\n    events.shuffle(\u0026mut rng);\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    assert_eq!(cqueue.len(), 101);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        println!(\"Itr: {}\", c);\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_simple_event_out_of_order_wrap_around() {\n    // This test is identicall to 'cqueue_simple_event_order_nonoverlapping'\n    // but with other config options for the cqueue.\n    let mut cqueue = CQueue::new(20, Duration::from_secs(1));\n    let mut events = (0..=100)\n        .map(|e| (e, Duration::from_secs(e)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    let mut rng = SmallRng::seed_from_u64(123);\n    events.shuffle(\u0026mut rng);\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_zero_bucket_in_out() {\n    let mut cqueue = CQueue::new(10, Duration::new(1, 0));\n    for i in 0..10 {\n        cqueue.add(Duration::ZERO, i);\n    }\n    assert_eq!(cqueue.len_zero(), 10);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 2 - without forwarding to the current event\n\n    for i in 0..10 {\n        cqueue.add(Duration::new(9, 0), i);\n    }\n    assert_eq!(cqueue.len_zero(), 0);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 3: allready forwared\n\n    for i in 0..10 {\n        cqueue.add(Duration::new(9, 0), i);\n    }\n    assert_eq!(cqueue.len_zero(), 10);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n}\n\n#[test]\nfn cqueue_zero_bucket_cancel() {\n    let mut cqueue = CQueue::new(10, Duration::new(1, 0));\n    let mut handles = (0..10)\n        .map(|i| cqueue.add(Duration::ZERO, i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len_zero(), 10);\n\n    // remove element 6\n    cqueue.cancel(handles.remove(6));\n    assert_eq!(cqueue.len(), 9);\n    assert_eq!(cqueue.len_zero(), 9);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        if c == 6 {\n            c += 1;\n            continue;\n        }\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 2 - without forwarding to the current event\n\n    let mut handles = (0..10)\n        .map(|i| cqueue.add(Duration::new(9, 0), i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len_zero(), 0);\n\n    cqueue.cancel(handles.remove(3));\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        if c == 3 {\n            c += 1;\n            continue;\n        }\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 3: allready forwared\n\n    let mut handles = (0..10)\n        .map(|i| cqueue.add(Duration::new(9, 0), i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len_zero(), 10);\n\n    cqueue.cancel(handles.remove(0));\n\n    let mut c = 1;\n    while !cqueue.is_empty() {\n        // if c == 0 { ... }\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n}\n\n#[test]\nfn cqueue_out_of_order_with_overlaps() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut delay = Duration::new(1, 0);\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut events = (0..200)\n        .map(|v| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.1, 1.0)));\n            (v, delay)\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    events.shuffle(\u0026mut rng);\n    let _ = events\n        .into_iter()\n        .map(|(event, time)| cqueue.add(time, event))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut last_time = Duration::ZERO;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 200 - c);\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e last_time);\n\n        last_time = t;\n        c += 1;\n    }\n    assert_eq!(c, 200);\n}\n\n#[test]\nfn cqueue_out_of_order_with_cancel() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut delay = Duration::new(1, 0);\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut events = (0..200)\n        .map(|v| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.1, 1.0)));\n            (v, delay, rng.sample(Uniform::new(1, 10)) == 8)\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    events.shuffle(\u0026mut rng);\n    let handles = events\n        .into_iter()\n        .map(|(event, time, cancel)| (cqueue.add(time, event), cancel, event))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let canceled = handles\n        .into_iter()\n        .filter_map(|(h, flg, event)| {\n            if flg {\n                cqueue.cancel(h);\n                Some(event)\n            } else {\n                None\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut last_time = Duration::ZERO;\n    while !cqueue.is_empty() {\n        if canceled.contains(\u0026c) {\n            c += 1;\n            continue;\n        }\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e last_time);\n\n        last_time = t;\n        c += 1;\n    }\n    // The 200th event was canceld thus the loop broke, event though one\n    // iteration was still due (to be simpliar to previous test cases)\n    assert_eq!(c, 199);\n}\n\n#[test]\nfn cqueue_out_of_order_boxes_overlapping() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut delay = Duration::new(1, 0);\n    let mut s = 0;\n    let mut event_boxes = (0..100)\n        .map(|_| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.0, 1.0)));\n            let n = rng.sample(Uniform::new(1, 4));\n            let old_s = s;\n            s += n;\n            (delay, old_s, n)\n        })\n        // .map(|(t, from, n)| (from..(from + n)).map(|i| (i, t)))\n        // .flatten()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    event_boxes.shuffle(\u0026mut rng);\n    let _ = event_boxes\n        .into_iter()\n        .map(|(t, from, n)| (from..(from + n)).map(move |i| (i, t)))\n        .flatten()\n        .map(|(e, t)| cqueue.add(t, e))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut lt = Duration::ZERO;\n    while !cqueue.is_empty() {\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e= lt);\n        c += 1;\n        lt = t;\n    }\n}\n\n#[test]\nfn cqueue_out_of_order_boxes_with_cancel() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut delay = Duration::new(1, 0);\n    let mut s = 0;\n    let mut event_boxes = (0..100)\n        .map(|_| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.0, 1.0)));\n            let n = rng.sample(Uniform::new(1, 4));\n            let old_s = s;\n            s += n;\n            (delay, old_s, n)\n        })\n        // .map(|(t, from, n)| (from..(from + n)).map(|i| (i, t)))\n        // .flatten()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    event_boxes.shuffle(\u0026mut rng);\n    let handles = event_boxes\n        .into_iter()\n        .map(|(t, from, n)| (from..(from + n)).map(move |i| (i, t)))\n        .flatten()\n        .map(|(e, t)| (cqueue.add(t, e), e, rng.sample(Uniform::new(1, 10)) == 2))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    // Cancel events\n    let cancelled = handles\n        .into_iter()\n        .filter_map(|(h, e, flg)| {\n            if flg {\n                cqueue.cancel(h);\n                Some(e)\n            } else {\n                None\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut lt = Duration::ZERO;\n    while !cqueue.is_empty() {\n        if cancelled.contains(\u0026c) {\n            c += 1;\n            continue;\n        }\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e= lt);\n        c += 1;\n        lt = t;\n    }\n}\n\n#[test]\nfn cqueue_cancel_validity() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut handles = (0..10)\n        .map(|i| Some(cqueue.add(Duration::from_secs(i), i)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len(), 10);\n\n    // Succesful cancel 0, 9\n    cqueue.cancel(handles[0].take().unwrap());\n    cqueue.cancel(handles[9].take().unwrap());\n\n    assert_eq!(cqueue.len(), 8);\n\n    // Cur [1,2,3,4,5,6,7,8]\n    for i in 1..4 {\n        let event = cqueue.fetch_next();\n        assert_eq!(event.0, i);\n    }\n    assert_eq!(cqueue.len(), 5);\n\n    // Cur [4,5,6,7,8]\n    cqueue.cancel(handles[2].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    cqueue.cancel(handles[3].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    // Suc again\n    cqueue.cancel(handles[8].take().unwrap());\n    assert_eq!(cqueue.len(), 4);\n\n    // Cur [4,5,6,7]\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let _ = cqueue.fetch_next();\n        c += 1;\n    }\n\n    assert_eq!(c, 4)\n}\n\n#[test]\nfn cqueue_cancel_validity_2() {\n    let mut cqueue = CQueue::new(10, Duration::new(3, 0));\n    let mut handles = (0..10)\n        .map(|i| Some(cqueue.add(Duration::from_secs(i), i)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len(), 10);\n\n    // Succesful cancel 0, 9\n    cqueue.cancel(handles[0].take().unwrap());\n    cqueue.cancel(handles[9].take().unwrap());\n\n    assert_eq!(cqueue.len(), 8);\n\n    // Cur [1,2,3,4,5,6,7,8]\n    for i in 1..4 {\n        let event = cqueue.fetch_next();\n        assert_eq!(event.0, i);\n    }\n    assert_eq!(cqueue.len(), 5);\n\n    // Cur [4,5,6,7,8]\n    cqueue.cancel(handles[2].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    cqueue.cancel(handles[3].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    // Suc again\n    cqueue.cancel(handles[8].take().unwrap());\n    assert_eq!(cqueue.len(), 4);\n\n    // Cur [4,5,6,7]\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let _ = cqueue.fetch_next();\n        c += 1;\n    }\n\n    assert_eq!(c, 4)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","stable","alloc.rs"],"content":"use std::{\n    alloc::{self, Layout},\n    fmt::Debug,\n    mem::{align_of, size_of},\n    ptr::NonNull,\n};\n\nstruct ListNode {\n    size: usize,\n    next: Option\u003c\u0026'static mut ListNode\u003e,\n}\n\nimpl ListNode {\n    fn new(size: usize) -\u003e Self {\n        ListNode { size, next: None }\n    }\n\n    fn start_addr(\u0026self) -\u003e usize {\n        self as *const Self as usize\n    }\n\n    fn end_addr(\u0026self) -\u003e usize {\n        self.start_addr() + self.size\n    }\n}\n\npub struct CQueueLLAllocatorInner {\n    head: ListNode,\n    pages: Vec\u003c*mut u8\u003e,\n    page_size: usize,\n    allocated_mem: usize,\n}\n\nimpl CQueueLLAllocatorInner {\n    /// Creates an empty `LinkedListAllocator`.\n    pub fn new() -\u003e Self {\n        Self::with_page_size(page_size::get())\n    }\n\n    pub fn with_page_size(page_size: usize) -\u003e Self {\n        let mut this = Self {\n            head: ListNode::new(0),\n            pages: Vec::new(),\n            page_size,\n            allocated_mem: 0,\n        };\n\n        unsafe {\n            this.add_page();\n        }\n\n        this\n    }\n\n    pub(super) fn metrics(\u0026self) -\u003e (usize, usize) {\n        (self.allocated_mem, self.page_size * self.page_size)\n    }\n\n    #[cfg(test)]\n    pub(crate) fn info(\u0026self) {}\n\n    unsafe fn add_page(\u0026mut self) {\n        let block = alloc::alloc_zeroed(\n            Layout::from_size_align(self.page_size, self.page_size).expect(\"page layout invalid\"),\n        );\n        self.pages.push(block);\n        self.add_free_region(block as usize, self.page_size);\n    }\n\n    pub fn handle(\u0026self) -\u003e CQueueLLAllocator {\n        CQueueLLAllocator {\n            inner: (self as *const CQueueLLAllocatorInner).cast_mut(),\n        }\n    }\n\n    #[cfg(test)]\n    pub(crate) fn dbg_alloc_total(\u0026self) -\u003e usize {\n        self.allocated_mem\n    }\n\n    #[cfg(test)]\n    pub(crate) fn dbg_is_empty(\u0026self) -\u003e bool {\n        self.allocated_mem == 0\n    }\n\n    #[cfg(test)]\n    pub(crate) fn dbg_pages(\u0026self) -\u003e usize {\n        self.pages.len()\n    }\n\n    /// Adds the given memory region to the front of the list.\n    unsafe fn add_free_region(\u0026mut self, addr: usize, size: usize) {\n        // ensure that the freed region is capable of holding ListNode\n        assert_eq!(align_up(addr, align_of::\u003cListNode\u003e()), addr);\n        assert!(size \u003e= size_of::\u003cListNode\u003e());\n\n        // create a new list node and append it at the start of the list\n        let mut node = ListNode::new(size);\n        node.next = self.head.next.take();\n        let node_ptr = addr as *mut ListNode;\n        node_ptr.write(node);\n        self.head.next = Some(\u0026mut *node_ptr);\n    }\n\n    /// Looks for a free region with the given size and alignment and removes\n    /// it from the list.\n    ///\n    /// Returns a tuple of the list node and the start address of the allocation.\n    fn find_region(\u0026mut self, size: usize, align: usize) -\u003e Option\u003c(\u0026'static mut ListNode, usize)\u003e {\n        // reference to current list node, updated for each iteration\n        let mut current = \u0026mut self.head;\n        // look for a large enough memory region in linked list\n        while let Some(ref mut region) = current.next {\n            if let Ok(alloc_start) = Self::alloc_from_region(region, size, align) {\n                // region suitable for allocation -\u003e remove node from list\n                let next = region.next.take();\n                let ret = Some((current.next.take().unwrap(), alloc_start));\n                current.next = next;\n                return ret;\n            }\n            // region not suitable -\u003e continue with next region\n            current = current.next.as_mut().unwrap();\n        }\n\n        // no suitable region found\n        // create new region\n        unsafe {\n            self.add_page();\n            self.find_region(size, align)\n        }\n    }\n\n    /// Try to use the given region for an allocation with given size and\n    /// alignment.\n    ///\n    /// Returns the allocation start address on success.\n    fn alloc_from_region(region: \u0026ListNode, size: usize, align: usize) -\u003e Result\u003cusize, ()\u003e {\n        let alloc_start = align_up(region.start_addr(), align);\n        let alloc_end = alloc_start.checked_add(size).ok_or(())?;\n\n        if alloc_end \u003e region.end_addr() {\n            // region too small\n            return Err(());\n        }\n\n        let excess_size = region.end_addr() - alloc_end;\n        if excess_size \u003e 0 \u0026\u0026 excess_size \u003c size_of::\u003cListNode\u003e() {\n            // rest of region too small to hold a ListNode (required because the\n            // allocation splits the region in a used and a free part)\n            return Err(());\n        }\n\n        // region suitable for allocation\n        Ok(alloc_start)\n    }\n\n    fn size_align(layout: Layout) -\u003e (usize, usize) {\n        let layout = layout\n            .align_to(align_of::\u003cListNode\u003e())\n            .expect(\"adjusting alignment failed\")\n            .pad_to_align();\n        let size = layout.size().max(size_of::\u003cListNode\u003e());\n        (size, layout.align())\n    }\n}\n\n#[allow(clippy::missing_fields_in_debug)]\nimpl Debug for CQueueLLAllocatorInner {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"CQueueLLAllocatorInner\")\n            .field(\"allocated_memory\", \u0026self.allocated_mem)\n            .field(\"pages\", \u0026self.pages.len())\n            .finish()\n    }\n}\n\nimpl Drop for CQueueLLAllocatorInner {\n    fn drop(\u0026mut self) {\n        let layout = Layout::from_size_align(self.page_size, self.page_size)\n            .expect(\"failed to generate page layout\");\n        for page in \u0026self.pages {\n            unsafe { alloc::dealloc(*page, layout) }\n        }\n    }\n}\n\n// impl Allocator for LinkedListAllocator {}\n\nfn align_up(addr: usize, align: usize) -\u003e usize {\n    (addr + align - 1) \u0026 !(align - 1)\n}\n\n#[derive(Clone, Copy, PartialEq, Eq, Hash)]\npub struct CQueueLLAllocator {\n    inner: *mut CQueueLLAllocatorInner,\n}\n\nimpl CQueueLLAllocator {\n    pub fn allocate(\u0026self, layout: std::alloc::Layout) -\u003e Result\u003c*mut u8, ()\u003e {\n        let (size, align) = CQueueLLAllocatorInner::size_align(layout);\n        let allocator = unsafe { \u0026mut *self.inner };\n\n        if size \u003e allocator.page_size {\n            return Err(());\n        }\n\n        if let Some((region, alloc_start)) = allocator.find_region(size, align) {\n            unsafe {\n                let alloc_end = alloc_start.checked_add(size).expect(\"overflow\");\n                let excess_size = region.end_addr() - alloc_end;\n                if excess_size \u003e 0 {\n                    if excess_size \u003c size {\n                        // println!(\"alloc: dropping {} bytes of memory\", excess_size);\n                        // alloc_end = alloc_end.checked_add(size).expect(\"overflow\");\n                    } else {\n                        allocator.add_free_region(alloc_end, excess_size);\n                    }\n                }\n                // println!(\n                //     \"alloc: Layout {{ size: {}, align: {} }} as Layout {{ size: {}, ptr: {} }}\",\n                //     layout.size(),\n                //     layout.align(),\n                //     size,\n                //     alloc_start\n                // );\n                allocator.allocated_mem += size;\n                Ok(alloc_start as *mut u8)\n            }\n        } else {\n            Err(())\n        }\n    }\n\n    pub unsafe fn deallocate(\u0026self, ptr: NonNull\u003cu8\u003e, layout: Layout) {\n        let (size, _) = CQueueLLAllocatorInner::size_align(layout);\n        let allocator = unsafe { \u0026mut *self.inner };\n        allocator.allocated_mem -= size;\n        allocator.add_free_region(ptr.as_ptr() as usize, size);\n    }\n}\n\nimpl Debug for CQueueLLAllocator {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"CQueueLLAllocator\")\n            .field(\"ptr\", \u0026self.inner)\n            .finish()\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":950867},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1911620},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1911620},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1433714},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1433714},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3100},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3100},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3100},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3100},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":180471},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":180471},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":480806},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":480806},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":958714},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":2902},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2902},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":477906},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":477906},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":955812},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":950481},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":955800},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":955800},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":955800},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":955800},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":955800},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":6398},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":3100},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1428575},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1428575},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":477905},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":477905},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":477905},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":477905},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":475480},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":469674},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":77,"coverable":88},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","stable","boxed.rs"],"content":"use std::{\n    alloc::Layout,\n    ops::{Deref, DerefMut},\n    ptr::{self, NonNull},\n};\n\nuse super::alloc::CQueueLLAllocator;\n\npub struct LocalBox\u003cE\u003e {\n    ptr: *mut E,\n    alloc: CQueueLLAllocator,\n}\n\nimpl\u003cE\u003e LocalBox\u003cE\u003e {\n    pub fn new_in(value: E, alloc: CQueueLLAllocator) -\u003e LocalBox\u003cE\u003e {\n        let bytes = alloc.allocate(Layout::new::\u003cE\u003e()).unwrap();\n        let ptr = bytes.cast::\u003cE\u003e();\n        unsafe {\n            ptr::write_volatile(ptr, value);\n        }\n        LocalBox { ptr, alloc }\n    }\n\n    pub unsafe fn from_raw_in(ptr: *mut E, alloc: CQueueLLAllocator) -\u003e LocalBox\u003cE\u003e {\n        LocalBox { ptr, alloc }\n    }\n}\n\nimpl\u003cE\u003e Deref for LocalBox\u003cE\u003e {\n    type Target = E;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        unsafe { \u0026*self.ptr }\n    }\n}\n\nimpl\u003cE\u003e DerefMut for LocalBox\u003cE\u003e {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        unsafe { \u0026mut *self.ptr }\n    }\n}\n\nimpl\u003cE\u003e Drop for LocalBox\u003cE\u003e {\n    fn drop(\u0026mut self) {\n        unsafe {\n            ptr::drop_in_place(self.ptr);\n\n            let ptr = NonNull::new(self.ptr.cast::\u003cu8\u003e()).unwrap();\n            self.alloc.deallocate(ptr, Layout::new::\u003cE\u003e());\n        }\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":297434},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":4149451},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4149451},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1658044},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1658044},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null}],"covered":13,"coverable":13},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","stable","linked_list.rs"],"content":"use super::{alloc::CQueueLLAllocator, boxed::LocalBox, EventHandle};\nuse std::{fmt::Debug, hash::Hash, marker::PhantomData, time::Duration};\n\npub(crate) struct DualLinkedList\u003cE\u003e {\n    alloc: CQueueLLAllocator,\n    head: LocalBox\u003cEventNode\u003cE\u003e\u003e,\n    tail: LocalBox\u003cEventNode\u003cE\u003e\u003e,\n    len: usize,\n}\n\n#[derive(Clone)]\npub struct EventNode\u003cE\u003e {\n    pub(super) value: Option\u003cE\u003e,\n    pub(super) time: Duration,\n\n    pub(super) id: usize,\n\n    pub(super) prev: *mut EventNode\u003cE\u003e,\n    pub(super) next: *mut EventNode\u003cE\u003e,\n}\n\n// IMPL: DLL\n\nimpl\u003cT\u003e DualLinkedList\u003cT\u003e {\n    pub(super) fn new(alloc: CQueueLLAllocator) -\u003e Self {\n        let mut head = EventNode::empty(Duration::ZERO, alloc);\n        let mut tail = EventNode::empty(Duration::MAX, alloc);\n\n        let head_ptr: *mut EventNode\u003cT\u003e = \u0026mut *head;\n        let tail_ptr: *mut EventNode\u003cT\u003e = \u0026mut *tail;\n\n        head.next = tail_ptr;\n        tail.prev = head_ptr;\n\n        Self {\n            alloc,\n            head,\n            tail,\n            len: 0,\n        }\n    }\n\n    pub(super) fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    pub(super) fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    pub(super) fn cancel(\u0026mut self, handle: \u0026EventHandle\u003cT\u003e) -\u003e bool {\n        let mut cur = self.head.next;\n        unsafe {\n            while !(*cur).next.is_null() {\n                if (*cur).id == handle.id {\n                    // remove\n                    let mut cur = LocalBox::from_raw_in(cur, self.alloc);\n                    (*cur.prev).next = cur.next;\n                    (*cur.next).prev = cur.prev;\n                    self.len -= 1;\n\n                    drop(cur);\n                    return true;\n                }\n                cur = (*cur).next;\n            }\n        }\n        false\n    }\n\n    pub(super) fn front_time(\u0026self) -\u003e Duration {\n        // SAFTEY:\n        // Value is guranteed to be valid since head-\u003enext is allways valid\n        let ptr = self.head.next;\n        let front = unsafe { \u0026mut *ptr };\n        if front.next.is_null() {\n            Duration::MAX\n        } else {\n            // SAFTEY:\n            // front is valid, and neither head nor tail so itt must contain a value\n            front.time\n        }\n    }\n\n    /// Inserts a new element into the queue, returing a Handle to\n    /// cancel the event at will\n    pub(super) fn add(\u0026mut self, event: T, time: Duration, event_id: usize) {\n        let mut node = EventNode::new(event, time, event_id, self.alloc);\n        self.len += 1;\n        let node_ptr: *mut EventNode\u003cT\u003e = \u0026mut *node;\n\n        // From back insert\n        let mut cur: *mut EventNode\u003cT\u003e = \u0026mut *self.tail;\n        loop {\n            // SAFTEY:\n            // There a two cases\n            // 1) cur is head -\u003e since head has Duration::MIN the loop will\n            //    break thus cur is a valid ptr.\n            // 2) cur is not head (maybe tail) -\u003e all such elements are guranteed to have\n            //    valid prev ptrs.\n            // Thus cur will be valid, non-null at the end of the loop.\n            // This loop will terminated if there are no circles in the DLL\n            unsafe {\n                if (*cur).time \u003e node.time {\n                    cur = (*cur).prev;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // SAFTEY: cur is valid after the end of the loop (see aboth)\n        let prev = cur;\n        let next = unsafe { (*cur).next };\n\n        node.prev = prev;\n        node.next = next;\n\n        // SAFTEY:\n        // If the ptr is non-null it is valid,\n        // since nodes are only dropped once they were removed from the DLL.\n        // At removal, they remove ptrs to themselfs from other nodes.\n        if !prev.is_null() {\n            unsafe { (*prev).next = node_ptr }\n        }\n\n        // SAFTEY: see prev\n        if !next.is_null() {\n            unsafe { (*next).prev = node_ptr }\n        }\n\n        // Forget the node to leak the memory.\n        std::mem::forget(node);\n    }\n\n    /// Removes the element with the earliest time from the queue.\n    pub(super) fn pop_min(\u0026mut self) -\u003e Option\u003c(T, Duration)\u003e {\n        let mut node = unsafe { LocalBox::from_raw_in(self.head.next, self.alloc) };\n        if node.next.is_null() {\n            // The node that would have been returned is the tail.\n            // Thus forgett this Box, since the tail is allready owned by self.\n            std::mem::forget(node);\n            None\n        } else {\n            self.len -= 1;\n\n            // The node is not the tail (or the head),\n            // Thus the node has valid ptrs to prev and next.\n            // 1) This head.next will point to a valid node (may be tail)\n            // 2) node.next will be a valid node\n            // 3) node.next.prev will point ot a valid node (head)\n            self.head.next = node.next;\n            unsafe {\n                (*node.next).prev = \u0026mut *self.head;\n            }\n\n            // All references are removed from the DLL thus the node\n            // is only owned by this instance.\n            // Droping the node via into_inner is valid since the only remaining\n            // ref (the NodeHandle) will be invalidated by this operation,\n            // if nessecary\n            Some(EventNode::into_inner(node))\n        }\n    }\n\n    pub(super) fn iter(\u0026self) -\u003e Iter\u003c'_, T\u003e {\n        self.into_iter()\n    }\n\n    #[allow(unused)]\n    pub(super) fn iter_mut(\u0026mut self) -\u003e IterMut\u003c'_, T\u003e {\n        self.into_iter()\n    }\n}\n\nimpl\u003cT\u003e Debug for DualLinkedList\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let head_ptr: *const EventNode\u003cT\u003e = \u0026*self.head;\n        let tail_ptr: *const EventNode\u003cT\u003e = \u0026*self.tail;\n\n        f.debug_struct(\"DLL\")\n            .field(\"head\", \u0026head_ptr)\n            .field(\"tail\", \u0026tail_ptr)\n            .finish()\n    }\n}\n\nimpl\u003cT\u003e Drop for DualLinkedList\u003cT\u003e {\n    fn drop(\u0026mut self) {\n        while self.pop_min().is_some() {}\n    }\n}\n\n// EQ\n\nimpl\u003cT: PartialEq\u003e PartialEq for DualLinkedList\u003cT\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        let mut lhs = self.iter();\n        let mut rhs = other.iter();\n\n        loop {\n            let l = lhs.next();\n            let r = rhs.next();\n            if let Some(l) = l {\n                if let Some(r) = r {\n                    if l.0 != r.0 {\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            } else if r.is_some() {\n                return false;\n            } else {\n                break;\n            }\n        }\n\n        true\n    }\n}\n\nimpl\u003cT: Eq\u003e Eq for DualLinkedList\u003cT\u003e {}\n\n// HASH\n\nimpl\u003cT: Hash\u003e Hash for DualLinkedList\u003cT\u003e {\n    fn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.iter().for_each(|v| v.hash(state));\n    }\n}\n\n// IMPL: DLL Into Iter\n\npub struct Iter\u003c'a, T\u003e {\n    marker: PhantomData\u003c\u0026'a DualLinkedList\u003cT\u003e\u003e,\n    cur: *mut EventNode\u003cT\u003e,\n    alloc: CQueueLLAllocator,\n}\n\nimpl\u003c'a, T\u003e Iterator for Iter\u003c'a, T\u003e {\n    type Item = (\u0026'a T, \u0026'a Duration);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        // SAFTEY:\n        // Will point to a valid node since:\n        // IA) head-\u003enext is a valid node\n        // IS) each time the next node is check to be non-null (thus valid)\n        let cur = unsafe { LocalBox::from_raw_in(self.cur, self.alloc) };\n        let result: Option\u003c(*const T, *const Duration)\u003e = {\n            if cur.next.is_null() {\n                // is tail\n                None\n            } else {\n                self.cur = cur.next;\n                // SAFTEY:\n                // cur is allways valid + now non-tail\n                Some((unsafe { cur.value.as_ref().unwrap_unchecked() }, \u0026cur.time))\n            }\n        };\n        std::mem::forget(cur);\n        result.map(|(v, t)| unsafe { (\u0026*v, \u0026*t) })\n    }\n}\n\nimpl\u003c'a, T\u003e IntoIterator for \u0026'a DualLinkedList\u003cT\u003e {\n    type Item = (\u0026'a T, \u0026'a Duration);\n    type IntoIter = Iter\u003c'a, T\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        Iter {\n            marker: PhantomData,\n            cur: self.head.next,\n            alloc: self.alloc,\n        }\n    }\n}\n\npub struct IterMut\u003c'a, T\u003e {\n    marker: PhantomData\u003c\u0026'a mut DualLinkedList\u003cT\u003e\u003e,\n    cur: *mut EventNode\u003cT\u003e,\n    alloc: CQueueLLAllocator,\n}\n\nimpl\u003c'a, T\u003e Iterator for IterMut\u003c'a, T\u003e {\n    type Item = (\u0026'a mut T, \u0026'a Duration);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        // SAFTEY:\n        // Will point to a valid node since:\n        // IA) head-\u003enext is a valid node\n        // IS) each time the next node is check to be non-null (thus valid)\n        let mut cur = unsafe { LocalBox::from_raw_in(self.cur, self.alloc) };\n        let result: Option\u003c(*mut T, *const Duration)\u003e = {\n            if cur.next.is_null() {\n                // is tail\n                None\n            } else {\n                self.cur = cur.next;\n                // SAFTEY:\n                // cur is allways valid + now non-tail\n                Some((unsafe { cur.value.as_mut().unwrap_unchecked() }, \u0026cur.time))\n            }\n        };\n        std::mem::forget(cur);\n        result.map(|(v, t)| unsafe { (\u0026mut *v, \u0026*t) })\n    }\n}\n\nimpl\u003c'a, T\u003e IntoIterator for \u0026'a mut DualLinkedList\u003cT\u003e {\n    type Item = (\u0026'a mut T, \u0026'a Duration);\n    type IntoIter = IterMut\u003c'a, T\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        IterMut {\n            marker: PhantomData,\n            cur: self.head.next,\n            alloc: self.alloc,\n        }\n    }\n}\n\npub struct IntoIter\u003cT\u003e {\n    dll: DualLinkedList\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Iterator for IntoIter\u003cT\u003e {\n    type Item = (T, Duration);\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.dll.pop_min()\n    }\n}\n\nimpl\u003cT\u003e IntoIterator for DualLinkedList\u003cT\u003e {\n    type Item = (T, Duration);\n    type IntoIter = IntoIter\u003cT\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        IntoIter { dll: self }\n    }\n}\n\n// IMPL: Node\n\nimpl\u003cT\u003e EventNode\u003cT\u003e {\n    pub(super) fn empty(time: Duration, alloc: CQueueLLAllocator) -\u003e LocalBox\u003cEventNode\u003cT\u003e\u003e {\n        LocalBox::new_in(\n            Self {\n                value: None,\n                id: 0,\n                time,\n                prev: std::ptr::null_mut(),\n                next: std::ptr::null_mut(),\n            },\n            alloc,\n        )\n    }\n\n    pub(super) fn new(\n        value: T,\n        time: Duration,\n        id: usize,\n        alloc: CQueueLLAllocator,\n    ) -\u003e LocalBox\u003cEventNode\u003cT\u003e\u003e {\n        LocalBox::new_in(\n            Self {\n                value: Some(value),\n                time,\n                id,\n                prev: std::ptr::null_mut(),\n                next: std::ptr::null_mut(),\n            },\n            alloc,\n        )\n    }\n\n    #[allow(clippy::boxed_local)]\n    fn into_inner(mut this: LocalBox\u003cSelf\u003e) -\u003e (T, Duration) {\n        // SAFTEY:\n        // This function may only be applied to nodes that are\n        // neither head nor tail. Such notes allways contain a value\n        (unsafe { this.value.take().unwrap_unchecked() }, this.time)\n    }\n}\n\nimpl\u003cE\u003e Debug for EventNode\u003cE\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"EventNode\")\n            .field(\"prev\", \u0026self.prev)\n            .field(\"next\", \u0026self.next)\n            .field(\"time\", \u0026self.time)\n            .field(\"value\", \u0026self.value.is_some())\n            .field(\"id\", \u0026self.id)\n            .finish()\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":674905},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":674905},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":674905},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":674905},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":221},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":221},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":167},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3158488},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":6199872},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3041384},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":297380},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":297380},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":297380},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":74,"coverable":137},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","stable","mod.rs"],"content":"use std::{collections::VecDeque, marker::PhantomData, ops::Rem, time::Duration};\n\n// mod _alloc;\nmod alloc;\nmod boxed;\nmod linked_list;\n\npub(crate) use alloc::*;\nuse linked_list::DualLinkedList;\n\n/// A calender queue.\n///\n/// This type acts as a sorter for entries of type E\n/// that occure at a given point in time, represented by the\n/// Duration type. This means that the `fetch_next`\n/// method will allways return the entry with the smallest timestamp.\n/// In general, this can be compared to a `BinaryHeap` where the entries\n/// are a tupel (E, Duration) sorted by the Duration.\n///\n/// Note however that this datatype is optimized for use in a discrete\n/// event simulation. Thus is supports O(1) inserts and removals, as\n/// well as O(1) `fetch_next`. Note that this is a amorised analysis\n/// assuming that the parameters are optimal for the given distribution\n/// of event arrival times. Additionaly the `CQueue` does not allow for\n/// the insertion of entries with a timestamp smaller that entries\n/// that was last fetched (or `Duration::ZERO` initally).\n///\n#[derive(Debug)]\npub struct CQueue\u003cE\u003e {\n    #[allow(unused)]\n    pub(crate) alloc: Box\u003cCQueueLLAllocatorInner\u003e,\n\n    // Parameters\n    pub(crate) n: usize,\n    pub(crate) t: Duration,\n    pub(crate) t_nanos: u128,\n\n    // Buckets\n    pub(crate) zero_event_bucket: VecDeque\u003c(E, Duration, usize)\u003e,\n    pub(crate) buckets: Vec\u003cDualLinkedList\u003cE\u003e\u003e,\n\n    pub(crate) head: usize,\n\n    pub(crate) t_current: Duration,\n    pub(crate) t0: Duration,\n    pub(crate) t1: Duration,\n    pub(crate) t_all: u128,\n\n    // Misc\n    pub(crate) event_id: usize,\n    pub(crate) len: usize,\n}\n\n/// A handle that identifies a event.\n#[derive(Debug, PartialEq, Eq, Hash)]\npub struct EventHandle\u003cE\u003e {\n    _phantom: PhantomData\u003cE\u003e,\n    id: usize,\n    time: Duration,\n}\n\nimpl\u003cE\u003e CQueue\u003cE\u003e {\n    /// Returns a String describing the datatype and its parameters.\n    #[must_use]\n    pub fn descriptor(\u0026self) -\u003e String {\n        format!(\"CTimeVDeque({}, {:?})\", self.n, self.t)\n    }\n\n    /// Returns the number of elements in the queue.\n    #[must_use]\n    pub fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    /// Returns the number of element in the subset that is\n    /// manage by the zero-event-time optimization.\n    #[must_use]\n    pub fn len_zero(\u0026self) -\u003e usize {\n        self.zero_event_bucket.len()\n    }\n\n    /// Returns the number of elements in the subset that is\n    /// not managed by the zero-event-time optimization.\n    #[must_use]\n    pub fn len_nonzero(\u0026self) -\u003e usize {\n        self.len() - self.len_zero()\n    }\n\n    /// Indicates whether the queue is empty.\n    #[must_use]\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    #[must_use]\n    pub fn metrics(\u0026self) -\u003e (usize, usize) {\n        let (alloc, total) = self.alloc.metrics();\n        let additional = std::mem::size_of::\u003cSelf\u003e();\n        let additional = additional + std::mem::size_of::\u003c(E, Duration, usize)\u003e() * self.len_zero();\n        (alloc + additional, total + additional)\n    }\n\n    /// Returns the timestamp of the last emitted event.\n    /// This acts as a lower bound to the insertion of new events.\n    #[must_use]\n    pub fn time(\u0026self) -\u003e Duration {\n        self.t_current\n    }\n\n    /// Creates a new parameteriszed `CQueue`.\n    #[must_use]\n    pub fn new(n: usize, t: Duration) -\u003e Self {\n        // essentialy t*n\n        let t_all = t.as_nanos() * n as u128;\n\n        let alloc = Box::new(CQueueLLAllocatorInner::new());\n\n        Self {\n            n,\n            t_nanos: t.as_nanos(),\n            t,\n\n            zero_event_bucket: VecDeque::with_capacity(64),\n            buckets: std::iter::repeat_with(|| DualLinkedList::new(alloc.handle()))\n                .take(n)\n                .collect(),\n            head: 0,\n            t_current: Duration::ZERO,\n\n            t0: Duration::ZERO,\n            t1: t,\n\n            t_all,\n\n            alloc,\n            event_id: 0,\n            len: 0,\n        }\n    }\n\n    ///\n    /// Adds an event to the calenderqueue.\n    ///\n    /// Returns an event handle to cancel the event at will.\n    ///\n    /// # Panics\n    ///\n    /// This funtion panics if the timestamp violates the lower\n    /// bound, defined by the timestamp of the last emitted event.\n    ///\n    pub fn add(\u0026mut self, time: Duration, event: E) -\u003e EventHandle\u003cE\u003e {\n        assert!(\n            time \u003e= self.t_current,\n            \"Cannot add past event to calender queue\"\n        );\n\n        self.len += 1;\n        if time == self.t_current {\n            let id = self.event_id;\n            self.zero_event_bucket.push_back((event, time, id));\n            self.event_id = id.wrapping_add(1);\n\n            EventHandle {\n                _phantom: PhantomData,\n                id,\n                time,\n            }\n        } else {\n            // delta time ?\n\n            let time_mod = time.as_nanos().rem(self.t_all);\n\n            let index = time_mod / self.t_nanos;\n            let index: usize = index as usize;\n            let index = index % self.n;\n\n            // find insert pos\n\n            let id = self.event_id;\n            self.buckets[index].add(event, time, id);\n            self.event_id = id.wrapping_add(1);\n            EventHandle {\n                _phantom: PhantomData,\n                id,\n                time,\n            }\n        }\n    }\n\n    #[allow(clippy::needless_pass_by_value)]\n    pub fn cancel(\u0026mut self, handle: EventHandle\u003cE\u003e) {\n        if handle.time \u003e= self.t_current {\n            if handle.time == self.t_current {\n                if let Some(i) = self\n                    .zero_event_bucket\n                    .iter()\n                    .position(| v| v.2 == handle.id)\n                {\n                    self.zero_event_bucket.remove(i);\n                    self.len -= 1;\n                }\n            } else {\n                let time_mod = handle.time.as_nanos().rem(self.t_all);\n\n                let index = time_mod / self.t_nanos;\n                let index: usize = index as usize;\n                let index = index % self.n;\n\n                if self.buckets[index].cancel(\u0026handle) {\n                    self.len -= 1;\n                }\n            }\n        }\n    }\n\n    ///\n    /// Fetches the smalles event from the calender queue.\n    ///\n    /// # Panics\n    ///\n    /// This function assummes that the queue is not empty.\n    /// If it is this function panics.\n    ///\n    pub fn fetch_next(\u0026mut self) -\u003e (E, Duration) {\n        assert!(!self.is_empty(), \"Cannot fetch from empty queue\");\n\n        if let Some((event, time, _)) = self.zero_event_bucket.pop_front() {\n            self.len -= 1;\n            return (event, time);\n        }\n\n        loop {\n            // Move until full bucket is found.\n            while self.buckets[self.head].is_empty() {\n                self.head = (self.head + 1) % self.n;\n                self.t0 += self.t;\n                self.t1 += self.t;\n            }\n\n            // Bucket with \u003e 0 elements found\n\n            let min = self.buckets[self.head].front_time();\n            if min \u003e self.t1 {\n                self.head = (self.head + 1) % self.n;\n                self.t0 += self.t;\n                self.t1 += self.t;\n                continue;\n            }\n\n            self.t_current = min;\n\n            // SAFTEY:\n            // Bucket is non-empty, thus pop-min returns a valid value.\n            self.len -= 1;\n            return unsafe { self.buckets[self.head].pop_min().unwrap_unchecked() };\n        }\n    }\n}\n\nimpl\u003cE\u003e Default for CQueue\u003cE\u003e {\n    fn default() -\u003e Self {\n        Self::new(1024, Duration::from_millis(5))\n    }\n}\n\nimpl\u003cE\u003e Drop for CQueue\u003cE\u003e {\n    fn drop(\u0026mut self) {\n        // Manually drop the DLL so that the alloc can be dropped last\n        for dll in self.buckets.drain(..) {\n            drop(dll);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":357172},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":357172},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":356910},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":356910},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":180704},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":119287},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":119287},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":119287},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":119287},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":119287},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2183},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2183},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2183},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":119227},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":119227},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":121404},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1187879},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":512974},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":512974},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":512974},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":44881},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":44881},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":44881},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":44881},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":360847},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null}],"covered":62,"coverable":76},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","stable","tests.rs"],"content":"use std::alloc::Layout;\nuse std::mem::size_of;\n\nuse super::{boxed::*, *};\nuse rand::distributions::Uniform;\nuse rand::rngs::SmallRng;\nuse rand::seq::SliceRandom;\nuse rand::*;\n\n#[test]\nfn alloc_single_page_one_alloc_one_allocator() {\n    // Layout will allways be big enoght for a Free Node\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu32 = LocalBox::new_in(42u32, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu32);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu64 = LocalBox::new_in(42u64, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu64);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu128 = LocalBox::new_in(42u128, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu128);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    // Now layout will grow\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let barray = LocalBox::new_in([42u8; 55], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 56); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let barray = LocalBox::new_in([42u8; 128], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 128); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n}\n\n#[test]\nfn alloc_single_page_one_alloc_shared_allocator() {\n    // Layout will allways be big enoght for a Free Node\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu32 = LocalBox::new_in(42u32, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu32);\n    assert!(alloc.dbg_is_empty());\n\n    let bu64 = LocalBox::new_in(42u64, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu64);\n    assert!(alloc.dbg_is_empty());\n\n    let bu128 = LocalBox::new_in(42u128, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu128);\n    assert!(alloc.dbg_is_empty());\n\n    // Now layout will grow\n\n    let barray = LocalBox::new_in([42u8; 55], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 56); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n\n    let barray = LocalBox::new_in([42u8; 128], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 128); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n}\n\n#[test]\nfn alloc_single_page_alloc_exceeds_page_size() {\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    assert!(alloc\n        .handle()\n        .allocate(Layout::new::\u003c[u8; 8000]\u003e())\n        .is_err())\n    // let _ = Box::new_in([42u8; 8000], alloc.handle());\n}\n\n#[test]\nfn alloc_single_page_list_alloc() {\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let mut boxes = Vec::new();\n    for i in 0..10 {\n        boxes.push(LocalBox::new_in([i as u8; 400], alloc.handle()))\n    }\n\n    // 4000 byte\n    assert_eq!(alloc.dbg_alloc_total(), 4000);\n    for i in 0..10 {\n        assert_eq!(boxes[i][0], i as u8);\n    }\n\n    // Drop the last 2000 byte\n    for _ in 0..5 {\n        boxes.pop();\n    }\n\n    assert_eq!(alloc.dbg_alloc_total(), 2000);\n\n    drop(boxes);\n\n    assert!(alloc.dbg_is_empty());\n}\n\n#[test]\nfn alloc_multiple_pages_same_size_allocation() {\n    #[allow(dead_code)]\n    struct A {\n        bytes: [u8; 32],\n        int: u128,\n        s: String,\n    }\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let mut boxes = Vec::new();\n    for _ in 0..100 {\n        boxes.push(LocalBox::new_in(\n            A {\n                bytes: [0; 32],\n                int: 42,\n                s: String::from(\"Hallow str\"),\n            },\n            alloc.handle(),\n        ));\n    }\n\n    assert!(\n        alloc.dbg_alloc_total() \u003e= size_of::\u003cA\u003e() * 100,\n        \"alloc: {} expected: {} * 100\",\n        alloc.dbg_alloc_total(),\n        size_of::\u003cA\u003e()\n    )\n}\n\n#[test]\nfn alloc_multiple_pages_skip_to_small_elements() {\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let b1 = LocalBox::new_in([0u8; 2500], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 2504); // align\n    assert_eq!(alloc.dbg_pages(), 1);\n\n    // remaining bytes of page 1 were skipped\n    // since elements are asssumed to be 2500 bytes big\n\n    let b2 = LocalBox::new_in([0u8; 128], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 2504 + 128); // align\n    assert_eq!(alloc.dbg_pages(), 2);\n\n    drop(b1);\n    drop(b2);\n\n    assert_eq!(alloc.dbg_alloc_total(), 0);\n    assert_eq!(alloc.dbg_pages(), 2);\n\n    drop(alloc);\n}\n\n#[test]\nfn alloc_16_byteboxes() {\n    struct Word {\n        _opaque: [u8; 16],\n    }\n\n    impl Word {\n        fn new() -\u003e Self {\n            Self { _opaque: [42; 16] }\n        }\n    }\n\n    assert_eq!(std::mem::size_of::\u003cWord\u003e(), 16);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let mut list = Vec::new();\n    for _ in 1..10 {\n        let b = LocalBox::new_in(Word::new(), alloc.handle());\n        list.push(b)\n    }\n    alloc.info();\n\n    list.remove(2);\n\n    alloc.info();\n\n    drop(list);\n\n    alloc.info();\n\n    for _ in 1..10 {\n        let b = LocalBox::new_in(Word::new(), alloc.handle());\n        std::mem::forget(b);\n    }\n\n    alloc.info();\n}\n\n#[test]\nfn cqueue_simple_event_order_nonoverlapping() {\n    let mut cqueue = CQueue::new(100, Duration::from_secs(1));\n    let events = (0..=100).map(|e| (e, Duration::from_secs(e)));\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    assert_eq!(cqueue.len(), 101);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        println!(\"Itr: {}\", c);\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_simple_event_order_wrap_around() {\n    // This test is identicall to 'cqueue_simple_event_order_nonoverlapping'\n    // but with other config options for the cqueue.\n    let mut cqueue = CQueue::new(20, Duration::from_secs(1));\n    let events = (0..=100).map(|e| (e, Duration::from_secs(e)));\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_simple_event_out_of_order_nonoverlapping() {\n    let mut cqueue = CQueue::new(100, Duration::from_secs(1));\n    let mut events = (0..=100)\n        .map(|e| (e, Duration::from_secs(e)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    let mut rng = SmallRng::seed_from_u64(123);\n    events.shuffle(\u0026mut rng);\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    assert_eq!(cqueue.len(), 101);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        println!(\"Itr: {}\", c);\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_simple_event_out_of_order_wrap_around() {\n    // This test is identicall to 'cqueue_simple_event_order_nonoverlapping'\n    // but with other config options for the cqueue.\n    let mut cqueue = CQueue::new(20, Duration::from_secs(1));\n    let mut events = (0..=100)\n        .map(|e| (e, Duration::from_secs(e)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    let mut rng = SmallRng::seed_from_u64(123);\n    events.shuffle(\u0026mut rng);\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_zero_bucket_in_out() {\n    let mut cqueue = CQueue::new(10, Duration::new(1, 0));\n    for i in 0..10 {\n        cqueue.add(Duration::ZERO, i);\n    }\n    assert_eq!(cqueue.len_zero(), 10);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 2 - without forwarding to the current event\n\n    for i in 0..10 {\n        cqueue.add(Duration::new(9, 0), i);\n    }\n    assert_eq!(cqueue.len_zero(), 0);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 3: allready forwared\n\n    for i in 0..10 {\n        cqueue.add(Duration::new(9, 0), i);\n    }\n    assert_eq!(cqueue.len_zero(), 10);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n}\n\n#[test]\nfn cqueue_zero_bucket_cancel() {\n    let mut cqueue = CQueue::new(10, Duration::new(1, 0));\n    let mut handles = (0..10)\n        .map(|i| cqueue.add(Duration::ZERO, i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len_zero(), 10);\n\n    // remove element 6\n    cqueue.cancel(handles.remove(6));\n    assert_eq!(cqueue.len(), 9);\n    assert_eq!(cqueue.len_zero(), 9);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        if c == 6 {\n            c += 1;\n            continue;\n        }\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 2 - without forwarding to the current event\n\n    let mut handles = (0..10)\n        .map(|i| cqueue.add(Duration::new(9, 0), i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len_zero(), 0);\n\n    cqueue.cancel(handles.remove(3));\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        if c == 3 {\n            c += 1;\n            continue;\n        }\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 3: allready forwared\n\n    let mut handles = (0..10)\n        .map(|i| cqueue.add(Duration::new(9, 0), i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len_zero(), 10);\n\n    cqueue.cancel(handles.remove(0));\n\n    let mut c = 1;\n    while !cqueue.is_empty() {\n        // if c == 0 { ... }\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n}\n\n#[test]\nfn cqueue_out_of_order_with_overlaps() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut delay = Duration::new(1, 0);\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut events = (0..200)\n        .map(|v| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.1, 1.0)));\n            (v, delay)\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    events.shuffle(\u0026mut rng);\n    let _ = events\n        .into_iter()\n        .map(|(event, time)| cqueue.add(time, event))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut last_time = Duration::ZERO;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 200 - c);\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e last_time);\n\n        last_time = t;\n        c += 1;\n    }\n    assert_eq!(c, 200);\n}\n\n#[test]\nfn cqueue_out_of_order_with_cancel() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut delay = Duration::new(1, 0);\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut events = (0..200)\n        .map(|v| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.1, 1.0)));\n            (v, delay, rng.sample(Uniform::new(1, 10)) == 8)\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    events.shuffle(\u0026mut rng);\n    let handles = events\n        .into_iter()\n        .map(|(event, time, cancel)| (cqueue.add(time, event), cancel, event))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let canceled = handles\n        .into_iter()\n        .filter_map(|(h, flg, event)| {\n            if flg {\n                cqueue.cancel(h);\n                Some(event)\n            } else {\n                None\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut last_time = Duration::ZERO;\n    while !cqueue.is_empty() {\n        if canceled.contains(\u0026c) {\n            c += 1;\n            continue;\n        }\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e last_time);\n\n        last_time = t;\n        c += 1;\n    }\n    // The 200th event was canceld thus the loop broke, event though one\n    // iteration was still due (to be simpliar to previous test cases)\n    assert_eq!(c, 199);\n}\n\n#[test]\nfn cqueue_out_of_order_boxes_overlapping() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut delay = Duration::new(1, 0);\n    let mut s = 0;\n    let mut event_boxes = (0..100)\n        .map(|_| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.0, 1.0)));\n            let n = rng.sample(Uniform::new(1, 4));\n            let old_s = s;\n            s += n;\n            (delay, old_s, n)\n        })\n        // .map(|(t, from, n)| (from..(from + n)).map(|i| (i, t)))\n        // .flatten()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    event_boxes.shuffle(\u0026mut rng);\n    let _ = event_boxes\n        .into_iter()\n        .map(|(t, from, n)| (from..(from + n)).map(move |i| (i, t)))\n        .flatten()\n        .map(|(e, t)| cqueue.add(t, e))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut lt = Duration::ZERO;\n    while !cqueue.is_empty() {\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e= lt);\n        c += 1;\n        lt = t;\n    }\n}\n\n#[test]\nfn cqueue_out_of_order_boxes_with_cancel() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut delay = Duration::new(1, 0);\n    let mut s = 0;\n    let mut event_boxes = (0..100)\n        .map(|_| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.0, 1.0)));\n            let n = rng.sample(Uniform::new(1, 4));\n            let old_s = s;\n            s += n;\n            (delay, old_s, n)\n        })\n        // .map(|(t, from, n)| (from..(from + n)).map(|i| (i, t)))\n        // .flatten()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    event_boxes.shuffle(\u0026mut rng);\n    let handles = event_boxes\n        .into_iter()\n        .map(|(t, from, n)| (from..(from + n)).map(move |i| (i, t)))\n        .flatten()\n        .map(|(e, t)| (cqueue.add(t, e), e, rng.sample(Uniform::new(1, 10)) == 2))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    // Cancel events\n    let cancelled = handles\n        .into_iter()\n        .filter_map(|(h, e, flg)| {\n            if flg {\n                cqueue.cancel(h);\n                Some(e)\n            } else {\n                None\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut lt = Duration::ZERO;\n    while !cqueue.is_empty() {\n        if cancelled.contains(\u0026c) {\n            c += 1;\n            continue;\n        }\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e= lt);\n        c += 1;\n        lt = t;\n    }\n}\n\n#[test]\nfn cqueue_cancel_validity() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut handles = (0..10)\n        .map(|i| Some(cqueue.add(Duration::from_secs(i), i)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len(), 10);\n\n    // Succesful cancel 0, 9\n    cqueue.cancel(handles[0].take().unwrap());\n    cqueue.cancel(handles[9].take().unwrap());\n\n    assert_eq!(cqueue.len(), 8);\n\n    // Cur [1,2,3,4,5,6,7,8]\n    for i in 1..4 {\n        let event = cqueue.fetch_next();\n        assert_eq!(event.0, i);\n    }\n    assert_eq!(cqueue.len(), 5);\n\n    // Cur [4,5,6,7,8]\n    cqueue.cancel(handles[2].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    cqueue.cancel(handles[3].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    // Suc again\n    cqueue.cancel(handles[8].take().unwrap());\n    assert_eq!(cqueue.len(), 4);\n\n    // Cur [4,5,6,7]\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let _ = cqueue.fetch_next();\n        c += 1;\n    }\n\n    assert_eq!(c, 4)\n}\n\n#[test]\nfn cqueue_cancel_validity_2() {\n    let mut cqueue = CQueue::new(10, Duration::new(3, 0));\n    let mut handles = (0..10)\n        .map(|i| Some(cqueue.add(Duration::from_secs(i), i)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len(), 10);\n\n    // Succesful cancel 0, 9\n    cqueue.cancel(handles[0].take().unwrap());\n    cqueue.cancel(handles[9].take().unwrap());\n\n    assert_eq!(cqueue.len(), 8);\n\n    // Cur [1,2,3,4,5,6,7,8]\n    for i in 1..4 {\n        let event = cqueue.fetch_next();\n        assert_eq!(event.0, i);\n    }\n    assert_eq!(cqueue.len(), 5);\n\n    // Cur [4,5,6,7,8]\n    cqueue.cancel(handles[2].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    cqueue.cancel(handles[3].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    // Suc again\n    cqueue.cancel(handles[8].take().unwrap());\n    assert_eq!(cqueue.len(), 4);\n\n    // Cur [4,5,6,7]\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let _ = cqueue.fetch_next();\n        c += 1;\n    }\n\n    assert_eq!(c, 4)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-macros","src","lib.rs"],"content":"#![warn(clippy::pedantic)]\n//! A crate for extending a DES simulation with NDL definitions.\n//!\n//! This crate provide macros for applieing NDL module definitions to\n//! rust structs to automate the module setup process.\n\nuse proc_macro::{self, TokenStream};\nuse proc_macro_error::proc_macro_error;\nuse syn::{parse_macro_input, DeriveInput};\n\n///\n/// A macro for deriving the `MessageBody` trait.\n///\n/// This macro requires that all subtypes of the applied type\n/// implement `MessageBody` themselfs.\n#[proc_macro_derive(MessageBody)]\n#[proc_macro_error]\npub fn derive_message_body(input: TokenStream) -\u003e TokenStream {\n    let DeriveInput {\n        ident,\n        data,\n        generics,\n        ..\n    } = parse_macro_input!(input);\n\n    match des_macros_core::message_body::derive_impl(ident, data, generics) {\n        Ok(ts) =\u003e ts.into(),\n        Err(e) =\u003e e.abort(),\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","Users","mk","Developer","rust","des","des-macros-core","src","lib.rs"],"content":"#![warn(clippy::pedantic)]\n//! Internal implmentations of proc macros.\n\npub mod message_body;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-macros-core","src","message_body.rs"],"content":"use proc_macro2::Span as Span2;\nuse proc_macro2::TokenStream;\nuse proc_macro_error::{Diagnostic, Level};\nuse quote::quote;\nuse quote::ToTokens;\nuse syn::token::Plus;\nuse syn::{parse2, Data, Fields, GenericParam, Generics, Ident, Index, TypeParamBound};\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, Diagnostic\u003e;\n\nstruct WrappedTokenStream(TokenStream);\n\nimpl ToTokens for WrappedTokenStream {\n    fn to_tokens(\u0026self, tokens: \u0026mut proc_macro2::TokenStream) {\n        tokens.extend::\u003cproc_macro2::TokenStream\u003e(self.0.clone());\n    }\n}\n\n/// Returns the derived token stream.\n///\n/// # Errors\n///\n/// Internal.\n///\n/// # Panics\n///\n/// Internal.\n#[allow(clippy::needless_pass_by_value, clippy::too_many_lines)]\npub fn derive_impl(ident: Ident, data: Data, generics: Generics) -\u003e Result\u003cTokenStream\u003e {\n    match data {\n        Data::Struct(data_struct) =\u003e {\n            let impl_ts = match data_struct.fields {\n                Fields::Named(named_fields) =\u003e {\n                    let mut ts = TokenStream::new();\n                    for field in named_fields.named {\n                        let ty = field.ty;\n                        let field_ident = field.ident.unwrap();\n\n                        ts.extend(quote! {\n                            \u003c#ty as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.#field_ident) +\n                        });\n                    }\n                    ts\n                }\n                Fields::Unnamed(unnamed_fields) =\u003e {\n                    // Does this case ever happen\n                    let mut ts = TokenStream::new();\n\n                    for (i, field) in unnamed_fields.unnamed.into_iter().enumerate() {\n                        let ty = field.ty;\n                        let field_ident = Index::from(i);\n\n                        ts.extend(quote! {\n                            \u003c#ty as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.#field_ident) +\n                        });\n                    }\n\n                    ts\n                }\n                Fields::Unit =\u003e TokenStream::new(),\n            };\n\n            let generics = generate_impl_generics(generics);\n            let (impl_generics, type_generics, where_clause) = generics.split_for_impl();\n\n            let wrapped = WrappedTokenStream(impl_ts);\n            Ok(quote! {\n                impl #impl_generics ::des::net::message::MessageBody for #ident #type_generics #where_clause {\n                    fn byte_len(\u0026self) -\u003e usize {\n                        #wrapped 0\n                    }\n                }\n            })\n        }\n        Data::Enum(data_enum) =\u003e {\n            let mut gts = TokenStream::new();\n            if data_enum.variants.is_empty() {\n                return Ok(quote! {\n                    impl ::des::net::message::MessageBody for #ident {\n                        fn byte_len(\u0026self) -\u003e usize { 0 }\n                    }\n                });\n            }\n\n            for variant in data_enum.variants {\n                let variant_ident = variant.ident;\n\n                let ts = match variant.fields {\n                    Fields::Named(named_fields) =\u003e {\n                        let mut prop_ts = TokenStream::new();\n                        let mut ts = TokenStream::new();\n\n                        for field in named_fields.named {\n                            let ty = field.ty;\n                            let field_ident = field.ident.unwrap();\n\n                            prop_ts.extend(quote! { ref #field_ident, });\n                            ts.extend(quote! {\n                                \u003c#ty as ::des::net::message::MessageBody\u003e::byte_len(#field_ident) +\n                            });\n                        }\n\n                        let wrapped = WrappedTokenStream(ts);\n                        quote! {\n                            #ident::#variant_ident { #prop_ts } =\u003e #wrapped 0\n                        }\n                    }\n                    Fields::Unnamed(unnamed_fields) =\u003e {\n                        // Does this case ever happen\n                        let mut property_ts = TokenStream::new();\n                        let mut ts = TokenStream::new();\n\n                        for (i, field) in unnamed_fields.unnamed.into_iter().enumerate() {\n                            let ty = field.ty;\n                            let field_ident = Ident::new(\u0026format!(\"v{i}\"), Span2::call_site());\n\n                            property_ts.extend(quote! { #field_ident,  });\n                            ts.extend(quote! {\n                                \u003c#ty as ::des::net::message::MessageBody\u003e::byte_len(#field_ident) +\n                            });\n                        }\n\n                        let wrapped = WrappedTokenStream(ts);\n                        quote! { #ident::#variant_ident(#property_ts) =\u003e #wrapped 0 }\n                    }\n                    Fields::Unit =\u003e {\n                        quote! {\n                            #ident::#variant_ident =\u003e 0\n                        }\n                    }\n                };\n\n                gts.extend(quote! {\n                    #ts,\n                });\n            }\n\n            let generics = generate_impl_generics(generics);\n            let (impl_generics, type_generics, where_clause) = generics.split_for_impl();\n\n            Ok(quote! {\n                impl #impl_generics ::des::net::message::MessageBody for #ident #type_generics #where_clause {\n                    fn byte_len(\u0026self) -\u003e usize {\n                        match self {\n                            #gts\n                        }\n                    }\n                }\n            })\n        }\n        Data::Union(_) =\u003e Err(Diagnostic::new(\n            Level::Error,\n            \"#[derive(MessageBody)] -- Macro does not support unions\".into(),\n        )),\n    }\n}\n\nfn generate_impl_generics(mut generics: Generics) -\u003e Generics {\n    for param in \u0026mut generics.params {\n        if let GenericParam::Type(param) = param {\n            if !param.bounds.trailing_punct() \u0026\u0026 !param.bounds.is_empty() {\n                param.bounds.push_punct(Plus {\n                    spans: [proc_macro2::Span::call_site()],\n                });\n            }\n\n            let input = quote::quote! { ::des::net::message::MessageBody };\n            param\n                .bounds\n                .push_value(TypeParamBound::Trait(parse2(input).unwrap()));\n        }\n    }\n\n    generics\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":18},"fn_name":null}],"covered":71,"coverable":77},{"path":["/","Users","mk","Developer","rust","des","des-macros-core","tests","message_body.rs"],"content":"use quote::quote;\nuse syn::{parse2, DeriveInput};\n\n#[test]\nfn struct_unit() {\n    let input = quote! {\n        struct Input;\n    };\n\n    let Ok(DeriveInput { ident, data, generics, .. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl ::des::net::message::MessageBody for Input {\n                fn byte_len(\u0026self) -\u003e usize {\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_named() {\n    let input = quote! {\n        struct Input {\n            a: u32,\n            b: Vec\u003cu8\u003e,\n            c: ()\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics, .. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl ::des::net::message::MessageBody for Input {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.a) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.b) +\n                    \u003c() as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.c) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_named_generic_nonbounded() {\n    let input = quote! {\n        struct Input\u003cT\u003e {\n            a: u32,\n            b: Vec\u003cu8\u003e,\n            c: T\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.a) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.b) +\n                    \u003cT as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.c) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_named_generic_bounded() {\n    let input = quote! {\n        struct Input\u003cT: Copy + Eq\u003e {\n            a: u32,\n            b: Vec\u003cu8\u003e,\n            c: T\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: Copy + Eq + ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.a) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.b) +\n                    \u003cT as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.c) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_named_generic_where_clause() {\n    let input = quote! {\n        struct Input\u003cT\u003e where T: Copy + std::hash::Hash {\n            a: u32,\n            b: Vec\u003cu8\u003e,\n            c: T\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e\n            where T: Copy + std::hash::Hash {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.a) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.b) +\n                    \u003cT as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.c) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_unnamed() {\n    let input = quote! {\n        struct Input(u32, Vec\u003cu8\u003e, ());\n    };\n\n    let Ok(DeriveInput { ident, data, generics, .. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl ::des::net::message::MessageBody for Input {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.0) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.1) +\n                    \u003c() as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.2) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_unnamed_generic_nonbounded() {\n    let input = quote! {\n        struct Input\u003cT\u003e(u32, Vec\u003cu8\u003e, T);\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.0) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.1) +\n                    \u003cT as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.2) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_unnamed_generic_bounded() {\n    let input = quote! {\n        struct Input\u003cT: Copy + Eq\u003e(u32, Vec\u003cu8\u003e, T);\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: Copy + Eq + ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.0) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.1) +\n                    \u003cT as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.2) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_unnamed_generic_where_clause() {\n    let input = quote! {\n        struct Input\u003cT\u003e(u32, Vec\u003cu8\u003e, T) where T: Copy + std::hash::Hash;\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e\n            where T: Copy + std::hash::Hash {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.0) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.1) +\n                    \u003cT as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.2) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn enum_unit_fields() {\n    let input = quote! {\n        enum Input {\n            A,\n            B,\n            CVariant,\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl ::des::net::message::MessageBody for Input {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A =\u003e 0,\n                          Input::B =\u003e 0,\n                          Input::CVariant =\u003e 0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn enum_unnamed_fields() {\n    let input = quote! {\n        enum Input {\n            A(u32),\n            B(Vec\u003cu8\u003e),\n            CVariant(f64, f32),\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl ::des::net::message::MessageBody for Input {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A(v0,) =\u003e \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::B(v0,) =\u003e \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::CVariant(v0, v1, ) =\u003e \n                            \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(v0) +\n                            \u003cf32 as ::des::net::message::MessageBody\u003e::byte_len(v1) + \n                            0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n\n#[test]\nfn enum_unnamed_fields_generic_unbounded() {\n    let input = quote! {\n        enum Input\u003cT\u003e {\n            A(T),\n            B(Vec\u003cu8\u003e),\n            CVariant(f64, T),\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A(v0,) =\u003e \u003cT as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::B(v0,) =\u003e \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::CVariant(v0, v1, ) =\u003e \n                            \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(v0) +\n                            \u003cT as ::des::net::message::MessageBody\u003e::byte_len(v1) + \n                            0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n\n#[test]\nfn enum_unnamed_fields_generic_bounded() {\n    let input = quote! {\n        enum Input\u003cT: Copy\u003e {\n            A(T),\n            B(Vec\u003cu8\u003e),\n            CVariant(f64, T),\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: Copy + ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A(v0,) =\u003e \u003cT as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::B(v0,) =\u003e \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::CVariant(v0, v1, ) =\u003e \n                            \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(v0) +\n                            \u003cT as ::des::net::message::MessageBody\u003e::byte_len(v1) + \n                            0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn enum_unnamed_fields_generic_where_clause() {\n    let input = quote! {\n        enum Input\u003cT\u003e where T: std::hash::Hash {\n            A(T),\n            B(Vec\u003cu8\u003e),\n            CVariant(f64, T),\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e \n             where T: std::hash::Hash {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A(v0,) =\u003e \u003cT as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::B(v0,) =\u003e \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::CVariant(v0, v1, ) =\u003e \n                            \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(v0) +\n                            \u003cT as ::des::net::message::MessageBody\u003e::byte_len(v1) + \n                            0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n// \n\n#[test]\nfn enum_named_fields() {\n    let input = quote! {\n        enum Input {\n            A { x: u32},\n            B { y: Vec\u003cu8\u003e, z: f64},\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl ::des::net::message::MessageBody for Input {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A { ref x, } =\u003e \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(x) + 0,\n                          Input::B { ref y, ref z, } =\u003e \n                          \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(y) +\n                          \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(z) + \n                          0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn enum_named_fields_generic_unbounded() {\n    let input = quote! {\n        enum Input\u003cT\u003e {\n            A { x: T },\n            B { y: Vec\u003cT\u003e, z: f64},\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A { ref x, } =\u003e \u003cT as ::des::net::message::MessageBody\u003e::byte_len(x) + 0,\n                          Input::B { ref y, ref z, } =\u003e \n                          \u003cVec\u003cT\u003e as ::des::net::message::MessageBody\u003e::byte_len(y) +\n                          \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(z) + \n                          0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn enum_named_fields_generic_bounded() {\n    let input = quote! {\n        enum Input\u003cT: Copy\u003e {\n            A { x: T },\n            B { y: Vec\u003cT\u003e, z: f64},\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: Copy + ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A { ref x, } =\u003e \u003cT as ::des::net::message::MessageBody\u003e::byte_len(x) + 0,\n                          Input::B { ref y, ref z, } =\u003e \n                          \u003cVec\u003cT\u003e as ::des::net::message::MessageBody\u003e::byte_len(y) +\n                          \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(z) + \n                          0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn enum_named_fields_generic_where_clause() {\n    let input = quote! {\n        enum Input\u003cT\u003e where T: Copy {\n            A { x: T },\n            B { y: Vec\u003cT\u003e, z: f64},\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e where T: Copy {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A { ref x, } =\u003e \u003cT as ::des::net::message::MessageBody\u003e::byte_len(x) + 0,\n                          Input::B { ref y, ref z, } =\u003e \n                          \u003cVec\u003cT\u003e as ::des::net::message::MessageBody\u003e::byte_len(y) +\n                          \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(z) + \n                          0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","cluster.rs"],"content":"use std::fmt;\n\nuse super::{Delimited, Lit};\nuse crate::{\n    ast::{parse::*, Delimiter, TokenTree},\n    error::*,\n    resource::Span,\n};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ClusterDefinition {\n    pub span: Span,\n    pub lit: Lit,\n}\n\nimpl fmt::Display for ClusterDefinition {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"[{}]\", self.lit.kind)\n    }\n}\n\nimpl Spanned for ClusterDefinition {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\nimpl Parse for Option\u003cClusterDefinition\u003e {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let Some(peek) = input.ts.peek() else {\n            return Ok(None);\n        };\n        let TokenTree::Delimited(_, delim, _) = peek else {\n            return Ok(None);\n        };\n        if *delim == Delimiter::Bracket {\n            Ok(Some(ClusterDefinition::parse(input)?))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\nimpl Parse for ClusterDefinition {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let def = Delimited::\u003cLit\u003e::parse_from(Delimiter::Bracket, input)?;\n        Ok(ClusterDefinition {\n            lit: def.inner,\n            span: Span::fromto(def.delim_span.open, def.delim_span.close),\n        })\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1494},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2869},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":260},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1115},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":260},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":520},"fn_name":null}],"covered":12,"coverable":13},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","delim.rs"],"content":"use crate::{\n    ast::{parse::*, DelimSpan, Delimiter, TokenTree},\n    error::*,\n    Span,\n};\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Delimited\u003cT\u003e {\n    pub delim: Delimiter,\n    pub delim_span: DelimSpan,\n    pub inner: T,\n}\n\nimpl\u003cT\u003e Spanned for Delimited\u003cT\u003e {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(self.delim_span.open, self.delim_span.close)\n    }\n}\n\nimpl\u003cT: Parse\u003e Delimited\u003cT\u003e {\n    pub fn parse_from(delim: Delimiter, input: ParseStream\u003c'_\u003e) -\u003e Result\u003cDelimited\u003cT\u003e\u003e {\n        let Some(peek) = input.ts.peek() else {\n            return Err(Error::new(ErrorKind::ExpectedDelimited, \"expected delimited sequence, found EOF\").spanned(input.ts.last_span()));\n        };\n\n        let (span, d) = match peek {\n            TokenTree::Delimited(span, d, _) =\u003e (span, d),\n            TokenTree::Token(token, _) =\u003e {\n                return Err(Error::new(\n                    ErrorKind::ExpectedDelimited,\n                    format!(\n                        \"expected delimited sequence, found {}\",\n                        token.kind.token_kind_err_output()\n                    ),\n                )\n                .spanned(peek.span()));\n            }\n        };\n\n        if *d == delim {\n            let substream = input.substream().unwrap();\n            input.ts.bump();\n            Ok(Self {\n                delim: *d,\n                delim_span: *span,\n                inner: T::parse(\u0026substream)?,\n            })\n        } else {\n            Err(Error::new(\n                ErrorKind::UnexpectedDelim,\n                format!(\"expected delimited sequence '{delim}', found delimited sequence '{d}'\"),\n            )\n            .spanned(Span::fromto(span.open, span.close)))\n        }\n    }\n\n    pub fn parse_option_from(delim: Delimiter, input: ParseStream\u003c'_\u003e) -\u003e Result\u003cOption\u003cSelf\u003e\u003e {\n        let peek = input.ts.peek();\n        if let Some(TokenTree::Delimited(_, d, _)) = peek {\n            if delim == *d {\n                Ok(Some(Self::parse_from(delim, input)?))\n            } else {\n                Ok(None)\n            }\n        } else {\n            Ok(None)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        ast::{Ident, Lit, TokenStream},\n        resource::SourceMap,\n    };\n\n    #[test]\n    fn success_single_token_delimited() {\n        // used to test all kind of delimiters\n\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"{ ident }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = Delimited::\u003cIdent\u003e::parse_from(Delimiter::Brace, \u0026buf).unwrap();\n        assert_eq!(item.delim, Delimiter::Brace);\n        assert_eq!(item.inner, \"ident\");\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"(ident)\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = Delimited::\u003cIdent\u003e::parse_from(Delimiter::Parenthesis, \u0026buf).unwrap();\n        assert_eq!(item.delim, Delimiter::Parenthesis);\n        assert_eq!(item.inner, \"ident\");\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"[ident]\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = Delimited::\u003cIdent\u003e::parse_from(Delimiter::Bracket, \u0026buf).unwrap();\n        assert_eq!(item.delim, Delimiter::Bracket);\n        assert_eq!(item.inner, \"ident\");\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"[123]\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = Delimited::\u003cLit\u003e::parse_from(Delimiter::Bracket, \u0026buf).unwrap();\n        assert_eq!(item.delim, Delimiter::Bracket);\n        assert_eq!(format!(\"{}\", item.inner.kind), \"123\");\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1934},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":3862},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1904},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1941},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":353},"fn_name":null}],"covered":29,"coverable":32},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","eitheror.rs"],"content":"use crate::{ast::parse::*, error::Result};\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum EitherOr\u003cE, O\u003e {\n    Either(E),\n    Or(O),\n}\n\nimpl\u003cE, O\u003e Spanned for EitherOr\u003cE, O\u003e\nwhere\n    E: Spanned,\n    O: Spanned,\n{\n    fn span(\u0026self) -\u003e crate::Span {\n        match self {\n            EitherOr::Either(either) =\u003e either.span(),\n            EitherOr::Or(or) =\u003e or.span(),\n        }\n    }\n}\n\nimpl\u003cE, O\u003e Parse for EitherOr\u003cE, O\u003e\nwhere\n    E: Parse,\n    O: Parse,\n{\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let old = input.ts.state();\n        match E::parse(input) {\n            Ok(either) =\u003e Ok(EitherOr::Either(either)),\n            Err(_) =\u003e {\n                input.ts.set_state(old);\n                let or = O::parse(input)?;\n                Ok(EitherOr::Or(or))\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::{Comma, Ident, Joined, Lit, Slash, TokenStream};\n    use crate::SourceMap;\n\n    use super::*;\n\n    #[test]\n    fn single_token() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"ident\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = EitherOr::\u003cIdent, Lit\u003e::parse(\u0026buf).unwrap();\n        assert!(matches!(item, EitherOr::Either(_)));\n        assert!(buf.ts.is_empty());\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"123\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = EitherOr::\u003cIdent, Lit\u003e::parse(\u0026buf).unwrap();\n        assert!(matches!(item, EitherOr::Or(_)));\n        assert!(buf.ts.is_empty());\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"@annot\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _item = EitherOr::\u003cIdent, Lit\u003e::parse(\u0026buf).unwrap_err();\n    }\n\n    #[test]\n    fn multiple_token_reset() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"ident/subident\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = EitherOr::\u003cJoined\u003cIdent, Slash\u003e, Lit\u003e::parse(\u0026buf).unwrap();\n        assert!(matches!(item, EitherOr::Either(_)));\n        assert!(buf.ts.is_empty(), \"remaining token: {:#?}..\", buf.ts.peek());\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"123\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = EitherOr::\u003cJoined\u003cIdent, Slash\u003e, Lit\u003e::parse(\u0026buf).unwrap();\n        assert!(matches!(item, EitherOr::Or(_)));\n        assert!(buf.ts.is_empty(), \"remaining token: {:#?}..\", buf.ts.peek());\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"ident/subident\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = EitherOr::\u003cJoined\u003cIdent, Slash\u003e, Lit\u003e::parse(\u0026buf).unwrap();\n        assert!(matches!(item, EitherOr::Either(_)));\n        assert!(buf.ts.is_empty(), \"remaining token: {:#?}..\", buf.ts.peek());\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"123/+\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = EitherOr::\u003cJoined\u003cLit, Slash\u003e, Lit\u003e::parse(\u0026buf).unwrap();\n        assert!(matches!(item, EitherOr::Or(_)));\n        assert!(!buf.ts.is_empty());\n    }\n\n    #[test]\n    fn joined() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"ident, odent, 123, mudent\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = Joined::\u003cEitherOr\u003cIdent, Lit\u003e, Comma\u003e::parse(\u0026buf).unwrap();\n        // assert!(matches!(item, EitherOr::Either(_)));\n        assert_eq!(item.len(), 4);\n        assert!(buf.ts.is_empty(), \"remaining token: {:#?}..\", buf.ts.peek());\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":162},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":101},"fn_name":null}],"covered":7,"coverable":12},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","joined.rs"],"content":"use crate::{ast::parse::*, error::Result, Span};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Joined\u003cT, P\u003e {\n    items: Vec\u003c(T, P)\u003e,\n    last: Box\u003cT\u003e,\n}\n\nimpl\u003cT, P\u003e Joined\u003cT, P\u003e {\n    pub fn len(\u0026self) -\u003e usize {\n        self.items.len() + 1\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        false\n    }\n\n    pub fn iter(\u0026self) -\u003e JoinedIter\u003c'_, T, P\u003e {\n        JoinedIter {\n            joined: self,\n            idx: 0,\n        }\n    }\n}\n\npub struct JoinedIter\u003c'a, T, P\u003e {\n    joined: \u0026'a Joined\u003cT, P\u003e,\n    idx: usize,\n}\n\nimpl\u003c'a, T, P\u003e Iterator for JoinedIter\u003c'a, T, P\u003e {\n    type Item = \u0026'a T;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        use std::cmp::Ordering::*;\n        match self.idx.cmp(\u0026self.joined.items.len()) {\n            Less =\u003e {\n                self.idx += 1;\n                Some(\u0026self.joined.items[self.idx - 1].0)\n            }\n            Equal =\u003e {\n                self.idx += 1;\n                Some(\u0026self.joined.last)\n            }\n            Greater =\u003e None,\n        }\n    }\n}\n\nimpl\u003cT, P\u003e Spanned for Joined\u003cT, P\u003e\nwhere\n    T: Spanned,\n{\n    fn span(\u0026self) -\u003e crate::Span {\n        Span::fromto(\n            self.items\n                .first()\n                .map(|i| i.0.span())\n                .unwrap_or(self.last.span()),\n            self.last.span(),\n        )\n    }\n}\n\nimpl\u003cT, P\u003e Parse for Joined\u003cT, P\u003e\nwhere\n    T: Parse,\n    P: Parse,\n{\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let mut items = Vec::new();\n        loop {\n            let item = T::parse(input).map_err(|e| {\n                let f = format!(\"{}\", e.internal);\n                e.override_internal(format!(\"failed to parse value in joined statement: {f}\"))\n            })?;\n            match P::parse(input) {\n                Ok(delim) =\u003e items.push((item, delim)),\n                Err(_) =\u003e {\n                    return Ok(Self {\n                        items,\n                        last: Box::new(item),\n                    });\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":220},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":220},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":755},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1558},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1558},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":755},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":755},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":719},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":320},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":320},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":798},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":79},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":306},"fn_name":null}],"covered":25,"coverable":32},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","kv.rs"],"content":"use crate::{ast::parse::*, error::Result, Span};\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct KeyValueField\u003cK, V, D\u003e {\n    pub key: K,\n    pub delim: D,\n    pub value: V,\n}\n\nimpl\u003cK, V, D\u003e Spanned for KeyValueField\u003cK, V, D\u003e\nwhere\n    K: Spanned,\n    V: Spanned,\n{\n    fn span(\u0026self) -\u003e crate::Span {\n        Span::fromto(self.key.span(), self.value.span())\n    }\n}\n\nimpl\u003cK, V, D\u003e Parse for KeyValueField\u003cK, V, D\u003e\nwhere\n    K: Parse,\n    V: Parse,\n    D: Parse,\n{\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let key = K::parse(input)?;\n        let delim = D::parse(input).map_err(|e| {\n            let f = format!(\"{}\", e.internal);\n            e.override_internal(format!(\"missing delimiter in key-value pair: {f}\"))\n        })?;\n        let value = V::parse(input).map_err(|e| {\n            let f = format!(\"{}\", e.internal);\n            e.override_internal(format!(\"missing value in key-value pair: {f}\"))\n        })?;\n\n        Ok(Self { key, delim, value })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::{parse::*, Eq, Ident, KeyValueField, Lit, LitKind, TokenStream};\n    use crate::resource::SourceMap;\n\n    #[test]\n    fn success_single_delim_token() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"first = 123\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let kv = KeyValueField::\u003cIdent, Lit, Eq\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(kv.key, \"first\");\n        assert_eq!(kv.value.kind, LitKind::Integer { lit: 123 });\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"first = \\\"first\\\"\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let kv = KeyValueField::\u003cIdent, Lit, Eq\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(kv.key, \"first\");\n        assert_eq!(\n            kv.value.kind,\n            LitKind::Str {\n                lit: \"first\".to_string()\n            }\n        );\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":570},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1140},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":570},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":564},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":558},"fn_name":null}],"covered":11,"coverable":11},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","macros.rs"],"content":"macro_rules! ast_expect_single_token {\n    (\n        $(\n        $vis:vis struct $type:ident {\n            token: $token:expr,\n        }\n        )*\n\n    ) =\u003e {\n       $(\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n        $vis struct $type {\n            $vis span: crate::Span\n        }\n\n        impl crate::ast::parse::Parse for $type {\n            fn parse(input: crate::ast::parse::ParseStream)\n                -\u003e crate::error::Result\u003c$type\u003e {\n                let Some(peek) = input.ts.peek() else {\n                    return Err(\n                        crate::error::Error::new(\n                            crate::error::ErrorKind::UnexpectedToken,\n                            format!(\"expected {}, found EOF\", $token.token_kind_err_output())\n                        )\n                    );\n                };\n\n                if let crate::ast::token::TokenTree::Token(token, spacing) = peek {\n                    if crate::ast::token::Spacing::Alone != *spacing {\n                        return Err(\n                            crate::error::Error::new(\n                                crate::error::ErrorKind::ExpectedSingleFoundJoint,\n                                format!(\"expected {}, found invalid spacing\", $token.token_kind_err_output())\n                            ).spanned(token.span)\n                        );\n                    }\n\n                    if token.kind == $token {\n                        let ret = Ok(Self { span: token.span });\n                        input.ts.bump();\n                        ret\n                    } else {\n                        Err(\n                            crate::error::Error::new(\n                                crate::error::ErrorKind::UnexpectedToken,\n                                format!(\"expected {}, found {}\", $token.token_kind_err_output(), token.kind.token_kind_err_output())\n                            ).spanned(token.span)\n                        )\n                    }\n                } else {\n                    Err(\n                        crate::error::Error::new(\n                            crate::error::ErrorKind::UnexpectedDelim,\n                            format!(\"expected {}, found delim\", $token.token_kind_err_output())\n                        ).spanned(peek.span())\n                    )\n                }\n            }\n        }\n\n        impl crate::ast::parse::Spanned for $type {\n            fn span(\u0026self) -\u003e crate::resource::Span {\n                self.span\n            }\n        }\n    )*\n    };\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":6522},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":6522},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":13031},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":5550},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":5550},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":5296},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":5296},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":5296},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1202},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1202},"fn_name":null}],"covered":24,"coverable":29},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","mod.rs"],"content":"use crate::ast::parse::*;\nuse crate::ast::Annotation;\nuse crate::ast::Keyword;\nuse crate::ast::Token;\nuse crate::ast::TokenKind;\nuse crate::ast::TokenStream;\nuse crate::ast::TokenTree;\nuse crate::error::*;\nuse crate::Span;\n\n#[macro_use]\nmod macros;\n\nmod cluster;\nmod delim;\nmod eitheror;\nmod joined;\nmod kv;\nmod punct;\n\npub use self::cluster::*;\npub use self::delim::*;\npub use self::eitheror::*;\npub use self::joined::*;\npub use self::kv::*;\npub use self::punct::*;\n\n// # Tokens\n\nast_expect_single_token! {\n    pub struct Slash {\n        token: TokenKind::Slash,\n    }\n    pub struct Dot {\n        token: TokenKind::Dot,\n    }\n    pub struct DotDot {\n        token: TokenKind::DotDot,\n    }\n    pub struct DotDotDot {\n        token: TokenKind::DotDotDot,\n    }\n    pub struct Eq {\n        token: TokenKind::Eq,\n    }\n    pub struct Semi {\n        token: TokenKind::Semi,\n    }\n    pub struct Comma {\n        token: TokenKind::Comma,\n    }\n    pub struct Colon {\n        token: TokenKind::Colon,\n    }\n    pub struct Plus {\n        token: TokenKind::Plus,\n    }\n    pub struct Minus {\n        token: TokenKind::Minus,\n    }\n    pub struct LeftSingleArrow {\n        token: TokenKind::LSingleArrow,\n    }\n    pub struct LeftRightSingleArrow {\n        token: TokenKind::LSingleArrowR,\n    }\n    pub struct RightSingleArrow {\n        token: TokenKind::RSingleArrow,\n    }\n    pub struct IncludeToken {\n        token: TokenKind::Keyword(Keyword::Include),\n    }\n    pub struct ModuleToken {\n        token: TokenKind::Keyword(Keyword::Module),\n    }\n    pub struct GatesToken {\n        token: TokenKind::Keyword(Keyword::Gates),\n    }\n    pub struct SubmodulesToken {\n        token: TokenKind::Keyword(Keyword::Submodules),\n    }\n    pub struct ConnectionsToken {\n        token: TokenKind::Keyword(Keyword::Connections),\n    }\n    pub struct LinkToken {\n        token: TokenKind::Keyword(Keyword::Link),\n    }\n    pub struct EntryToken {\n        token: TokenKind::Keyword(Keyword::Entry),\n    }\n    pub struct DynToken {\n        token: TokenKind::Keyword(Keyword::Dyn),\n    }\n}\n\n// # EXT\n\npub use crate::ast::token::Ident;\npub use crate::ast::token::Lit;\n\nimpl Spanned for Ident {\n    fn span(\u0026self) -\u003e crate::Span {\n        self.span\n    }\n}\n\nimpl Parse for Ident {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        match input.ts.peek() {\n            Some(TokenTree::Token(\n                Token {\n                    kind: TokenKind::Ident(ident),\n                    ..\n                },\n                _,\n            )) =\u003e {\n                let ident = ident.clone();\n                input.ts.bump();\n                Ok(ident)\n            }\n\n            Some(TokenTree::Token(\n                Token {\n                    kind: TokenKind::Keyword(keyword),\n                    ..\n                },\n                _,\n            )) =\u003e Err(Error::new(\n                ErrorKind::ExpectedIdentFoundKeyword,\n                format!(\"expected \u003cident\u003e, found \u003ckeyword\u003e '{}'\", keyword),\n            )),\n\n            Some(TokenTree::Token(token, _)) =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                format!(\n                    \"expected \u003cident\u003e, found {}\",\n                    token.kind.token_kind_err_output()\n                ),\n            )\n            .spanned(token.span)),\n\n            Some(TokenTree::Delimited(delim, _, _)) =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                \"expected \u003cident\u003e, found delim\",\n            )\n            .spanned(Span::fromto(delim.open, delim.close))),\n\n            _ =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                \"expected \u003cident\u003e, found EOF\",\n            )),\n        }\n    }\n}\n\nimpl Spanned for Annotation {\n    fn span(\u0026self) -\u003e crate::Span {\n        self.span\n    }\n}\n\nimpl Parse for Annotation {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        match input.ts.peek() {\n            Some(TokenTree::Token(\n                Token {\n                    kind: TokenKind::Annotation(annot),\n                    ..\n                },\n                _,\n            )) =\u003e {\n                let annot = annot.clone();\n                input.ts.bump();\n                Ok(annot)\n            }\n\n            Some(TokenTree::Token(token, _)) =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                format!(\n                    \"expected \u003cannotation\u003e, found {}\",\n                    token.kind.token_kind_err_output()\n                ),\n            )\n            .spanned(token.span)),\n\n            Some(TokenTree::Delimited(delim, _, _)) =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                \"expected \u003cannotation\u003e, found delim\",\n            )\n            .spanned(Span::fromto(delim.open, delim.close))),\n\n            _ =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                \"expected \u003cannotation\u003e, found EOF\",\n            )),\n        }\n    }\n}\n\nimpl Spanned for Lit {\n    fn span(\u0026self) -\u003e crate::Span {\n        self.span\n    }\n}\n\nimpl Parse for Lit {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        match input.ts.peek() {\n            Some(TokenTree::Token(\n                Token {\n                    kind: TokenKind::Literal(lit),\n                    ..\n                },\n                _,\n            )) =\u003e {\n                let lit = lit.clone();\n                input.ts.bump();\n                Ok(lit)\n            }\n\n            Some(TokenTree::Token(token, _)) =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                format!(\n                    \"expected \u003cliteral\u003e, found {}\",\n                    token.kind.token_kind_err_output()\n                ),\n            )\n            .spanned(token.span)),\n\n            Some(TokenTree::Delimited(delim, _, _)) =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                \"expected \u003cliteral\u003e, found delim\",\n            )\n            .spanned(Span::fromto(delim.open, delim.close))),\n\n            _ =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                \"expected \u003cliteral\u003e, found EOF\",\n            )),\n        }\n    }\n}\n\nimpl Parse for TokenStream {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        if input.ts.state() == 0 {\n            Ok(TokenStream {\n                items: input.ts.raw(),\n            })\n        } else {\n            Err(Error::new(ErrorKind::MissingToken, \"missing token\"))\n        }\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":670},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":670},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":4259},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":4259},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":790},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":790},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":45,"coverable":83},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","punct.rs"],"content":"use crate::{ast::parse::*, error::*, Span};\n\n// Eg \u003cLit, Comma\u003e,\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Punctuated\u003cT, P\u003e {\n    inner: Vec\u003c(T, P)\u003e,\n    last: Option\u003cBox\u003cT\u003e\u003e,\n}\n\nimpl\u003cT, P\u003e Punctuated\u003cT, P\u003e {\n    pub const fn new() -\u003e Self {\n        Self {\n            inner: Vec::new(),\n            last: None,\n        }\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.inner.len() + if self.last.is_some() { 1 } else { 0 }\n    }\n\n    pub fn first(\u0026self) -\u003e Option\u003c\u0026T\u003e {\n        self.inner.first().map(|v| \u0026v.0)\n    }\n\n    pub fn first_mut(\u0026mut self) -\u003e Option\u003c\u0026mut T\u003e {\n        self.inner.first_mut().map(|v| \u0026mut v.0)\n    }\n\n    pub fn trailing_punct(\u0026self) -\u003e bool {\n        self.last.is_none()\n    }\n\n    pub fn push_value(\u0026mut self, value: T) {\n        assert!(self.last.is_none());\n        self.last = Some(Box::new(value));\n    }\n\n    pub fn push_punct(\u0026mut self, punct: P) {\n        assert!(self.last.is_some());\n        self.inner.push((*self.last.take().unwrap(), punct))\n    }\n\n    pub fn iter(\u0026self) -\u003e PunctIter\u003c'_, T, P\u003e {\n        PunctIter {\n            punct: self,\n            idx: 0,\n        }\n    }\n}\n\nimpl\u003cT, P\u003e Spanned for Punctuated\u003cT, P\u003e\nwhere\n    T: Spanned,\n    P: Spanned,\n{\n    fn span(\u0026self) -\u003e Span {\n        if self.is_empty() {\n            Span::new(0, 0)\n        } else {\n            Span::fromto(\n                self.iter().next().unwrap().span(),\n                self.last\n                    .as_ref()\n                    .map(|v| v.span())\n                    .unwrap_or(self.inner.last().unwrap().1.span()),\n            )\n        }\n    }\n}\n\nimpl\u003cT, P\u003e Parse for Punctuated\u003cT, P\u003e\nwhere\n    T: Parse,\n    P: Parse,\n{\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let mut this = Self::new();\n        while !input.ts.is_empty() {\n            let item = T::parse(input)?;\n\n            /* .map_err(|e| {\n                if matches!(e.kind, ErrorKind::UnexpectedToken | UnexpectedEOF) {\n                    let f = format!(\"{}\", e.internal);\n                    e.override_internal(format!(\"expected value in punctuated statement: {f}\"))\n                } else {\n                    e\n                }\n            }) */\n\n            if input.ts.is_empty() {\n                // no tailing delim needed\n                this.last = Some(Box::new(item));\n                break;\n            } else {\n                let delim = P::parse(input)?;\n                this.inner.push((item, delim))\n            }\n        }\n\n        assert!(input.ts.is_empty());\n        Ok(this)\n    }\n}\n\n// # Iter\n\npub struct PunctIter\u003c'a, T, P\u003e {\n    punct: \u0026'a Punctuated\u003cT, P\u003e,\n    idx: usize,\n}\n\nimpl\u003c'a, T, P\u003e Iterator for PunctIter\u003c'a, T, P\u003e {\n    type Item = \u0026'a T;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        use std::cmp::Ordering::*;\n        match self.idx.cmp(\u0026self.punct.inner.len()) {\n            Less =\u003e {\n                self.idx += 1;\n                Some(\u0026self.punct.inner[self.idx - 1].0)\n            }\n            Equal =\u003e {\n                self.idx += 1;\n                self.punct.last.as_deref()\n            }\n            Greater =\u003e None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::ast::{Comma, Eq, Ident, KeyValueField, Lit, Punctuated, Semi, TokenStream};\n    use crate::resource::SourceMap;\n\n    #[test]\n    fn success_single_token_patterns() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"first,second,third,\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cIdent, Comma\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 3);\n        assert_eq!(punct.trailing_punct(), true);\n\n        assert_eq!(\n            punct.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\"first\", \"second\", \"third\"]\n        );\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"first,second,third\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cIdent, Comma\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 3);\n        assert_eq!(punct.trailing_punct(), false);\n\n        assert_eq!(\n            punct.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\"first\", \"second\", \"third\"]\n        );\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"first,\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cIdent, Comma\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 1);\n        assert_eq!(punct.trailing_punct(), true);\n\n        assert_eq!(punct.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e(), vec![\"first\"]);\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"first\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cIdent, Comma\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 1);\n        assert_eq!(punct.trailing_punct(), false);\n\n        assert_eq!(punct.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e(), vec![\"first\"]);\n    }\n\n    #[test]\n    fn success_multi_token_patterns() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"\n        ident = 123;\n        key = 123123123;\n        comma = 13;\n        \",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cKeyValueField\u003cIdent, Lit, Eq\u003e, Semi\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 3);\n        assert_eq!(punct.trailing_punct(), true);\n\n        assert_eq!(\n            punct\n                .iter()\n                .cloned()\n                .map(|v| (format!(\"{}\", v.key.raw), format!(\"{}\", v.value.kind), \"=\"))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"ident\".to_string(), \"123\".to_string(), \"=\"),\n                (\"key\".to_string(), \"123123123\".to_string(), \"=\"),\n                (\"comma\".to_string(), \"13\".to_string(), \"=\"),\n            ]\n        );\n    }\n\n    #[test]\n    fn success_pattern_delim_same_type() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \",,,,,,\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cComma, Comma\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 3);\n        assert_eq!(punct.trailing_punct(), true);\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \",,,,,\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cComma, Comma\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 3);\n        assert_eq!(punct.trailing_punct(), false);\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":879},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":879},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":484},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":968},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1850},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":879},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":879},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1984},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3192},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":452},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":452},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2210},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1105},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":840},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":840},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":4867},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":4867},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1965},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1965},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1838},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1838},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1064},"fn_name":null}],"covered":24,"coverable":47},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","entry.rs"],"content":"use super::{EntryToken, Ident, Semi};\nuse crate::{ast::parse::*, error::*, Span};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct EntryStmt {\n    pub entry: EntryToken,\n    pub symbol: Ident,\n    pub semi: Semi,\n}\n\nimpl Spanned for EntryStmt {\n    fn span(\u0026self) -\u003e crate::Span {\n        Span::fromto(self.entry.span(), self.semi.span())\n    }\n}\n\nimpl Parse for EntryStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let entry = EntryToken::parse(input)?;\n        let symbol = Ident::parse(input)?;\n        let semi = Semi::parse(input)?;\n        Ok(Self {\n            entry,\n            symbol,\n            semi,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{ast::TokenStream, resource::SourceMap};\n\n    #[test]\n    fn parse_entry_statement() {\n        let mut smap = SourceMap::new();\n\n        // Case #0\n        let asset = smap.load_raw(\"raw:case0\", \"entry Main;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = EntryStmt::parse(\u0026buf).unwrap();\n        assert_eq!(expr.symbol, \"Main\")\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":510},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":255},"fn_name":null}],"covered":8,"coverable":10},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","include.rs"],"content":"use crate::Span;\n\nuse crate::ast::{parse::*, DotDot, EitherOr, Ident, IncludeToken, Joined, Semi, Slash};\nuse crate::error::*;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct IncludeStmt {\n    pub include: IncludeToken,\n    pub path: Joined\u003cEitherOr\u003cIdent, DotDot\u003e, Slash\u003e,\n    pub semi: Semi,\n}\n\nimpl Joined\u003cEitherOr\u003cIdent, DotDot\u003e, Slash\u003e {\n    pub fn path(\u0026self) -\u003e String {\n        self.iter()\n            .map(|v| match v {\n                EitherOr::Either(either) =\u003e \u0026either.raw[..],\n                EitherOr::Or(_) =\u003e \"..\",\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"/\")\n    }\n}\n\nimpl Spanned for IncludeStmt {\n    fn span(\u0026self) -\u003e crate::Span {\n        Span::fromto(self.include.span(), self.semi.span())\n    }\n}\n\n// # Parsing\n\nimpl Parse for IncludeStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let include = IncludeToken::parse(input)?;\n        let path = Joined::\u003c_, Slash\u003e::parse(input)?;\n        let semi = Semi::parse(input)?;\n        Ok(Self {\n            include,\n            path,\n            semi,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{IncludeStmt, Parse, ParseBuffer};\n    use crate::{\n        ast::TokenStream,\n        resource::{SourceMap, Span},\n    };\n\n    #[test]\n    fn success_single_path_component() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"include abcde;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(0, 7));\n        assert_eq!(include.semi.span, Span::new(13, 1));\n\n        assert_eq!(include.path.len(), 1);\n        assert_eq!(include.path.path(), \"abcde\");\n\n        // # Case 1\n        let offset = 14;\n        let asset = smap.load_raw(\"raw:case1\", \"include _abc1321231_123_acd;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(offset, 7));\n        assert_eq!(include.semi.span, Span::new(offset + 27, 1));\n\n        assert_eq!(include.path.len(), 1);\n        assert_eq!(include.path.path(), \"_abc1321231_123_acd\");\n\n        // # Case 2\n        let offset = 42;\n        let asset = smap.load_raw(\"raw:case2\", \"include cdc;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(offset, 7));\n        assert_eq!(include.path.len(), 1);\n        assert_eq!(include.path.path(), \"cdc\");\n\n        // # Case 3\n        let offset = 54;\n        let asset = smap.load_raw(\"raw:case3\", \"include \\n\\t\\t// AB\\n     cdc;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(offset, 7));\n\n        assert_eq!(include.path.len(), 1);\n        assert_eq!(include.path.path(), \"cdc\");\n    }\n\n    #[test]\n    fn success_more_path_components() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"include a/b/c;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(0, 7));\n        assert_eq!(include.semi.span, Span::new(13, 1));\n\n        assert_eq!(include.path.len(), 3);\n        assert_eq!(include.path.path(), \"a/b/c\");\n\n        // # Case 1\n        let offset = 14;\n        let asset = smap.load_raw(\"raw:case1\", \"include a12312/b12312/_c;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(offset, 7));\n        assert_eq!(include.semi.span, Span::new(offset + 24, 1));\n\n        assert_eq!(include.path.len(), 3);\n        assert_eq!(include.path.path(), \"a12312/b12312/_c\");\n\n        // # Case 2\n        let offset = 39;\n        let asset = smap.load_raw(\"raw:case2\", \"include a12312/b12312/_c;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(offset, 7));\n\n        assert_eq!(include.path.len(), 3);\n        assert_eq!(include.path.path(), \"a12312/b12312/_c\");\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":163},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":163},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":332},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":87},"fn_name":null}],"covered":14,"coverable":15},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","items.rs"],"content":"use std::sync::Arc;\n\nuse crate::{\n    ast::{\n        parse::*, EntryStmt, Ident, IncludeStmt, Keyword, LinkStmt, ModuleStmt, Token, TokenKind,\n        TokenTree,\n    },\n    error::*,\n};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct File {\n    pub items: Vec\u003cItem\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Item {\n    Include(Arc\u003cIncludeStmt\u003e),\n    Link(Arc\u003cLinkStmt\u003e),\n    Module(Arc\u003cModuleStmt\u003e),\n    Entry(Arc\u003cEntryStmt\u003e),\n}\n\n// # Impl\n\nimpl Item {\n    pub fn symbol(\u0026self) -\u003e Option\u003c\u0026Ident\u003e {\n        match self {\n            Item::Include(_) | Item::Entry(_) =\u003e None,\n            Item::Module(module) =\u003e Some(\u0026module.ident),\n            Item::Link(link) =\u003e Some(\u0026link.ident),\n        }\n    }\n}\n\n// # Spaning\n\nimpl Spanned for Item {\n    fn span(\u0026self) -\u003e crate::Span {\n        match self {\n            Self::Entry(entry) =\u003e entry.span(),\n            Self::Include(include) =\u003e include.span(),\n            Self::Link(link) =\u003e link.span(),\n            Self::Module(module) =\u003e module.span(),\n        }\n    }\n}\n\n// # Parse\n\nimpl Parse for File {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let mut items = Vec::new();\n        while !input.ts.is_empty() {\n            items.push(Item::parse(input)?)\n        }\n        Ok(File { items })\n    }\n}\n\nimpl Parse for Item {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        match input.ts.peek() {\n            Some(TokenTree::Token(\n                Token {\n                    kind: TokenKind::Keyword(keyword),\n                    span,\n                },\n                _,\n            )) =\u003e match keyword {\n                Keyword::Include =\u003e Ok(Item::Include(Arc::new(IncludeStmt::parse(input)?))),\n                Keyword::Link =\u003e Ok(Item::Link(Arc::new(LinkStmt::parse(input)?))),\n                Keyword::Module =\u003e Ok(Item::Module(Arc::new(ModuleStmt::parse(input)?))),\n                Keyword::Entry =\u003e Ok(Item::Entry(Arc::new(EntryStmt::parse(input)?))),\n                _ =\u003e Err(\n                    Error::new(ErrorKind::UnexpectedToken, \"expected top-level \u003ckeyword\u003e\")\n                        .spanned(*span),\n                ),\n            },\n\n            Some(t) =\u003e Err(\n                Error::new(ErrorKind::UnexpectedToken, \"expected top-level \u003ckeyword\u003e\")\n                    .spanned(t.span()),\n            ),\n\n            None =\u003e Err(\n                Error::new(ErrorKind::UnexpectedEOF, \"unexpected end of tokenstream\")\n                    .spanned(input.ts.last_span()),\n            ),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{ast::TokenStream, SourceMap};\n\n    #[test]\n    fn simple_top_level_definitions() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"include std; link A {} module B {} entry C;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let file = File::parse(\u0026buf).unwrap();\n        assert_eq!(file.items.len(), 4);\n\n        assert!(matches!(file.items[0], Item::Include(_)));\n        assert!(matches!(file.items[1], Item::Link(_)));\n        assert!(matches!(file.items[2], Item::Module(_)));\n        assert!(matches!(file.items[3], Item::Entry(_)));\n\n        // # Case 1\n        let asset = smap.load_raw(\n            \"raw:case1\",\n            \"include std; link A: Super { key: 123, } module B { gates { in, out } } entry C;\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let file = File::parse(\u0026buf).unwrap();\n        assert_eq!(file.items.len(), 4);\n\n        assert!(matches!(file.items[0], Item::Include(_)));\n        assert!(matches!(file.items[1], Item::Link(_)));\n        assert!(matches!(file.items[2], Item::Module(_)));\n        assert!(matches!(file.items[3], Item::Entry(_)));\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":1179},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1179},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":330},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":669},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":435},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":435},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1658},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1415},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":339},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":839},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":24,"coverable":32},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","link.rs"],"content":"use crate::{\n    ast::{\n        parse::*, Colon, Comma, Delimited, Delimiter, Ident, Joined, KeyValueField, LinkToken, Lit,\n        Plus, Punctuated,\n    },\n    error::*,\n    resource::Span,\n};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct LinkStmt {\n    pub link_token: LinkToken,\n    pub ident: Ident,\n    pub inheritance: Option\u003cLinkInheritance\u003e,\n    pub data: LinkData,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct LinkInheritance {\n    pub colon: Colon,\n    pub symbols: Joined\u003cIdent, Plus\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct LinkData {\n    pub items: Punctuated\u003cKeyValueField\u003cIdent, Lit, Colon\u003e, Comma\u003e,\n    pub span: Span,\n}\n\n// # Spanning\n\nimpl Spanned for LinkStmt {\n    fn span(\u0026self) -\u003e crate::Span {\n        Span::fromto(self.link_token.span(), self.data.span())\n    }\n}\n\nimpl Spanned for LinkInheritance {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(self.colon.span(), self.symbols.span())\n    }\n}\n\nimpl Spanned for LinkData {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\n// # Parsing\n\nimpl Parse for LinkStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let link_token = LinkToken::parse(input)?;\n        let ident = Ident::parse(input).map_err(|e| {\n            let f = format!(\"{}\", e.internal);\n            e.override_internal(format!(\"unexpected token for link symbol: {}\", f))\n        })?;\n        let inheritance = Option::\u003cLinkInheritance\u003e::parse(input)?;\n        let data = LinkData::parse(input)?;\n\n        Ok(Self {\n            link_token,\n            ident,\n            inheritance,\n            data,\n        })\n    }\n}\n\nimpl Parse for Option\u003cLinkInheritance\u003e {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let colon = match Colon::parse(input) {\n            Ok(v) =\u003e v,\n            Err(_) =\u003e return Ok(None),\n        };\n\n        let symbols = Joined::\u003cIdent, Plus\u003e::parse(input)?;\n        Ok(Some(LinkInheritance { colon, symbols }))\n    }\n}\n\nimpl Parse for LinkData {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let items = Delimited::\u003cPunctuated\u003cKeyValueField\u003cIdent, Lit, Colon\u003e, Comma\u003e\u003e::parse_from(\n            Delimiter::Brace,\n            input,\n        )?;\n        let span = Span::fromto(items.delim_span.open, items.delim_span.close);\n        Ok(Self {\n            items: items.inner,\n            span,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::{parse::*, LinkStmt, TokenStream};\n    use crate::resource::SourceMap;\n\n    #[test]\n    fn multiple_lit_parse() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"link FastLink { ident: 123, other: 1.0 }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = LinkStmt::parse(\u0026buf).unwrap();\n        assert_eq!(expr.ident, \"FastLink\");\n        assert_eq!(expr.link_token.span.pos, 0);\n        assert_eq!(\n            expr.data\n                .items\n                .iter()\n                .cloned()\n                .map(|v| (v.key.raw, format!(\"{}\", v.value.kind)))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"ident\".to_string(), \"123\".to_string()),\n                (\"other\".to_string(), \"1.0\".to_string())\n            ]\n        );\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"link FastLink { ident: 123, other: 1.0, }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = LinkStmt::parse(\u0026buf).unwrap();\n        assert_eq!(expr.ident, \"FastLink\");\n        assert_eq!(\n            expr.data\n                .items\n                .iter()\n                .cloned()\n                .map(|v| (v.key.raw, format!(\"{}\", v.value.kind)))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"ident\".to_string(), \"123\".to_string()),\n                (\"other\".to_string(), \"1.0\".to_string())\n            ]\n        );\n    }\n\n    #[test]\n    fn inheritance_statement() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"link FastLink: pident { ident: 123, other: 1.0 }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = LinkStmt::parse(\u0026buf).unwrap();\n        assert_eq!(expr.ident, \"FastLink\");\n        assert_eq!(\n            expr.inheritance\n                .map(|v| v.symbols.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e())\n                .unwrap(),\n            vec![\"pident\"]\n        );\n        assert_eq!(expr.link_token.span.pos, 0);\n        assert_eq!(\n            expr.data\n                .items\n                .iter()\n                .cloned()\n                .map(|v| (v.key.raw, format!(\"{}\", v.value.kind)))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"ident\".to_string(), \"123\".to_string()),\n                (\"other\".to_string(), \"1.0\".to_string())\n            ]\n        );\n\n        // # Case 2\n        let asset = smap.load_raw(\n            \"raw:case2\",\n            \"link FastLink: A + B + C { ident: 123, other: 1.0, }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = LinkStmt::parse(\u0026buf).unwrap();\n        assert_eq!(expr.ident, \"FastLink\");\n        assert_eq!(\n            expr.inheritance\n                .map(|v| v.symbols.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e())\n                .unwrap(),\n            vec![\"A\", \"B\", \"C\"]\n        );\n        assert_eq!(\n            expr.data\n                .items\n                .iter()\n                .cloned()\n                .map(|v| (v.key.raw, format!(\"{}\", v.value.kind)))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"ident\".to_string(), \"123\".to_string()),\n                (\"other\".to_string(), \"1.0\".to_string())\n            ]\n        );\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":221},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":442},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":221},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":209},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":191},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":191},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":191},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":191},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":191},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":316},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":101},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":209},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":209},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":209},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","mod.rs"],"content":"mod common;\nmod entry;\nmod include;\nmod items;\nmod link;\nmod module;\n\npub use common::*;\npub use entry::*;\npub use include::*;\npub use items::*;\npub use link::*;\npub use module::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","module","connections.rs"],"content":"use std::fmt;\n\nuse crate::{\n    ast::{\n        parse::*, ClusterDefinition, Comma, ConnectionsToken, Delimited, Delimiter, Ident,\n        LeftSingleArrow, Punctuated, RightSingleArrow, Slash, LeftRightSingleArrow, EitherOr,\n    },\n    error::Result,\n    resource::Span,\n};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ConnectionsStmt {\n    pub keyword: ConnectionsToken,\n    pub span: Span,\n    pub items: Punctuated\u003cConnectionDefinition, Comma\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ConnectionDefinition {\n    pub lhs: ModuleGateReference,\n    pub rhs: ModuleGateReference,\n    pub first_arrow: EitherOr\u003cLeftSingleArrow, LeftRightSingleArrow\u003e,\n    pub second_arrow: Option\u003cRightSingleArrow\u003e,\n    pub link: Option\u003cIdent\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum ModuleGateReference {\n    Local(LocalModuleGateReference),\n    Nonlocal(NonlocalModuleGateReference),\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct LocalModuleGateReference {\n    pub gate: Ident,\n    pub gate_cluster: Option\u003cClusterDefinition\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct NonlocalModuleGateReference {\n    pub submodule: Ident,\n    pub submodule_cluster: Option\u003cClusterDefinition\u003e,\n    pub slash: Slash,\n    pub gate: LocalModuleGateReference,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum ConnectionArrow {\n    Double(LeftRightSingleArrow),\n    Left(LeftSingleArrow),\n    Right(RightSingleArrow),\n}\n\n// # Impl\n\nimpl ConnectionArrow {\n    pub fn is_double(\u0026self) -\u003e bool {\n        matches!(self, Self::Double(_))\n    }\n\n    pub fn is_right(\u0026self) -\u003e bool {\n        matches!(self, Self::Right(_))\n    }\n}\n\nimpl LocalModuleGateReference {\n    pub fn pos(\u0026self) -\u003e usize {\n        self.gate_cluster\n            .as_ref()\n            .map(|c| c.lit.as_integer() as usize)\n            .unwrap_or(0)\n    }\n}\n\nimpl fmt::Display for ModuleGateReference {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Self::Local(local) =\u003e local.fmt(f),\n            Self::Nonlocal(nonlocal) =\u003e nonlocal.fmt(f),\n        }\n    }\n}\n\nimpl fmt::Display for LocalModuleGateReference {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        if let Some(cluster) = \u0026self.gate_cluster {\n            write!(f, \"{}{}\", self.gate.raw, cluster)\n        } else {\n            write!(f, \"{}\", self.gate.raw)\n        }\n    }\n}\n\nimpl fmt::Display for NonlocalModuleGateReference {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.submodule.raw)?;\n        if let Some(cluster) = \u0026self.submodule_cluster {\n            write!(f, \"{}\", cluster)?;\n        }\n        write!(f, \"/{}\", self.gate)?;\n\n        Ok(())\n    }\n}\n\n// # Spanning\n\nimpl Spanned for ConnectionsStmt {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\nimpl Spanned for ConnectionDefinition {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(self.lhs.span(), self.rhs.span())\n    }\n}\n\nimpl Spanned for ModuleGateReference {\n    fn span(\u0026self) -\u003e Span {\n        match self {\n            Self::Local(local) =\u003e local.span(),\n            Self::Nonlocal(nonlocal) =\u003e nonlocal.span(),\n        }\n    }\n}\n\nimpl Spanned for LocalModuleGateReference {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(\n            self.gate.span(),\n            self.gate_cluster\n                .as_ref()\n                .map(|v| v.span())\n                .unwrap_or(self.gate.span()),\n        )\n    }\n}\n\nimpl Spanned for NonlocalModuleGateReference {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(self.submodule.span(), self.gate.span())\n    }\n}\n\nimpl Spanned for ConnectionArrow {\n    fn span(\u0026self) -\u003e Span {\n        match self {\n            Self::Double(d) =\u003e d.span(),\n            Self::Left(left) =\u003e left.span(),\n            Self::Right(right) =\u003e right.span(),\n        }\n    }\n}\n\n// # Parse\n\nimpl Parse for ConnectionsStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let keyword = ConnectionsToken::parse(input)?;\n        let delim = Delimited::\u003cPunctuated\u003cConnectionDefinition, Comma\u003e\u003e::parse_from(\n            Delimiter::Brace,\n            input,\n        )?;\n        let span = Span::fromto(delim.delim_span.open, delim.delim_span.close);\n        Ok(ConnectionsStmt {\n            keyword,\n            span,\n            items: delim.inner,\n        })\n    }\n}\n\nimpl Parse for ConnectionDefinition {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let first = ModuleGateReference::parse(input)?;\n        let first_arrow = EitherOr::parse(input)?;\n\n        if matches!(first_arrow, EitherOr::Either(_)){\n            // Could be a delayed connections\n            let link = Ident::parse(input)?;\n            let second_arrow = RightSingleArrow::parse(input)?;\n            let third = ModuleGateReference::parse(input)?;\n\n            Ok(ConnectionDefinition {\n                lhs: first,\n                rhs: third,\n                first_arrow,\n                second_arrow: Some(second_arrow),\n                link: Some(link),\n            })\n        } else {\n            let second = ModuleGateReference::parse(input)?;\n\n            Ok(ConnectionDefinition {\n                lhs: first,\n                first_arrow,\n                rhs: second,\n                second_arrow: None,\n                link: None,\n            })\n        }\n    }\n}\n\nimpl Parse for ModuleGateReference {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let old_state = input.ts.state();\n        match NonlocalModuleGateReference::parse(input) {\n            Ok(v) =\u003e Ok(ModuleGateReference::Nonlocal(v)),\n            Err(_e) =\u003e {\n                input.ts.set_state(old_state);\n                let local = LocalModuleGateReference::parse(input)?;\n                Ok(ModuleGateReference::Local(local))\n            }\n        }\n    }\n}\n\nimpl Parse for LocalModuleGateReference {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let gate = Ident::parse(input)?;\n        let gate_cluster = Option::\u003cClusterDefinition\u003e::parse(input)?;\n        Ok(LocalModuleGateReference { gate, gate_cluster })\n    }\n}\n\nimpl Parse for NonlocalModuleGateReference {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let submodule = Ident::parse(input)?;\n        let submodule_cluster = Option::\u003cClusterDefinition\u003e::parse(input)?;\n        let slash = Slash::parse(input)?;\n        let gate = Ident::parse(input)?;\n        let gate_cluster = Option::\u003cClusterDefinition\u003e::parse(input)?;\n\n        Ok(NonlocalModuleGateReference {\n            submodule,\n            submodule_cluster,\n            slash,\n            gate: LocalModuleGateReference { gate, gate_cluster },\n        })\n    }\n}\n\nimpl Parse for ConnectionArrow {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        LeftSingleArrow::parse(input)\n            .map(ConnectionArrow::Left)\n            .or_else(|_| RightSingleArrow::parse(input).map(ConnectionArrow::Right))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{ast::TokenStream, SourceMap};\n\n    #[test]\n    fn simple_noncluster_connections() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"connections { from \u003c--\u003e to, iden_t \u003c--\u003e from_dent }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(items.len(), 2);\n\n        assert_eq!(items[0].lhs.to_string(), \"from\");\n        assert_eq!(items[0].rhs.to_string(), \"to\");\n        assert_eq!(items[0].link, None);\n\n        assert_eq!(items[1].lhs.to_string(), \"iden_t\");\n        assert_eq!(items[1].rhs.to_string(), \"from_dent\");\n        assert_eq!(items[1].link, None);\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"connections { from \u003c--\u003e 123 }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"connections { from + \u003c--\u003e ident }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"connections {  \u003c--\u003e ident }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"connections { from \u003c--\u003e ident,, }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n    }\n\n    #[test]\n    fn simple_cluster_connections() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"connections { from[1] \u003c--\u003e to, iden_t[10] \u003c--\u003e from_dent[12] }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(items[0].lhs.to_string(), \"from[1]\");\n        assert_eq!(items[0].rhs.to_string(), \"to\");\n        assert_eq!(items[0].link, None);\n\n        assert_eq!(items[1].lhs.to_string(), \"iden_t[10]\");\n        assert_eq!(items[1].rhs.to_string(), \"from_dent[12]\");\n        assert_eq!(items[1].link, None);\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"connections { from[ident] --\u003e to }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"connections { from[] --\u003e to }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"connections { from[213 --\u003e to }\");\n        let _ts = TokenStream::new(asset).unwrap_err();\n    }\n\n    #[test]\n    fn nonlocal_noncluster_connections() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"connections { child/from \u003c--\u003e child/to, child/iden_t \u003c--\u003e child/from_dent }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(items.len(), 2);\n\n        assert_eq!(items[0].lhs.to_string(), \"child/from\");\n        assert_eq!(items[0].rhs.to_string(), \"child/to\");\n        assert_eq!(items[0].link, None);\n\n        assert_eq!(items[1].lhs.to_string(), \"child/iden_t\");\n        assert_eq!(items[1].rhs.to_string(), \"child/from_dent\");\n        assert_eq!(items[1].link, None);\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"connections { child/from --\u003e child/123 }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"connections { child/from + --\u003e child/ident }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"connections {  --\u003e child/ident }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"connections { child/ --\u003e ident }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n    }\n\n    #[test]\n    fn nonlocal_cluster_connections() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"connections { child/from[1] \u003c--\u003e child/to, child/iden_t[10] \u003c--\u003e child/from_dent[12] }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(items[0].lhs.to_string(), \"child/from[1]\");\n        assert_eq!(items[0].rhs.to_string(), \"child/to\");\n        assert_eq!(items[0].link, None);\n\n        assert_eq!(items[1].lhs.to_string(), \"child/iden_t[10]\");\n        assert_eq!(items[1].rhs.to_string(), \"child/from_dent[12]\");\n        assert_eq!(items[1].link, None);\n\n        // # Case 1\n        let asset = smap.load_raw(\n            \"raw:case1\",\n            \"connections { child/from[ident] \u003c--\u003e child/to }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"connections { child/from[] \u003c--\u003e child/to }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"connections { child/from[213 \u003c--\u003e child/to }\");\n        let _ts = TokenStream::new(asset).unwrap_err();\n\n        // # Case 4\n        let asset = smap.load_raw(\n            \"raw:case4\",\n            \"connections { child[1]/from \u003c--\u003e child/to, child[10]/iden_t \u003c--\u003e child[12]/from_dent }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(items[0].lhs.to_string(), \"child[1]/from\");\n        assert_eq!(items[0].rhs.to_string(), \"child/to\");\n        assert_eq!(items[0].link, None);\n\n        assert_eq!(items[1].lhs.to_string(), \"child[10]/iden_t\");\n        assert_eq!(items[1].rhs.to_string(), \"child[12]/from_dent\");\n        assert_eq!(items[1].link, None);\n\n        // # Case 5\n        let asset = smap.load_raw(\n            \"raw:case5\",\n            \"connections { child[ident]/from \u003c--\u003e child/to }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 6\n        let asset = smap.load_raw(\"raw:case6\", \"connections { child[]/from \u003c--\u003e child[1]/to }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n    }\n\n    #[test]\n    fn delayed_connections() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"connections { from \u003c-- FastLink --\u003e to, iden_t \u003c-- L --\u003e from_dent }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(items.len(), 2);\n\n        assert_eq!(items[0].lhs.to_string(), \"from\");\n        assert_eq!(items[0].rhs.to_string(), \"to\");\n        assert_eq!(items[0].link.as_ref().map(|v| \u0026v.raw[..]), Some(\"FastLink\"));\n\n        assert_eq!(items[1].lhs.to_string(), \"iden_t\");\n        assert_eq!(items[1].rhs.to_string(), \"from_dent\");\n        assert_eq!(items[1].link.as_ref().map(|v| \u0026v.raw[..]), Some(\"L\"));\n\n        // # Case 1\n        let asset = smap.load_raw(\n            \"raw:case1\",\n            \"connections { from[1] \u003c-- FastLink --\u003e to, iden_t[5] \u003c--\u003e from_dent }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(items.len(), 2);\n\n        assert_eq!(items[0].lhs.to_string(), \"from[1]\");\n        assert_eq!(items[0].rhs.to_string(), \"to\");\n        assert_eq!(items[0].link.as_ref().map(|v| \u0026v.raw[..]), Some(\"FastLink\"));\n\n        assert_eq!(items[1].lhs.to_string(), \"iden_t[5]\");\n        assert_eq!(items[1].rhs.to_string(), \"from_dent\");\n        assert_eq!(items[1].link.as_ref().map(|v| \u0026v.raw[..]), None);\n    }\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":346},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":166},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":333},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":333},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":333},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":278},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":333},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":666},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":329},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":325},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":281},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":280},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":278},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":278},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":278},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":278},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":278},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":62,"coverable":95},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","module","gates.rs"],"content":"use crate::{\n    ast::{\n        parse::*, Annotation, ClusterDefinition, Comma, Delimited, Delimiter, GatesToken, Ident,\n        Punctuated, TokenKind, TokenTree,\n    },\n    error::Result,\n    resource::Span,\n};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct GatesStmt {\n    pub keyword: GatesToken,\n    pub span: Span,\n    pub items: Punctuated\u003cGateDefinition, Comma\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct GateDefinition {\n    pub ident: Ident,\n    pub cluster: Option\u003cClusterDefinition\u003e,\n}\n\n// # Spanning\n\nimpl Spanned for GatesStmt {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\nimpl Spanned for GateDefinition {\n    fn span(\u0026self) -\u003e Span {\n       self.ident.span()\n    }\n}\n\n// # Parsing\n\nimpl Parse for GatesStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let keyword = GatesToken::parse(input)?;\n        let items =\n            Delimited::\u003cPunctuated\u003cGateDefinition, Comma\u003e\u003e::parse_from(Delimiter::Brace, input)?;\n        let span = Span::fromto(items.delim_span.open, items.delim_span.close);\n        Ok(Self {\n            keyword,\n            span,\n            items: items.inner,\n        })\n    }\n}\n\nimpl Parse for GateDefinition {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let ident = Ident::parse(input)?;\n        let cluster = Option::\u003cClusterDefinition\u003e::parse(input)?;\n        Ok(Self {\n            ident,\n            cluster,\n        })\n    }\n}\n\nimpl Parse for Option\u003cAnnotation\u003e {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let Some(peek) = input.ts.peek() else {\n            return Ok(None);\n        };\n        let TokenTree::Token(token, _) = peek else {\n            return Ok(None);\n        };\n        if matches!(token.kind, TokenKind::Annotation(_)) {\n            Ok(Some(Annotation::parse(input)?))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::ast::TokenStream;\n    use crate::resource::SourceMap;\n\n    #[test]\n    fn simple_gates() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"gates { in, out, debug }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = GatesStmt::parse(\u0026buf).unwrap();\n        let defs = stmt\n            .items\n            .iter()\n            .cloned()\n            .map(|d| (d.ident.raw, d.cluster))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(defs.len(), 3);\n        assert_eq!(\n            defs,\n            vec![\n                (\"in\".to_string(), None),\n                (\"out\".to_string(), None),\n                (\"debug\".to_string(), None)\n            ]\n        );\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"gates { __ident, _hid3, debug, }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = GatesStmt::parse(\u0026buf).unwrap();\n        let defs = stmt\n            .items\n            .iter()\n            .cloned()\n            .map(|d| (d.ident.raw, d.cluster))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(defs.len(), 3);\n        assert_eq!(\n            defs,\n            vec![\n                (\"__ident\".to_string(), None),\n                (\"_hid3\".to_string(), None),\n                (\"debug\".to_string(), None)\n            ]\n        );\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"gates { __ident, 123, debug, }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = GatesStmt::parse(\u0026buf).unwrap_err();\n    }\n\n\n    #[test]\n    fn clusted_gates() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"gates { in[5], out[0], debug }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = GatesStmt::parse(\u0026buf).unwrap();\n        let defs = stmt\n            .items\n            .iter()\n            .cloned()\n            .map(|d| {\n                (\n                    d.ident.raw,\n                    d.cluster.map(|v| format!(\"{}\", v.lit.kind)),\n                )\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(defs.len(), 3);\n        assert_eq!(\n            defs,\n            vec![\n                (\"in\".to_string(), Some(\"5\".to_string())),\n                (\"out\".to_string(), Some(\"0\".to_string())),\n                (\"debug\".to_string(), None)\n            ]\n        );\n\n        // # Case 1\n        let asset = smap.load_raw(\n            \"raw:case1\",\n            \"gates { __ident[5], _hid3[1.0], debug[\\\"str\\\"], }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = GatesStmt::parse(\u0026buf).unwrap();\n        let defs = stmt\n            .items\n            .iter()\n            .cloned()\n            .map(|d| {\n                (\n                    d.ident.raw,\n                    d.cluster.map(|v| format!(\"{}\", v.lit.kind)),\n                )\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(defs.len(), 3);\n        assert_eq!(\n            defs,\n            vec![\n                (\"__ident\".to_string(), Some(\"5\".to_string())),\n                (\"_hid3\".to_string(), Some(\"1.0\".to_string())),\n                (\"debug\".to_string(), Some(\"\\\"str\\\"\".to_string()))\n            ]\n        );\n    }\n\n    #[test]\n    fn full_gates() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"gates { in[6] }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = GatesStmt::parse(\u0026buf).unwrap();\n        let defs = stmt\n            .items\n            .iter()\n            .cloned()\n            .map(|d| {\n                (\n                    d.ident.raw,\n                    d.cluster.map(|v| format!(\"{}\", v.lit.kind)),\n                )\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(defs.len(), 1);\n        assert_eq!(\n            defs,\n            vec![(\n                \"in\".to_string(),\n                Some(\"6\".to_string()),\n            ),]\n        );\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":440},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":880},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":433},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":433},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":433},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":433},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":27},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","module","submodules.rs"],"content":"use crate::{\n    ast::{\n        parse::*, ClusterDefinition, Colon, Comma, Delimited, Delimiter, DynToken, Eq, Ident,\n        KeyValueField, Keyword, Punctuated, SubmodulesToken, Token, TokenKind, TokenTree,\n    },\n    error::Result,\n    resource::Span,\n};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct SubmodulesStmt {\n    pub keyword: SubmodulesToken,\n    pub span: Span,\n    pub items: Punctuated\u003cSubmoduleDefinition, Comma\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct SubmoduleDefinition {\n    pub ident: Ident,\n    pub cluster: Option\u003cClusterDefinition\u003e,\n    pub colon: Colon,\n    pub typ: SubmoduleTyp,\n    pub dyn_spec: Option\u003cSubmoduleDynSpec\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum SubmoduleTyp {\n    Static(Ident),\n    Dynamic(DynToken, Ident),\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct SubmoduleDynSpec {\n    pub span: Span,\n    pub items: Punctuated\u003cKeyValueField\u003cIdent, Ident, Eq\u003e, Comma\u003e,\n}\n\n// # Impl\n\nimpl SubmoduleTyp {\n    pub fn raw(\u0026self) -\u003e String {\n        match self {\n            Self::Static(s) =\u003e s.raw.clone(),\n            Self::Dynamic(_, s) =\u003e s.raw.clone(),\n        }\n    }\n\n    pub fn is_dyn(\u0026self) -\u003e bool {\n        matches!(self, Self::Dynamic(_, _))\n    }\n}\n\n// # Spanning\n\nimpl Spanned for SubmodulesStmt {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\nimpl Spanned for SubmoduleDefinition {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(self.ident.span(), self.typ.span())\n    }\n}\n\nimpl Spanned for SubmoduleTyp {\n    fn span(\u0026self) -\u003e Span {\n        match self {\n            Self::Static(ident) =\u003e ident.span(),\n            Self::Dynamic(dyn_token, ident) =\u003e Span::fromto(dyn_token.span(), ident.span()),\n        }\n    }\n}\n\nimpl Spanned for SubmoduleDynSpec {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\n// # Parsing\n\nimpl Parse for SubmodulesStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let keyword = SubmodulesToken::parse(input)?;\n        let delim = Delimited::\u003cPunctuated\u003cSubmoduleDefinition, Comma\u003e\u003e::parse_from(\n            Delimiter::Brace,\n            input,\n        )?;\n        let span = Span::fromto(delim.delim_span.open, delim.delim_span.close);\n        Ok(SubmodulesStmt {\n            keyword,\n            span,\n            items: delim.inner,\n        })\n    }\n}\n\nimpl Parse for SubmoduleDefinition {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let ident = Ident::parse(input)?;\n        let cluster = Option::\u003cClusterDefinition\u003e::parse(input)?;\n        let colon = Colon::parse(input)?;\n        let typ = SubmoduleTyp::parse(input)?;\n        let dyn_spec = Option::\u003cSubmoduleDynSpec\u003e::parse(input)?;\n        Ok(SubmoduleDefinition {\n            ident,\n            cluster,\n            colon,\n            typ,\n            dyn_spec,\n        })\n    }\n}\n\nimpl Parse for SubmoduleTyp {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let peek = input.ts.peek();\n        match peek {\n            Some(TokenTree::Token(\n                Token {\n                    kind: TokenKind::Keyword(Keyword::Dyn),\n                    ..\n                },\n                _,\n            )) =\u003e {\n                let keyword = DynToken::parse(input)?;\n                let ident = Ident::parse(input)?;\n                Ok(Self::Dynamic(keyword, ident))\n            }\n            _ =\u003e Ok(Self::Static(Ident::parse(input)?)),\n        }\n    }\n}\n\nimpl Parse for Option\u003cSubmoduleDynSpec\u003e {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let delim =\n            Delimited::\u003cPunctuated\u003cKeyValueField\u003cIdent, Ident, Eq\u003e, Comma\u003e\u003e::parse_option_from(\n                Delimiter::Brace,\n                input,\n            )?;\n        if let Some(delim) = delim {\n            let span = delim.span();\n            Ok(Some(SubmoduleDynSpec {\n                span,\n                items: delim.inner,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::ast::TokenStream;\n    use crate::resource::SourceMap;\n\n    #[test]\n    fn single_submodules() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"submodules { parent: P, child: C }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = SubmodulesStmt::parse(\u0026buf).unwrap();\n        assert_eq!(\n            expr.items\n                .iter()\n                .cloned()\n                .map(|v| (\n                    v.ident.raw,\n                    v.typ.raw(),\n                    v.cluster.map(|v| format!(\"{}\", v.lit.kind))\n                ))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"parent\".to_string(), \"P\".to_string(), None),\n                (\"child\".to_string(), \"C\".to_string(), None),\n            ]\n        );\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"submodules { parent: P, child: _C, }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = SubmodulesStmt::parse(\u0026buf).unwrap();\n        assert_eq!(\n            expr.items\n                .iter()\n                .cloned()\n                .map(|v| (\n                    v.ident.raw,\n                    v.typ.raw(),\n                    v.cluster.map(|v| format!(\"{}\", v.lit.kind))\n                ))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"parent\".to_string(), \"P\".to_string(), None),\n                (\"child\".to_string(), \"_C\".to_string(), None),\n            ]\n        );\n    }\n\n    #[test]\n    fn clustered_submodules() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"submodules { parent[1]: P, child[\\\"str\\\"]: C }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = SubmodulesStmt::parse(\u0026buf).unwrap();\n        assert_eq!(\n            expr.items\n                .iter()\n                .cloned()\n                .map(|v| (\n                    v.ident.raw,\n                    v.typ.raw(),\n                    v.cluster.map(|v| format!(\"{}\", v.lit.kind))\n                ))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"parent\".to_string(), \"P\".to_string(), Some(\"1\".to_string())),\n                (\n                    \"child\".to_string(),\n                    \"C\".to_string(),\n                    Some(\"\\\"str\\\"\".to_string())\n                ),\n            ]\n        );\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"submodules { parent[10]: P, child: _C, }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = SubmodulesStmt::parse(\u0026buf).unwrap();\n        assert_eq!(\n            expr.items\n                .iter()\n                .cloned()\n                .map(|v| (\n                    v.ident.raw,\n                    v.typ.raw(),\n                    v.cluster.map(|v| format!(\"{}\", v.lit.kind))\n                ))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\n                    \"parent\".to_string(),\n                    \"P\".to_string(),\n                    Some(\"10\".to_string())\n                ),\n                (\"child\".to_string(), \"_C\".to_string(), None),\n            ]\n        );\n    }\n\n    #[test]\n    fn dyn_submodules() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"submodules { parent: dyn P, child: C }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = SubmodulesStmt::parse(\u0026buf).unwrap();\n        assert_eq!(\n            expr.items\n                .iter()\n                .cloned()\n                .map(|v| (\n                    v.ident.raw,\n                    v.typ.raw(),\n                    v.typ.is_dyn(),\n                    v.cluster.map(|v| format!(\"{}\", v.lit.kind))\n                ))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"parent\".to_string(), \"P\".to_string(), true, None),\n                (\"child\".to_string(), \"C\".to_string(), false, None)\n            ]\n        );\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":982},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":982},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":861},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":121},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":657},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1187},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":272},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":272},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":212},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":298},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":596},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":280},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":280},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":280},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":280},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":280},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":802},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":134},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":340},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":353},"fn_name":null}],"covered":48,"coverable":52},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","module.rs"],"content":"use crate::{\n    ast::{\n        parse::*, Colon, Delimited, Delimiter, Ident, Joined, Keyword, ModuleToken, Plus, Token,\n        TokenKind, TokenStream, TokenTree,\n    },\n    error::*,\n    Span,\n};\n\nmod connections;\nmod gates;\nmod submodules;\n\npub use connections::*;\npub use gates::*;\npub use submodules::*;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ModuleStmt {\n    pub keyword: ModuleToken,\n    pub ident: Ident,\n    pub inheritance: Option\u003cModuleInheritance\u003e,\n    pub gates: Vec\u003cGatesStmt\u003e,\n    pub submodules: Vec\u003cSubmodulesStmt\u003e,\n    pub connections: Vec\u003cConnectionsStmt\u003e,\n    pub span: Span,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ModuleInheritance {\n    pub colon: Colon,\n    pub symbols: Joined\u003cIdent, Plus\u003e,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum ModuleTypus {\n    Primal,\n    Inherited,\n    Dynamic,\n}\n\nimpl ModuleStmt {\n    pub fn typus(\u0026self) -\u003e ModuleTypus {\n        if self.inheritance.is_some() {\n            return ModuleTypus::Inherited;\n        }\n        if self\n            .submodules\n            .iter()\n            .any(|st| st.items.iter().any(|s| s.typ.is_dyn()))\n        {\n            return ModuleTypus::Dynamic;\n        }\n        ModuleTypus::Primal\n    }\n}\n\nimpl Spanned for ModuleStmt {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\nimpl Spanned for ModuleInheritance {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(self.colon.span(), self.symbols.span())\n    }\n}\n\nimpl Parse for ModuleStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let keyword = ModuleToken::parse(input)?;\n        let ident = Ident::parse(input).map_err(|e| {\n            let f = format!(\"{}\", e.internal);\n            e.override_internal(format!(\"unexpected token for module symbol: {f}\"))\n        })?;\n\n        let inheritance = Option::\u003cModuleInheritance\u003e::parse(input)?;\n        let delim = Delimited::\u003cTokenStream\u003e::parse_from(Delimiter::Brace, input)?;\n        let inner = ParseBuffer::new(input.asset, delim.inner);\n        let span = Span::fromto(keyword.span(), delim.delim_span.close);\n\n        let mut this = ModuleStmt {\n            keyword,\n            ident,\n            inheritance,\n            gates: Vec::new(),\n            submodules: Vec::new(),\n            connections: Vec::new(),\n            span,\n        };\n\n        while !inner.ts.is_empty() {\n            match inner.ts.peek() {\n                Some(TokenTree::Token(\n                    Token {\n                        kind: TokenKind::Keyword(Keyword::Gates),\n                        ..\n                    },\n                    _,\n                )) =\u003e this.gates.push(GatesStmt::parse(\u0026inner)?),\n\n                Some(TokenTree::Token(\n                    Token {\n                        kind: TokenKind::Keyword(Keyword::Submodules),\n                        ..\n                    },\n                    _,\n                )) =\u003e this.submodules.push(SubmodulesStmt::parse(\u0026inner)?),\n\n                Some(TokenTree::Token(\n                    Token {\n                        kind: TokenKind::Keyword(Keyword::Connections),\n                        ..\n                    },\n                    _,\n                )) =\u003e this.connections.push(ConnectionsStmt::parse(\u0026inner)?),\n\n                Some(other) =\u003e {\n                    return Err(Error::new(\n                        ErrorKind::ExpectedInModuleKeyword,\n                        \"expected keyword 'gates', 'submodules' or 'connections'\",\n                    )\n                    .spanned(other.span()))\n                }\n                None =\u003e unreachable!(),\n            }\n        }\n\n        Ok(this)\n    }\n}\n\nimpl Parse for Option\u003cModuleInheritance\u003e {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let colon = match Colon::parse(input) {\n            Ok(v) =\u003e v,\n            Err(_) =\u003e return Ok(None),\n        };\n\n        let symbols = Joined::\u003cIdent, Plus\u003e::parse(input)?;\n        Ok(Some(ModuleInheritance { colon, symbols }))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::SourceMap;\n\n    #[test]\n    fn empty_module() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"module A {}\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ModuleStmt::parse(\u0026buf).unwrap();\n        assert_eq!(stmt.ident, \"A\");\n        assert_eq!(stmt.gates, vec![]);\n        assert_eq!(stmt.submodules, vec![]);\n        assert_eq!(stmt.connections, vec![]);\n    }\n\n    #[test]\n    fn keyword_triggered_modules() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"module A { gates {} connections {} submodules {}}\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ModuleStmt::parse(\u0026buf).unwrap();\n        assert_eq!(stmt.ident, \"A\");\n        assert!(stmt.gates.len() \u003e 0);\n        assert!(stmt.submodules.len() \u003e 0);\n        assert!(stmt.connections.len() \u003e 0);\n    }\n\n    #[test]\n    fn invalid_tokens() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"module A { 123 }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ModuleStmt::parse(\u0026buf).unwrap_err();\n    }\n\n    #[test]\n    fn inheritance() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"module A: B + C { }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ModuleStmt::parse(\u0026buf).unwrap();\n        assert!(stmt.inheritance.is_some())\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":91},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":91},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":786},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1572},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":786},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":774},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":768},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1339},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":620},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":253},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":311},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":91},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":719},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":774},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":901},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":647},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":121},"fn_name":null}],"covered":35,"coverable":35},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","mod.rs"],"content":"pub(crate) mod expr;\npub(crate) mod parse;\npub(crate) mod token;\npub(crate) mod validate;\n\npub use expr::*;\npub use parse::*;\npub use token::*;\npub use validate::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","parse","buffer.rs"],"content":"use std::borrow::Borrow;\n\nuse super::{cursor::Cursor, *};\nuse crate::{ast::TokenStream, Asset};\n\npub type ParseStream\u003c'a\u003e = \u0026'a ParseBuffer\u003c'a\u003e;\n\n#[derive(Debug)]\npub struct ParseBuffer\u003c'a\u003e {\n    pub asset: Asset\u003c'a\u003e,\n    pub ts: Cursor,\n}\n\nimpl\u003c'a\u003e ParseBuffer\u003c'a\u003e {\n    pub fn new(asset: Asset\u003c'a\u003e, ts: impl Borrow\u003cTokenStream\u003e) -\u003e Self {\n        Self {\n            asset,\n            ts: Cursor::new(ts.borrow()),\n        }\n    }\n\n    pub fn parse\u003cT: Parse\u003e(\u0026self) -\u003e Result\u003cT\u003e {\n        T::parse(self)\n    }\n\n    pub fn call\u003cT\u003e(\u0026self, f: fn(ParseStream\u003c'_\u003e) -\u003e Result\u003cT\u003e) -\u003e Result\u003cT\u003e {\n        f(self)\n    }\n\n    pub fn substream(\u0026self) -\u003e Option\u003cParseBuffer\u003c'a\u003e\u003e {\n        let ts = self.ts.subcursor()?;\n        Some(Self {\n            ts,\n            asset: self.asset,\n        })\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":1274},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1274},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3784},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":11},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","parse","cursor.rs"],"content":"use std::{cell::Cell, sync::Arc};\n\nuse crate::{\n    ast::token::{TokenStream, TokenTree},\n    Span,\n};\n\n#[derive(Debug)]\npub struct Cursor {\n    ts: Arc\u003cVec\u003cTokenTree\u003e\u003e,\n    idx: Cell\u003cusize\u003e,\n}\n\nimpl Cursor {\n    pub(crate) fn new(ts: \u0026TokenStream) -\u003e Self {\n        Self {\n            ts: ts.items.clone(),\n            idx: Cell::new(0),\n        }\n    }\n\n    pub(crate) fn raw(\u0026self) -\u003e Arc\u003cVec\u003cTokenTree\u003e\u003e {\n        self.ts.clone()\n    }\n\n    pub(crate) fn state(\u0026self) -\u003e usize {\n        self.idx.get()\n    }\n\n    pub(crate) fn set_state(\u0026self, state: usize) {\n        self.idx.set(state);\n    }\n\n    pub(crate) fn is_empty(\u0026self) -\u003e bool {\n        self.idx.get() \u003e= self.ts.len()\n    }\n\n    pub(crate) fn peek(\u0026self) -\u003e Option\u003c\u0026TokenTree\u003e {\n        if self.idx.get() \u003e= self.ts.len() {\n            None\n        } else {\n            Some(\u0026self.ts[self.idx.get()])\n        }\n    }\n\n    // pub(crate) fn next(\u0026self) -\u003e Option\u003c\u0026TokenTree\u003e {\n    //     if self.idx.get() \u003e= self.ts.len() {\n    //         None\n    //     } else {\n    //         self.bump();\n    //         Some(\u0026self.ts[self.idx.get() - 1])\n    //     }\n    // }\n\n    pub(crate) fn last_span(\u0026self) -\u003e Span {\n        self.ts.last().unwrap().span()\n    }\n\n    pub(crate) fn bump(\u0026self) {\n        self.idx.set(self.idx.get() + 1)\n    }\n\n    pub(crate) fn subcursor(\u0026self) -\u003e Option\u003cCursor\u003e {\n        let cur = \u0026self.ts.get(self.idx.get())?;\n        let TokenTree::Delimited(_, _, sub) = cur else {\n            return None;\n        };\n        Some(Cursor::new(sub))\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":3166},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":3166},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3166},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1359},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1359},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":163},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":163},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":7385},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":7385},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":17734},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":17734},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":310},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":17424},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":12163},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":12163},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3784},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null}],"covered":23,"coverable":24},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","parse","mod.rs"],"content":"mod buffer;\nmod cursor;\n\nuse crate::error::*;\nuse crate::Span;\n\npub use buffer::*;\n\npub trait Parse: Sized {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e;\n}\n\npub trait Spanned {\n    fn span(\u0026self) -\u003e Span;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","token","cursor.rs"],"content":"use crate::{\n    error::*,\n    lexer::{Token, TokenKind},\n    Asset, Span,\n};\n\nuse super::Delimiter;\n\n#[derive(Debug)]\npub(super) struct Cursor\u003c'a\u003e {\n    pub(super) ts: \u0026'a [Token],\n    pub(super) idx: usize,\n    pub(super) span_pos: usize,\n\n    pub(super) asset: \u0026'a Asset\u003c'a\u003e,\n}\n\nimpl Cursor\u003c'_\u003e {\n    pub(super) fn extract_subcursor(\u0026mut self, delim: Delimiter) -\u003e Result\u003cCursor\u003c'_\u003e\u003e {\n        let start = self.idx;\n        let start_span = self.span_pos;\n\n        let mut c = 1;\n        while c \u003e 0 \u0026\u0026 self.idx \u003c self.ts.len() {\n            let k = self.ts[self.idx].kind;\n            if k == delim.open() {\n                c += 1;\n            }\n            if k == delim.close() {\n                c -= 1;\n            }\n\n            self.span_pos += self.ts[self.idx].len;\n            self.idx += 1;\n        }\n\n        if c == 0 {\n            Ok(Cursor {\n                ts: \u0026self.ts[start..(self.idx - 1)],\n                idx: 0,\n                span_pos: start_span,\n                asset: self.asset,\n            })\n        } else {\n            Err(Error::new(ErrorKind::MissingDelim, \"missing delim\"))\n        }\n    }\n\n    pub(super) fn end_span(\u0026self) -\u003e Span {\n        assert!(self.is_done());\n        Span::new(self.span_pos, 1)\n    }\n\n    // pub(super) fn rem_stream_span(\u0026self) -\u003e Span {\n    //     Span::new(self.span_pos, self.rem_stream_len())\n    // }\n\n    // pub(super) fn rem_stream_len(\u0026self) -\u003e usize {\n    //     let mut len = 0;\n    //     for token in \u0026self.ts[self.idx..] {\n    //         len += token.len;\n    //     }\n    //     len\n    // }\n}\n\nimpl\u003c'a\u003e Cursor\u003c'a\u003e {\n    pub(super) fn new(ts: \u0026'a [Token], span_pos: usize, asset: \u0026'a Asset\u003c'a\u003e) -\u003e Self {\n        Self {\n            ts,\n            span_pos,\n            idx: 0,\n            asset,\n        }\n    }\n\n    pub(super) fn is_done(\u0026self) -\u003e bool {\n        self.idx == self.ts.len()\n    }\n\n    pub(super) fn next(\u0026mut self) -\u003e Option\u003c(Token, Span)\u003e {\n        if self.idx \u003e= self.ts.len() {\n            None\n        } else {\n            let token = self.ts[self.idx];\n            let span = Span::new(self.span_pos, token.len);\n            self.bump(1);\n            Some((token, span))\n        }\n    }\n\n    pub(super) fn bump(\u0026mut self, n: usize) {\n        for _ in 0..n {\n            self.span_pos += self.ts[self.idx].len;\n            self.idx += 1;\n        }\n    }\n\n    // pub(super) fn bump_back(\u0026mut self, n: usize) {\n    //     for _ in 0..n {\n    //         self.idx -= 1;\n    //         self.span_pos -= self.ts[self.idx].len;\n    //     }\n    // }\n\n    pub(super) fn peek(\u0026self, offset: usize) -\u003e Option\u003cToken\u003e {\n        let idx = self.idx + offset;\n        if idx \u003e= self.ts.len() {\n            None\n        } else {\n            Some(self.ts[idx])\n        }\n    }\n\n    pub(super) fn eat_while(\u0026mut self, f: impl Fn(\u0026Token) -\u003e bool) -\u003e usize {\n        let mut c = 0;\n        while self.idx \u003c self.ts.len() \u0026\u0026 f(\u0026self.ts[self.idx]) {\n            self.bump(1);\n            c += 1;\n        }\n        c\n    }\n\n    pub(super) fn eat_whitespace(\u0026mut self) -\u003e usize {\n        self.eat_while(|t| t.kind == TokenKind::Whitespace)\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":53376},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":26405},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":703},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":28373},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2671},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1968},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1968},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1968},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1968},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1968},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1966},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1966},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1966},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":521},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":17310},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":17310},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":13597},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":13597},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":13597},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":13597},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":13597},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":13597},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":23403},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":46806},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":23403},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":23403},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":703},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":703},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":703},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":703},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":28203},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":28203},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":83321},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":9800},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":9800},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":28203},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":28203},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":91924},"fn_name":null}],"covered":47,"coverable":49},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","token","mod.rs"],"content":"use std::fmt;\n\nuse self::cursor::Cursor;\nuse crate::{\n    error::{Error, ErrorKind},\n    lexer::{self, tokenize, LiteralKind},\n    Asset, Span,\n};\n\npub use stream::DelimSpan;\npub use stream::Spacing;\npub use stream::TokenStream;\npub use stream::TokenTree;\n\nmod cursor;\nmod stream;\nmod symbol;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Token {\n    pub kind: TokenKind,\n    pub span: Span,\n}\n\nimpl Token {\n    pub(super) fn new(kind: TokenKind, span: Span) -\u003e Token {\n        Token { kind, span }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum TokenKind {\n    Lt,\n    Le,\n    Gt,\n    Ge,\n    Eq,\n    EqEq,\n    Dot,\n    DotDot,\n    DotDotDot,\n    DotDotEq,\n    Comma,\n    Minus,\n    Plus,\n    Semi,\n    LDoubleArrow,\n    RDoubleArrow,\n    LSingleArrow,\n    RSingleArrow,\n    LSingleArrowR,\n    Colon,\n    Slash,\n    Keyword(Keyword),\n    OpenDelim(Delimiter),\n    CloseDelim(Delimiter),\n    Literal(Lit),\n    Ident(Ident),\n    Annotation(Annotation),\n}\n\nimpl TokenKind {\n    fn ident_or_keyword(span: Span, cursor: \u0026mut Cursor) -\u003e TokenKind {\n        let ident = Ident::from_span(span, cursor);\n        match \u0026ident.raw[..] {\n            \"module\" =\u003e TokenKind::Keyword(Keyword::Module),\n            \"gates\" =\u003e TokenKind::Keyword(Keyword::Gates),\n            \"submodules\" =\u003e TokenKind::Keyword(Keyword::Submodules),\n            \"connections\" =\u003e TokenKind::Keyword(Keyword::Connections),\n            \"link\" =\u003e TokenKind::Keyword(Keyword::Link),\n            \"include\" =\u003e TokenKind::Keyword(Keyword::Include),\n            \"entry\" =\u003e TokenKind::Keyword(Keyword::Entry),\n            \"dyn\" =\u003e TokenKind::Keyword(Keyword::Dyn),\n            _ =\u003e TokenKind::Ident(ident),\n        }\n    }\n\n    pub fn token_kind_err_output(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Lt =\u003e \"'\u003c'\",\n            Self::Le =\u003e \"'\u003c='\",\n            Self::Gt =\u003e \"'\u003e'\",\n            Self::Ge =\u003e \"'\u003e='\",\n            Self::Eq =\u003e \"'='\",\n            Self::EqEq =\u003e \"'=='\",\n            Self::Dot =\u003e \"'.'\",\n            Self::DotDot =\u003e \"'..'\",\n            Self::DotDotDot =\u003e \"'...'\",\n            Self::DotDotEq =\u003e \"'..='\",\n            Self::Comma =\u003e \"','\",\n            Self::Minus =\u003e \"'-'\",\n            Self::Plus =\u003e \"'+'\",\n            Self::Semi =\u003e \"';'\",\n            Self::LDoubleArrow =\u003e \"'\u003c==''\",\n            Self::RDoubleArrow =\u003e \"'==\u003e'\",\n            Self::LSingleArrow =\u003e \"'\u003c--''\",\n            Self::RSingleArrow =\u003e \"'--\u003e'\",\n            Self::LSingleArrowR =\u003e \"'\u003c--\u003e'\",\n            Self::Colon =\u003e \"':'\",\n            Self::Slash =\u003e \"'/'\",\n            Self::Keyword(keyword) =\u003e keyword.token_kind_err_output(),\n            Self::OpenDelim(_) =\u003e \"\u003copen_delim\u003e\",\n            Self::CloseDelim(_) =\u003e \"\u003cclose_delim\u003e\",\n            Self::Literal(_) =\u003e \"\u003cliteral\u003e\",\n            Self::Ident(_) =\u003e \"\u003cident\u003e\",\n            Self::Annotation(_) =\u003e \"\u003cannotation\u003e\",\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Keyword {\n    Module,\n    Gates,\n    Submodules,\n    Connections,\n    Link,\n    Include,\n    Entry,\n    Dyn,\n}\n\nimpl Keyword {\n    fn token_kind_err_output(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Module =\u003e \"'module'\",\n            Self::Gates =\u003e \"'gates'\",\n            Self::Submodules =\u003e \"'submodules'\",\n            Self::Connections =\u003e \"'connections'\",\n            Self::Link =\u003e \"'link'\",\n            Self::Include =\u003e \"'include'\",\n            Self::Entry =\u003e \"'entry'\",\n            Self::Dyn =\u003e \"'dyn'\",\n        }\n    }\n}\n\nimpl fmt::Display for Keyword {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.token_kind_err_output())\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n\npub enum Delimiter {\n    Parenthesis,\n    Brace,\n    Bracket,\n    Invisible,\n}\n\nimpl Delimiter {\n    fn from(kind: lexer::TokenKind) -\u003e Self {\n        match kind {\n            lexer::TokenKind::OpenParen =\u003e Delimiter::Parenthesis,\n            lexer::TokenKind::OpenBrace =\u003e Delimiter::Brace,\n            lexer::TokenKind::OpenBracket =\u003e Delimiter::Bracket,\n            _ =\u003e unimplemented!(),\n        }\n    }\n\n    fn open(\u0026self) -\u003e lexer::TokenKind {\n        match self {\n            Delimiter::Parenthesis =\u003e lexer::TokenKind::OpenParen,\n            Delimiter::Brace =\u003e lexer::TokenKind::OpenBrace,\n            Delimiter::Bracket =\u003e lexer::TokenKind::OpenBracket,\n            _ =\u003e unimplemented!(),\n        }\n    }\n\n    fn close(\u0026self) -\u003e lexer::TokenKind {\n        match self {\n            Delimiter::Parenthesis =\u003e lexer::TokenKind::CloseParen,\n            Delimiter::Brace =\u003e lexer::TokenKind::CloseBrace,\n            Delimiter::Bracket =\u003e lexer::TokenKind::CloseBracket,\n            _ =\u003e unimplemented!(),\n        }\n    }\n}\n\nimpl fmt::Display for Delimiter {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Self::Parenthesis =\u003e write!(f, \"( ... )\"),\n            Self::Brace =\u003e write!(f, \"{{ ... }}\"),\n            Self::Bracket =\u003e write!(f, \"[ ... ]\"),\n            Self::Invisible =\u003e write!(f, \"...\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum LitKind {\n    Integer { lit: i32 },\n    Float { lit: f64 },\n    Str { lit: String },\n}\n\nimpl LitKind {\n    pub(super) fn typ(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Integer { .. } =\u003e \"integer\",\n            Self::Float { .. } =\u003e \"float\",\n            Self::Str { .. } =\u003e \"string\",\n        }\n    }\n}\n\nimpl fmt::Display for LitKind {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Self::Integer { lit } =\u003e write!(f, \"{}\", lit),\n            Self::Float { lit } =\u003e write!(f, \"{:.1}\", lit),\n            Self::Str { lit } =\u003e write!(f, \"\\\"{}\\\"\", lit),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Lit {\n    pub kind: LitKind,\n    pub span: Span,\n}\n\nimpl Lit {\n    fn from_span(kind: LiteralKind, span: Span, cursor: \u0026Cursor) -\u003e Result\u003cSelf, Error\u003e {\n        let source = cursor.asset.slice_for(span);\n        match kind {\n            LiteralKind::Int { .. } =\u003e Ok(Lit {\n                kind: LitKind::Integer {\n                    lit: source\n                        .parse()\n                        .map_err(|e| Error::new(ErrorKind::ParseLitError, e))?,\n                },\n                span,\n            }),\n            LiteralKind::Float { .. } =\u003e Ok(Lit {\n                kind: LitKind::Float {\n                    lit: source\n                        .parse()\n                        .map_err(|e| Error::new(ErrorKind::ParseLitError, e))?,\n                },\n                span,\n            }),\n            LiteralKind::Str { .. } =\u003e Ok(Lit {\n                kind: LitKind::Str {\n                    lit: source\n                        .trim_start_matches('\"')\n                        .trim_end_matches('\"')\n                        .to_string(),\n                },\n                span,\n            }),\n        }\n    }\n\n    pub fn as_float(\u0026self) -\u003e f64 {\n        match self.kind {\n            LitKind::Float { lit } =\u003e lit,\n            _ =\u003e panic!(\"unexpected cast\"),\n        }\n    }\n\n    pub fn as_integer(\u0026self) -\u003e i32 {\n        match self.kind {\n            LitKind::Integer { lit } =\u003e lit,\n            _ =\u003e panic!(\"unexpected cast\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Ident {\n    pub raw: String,\n    pub span: Span,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Annotation {\n    pub raw: String,\n    pub span: Span,\n}\n\nimpl Ident {\n    fn from_span(span: Span, cursor: \u0026Cursor) -\u003e Self {\n        Self {\n            raw: cursor.asset.slice_for(span).to_string(),\n            span,\n        }\n    }\n}\n\nimpl AsRef\u003cstr\u003e for Ident {\n    fn as_ref(\u0026self) -\u003e \u0026str {\n        self.raw.as_ref()\n    }\n}\n\nimpl PartialEq\u003c\u0026str\u003e for Ident {\n    fn eq(\u0026self, other: \u0026\u0026str) -\u003e bool {\n        \u0026self.raw == other\n    }\n}\n\nimpl Annotation {\n    fn from_span(span: Span, cursor: \u0026Cursor) -\u003e Self {\n        Self {\n            raw: cursor\n                .asset\n                .slice_for(span)\n                .trim_start_matches('@')\n                .to_string(),\n            span,\n        }\n    }\n}\n\nimpl PartialEq\u003c\u0026str\u003e for Annotation {\n    fn eq(\u0026self, other: \u0026\u0026str) -\u003e bool {\n        \u0026self.raw == other\n    }\n}\n\n// # main\n\nimpl TokenStream {\n    pub fn new(asset: Asset) -\u003e Result\u003cTokenStream, Error\u003e {\n        let ts = tokenize(asset.source(), 0).collect::\u003cVec\u003c_\u003e\u003e();\n        let mut cursor = Cursor::new(\u0026ts, asset.source_span().pos, \u0026asset);\n\n        TokenStream::parse(\u0026mut cursor)\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":10889},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":7349},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":5992},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":5790},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":5297},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":5288},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":4933},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":5062},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":4523},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":4389},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1549},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1549},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":111},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":767},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":139},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1701},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":262},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":25038},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":578},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":25038},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":578},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":831},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":831},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":831},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":726},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":138},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":138},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":521},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":521},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":521},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":521},"fn_name":null}],"covered":95,"coverable":125},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","token","stream.rs"],"content":"use super::{Cursor, Delimiter, Token};\nuse crate::{\n    ast::{token::TokenKind, Lit},\n    error::{Error, ErrorKind},\n    lexer::{self, LiteralKind},\n    Span,\n};\nuse std::sync::Arc;\n\n#[derive(Debug, Clone)]\npub struct TokenStream {\n    pub items: Arc\u003cVec\u003cTokenTree\u003e\u003e,\n}\n\n#[derive(Debug, Clone)]\npub enum TokenTree {\n    Token(Token, Spacing),\n    Delimited(DelimSpan, Delimiter, TokenStream),\n}\n\nimpl TokenTree {\n    pub fn span(\u0026self) -\u003e Span {\n        match self {\n            Self::Token(token, _) =\u003e token.span,\n            Self::Delimited(delim, _, _) =\u003e Span::fromto(delim.open, delim.close),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Spacing {\n    Alone,\n    Joint,\n}\n\nimpl Spacing {\n    fn infer(token: lexer::TokenKind, next: lexer::TokenKind) -\u003e Spacing {\n        use lexer::TokenKind::*;\n        match (token, next) {\n            (Eq, Eq) =\u003e Spacing::Joint,\n            (Plus, Eq) | (Minus, Eq) | (Star, Eq) | (Slash, Eq) =\u003e Spacing::Joint,\n            _ =\u003e Spacing::Alone,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct DelimSpan {\n    pub open: Span,\n    pub close: Span,\n}\n\nimpl TokenStream {\n    pub(super) fn parse(cursor: \u0026mut Cursor) -\u003e Result\u003cTokenStream, Error\u003e {\n        let mut items = Vec::new();\n        loop {\n            cursor.eat_whitespace();\n            if cursor.is_done() {\n                return Ok(Self {\n                    items: Arc::new(items),\n                });\n            }\n\n            let Some(tree) = TokenTree::parse(cursor)? else {\n                return Ok(Self {\n                    items: Arc::new(items),\n                });\n            };\n            items.push(tree);\n        }\n    }\n}\n\nimpl TokenTree {\n    pub(super) fn parse(cursor: \u0026mut Cursor) -\u003e Result\u003cOption\u003cTokenTree\u003e, Error\u003e {\n        cursor.eat_whitespace();\n\n        // let span = cursor.rem_stream_span();\n        // println!(\"[TokenTree]\\n{}\", cursor.asset.slice_for(span));\n\n        // will not be a whitespace\n        let Some((mut token, mut span)) = cursor.next() else {\n            unimplemented!()\n        };\n\n        if token.kind.is_delim_open() {\n            let delim = Delimiter::from(token.kind);\n            let open = span;\n\n            let mut sub = cursor.extract_subcursor(delim)?;\n            let ts = TokenStream::parse(\u0026mut sub)?;\n            let close = sub.end_span();\n\n            Ok(TokenTree::Delimited(DelimSpan { open, close }, delim, ts).into())\n        } else {\n            use crate::lexer::TokenKind::*;\n\n            loop {\n                // normal token\n                return match token.kind {\n                    Dot =\u003e {\n                        // Check for second dot\n                        let Some(next) = cursor.peek(0) else {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::Dot, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        };\n\n                        if next.kind != Dot {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::Dot, span),\n                                Spacing::infer(token.kind, next.kind),\n                            )\n                            .into());\n                        }\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        // check for third dot.\n                        let Some(next) = cursor.peek(0) else {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::DotDot, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        };\n\n                        if next.kind == Eq {\n                            let (_, s) = cursor.next().unwrap();\n                            span = Span::fromto(span, s);\n\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::DotDotEq, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        }\n\n                        if next.kind != Dot {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::DotDot, span),\n                                Spacing::infer(token.kind, next.kind),\n                            )\n                            .into());\n                        }\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        Ok(\n                            TokenTree::Token(\n                                Token::new(TokenKind::DotDotDot, span),\n                                Spacing::Alone,\n                            )\n                            .into(),\n                        )\n                    }\n\n                    Colon =\u003e Ok(TokenTree::Token(\n                        Token::new(TokenKind::Colon, span),\n                        Spacing::Alone,\n                    )\n                    .into()),\n                    Slash =\u003e Ok(TokenTree::Token(\n                        Token::new(TokenKind::Slash, span),\n                        Spacing::Alone,\n                    )\n                    .into()),\n                    Semi =\u003e Ok(\n                        TokenTree::Token(Token::new(TokenKind::Semi, span), Spacing::Alone).into(),\n                    ),\n                    Comma =\u003e Ok(TokenTree::Token(\n                        Token::new(TokenKind::Comma, span),\n                        Spacing::Alone,\n                    )\n                    .into()),\n\n                    Plus =\u003e Ok(\n                        TokenTree::Token(Token::new(TokenKind::Plus, span), Spacing::Alone).into(),\n                    ),\n\n                    Eq =\u003e {\n                        if cursor.peek(0).map(|t| t.kind) != Some(Eq) {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::Eq, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        }\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        if cursor.peek(0).map(|t| t.kind) != Some(Gt) {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::EqEq, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        }\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        Ok(TokenTree::Token(\n                            Token::new(TokenKind::RDoubleArrow, span),\n                            Spacing::Alone,\n                        )\n                        .into())\n                    }\n\n                    Minus =\u003e {\n                        if cursor.peek(0).map(|t| t.kind) != Some(Minus) {\n                            if let Some(lexer::Token {\n                                kind: Literal { kind, .. },\n                                len,\n                            }) = cursor.peek(0)\n                            {\n                                if matches!(\n                                    kind,\n                                    LiteralKind::Int { .. } | LiteralKind::Float { .. }\n                                ) {\n                                    span = Span::new(span.pos, span.len + len);\n                                    cursor.bump(1);\n                                    let lit = Lit::from_span(kind, span, cursor)?;\n                                    return Ok(TokenTree::Token(\n                                        Token::new(TokenKind::Literal(lit), span),\n                                        Spacing::Alone,\n                                    )\n                                    .into());\n                                }\n                            }\n\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::Minus, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        }\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        if cursor.peek(0).map(|t| t.kind) != Some(Gt) {\n                            unimplemented!(\"-- without --\u003e\")\n                        }\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        Ok(TokenTree::Token(\n                            Token::new(TokenKind::RSingleArrow, span),\n                            Spacing::Alone,\n                        )\n                        .into())\n                    }\n                    Lt =\u003e match cursor.peek(0).map(|t| t.kind) {\n                        Some(Eq) =\u003e {\n                            let (_, s) = cursor.next().unwrap();\n                            span = Span::fromto(span, s);\n\n                            if cursor.peek(0).map(|t| t.kind) != Some(Eq) {\n                                return Ok(TokenTree::Token(\n                                    Token::new(TokenKind::Le, span),\n                                    Spacing::Alone,\n                                )\n                                .into());\n                            }\n\n                            let (_, s) = cursor.next().unwrap();\n                            span = Span::fromto(span, s);\n\n                            Ok(TokenTree::Token(\n                                Token::new(TokenKind::LDoubleArrow, span),\n                                Spacing::Alone,\n                            )\n                            .into())\n                        }\n                        Some(Minus) =\u003e {\n                            let (_, s) = cursor.next().unwrap();\n                            span = Span::fromto(span, s);\n\n                            if cursor.peek(0).map(|t| t.kind) != Some(Minus) {\n                                unimplemented!(\"\u003c- but not \u003c--\")\n                            }\n\n                            let (_, s) = cursor.next().unwrap();\n                            span = Span::fromto(span, s);\n\n                            if cursor.peek(0).map(|t| t.kind) == Some(Gt) {\n                                let (_, s) = cursor.next().unwrap();\n                                span = Span::fromto(span, s);\n                                Ok(TokenTree::Token(\n                                    Token::new(TokenKind::LSingleArrowR, span),\n                                    Spacing::Alone,\n                                )\n                                .into())\n                            } else {\n                                Ok(TokenTree::Token(\n                                    Token::new(TokenKind::LSingleArrow, span),\n                                    Spacing::Alone,\n                                )\n                                .into())\n                            }\n                        }\n                        _ =\u003e Ok(\n                            TokenTree::Token(Token::new(TokenKind::Lt, span), Spacing::Alone)\n                                .into(),\n                        ),\n                    },\n                    Gt =\u003e {\n                        if cursor.peek(0).map(|t| t.kind) != Some(Eq) {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::Gt, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        };\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        Ok(\n                            TokenTree::Token(Token::new(TokenKind::Ge, span), Spacing::Alone)\n                                .into(),\n                        )\n                    }\n\n                    OpenBrace | OpenBracket | OpenParen =\u003e {\n                        unreachable!(\"\")\n                    }\n                    CloseBrace | CloseBracket | CloseParen =\u003e Err(Error::new(\n                        ErrorKind::MissingDelim,\n                        format!(\"missing opening delimiter for {:?}\", token),\n                    )),\n\n                    Ident =\u003e Ok(TokenTree::Token(\n                        Token::new(TokenKind::ident_or_keyword(span, cursor), span),\n                        Spacing::Alone,\n                    )\n                    .into()),\n                    Annotation =\u003e Ok(TokenTree::Token(\n                        Token::new(\n                            TokenKind::Annotation(super::Annotation::from_span(span, cursor)),\n                            span,\n                        ),\n                        Spacing::Alone,\n                    )\n                    .into()),\n\n                    Literal { kind, .. } =\u003e Ok(TokenTree::Token(\n                        Token::new(\n                            TokenKind::Literal(super::Lit::from_span(kind, span, cursor)?),\n                            span,\n                        ),\n                        Spacing::Alone,\n                    )\n                    .into()),\n\n                    Comment | Whitespace =\u003e {\n                        match cursor.next() {\n                            Some(value) =\u003e (token, span) = value,\n                            None =\u003e {\n                                return Ok(None);\n                            }\n                        }\n                        continue;\n                    }\n\n                    _ =\u003e unimplemented!(\"missing parser for {token:?}\"),\n                };\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{SourceMap, ast::token};\n    use super::*;\n\n    #[test]\n    fn recognize_arrows() {\n        let mut smap = SourceMap::new();\n        let asset = smap.load_raw(\n            \"raw:token:0\",\n            \"module A {{\n            connections {{\n                a \u003c--\u003e b,\n                c \u003c-- Link --\u003e d\n            }}\n        }}\",\n        );\n\n        let ts = TokenStream::new(asset).unwrap();\n        let TokenTree::Delimited(_, _, ref module_stmt) = ts.items[2] else {\n            unreachable!()\n        };\n        let TokenTree::Delimited(_, _, ref module_stmt) = module_stmt.items[0] else {\n            unreachable!()\n        };\n\n        dbg!(module_stmt);\n\n        let TokenTree::Delimited(_, _, ref conn_stmt) = module_stmt.items[1] else {\n            unreachable!()\n        };\n\n        let TokenTree::Delimited(_, _, ref list) = conn_stmt.items[0] else {\n            unreachable!()\n        };\n\n\n        let TokenTree::Token(ref arrow, _) = list.items[1] else {\n            unreachable!()\n        };\n        assert_eq!(arrow.kind, token::TokenKind::LSingleArrowR);\n\n        let TokenTree::Token(ref arrow, _) = list.items[5] else {\n            unreachable!()\n        };\n        assert_eq!(arrow.kind, token::TokenKind::LSingleArrow);\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":990},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":990},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2489},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2489},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":15344},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":15344},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2485},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2485},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":12859},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":12855},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":12859},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":12859},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":25718},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3940},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1968},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1966},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1966},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":11047},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":11047},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1218},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1218},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1218},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1218},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":411},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":411},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1229},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1229},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1229},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1229},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":141},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":228},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":140},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":825},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":825},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":825},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":825},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":825},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":825},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":158},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":158},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":158},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":101,"coverable":195},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","token","symbol.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","validate","blanket.rs"],"content":"use super::*;\nuse crate::ast::{EntryStmt, IncludeStmt};\n\nimpl Validate for IncludeStmt {\n    fn validate(\u0026self, _: \u0026mut ErrorsMut) {}\n}\n\nimpl Validate for EntryStmt {\n    fn validate(\u0026self, _: \u0026mut ErrorsMut) {}\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":252},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","validate","items.rs"],"content":"use super::*;\nuse crate::ast::{File, Item, Spanned};\n\nimpl Validate for File {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        let mut symbols = Vec::with_capacity(self.items.len());\n        for item in self.items.iter() {\n            // (0) Internal validation\n            item.validate(errors);\n\n            // (1) Symbol duplication\n            if let Some(symbol) = item.symbol() {\n                if symbols.contains(\u0026\u0026symbol.raw) {\n                    errors.add(\n                        Error::new(\n                            ErrorKind::SymbolDuplication,\n                            format!(\n                                \"cannot create new symbol '{}', was allready defined\",\n                                symbol.raw\n                            ),\n                        )\n                        .spanned(item.span()),\n                    )\n                } else {\n                    symbols.push(\u0026symbol.raw)\n                }\n            }\n        }\n    }\n}\n\nimpl Validate for Item {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        match self {\n            Self::Entry(entry) =\u003e entry.validate(errors),\n            Self::Include(include) =\u003e include.validate(errors),\n            Self::Link(link) =\u003e link.validate(errors),\n            Self::Module(module) =\u003e module.validate(errors),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::{Parse, ParseBuffer, TokenStream},\n        SourceMap,\n    };\n\n    use super::*;\n\n    #[test]\n    fn symbol_dupliaction() {\n        let mut smap = SourceMap::new();\n\n        let asset = smap.load_raw(\"raw:case0\", \"module A {} module B {} module A {}\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = File::parse(\u0026buf).unwrap();\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n\n        assert_eq!(errors.len(), 1);\n        assert_eq!(errors.get(0).unwrap().kind, ErrorKind::SymbolDuplication);\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":337},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":337},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":1516},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":1179},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":2028},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":842},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1179},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1179},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":669},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","validate","link.rs"],"content":"use super::*;\nuse crate::ast::{LinkData, LinkInheritance, LinkStmt, LitKind, Spanned};\n\nimpl Validate for LinkStmt {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        if let Some(ref inh) = self.inheritance {\n            inh.validate(errors)\n        }\n        self.data.validate(errors);\n    }\n}\n\nimpl Validate for LinkInheritance {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        let mut symbols = Vec::with_capacity(self.symbols.len());\n        for symbol in self.symbols.iter() {\n            if symbols.contains(\u0026\u0026symbol.raw) {\n                errors.add(\n                    Error::new(\n                        ErrorKind::LinkInheritanceDuplicatedSymbols,\n                        format!(\n                            \"found duplicated symbol '{}' in link inheritance statement\",\n                            symbol.raw\n                        ),\n                    )\n                    .spanned(self.span()),\n                );\n                continue;\n            }\n            symbols.push(\u0026symbol.raw);\n        }\n    }\n}\n\nimpl Validate for LinkData {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        for item in self.items.iter() {\n            // Do not make generic to Key\u003cIdent, Lit, _\u003e since known values\n            // are only known in linkdata context\n            match item.key.raw.as_str() {\n                \"jitter\" =\u003e {\n                    if !matches!(item.value.kind, LitKind::Float { .. }) {\n                        errors.add(\n                            Error::new(\n                                ErrorKind::LinkKnownKeysInvalidValue,\n                                \"known key 'jitter' expects a value of type float\",\n                            )\n                            .spanned(item.span()),\n                        );\n                    }\n                }\n                \"latency\" =\u003e {\n                    if !matches!(item.value.kind, LitKind::Float { .. }) {\n                        errors.add(\n                            Error::new(\n                                ErrorKind::LinkKnownKeysInvalidValue,\n                                \"known key 'latency' expects a value of type float \",\n                            )\n                            .spanned(item.span()),\n                        );\n                    }\n                }\n                \"bitrate\" =\u003e {\n                    if !matches!(item.value.kind, LitKind::Integer { .. }) {\n                        errors.add(\n                            Error::new(\n                                ErrorKind::LinkKnownKeysInvalidValue,\n                                \"known key 'bitrate' expects a value of type interger\",\n                            )\n                            .spanned(item.span()),\n                        );\n                    }\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::{Parse, ParseBuffer, TokenStream},\n        SourceMap,\n    };\n\n    use super::*;\n\n    fn load_link(smap: \u0026mut SourceMap, asset: \u0026str, s: \u0026str) -\u003e LinkStmt {\n        let asset = smap.load_raw(asset, s);\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n        LinkStmt::parse(\u0026buf).unwrap()\n    }\n\n    #[test]\n    fn inheritance_dup() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let link = load_link(\u0026mut smap, \"raw:case0\", \"link A: B + C + D + B {}\");\n        let mut errors = Errors::new().as_mut();\n        link.validate(\u0026mut errors);\n\n        assert_eq!(errors.len(), 1);\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::LinkInheritanceDuplicatedSymbols\n        );\n\n        // # Case 1\n        let link = load_link(\u0026mut smap, \"raw:case1\", \"link A: SomeLink + SomeLink {}\");\n        let mut errors = Errors::new().as_mut();\n        link.validate(\u0026mut errors);\n\n        assert_eq!(errors.len(), 1);\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::LinkInheritanceDuplicatedSymbols\n        );\n    }\n\n    #[test]\n    fn known_values_invalid_typ() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let link = load_link(\u0026mut smap, \"raw:case0\", \"link A { jitter: 100 }\");\n        let mut errors = Errors::new().as_mut();\n        link.validate(\u0026mut errors);\n\n        assert_eq!(errors.len(), 1);\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::LinkKnownKeysInvalidValue\n        );\n\n        // # Case 1\n        let link = load_link(\u0026mut smap, \"raw:case1\", \"link A { bitrate: 1.0 }\");\n        let mut errors = Errors::new().as_mut();\n        link.validate(\u0026mut errors);\n\n        assert_eq!(errors.len(), 1);\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::LinkKnownKeysInvalidValue\n        );\n\n        // # Case 1\n        let link = load_link(\n            \u0026mut smap,\n            \"raw:case1\",\n            \"link A { latency: \\\"str\\\", bitrate: 1.0 }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        link.validate(\u0026mut errors);\n\n        assert_eq!(errors.len(), 2);\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::LinkKnownKeysInvalidValue\n        );\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":277},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":212},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":675},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":490},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":490},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":177},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":327},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":147},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":138},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":48},"fn_name":null}],"covered":41,"coverable":41},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","validate","mod.rs"],"content":"use crate::error::*;\n\nmod blanket;\nmod items;\nmod link;\nmod module;\n\npub trait Validate {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","validate","module.rs"],"content":"use super::*;\nuse crate::ast::*;\n\nimpl Validate for ModuleStmt {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        let has_inh = self.inheritance.is_some();\n        let has_dyn = self\n            .submodules\n            .iter()\n            .any(|s| s.items.iter().any(|s| s.typ.is_dyn()));\n        if has_inh \u0026\u0026 has_dyn {\n            errors.add(\n                Error::new(\n                    ErrorKind::ModuleBothInheritanceAndDyn,\n                    \"module is defined with both inheritance and dyn members: not supported\",\n                )\n                .spanned(self.span()),\n            );\n        }\n\n        if let Some(ref inh) = self.inheritance {\n            inh.validate(errors)\n        }\n        self.gates.iter().for_each(|s| s.validate(errors));\n        self.submodules.iter().for_each(|s| s.validate(errors));\n        self.connections.iter().for_each(|s| s.validate(errors));\n    }\n}\n\nimpl Validate for ModuleInheritance {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        let mut symbols = Vec::with_capacity(self.symbols.len());\n        for symbol in self.symbols.iter() {\n            if symbols.contains(\u0026\u0026symbol.raw) {\n                errors.add(\n                    Error::new(\n                        ErrorKind::ModuleInheritanceDuplicatedSymbols,\n                        format!(\n                            \"found duplicated symbol '{}' in module inheritance statement\",\n                            symbol.raw\n                        ),\n                    )\n                    .spanned(self.span()),\n                );\n                continue;\n            }\n            symbols.push(\u0026symbol.raw);\n        }\n    }\n}\n\nimpl Validate for GatesStmt {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        let mut symbols = Vec::with_capacity(self.items.len());\n        for gate_def in self.items.iter() {\n            // (0) Duplication checking\n            if symbols.contains(\u0026\u0026gate_def.ident.raw) {\n                errors.add(\n                    Error::new(\n                        ErrorKind::ModuleGatesDuplicatedSymbols,\n                        format!(\n                            \"gate(-cluster) '{}' was defined multiple times\",\n                            gate_def.ident.raw\n                        ),\n                    )\n                    .spanned(gate_def.span()),\n                );\n            } else {\n                symbols.push(\u0026gate_def.ident.raw);\n            }\n            // (2) Literal checking\n            if let Some(cluster) = gate_def.cluster.as_ref() {\n                if let LitKind::Integer { ref lit } = cluster.lit.kind {\n                    if *lit \u003e 0 {\n                        /* GOOD */\n                    } else {\n                        errors.add(\n                            Error::new(\n                                ErrorKind::ModuleGatesInvalidClusterSize,\n                                format!(\n                                \"cannot create gate-cluster of size '{}', requires positiv integer\",\n                                lit\n                            ),\n                            )\n                            .spanned(cluster.span()),\n                        );\n                    }\n                } else {\n                    errors.add(Error::new(\n                        ErrorKind::InvalidLitTyp,\n                        format!(\n                            \"cannot create gate-cluster with literal of type {}, expected literal of type integer\",\n                            cluster.lit.kind.typ()\n                        ),\n                    ).spanned(cluster.span()))\n                }\n            }\n        }\n    }\n}\n\nimpl Validate for SubmodulesStmt {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        let mut symbols = Vec::with_capacity(self.items.len());\n        for submod_def in self.items.iter() {\n            // (0) Duplication checking\n            if symbols.contains(\u0026\u0026submod_def.ident.raw) {\n                errors.add(\n                    Error::new(\n                        ErrorKind::ModuleSubDuplicatedSymbols,\n                        format!(\n                            \"submodule(-cluster) '{}' was defined multiple times\",\n                            submod_def.ident.raw\n                        ),\n                    )\n                    .spanned(submod_def.span()),\n                );\n            } else {\n                symbols.push(\u0026submod_def.ident.raw);\n            }\n\n            // (2) Literal checking\n            if let Some(cluster) = submod_def.cluster.as_ref() {\n                if let LitKind::Integer { ref lit } = cluster.lit.kind {\n                    if *lit \u003e 0 {\n                        /* GOOD */\n                    } else {\n                        errors.add(Error::new(\n                            ErrorKind::ModuleSubInvalidClusterSize,\n                            format!(\n                                \"cannot create submodule cluster of size '{}', requires positiv integer\",\n                                lit\n                            ),\n                        ).spanned(cluster.span()));\n                    }\n                } else {\n                    errors.add(\n                        Error::new(\n                            ErrorKind::InvalidLitTyp,\n                            format!(\n                                \"invalid literal type {}, expected literal of type integer\",\n                                cluster.lit.kind.typ()\n                            ),\n                        )\n                        .spanned(cluster.span()),\n                    )\n                }\n            }\n        }\n    }\n}\n\nimpl Validate for ConnectionsStmt {\n    fn validate(\u0026self, _errors: \u0026mut ErrorsMut) {}\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::{Parse, ParseBuffer},\n        SourceMap,\n    };\n\n    use super::*;\n\n    fn load_module(smap: \u0026mut SourceMap, asset: \u0026str, raw: \u0026str) -\u003e ModuleStmt {\n        let asset = smap.load_raw(asset, raw);\n        let ts = TokenStream::new(asset).expect(\"Failed to create tokenstream, in validation pass\");\n        let buf = ParseBuffer::new(asset, ts);\n\n        ModuleStmt::parse(\u0026buf).expect(\"Failed to create object, in validation pass\")\n    }\n\n\n    #[test]\n    fn invalid_gates() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0 (baseline)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case0\",\n            \"module A { \n            gates {\n                in,\n                out[5],\n                inout,\n                outin[2],\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert!(errors.is_empty());\n\n        // # Case 1 (duplication)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case1\",\n            \"module A { \n            gates {\n                in,\n                out[5],\n                inout,\n                outin[2],\n                in,\n                out,\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 2);\n\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::ModuleGatesDuplicatedSymbols\n        );\n        assert_eq!(\n            errors.get(1).unwrap().kind,\n            ErrorKind::ModuleGatesDuplicatedSymbols\n        );\n\n        // # Case 2 (annotation)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case2\",\n            \"module A { \n            gates {\n                in,\n                out[5],\n                inout,\n                outin[2]\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 0);\n\n        // # Case 3 (literals)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case3\",\n            \"module A { \n            gates {\n                in,\n                out[1.0],\n                inout,\n                outin[\\\"\\\"]\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 2);\n\n        assert_eq!(errors.get(0).unwrap().kind, ErrorKind::InvalidLitTyp);\n        assert_eq!(errors.get(1).unwrap().kind, ErrorKind::InvalidLitTyp);\n\n        // # Case 3 (cluster-size)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case3\",\n            \"module A { \n            gates {\n                in,\n                out[0],\n                inout,\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 1);\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::ModuleGatesInvalidClusterSize\n        );\n    }\n\n    #[test]\n    fn invalid_submodules() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0 (baseline)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case0\",\n            \"module A { \n            submodules {\n                in: A,\n                out[5]: B,\n                inout: C,\n                outin[2]: D,\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert!(errors.is_empty());\n\n        // # Case 1 (duplication)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case1\",\n            \"module A { \n            submodules {\n                in: In,\n                in: Out,\n                out: Out,\n                out[4]: In\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 2);\n\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::ModuleSubDuplicatedSymbols\n        );\n        assert_eq!(\n            errors.get(1).unwrap().kind,\n            ErrorKind::ModuleSubDuplicatedSymbols\n        );\n\n        // # Case 2 (literals)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case2\",\n            \"module A { \n            submodules {\n                in: In,\n                out[\\\"str\\\"]: Out,\n                pash[0.0]: C\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 2);\n\n        assert_eq!(errors.get(0).unwrap().kind, ErrorKind::InvalidLitTyp);\n        assert_eq!(errors.get(1).unwrap().kind, ErrorKind::InvalidLitTyp);\n\n        // # Case 2 (cluster-size)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case2\",\n            \"module A { \n            submodules {\n                in: In,\n                out[0]: Out,\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 1);\n\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::ModuleSubInvalidClusterSize\n        );\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":678},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":678},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":678},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":678},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":2271},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":804},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":798},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":881},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":274},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":132},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":203},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":203},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":584},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":389},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":373},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":498},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":274},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":274},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":653},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":371},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":427},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":90},"fn_name":null}],"covered":87,"coverable":87},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","bin","ast-expr.rs"],"content":"use des_ndl::ast::*;\nuse des_ndl::*;\n\nconst TEXT: \u0026str = \"\nmodule A {\n    gates {\n        in @input,\n        out @output,\n    }\n\n    submodules {\n        in: In,\n        out[1]: Out,\n    }\n\n    connections {\n        in --\u003e LaLink --\u003e out\n    }\n}\n\";\n\nfn main() {\n    let mut smap = SourceMap::new();\n    let asset = smap.load_raw(\"raw:srctext\", TEXT);\n\n    let ts = TokenStream::new(asset).unwrap();\n    let buf = ParseBuffer::new(asset, ts);\n    let expr = ModuleStmt::parse(\u0026buf).unwrap();\n\n    println!(\"{expr:#?}\");\n    // for entry in expr.iter() {\n    //     println!(\"- {entry:?}\")\n    // }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","bin","ast-tokenstream.rs"],"content":"use des_ndl::{ast::TokenStream, *};\n\nconst TEXT: \u0026str = \"\ninclude str;\ninclude ast as ast;\n\n// Comments\n\nmodule A {\n    gates {\n        in @input\n        out[5] @output\n    }\n    connections {\n        in --\u003e out[1]\n    }\n}\n\";\n\nfn main() {\n    let mut smap = SourceMap::new();\n    let asset = smap.load_raw(\"raw:srctext\", TEXT);\n\n    let ts = TokenStream::new(asset).unwrap();\n    println!(\"{:#?}\", ts)\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","bin","ctx-full.rs"],"content":"use des_ndl::*;\n\nfn main() {\n    let mut ctx = match Context::load(\"des-ndl/src/bin/case-2/main.ndl\") {\n        Ok(ctx) =\u003e ctx,\n        Err(e) =\u003e {\n            println!(\"[{e}]\");\n            return;\n        }\n    };\n    let entry = ctx.entry.take().unwrap();\n    drop(ctx);\n\n    println!(\"################################################################\");\n    println!(\"{:#?}\", entry.connections);\n    drop(entry);\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":4,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","bin","ctx-include.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::*;\n\nfn main() -\u003e RootResult\u003c()\u003e {\n    let ctx = Context::load(\"des-ndl/src/bin/case-0/main.ndl\")?;\n\n    // println!(\"{:#?}\", tbl);\n    // println!(\"{:#?}\", tbl2);\n    println!(\"{:#?}\", ctx.ir);\n    Ok(())\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","bin","ctx-ir.rs"],"content":"use des_ndl::*;\n\nfn main() {\n    let mut ctx = match Context::load(\"des-ndl2/blueprint.ndl\") {\n        Ok(ctx) =\u003e ctx,\n        Err(e) =\u003e {\n            println!(\"[{e}]\");\n            return;\n        }\n    };\n    let entry = ctx.entry.take();\n    drop(ctx);\n\n    println!(\"{:#?}\", entry);\n    drop(entry);\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":4,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","context.rs"],"content":"use std::{\n    collections::HashMap,\n    path::{Path, PathBuf},\n    sync::Arc,\n};\n\nuse crate::{\n    ast::{self, validate::Validate, Parse, ParseBuffer, Spanned, TokenStream},\n    error::*,\n    ir,\n    resource::{fs::canon, AssetIdentifier},\n    util::dfs_cycles,\n    SourceMap, Span,\n};\n\n#[derive(Debug)]\npub struct Context {\n    pub smap: SourceMap,\n\n    pub root: AssetIdentifier,\n    pub assets: Vec\u003cAssetIdentifier\u003e,\n    pub deps: HashMap\u003cAssetIdentifier, Vec\u003cAssetIdentifier\u003e\u003e,\n\n    pub ast: HashMap\u003cAssetIdentifier, ast::File\u003e,\n    pub ir: HashMap\u003cAssetIdentifier, ir::Items\u003e,\n    pub entry: Option\u003cArc\u003cir::Module\u003e\u003e,\n}\n\nimpl Context {\n    pub fn load(path: impl AsRef\u003cPath\u003e) -\u003e RootResult\u003cContext\u003e {\n        let path = path.as_ref().to_path_buf();\n\n        let mut this = Self::load_initial_tree(path)?;\n        let mut errors = Errors::new().as_mut();\n\n        this.ast_validate_assets(\u0026mut errors);\n        if !errors.is_empty() {\n            return Err(RootError::new(errors.into_inner(), this.smap));\n        }\n\n        this.load_deps(\u0026mut errors);\n        if !errors.is_empty() {\n            return Err(RootError::new(errors.into_inner(), this.smap));\n        }\n\n        this.load_ir(\u0026mut errors);\n        if !errors.is_empty() {\n            return Err(RootError::new(errors.into_inner(), this.smap));\n        }\n\n        this.load_entry_and_check_dyn(\u0026mut errors);\n        if !errors.is_empty() {\n            return Err(RootError::new(errors.into_inner(), this.smap));\n        }\n\n        Ok(this)\n    }\n\n    fn load_initial_tree(path: PathBuf) -\u003e RootResult\u003cContext\u003e {\n        let mut smap = SourceMap::new();\n        let ident = AssetIdentifier::Root {\n            path,\n            alias: \"root\".to_string(),\n        };\n\n        let asset = match smap.load_file(ident.clone()).map_err(Error::from_io) {\n            Ok(asset) =\u003e asset,\n            Err(e) =\u003e return Err(RootError::single(e, smap)),\n        };\n        let ts = match TokenStream::new(asset) {\n            Ok(ts) =\u003e ts,\n            Err(e) =\u003e return Err(RootError::single(e, smap)),\n        };\n        let buf = ParseBuffer::new(asset, ts);\n        let file = match ast::File::parse(\u0026buf) {\n            Ok(file) =\u003e file,\n            Err(e) =\u003e return Err(RootError::single(e, smap)),\n        };\n\n        let mut this = Context {\n            smap,\n            root: ident.clone(),\n            assets: vec![ident.clone()],\n            deps: HashMap::new(),\n\n            ast: HashMap::from([(ident, file)]),\n            ir: HashMap::new(),\n            entry: None,\n        };\n        if let Err(e) = this.load_includes() {\n            return Err(RootError::single(e, this.smap));\n        }\n        Ok(this)\n    }\n\n    fn load_includes(\u0026mut self) -\u003e Result\u003c()\u003e {\n        let mut i = 0;\n        while i \u003c self.assets.len() {\n            let asset = self.assets[i].clone();\n            let items = self\n                .ast\n                .get(\u0026asset)\n                .expect(\"Asset was registered, but not ast provided\");\n\n            let mut tasks = Vec::new();\n            for item in \u0026items.items {\n                if let ast::Item::Include(include) = item {\n                    let ipath = include.path.path();\n                    match asset.path() {\n                        Ok(anchor) =\u003e {\n                            assert!(anchor\n                                .extension()\n                                .map(|e| e.to_string_lossy().contains(\"ndl\"))\n                                .unwrap_or(false));\n\n                            let mut anchor = anchor.parent().unwrap().to_path_buf();\n                            for comp in ipath.split('/') {\n                                anchor.push(comp)\n                            }\n                            anchor = canon(anchor);\n                            anchor.set_extension(\"ndl\");\n                            // anchor = anchor.canonicalize().unwrap();\n\n                            if !self\n                                .assets\n                                .iter()\n                                .any(|asset| asset.path().unwrap() == \u0026anchor)\n                            {\n                                tasks.push((anchor, include.span()))\n                            };\n                        }\n                        Err(_) =\u003e todo!(),\n                    }\n                }\n            }\n\n            // drop scope for items\n            for (path, span) in tasks {\n                let alias = self.root.relative_asset_alias(\u0026path);\n\n                let ident = AssetIdentifier::Included {\n                    path,\n                    alias,\n                    include: span,\n                };\n                let asset = self.smap.load_file(ident.clone()).map_err(Error::from_io)?;\n                let ts = TokenStream::new(asset)?;\n                let buf = ParseBuffer::new(asset, ts);\n\n                let file = ast::File::parse(\u0026buf)?;\n                self.assets.push(ident.clone());\n                self.ast.insert(ident, file);\n            }\n\n            i += 1;\n        }\n        Ok(())\n    }\n\n    fn ast_validate_assets(\u0026mut self, errors: \u0026mut ErrorsMut) {\n        for ast in self.ast.values() {\n            ast.validate(errors)\n        }\n    }\n\n    pub(crate) fn asts_for_asset(\n        \u0026self,\n        asset: \u0026AssetIdentifier,\n    ) -\u003e Vec\u003c(\u0026AssetIdentifier, \u0026ast::File)\u003e {\n        let iter = self\n            .deps\n            .get(asset)\n            .unwrap()\n            .iter()\n            .map(|k| (k, self.ast.get(k).unwrap()));\n\n        let asset = self.assets.iter().find(|a| *a == asset).unwrap(); // for lifetimes\n        let init = std::iter::once((asset, self.ast.get(asset).unwrap()));\n\n        Vec::from_iter(init.chain(iter))\n    }\n\n    pub(crate) fn ir_for_asset(\n        \u0026self,\n        asset: \u0026AssetIdentifier,\n        include_self: bool,\n    ) -\u003e Vec\u003c(\u0026AssetIdentifier, \u0026ir::Items)\u003e {\n        let iter = self\n            .deps\n            .get(asset)\n            .unwrap()\n            .iter()\n            .map(|k| (k, self.ir.get(k).unwrap()));\n\n        if include_self {\n            let asset = self.assets.iter().find(|a| *a == asset).unwrap(); // for lifetimes\n            let init = std::iter::once((asset, self.ir.get(asset).unwrap()));\n\n            Vec::from_iter(init.chain(iter))\n        } else {\n            iter.collect()\n        }\n    }\n\n    fn load_deps(\u0026mut self, errors: \u0026mut ErrorsMut) {\n        if !self.deps.is_empty() {\n            return;\n        }\n\n        let mut topo: Vec\u003cVec\u003cusize\u003e\u003e = vec![Vec::new(); self.assets.len()];\n        let mut topo_span: Vec\u003cVec\u003cSpan\u003e\u003e = vec![Vec::new(); self.assets.len()];\n\n        // Build topology from raw edges.\n        for i in 0..self.assets.len() {\n            let ast = self.ast.get(\u0026self.assets[i]).unwrap();\n            for item in ast.items.iter() {\n                if let ast::Item::Include(include) = item {\n                    let ipath = include.path.path();\n                    let mut anchor = self.assets[i]\n                        .path()\n                        .unwrap()\n                        .parent()\n                        .unwrap()\n                        .to_path_buf();\n                    for comp in ipath.split('/') {\n                        anchor.push(comp)\n                    }\n                    anchor = canon(anchor);\n                    anchor.set_extension(\"ndl\");\n\n                    let Some(asset_pos) = self.assets.iter().position(|asset| *asset.path().unwrap() == anchor) else {\n                        unreachable!()\n                    };\n\n                    topo[i].push(asset_pos);\n                    topo_span[i].push(include.span())\n                }\n            }\n        }\n\n        // Check for cycles - throw error if found\n        match dfs_cycles(\u0026topo) {\n            Ok(reachability) =\u003e {\n                // Add fully expanded dep trees\n                for i in 0..self.assets.len() {\n                    let mut deps = Vec::with_capacity(self.assets.len());\n                    for (j, \u0026reachable) in reachability[i].iter().enumerate() {\n                        if reachable \u0026\u0026 i != j {\n                            deps.push(self.assets[j].clone());\n                        }\n                    }\n\n                    self.deps.insert(self.assets[i].clone(), deps);\n                }\n            }\n            Err(cycles) =\u003e {\n                // Append each elementary cycles as its own error\n                for cycle in cycles {\n                    let s = cycle[0];\n\n                    let mut fmt = vec![self.assets[s].alias()];\n                    for \u0026e in cycle.iter().rev() {\n                        fmt.push(self.assets[e].alias());\n                    }\n\n                    // find inital edge for span\n                    let mut span = Span::new(0, 0);\n                    for j in 0..topo[s].len() {\n                        if topo[s][j] == cycle[1] {\n                            span = topo_span[s][j]\n                        }\n                    }\n\n                    errors.add(\n                        Error::new(\n                            ErrorKind::CyclicDeps,\n                            format!(\"found cyclic includes: {}\", fmt.join(\" \u003c- \")),\n                        )\n                        .spanned(span),\n                    )\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":732},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":606},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2688},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":606},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1380},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2040},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1380},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":324},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":510},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1326},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1116},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":660},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":108,"coverable":118},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","error","errors.rs"],"content":"use std::ops::Deref;\n\nuse super::*;\n\n#[derive(Debug)]\npub struct Errors {\n    pub(crate) list: LinkedList\u003cError\u003e,\n}\n\npub struct ErrorsMut {\n    errors: Errors,\n    mappings: Vec\u003cBox\u003cdyn Fn(Error) -\u003e Error\u003e\u003e,\n}\n\nimpl Errors {\n    pub fn len(\u0026self) -\u003e usize {\n        self.list.len()\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    pub fn get(\u0026self, n: usize) -\u003e Option\u003c\u0026Error\u003e {\n        self.list.iter().nth(n)\n    }\n\n    pub fn new() -\u003e Errors {\n        Errors {\n            list: LinkedList::new(),\n        }\n    }\n\n    pub fn as_mut(self) -\u003e ErrorsMut {\n        ErrorsMut {\n            errors: self,\n            mappings: Vec::new(),\n        }\n    }\n}\n\nimpl ErrorsMut {\n    pub fn with_mapping(\n        \u0026mut self,\n        mapping: impl Fn(Error) -\u003e Error + 'static,\n        f: impl FnOnce(\u0026mut ErrorsMut),\n    ) {\n        self.mappings.push(Box::new(mapping));\n        f(self);\n        self.mappings.pop();\n    }\n\n    pub fn add(\u0026mut self, mut error: Error) {\n        for map in self.mappings.iter().rev() {\n            error = map(error);\n        }\n        self.errors.list.push_back(error)\n    }\n\n    pub fn into_inner(self) -\u003e Errors {\n        self.errors\n    }\n}\n\nimpl Default for Errors {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Deref for ErrorsMut {\n    type Target = Errors;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.errors\n    }\n}\n\nimpl Deref for Errors {\n    type Target = LinkedList\u003cError\u003e;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.list\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":2331},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":2331},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":866},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":866},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":370},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":370},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":429},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":429},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":333},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":333},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1134},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1134},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1134},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1134},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":275},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":827},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":275},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2083},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2083},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":54},"fn_name":null}],"covered":24,"coverable":26},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","error","mod.rs"],"content":"use crate::Span;\nuse std::{collections::LinkedList, error, fmt, io};\n\nmod errors;\nmod root;\n\npub use self::errors::*;\npub use self::root::*;\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\n#[derive(Debug)]\npub struct Error {\n    pub kind: ErrorKind,\n    pub internal: Box\u003cdyn error::Error + Send + Sync\u003e,\n    pub span: Option\u003cSpan\u003e,\n    pub hints: Vec\u003cErrorHint\u003e,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(u8)]\npub enum ErrorKind {\n    ParseLitError,\n    MissingDelim,\n    UnexpectedToken,\n    UnexpectedDelim,\n    ExpectedSingleFoundJoint,\n    ExpectedDelimited,\n    ExpectedInModuleKeyword,\n    ExpectedIdentFoundKeyword,\n    MissingToken,\n    UnexpectedEOF,\n    LinkInheritanceDuplicatedSymbols,\n    ModuleInheritanceDuplicatedSymbols,\n    ModuleBothInheritanceAndDyn,\n    LinkKnownKeysInvalidValue,\n    ModuleGatesDuplicatedSymbols,\n    ModuleGatesInvalidClusterSize,\n    ModuleSubDuplicatedSymbols,\n    ModuleSubInvalidClusterSize,\n    InvalidAnnotation,\n    InvalidLitTyp,\n    SymbolDuplication,\n    IoError,\n    CyclicDeps,\n    RootError,\n    SymbolNotFound,\n    LinkMissingRequiredFields,\n    LinkLocalCyclicDeps,\n    InvalidConGateServiceTyp,\n    InvalidConDefSizes,\n    InvalidConClusterIndex,\n    ModuleLocalCyclicDeps,\n    ModuleDynConstraintsBroken,\n    ModuleDynNotResolved,\n    MissingEntryPoint,\n}\n\n#[derive(Debug)]\npub enum ErrorHint {\n    Note(String),\n    Help(String),\n    Solution(ErrorSolution),\n}\n\n#[derive(Debug)]\npub struct ErrorSolution {\n    pub description: String,\n    pub span: Span,\n    pub replacement: String,\n}\n\nimpl Error {\n    pub fn new(kind: ErrorKind, internal: impl Into\u003cBox\u003cdyn error::Error + Send + Sync\u003e\u003e) -\u003e Self {\n        Self {\n            kind,\n            internal: internal.into(),\n            span: None,\n            hints: Vec::new(),\n        }\n    }\n\n    pub fn map(self, f: impl FnOnce(Error) -\u003e Error) -\u003e Error {\n        f(self)\n    }\n\n    pub fn solution(\u0026self) -\u003e Option\u003c\u0026ErrorSolution\u003e {\n        self.hints.iter().find_map(|h| {\n            if let ErrorHint::Solution(s) = h {\n                Some(s)\n            } else {\n                None\n            }\n        })\n    }\n\n    pub fn spanned(mut self, span: Span) -\u003e Self {\n        self.span = Some(span);\n        self\n    }\n\n    pub fn override_internal(\n        mut self,\n        internal: impl Into\u003cBox\u003cdyn error::Error + Send + Sync\u003e\u003e,\n    ) -\u003e Self {\n        self.internal = internal.into();\n        self\n    }\n\n    pub fn add_hints(mut self, hint: impl Into\u003cErrorHint\u003e) -\u003e Self {\n        self.hints.push(hint.into());\n        let mut l = self.hints.len() - 1;\n        for i in 0..self.hints.len() {\n            if i \u003e= l {\n                break;\n            }\n            if let ErrorHint::Solution(_) = self.hints[i] {\n                self.hints.swap(i, l);\n                l -= 1;\n            }\n        }\n        self\n    }\n\n    pub fn from_io(io: io::Error) -\u003e Self {\n        Self {\n            kind: ErrorKind::IoError,\n            internal: Box::new(io),\n            span: None,\n            hints: Vec::new(),\n        }\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{} ({})\", self.internal, self.kind)\n    }\n}\n\nimpl error::Error for Error {}\n\nimpl fmt::Display for ErrorKind {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        \u003cSelf as fmt::Debug\u003e::fmt(self, f)\n    }\n}\n\n// # composite errors\n","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":1620},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1620},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1620},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":666},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":354},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1582},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1582},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1582},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":774},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":492},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":78},"fn_name":null}],"covered":27,"coverable":32},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","error","root.rs"],"content":"use std::{\n    error, fmt,\n    io::{self, Write},\n};\n\nuse termcolor::{Buffer, BufferWriter, Color, ColorChoice, ColorSpec, WriteColor};\n\nuse super::{Error, ErrorHint, Errors};\nuse crate::resource::SourceMap;\n\npub type RootResult\u003cT\u003e = Result\u003cT, RootError\u003e;\n\npub struct RootError {\n    pub errors: Errors,\n    pub smap: SourceMap,\n}\n\nimpl RootError {\n    pub fn new(errors: Errors, smap: SourceMap) -\u003e RootError {\n        Self { errors, smap }\n    }\n\n    pub fn single(error: Error, smap: SourceMap) -\u003e RootError {\n        let mut errors = Errors::new();\n        errors.list.push_back(error);\n        Self { errors, smap }\n    }\n}\n\nimpl Error {\n    fn fmt(\u0026self, smap: \u0026SourceMap, fmt: \u0026mut Buffer) -\u003e fmt::Result {\n        self.fmt_title(fmt).map_err(|_| fmt::Error)?;\n        self.fmt_span(smap, fmt).map_err(|_| fmt::Error)?;\n        self.fmt_hint(smap, fmt).map_err(|_| fmt::Error)?;\n        Ok(())\n    }\n\n    fn fmt_title(\u0026self, fmt: \u0026mut Buffer) -\u003e io::Result\u003c()\u003e {\n        fmt.set_color(ColorSpec::new().set_fg(Some(Color::Red)).set_bold(true))?;\n        write!(fmt, \"error[{}]: \", self.kind as u8)?;\n\n        fmt.reset()?;\n        fmt.set_color(ColorSpec::new().set_bold(true))?;\n        writeln!(fmt, \"{} ({})\", self.internal, self.kind)?;\n\n        Ok(())\n    }\n\n    fn fmt_span(\u0026self, smap: \u0026SourceMap, fmt: \u0026mut Buffer) -\u003e io::Result\u003c()\u003e {\n        let Some(span) = self.span else { return Ok(()) };\n        let asset = smap.asset_for(span).expect(\"Failed to fetch asset\");\n        let line = smap.line_for(span).expect(\"Failed to fetch asset\");\n\n        // File path line\n        fmt.set_color(ColorSpec::new().set_fg(Some(Color::Blue)).set_bold(true))?;\n        write!(fmt, \"   --\u003e \")?;\n\n        fmt.reset()?;\n        writeln!(\n            fmt,\n            \"{}:{}\",\n            asset.ident.path().unwrap().to_str().unwrap(),\n            line\n        )?;\n\n        let (pstr, p) = smap.slice_padded_for(span);\n        // Print padded lines\n        fmt.set_color(ColorSpec::new().set_fg(Some(Color::Blue)).set_bold(true))?;\n        if p == 0 {\n            write!(fmt, \"{:\u003e3} | \", line)?;\n        } else {\n            write!(fmt, \"    | \")?;\n        }\n        fmt.reset()?;\n\n        let mut line_drawn = 1;\n\n        for c in pstr.chars() {\n            write!(fmt, \"{}\", c)?;\n            if c == '\\n' {\n                fmt.set_color(ColorSpec::new().set_fg(Some(Color::Blue)).set_bold(true))?;\n\n                if line_drawn != p {\n                    write!(fmt, \"    | \")?;\n                } else {\n                    write!(fmt, \"{:\u003e3} | \", line)?;\n                }\n                line_drawn += 1;\n                fmt.reset()?;\n            }\n        }\n\n        writeln!(fmt)?;\n\n        Ok(())\n    }\n\n    fn fmt_hint(\u0026self, smap: \u0026SourceMap, fmt: \u0026mut Buffer) -\u003e io::Result\u003c()\u003e {\n        for hint in \u0026self.hints {\n            match hint {\n                ErrorHint::Help(help) =\u003e {\n                    fmt.set_color(ColorSpec::new().set_fg(Some(Color::Blue)).set_bold(true))?;\n                    write!(fmt, \"    = \")?;\n\n                    fmt.reset()?;\n                    fmt.set_color(ColorSpec::new().set_bold(true))?;\n                    write!(fmt, \"help: \")?;\n\n                    fmt.reset()?;\n                    writeln!(fmt, \"{}\", help)?;\n                }\n                ErrorHint::Note(note) =\u003e {\n                    fmt.set_color(ColorSpec::new().set_fg(Some(Color::Blue)).set_bold(true))?;\n                    write!(fmt, \"    = \")?;\n\n                    fmt.reset()?;\n                    fmt.set_color(ColorSpec::new().set_bold(true))?;\n                    write!(fmt, \"note: \")?;\n\n                    fmt.reset()?;\n                    writeln!(fmt, \"{}\", note)?;\n                }\n                ErrorHint::Solution(solution) =\u003e {\n                    let sasset = smap.asset_for(solution.span).unwrap();\n                    let sline = sasset.line_for(solution.span.pos);\n\n                    fmt.set_color(ColorSpec::new().set_fg(Some(Color::Blue)).set_bold(true))?;\n                    writeln!(fmt, \"    = {}\", solution.description)?;\n                    writeln!(\n                        fmt,\n                        \"       in {}:{}\",\n                        sasset.ident.path().unwrap().to_str().unwrap(),\n                        sline\n                    )?;\n\n                    fmt.reset()?;\n                }\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl error::Error for RootError {}\nimpl fmt::Display for RootError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let stream = BufferWriter::stderr(ColorChoice::Always);\n        let mut buffer = stream.buffer();\n        for error in \u0026*self.errors {\n            error.fmt(\u0026self.smap, \u0026mut buffer)?;\n        }\n        write!(f, \"{}\", String::from_utf8_lossy(buffer.as_slice()))\n    }\n}\nimpl fmt::Debug for RootError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        \u003cSelf as fmt::Display\u003e::fmt(self, f)\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":4956},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":4956},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4956},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":330},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":132},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":77,"coverable":80},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ir","link.rs"],"content":"use crate::ast::{self, LinkStmt, Spanned};\nuse std::{collections::HashMap, fmt, sync::Arc};\n\nuse super::*;\n\n#[derive(Clone, PartialEq)]\npub struct Link {\n    pub ast: Arc\u003cLinkStmt\u003e,\n\n    pub ident: RawSymbol,\n    pub fields: HashMap\u003cString, Literal\u003e,\n\n    // common\n    pub jitter: f64,\n    pub latency: f64,\n    pub bitrate: i32,\n\n    pub(crate) dirty: bool,\n}\n\nimpl fmt::Debug for Link {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"Link\")\n            .field(\"ast\", \u0026self.ast.span())\n            .field(\"ident\", \u0026self.ident)\n            .field(\"fields\", \u0026self.fields)\n            .field(\"jitter\", \u0026self.jitter)\n            .field(\"latency\", \u0026self.latency)\n            .field(\"bitrate\", \u0026self.bitrate)\n            .field(\"dirty\", \u0026self.dirty)\n            .finish()\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Literal {\n    Float(f64),\n    Integer(i32),\n    String(String),\n}\n\nimpl Literal {\n    pub fn as_float_casted(\u0026self) -\u003e f64 {\n        match self {\n            Self::Float(f) =\u003e *f,\n            Self::Integer(i) =\u003e *i as f64,\n            Self::String(s) =\u003e s.parse().expect(\"Force casted as float\"),\n        }\n    }\n\n    pub fn as_integer_casted(\u0026self) -\u003e i32 {\n        match self {\n            Self::Integer(i) =\u003e *i,\n            Self::Float(f) =\u003e *f as i32,\n            Self::String(s) =\u003e s.parse().expect(\"Force casted as integer\"),\n        }\n    }\n}\n\nimpl From\u003cast::Lit\u003e for Literal {\n    fn from(value: ast::Lit) -\u003e Self {\n        match value.kind {\n            ast::LitKind::Float { lit } =\u003e Literal::Float(lit),\n            ast::LitKind::Integer { lit } =\u003e Literal::Integer(lit),\n            ast::LitKind::Str { lit } =\u003e Literal::String(lit),\n        }\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":24},"fn_name":null}],"covered":7,"coverable":24},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ir","mod.rs"],"content":"use std::sync::Arc;\n\nmod link;\nmod module;\nmod refs;\nmod symbol;\n\npub use self::link::*;\npub use self::module::*;\npub use self::refs::*;\npub use self::symbol::*;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Items {\n    pub items: Vec\u003cItem\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Item {\n    Link(Arc\u003cLink\u003e),\n    Module(Arc\u003cModule\u003e),\n}\n\nimpl Items {\n    pub fn link(\u0026self, ident: impl AsRef\u003cstr\u003e) -\u003e Option\u003cArc\u003cLink\u003e\u003e {\n        let ident = ident.as_ref();\n        self.items.iter().find_map(|v| {\n            if let Item::Link(l) = v {\n                if l.ident.raw == ident {\n                    Some(l.clone())\n                } else {\n                    None\n                }\n            } else {\n                None\n            }\n        })\n    }\n\n    pub fn module(\u0026self, ident: impl AsRef\u003cstr\u003e) -\u003e Option\u003cArc\u003cModule\u003e\u003e {\n        let ident = ident.as_ref();\n        self.items.iter().find_map(|v| {\n            if let Item::Module(l) = v {\n                if l.ident.raw == ident {\n                    Some(l.clone())\n                } else {\n                    None\n                }\n            } else {\n                None\n            }\n        })\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":16},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ir","module.rs"],"content":"use std::{\n    fmt::{self, Debug, Display},\n    sync::Arc,\n};\n\nuse super::*;\nuse crate::{\n    ast::{ClusterDefinition, ModuleStmt},\n    ir::GateRef,\n    Span,\n};\n\n#[derive(Clone, PartialEq)]\npub struct Module {\n    pub ast: Arc\u003cModuleStmt\u003e,\n\n    pub ident: RawSymbol,\n    pub inherited: Vec\u003cSymbol\u003e,\n    pub gates: Vec\u003cGate\u003e,\n    pub submodules: Vec\u003cSubmodule\u003e,\n    pub connections: Vec\u003cConnection\u003e,\n\n    pub(crate) dirty: bool,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Gate {\n    pub ident: RawSymbol,\n    pub cluster: Cluster,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Submodule {\n    pub span: Span,\n    pub ident: RawSymbol,\n    pub typ: Symbol,\n    pub cluster: Cluster,\n    pub dynamic: bool,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Cluster {\n    Standalone,\n    Clusted(usize),\n}\n#[derive(Debug, Clone, PartialEq)]\npub struct Connection {\n    pub lhs: ConnectionEndpoint,\n    pub rhs: ConnectionEndpoint,\n    pub delay: Option\u003cSymbol\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum ConnectionEndpoint {\n    Local(RawSymbol, Cluster),\n    Nonlocal(RawSymbol, Cluster, (RawSymbol, Cluster)),\n}\n\n// # Impl\n\nimpl Module {\n    pub fn all_modules(this: Arc\u003cModule\u003e) -\u003e Vec\u003cArc\u003cModule\u003e\u003e {\n        let mut result = Vec::new();\n        Self::_all_modules(this, \u0026mut result);\n        result\n    }\n\n    fn _all_modules(this: Arc\u003cModule\u003e, result: \u0026mut Vec\u003cArc\u003cModule\u003e\u003e) {\n        if !result.iter().any(|r| Arc::ptr_eq(r, \u0026this)) {\n            result.push(this.clone());\n            for submod in \u0026this.submodules {\n                let Some(sub) = submod.typ.as_module_arc() else {\n                    continue;\n                };\n                Self::_all_modules(sub, result);\n            }\n        }\n    }\n}\n\n// impl ConnectionEndpoint {\n//     pub fn new(endp: \u0026ModuleGateReference, gate: \u0026GateRef) -\u003e Self {\n//         match endp {\n//             ModuleGateReference::Local(local) =\u003e ConnectionEndpoint::Local(\n//                 RawSymbol {\n//                     raw: local.gate.raw.clone(),\n//                 },\n//                 Cluster::new(gate),\n//             ),\n//             ModuleGateReference::Nonlocal(nonlocal) =\u003e ConnectionEndpoint::Nonlocal(\n//                 RawSymbol {\n//                     raw: nonlocal.submodule.raw.clone(),\n//                 },\n//                 Cluster::new(gate),\n//                 (\n//                     RawSymbol {\n//                         raw: nonlocal.gate.gate.raw.clone(),\n//                     },\n//                     Cluster::new(gate),\n//                 ),\n//             ),\n//         }\n//     }\n// }\n\nimpl Cluster {\n    pub fn new(gate: \u0026GateRef) -\u003e Self {\n        match gate.pos {\n            Some(pos) =\u003e Self::Clusted(pos),\n            None =\u003e Self::Standalone,\n        }\n    }\n\n    pub fn contains(\u0026self, other: \u0026Self) -\u003e bool {\n        match self {\n            Self::Standalone =\u003e matches!(other, Self::Standalone),\n            Self::Clusted(cs) =\u003e match other {\n                Self::Standalone =\u003e true,\n                Self::Clusted(i) =\u003e i \u003c cs,\n            },\n        }\n    }\n\n    pub fn as_size(\u0026self) -\u003e usize {\n        match self {\n            Self::Standalone =\u003e 1,\n            Self::Clusted(n) =\u003e *n,\n        }\n    }\n\n    pub fn as_index(\u0026self) -\u003e usize {\n        match self {\n            Self::Standalone =\u003e 0,\n            Self::Clusted(n) =\u003e *n,\n        }\n    }\n}\n\nimpl From\u003cGateRef\u003c'_\u003e\u003e for ConnectionEndpoint {\n    fn from(value: GateRef\u003c'_\u003e) -\u003e Self {\n        let gc = Cluster::new(\u0026value);\n        match value.submod {\n            Some((pos, submod, cl)) =\u003e ConnectionEndpoint::Nonlocal(\n                RawSymbol { raw: submod },\n                if pos == 0 \u0026\u0026 cl == Cluster::Standalone {\n                    Cluster::Standalone\n                } else {\n                    Cluster::Clusted(pos)\n                },\n                (value.def.ident.clone(), gc),\n            ),\n            None =\u003e ConnectionEndpoint::Local(value.def.ident.clone(), gc),\n        }\n    }\n}\n\nimpl From\u003c\u0026ClusterDefinition\u003e for Cluster {\n    fn from(value: \u0026ClusterDefinition) -\u003e Self {\n        Cluster::Clusted(value.lit.as_integer() as usize)\n    }\n}\n\nimpl From\u003c\u0026Option\u003cClusterDefinition\u003e\u003e for Cluster {\n    fn from(value: \u0026Option\u003cClusterDefinition\u003e) -\u003e Self {\n        value\n            .as_ref()\n            .map(Cluster::from)\n            .unwrap_or(Cluster::Standalone)\n    }\n}\n\n\nimpl Display for Cluster {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Self::Standalone =\u003e Ok(()),\n            Self::Clusted(c) =\u003e write!(f, \"[{c}]\"),\n        }\n    }\n}\n\nimpl Debug for Module {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"Module\")\n            .field(\"ident\", \u0026self.ident)\n            .field(\n                \"inherited\",\n                \u0026self.inherited.iter().map(|v| v.raw()).collect::\u003cVec\u003c_\u003e\u003e(),\n            )\n            .field(\"gates\", \u0026self.gates)\n            .field(\"submodules\", \u0026self.submodules)\n            .field(\"connections\", \u0026self.connections)\n            .field(\"dirty\", \u0026self.dirty)\n            .finish()\n    }\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":780},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":204},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":24},"fn_name":null}],"covered":39,"coverable":55},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ir","refs.rs"],"content":"use super::*;\n\n#[derive(Debug)]\npub struct GateRef\u003c'a\u003e {\n    pub submod: Option\u003c(usize, String, Cluster)\u003e,\n    pub def: \u0026'a Gate,\n    pub pos: Option\u003cusize\u003e,\n}\n\n#[derive(Debug)]\npub struct SubmoduleRef\u003c'a\u003e {\n    pub def: \u0026'a Submodule,\n    pub pos: usize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ir","symbol.rs"],"content":"use std::sync::Arc;\n\nuse super::*;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct RawSymbol {\n    pub raw: String,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Symbol {\n    Module(Arc\u003cModule\u003e),\n    Link(Arc\u003cLink\u003e),\n    Unresolved(RawSymbol),\n}\n\n// # Impl\n\nimpl RawSymbol {\n    pub fn could_be_submodule(\u0026self, ident: impl AsRef\u003cstr\u003e, cluster: \u0026Cluster) -\u003e bool {\n        self.raw == format!(\"{}{}\", ident.as_ref(), cluster)\n    }\n}\n\nimpl Symbol {\n    pub fn as_link(\u0026self) -\u003e Option\u003c\u0026Link\u003e {\n        match self {\n            Self::Link(l) =\u003e Some(\u0026**l),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn as_module(\u0026self) -\u003e Option\u003c\u0026Module\u003e {\n        match self {\n            Self::Module(m) =\u003e Some(\u0026**m),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn as_link_arc(\u0026self) -\u003e Option\u003cArc\u003cLink\u003e\u003e {\n        match self {\n            Self::Link(l) =\u003e Some(l.clone()),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn as_module_arc(\u0026self) -\u003e Option\u003cArc\u003cModule\u003e\u003e {\n        match self {\n            Self::Module(m) =\u003e Some(m.clone()),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn raw(\u0026self) -\u003e \u0026RawSymbol {\n        match self {\n            Self::Link(l) =\u003e \u0026l.ident,\n            Self::Module(m) =\u003e \u0026m.ident,\n            Self::Unresolved(i) =\u003e i,\n        }\n    }\n}\n\nimpl From\u003cArc\u003cModule\u003e\u003e for Symbol {\n    fn from(module: Arc\u003cModule\u003e) -\u003e Self {\n        Symbol::Module(module)\n    }\n}\n\nimpl From\u003cArc\u003cLink\u003e\u003e for Symbol {\n    fn from(link: Arc\u003cLink\u003e) -\u003e Self {\n        Symbol::Link(link)\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":750},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":750},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":726},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":324},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":324},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":324},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":390},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":390},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":60},"fn_name":null}],"covered":17,"coverable":27},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","lexer","cursor.rs"],"content":"use std::str::Chars;\n\n/// Peekable iterator over a char sequence.\n///\n/// Next characters can be peeked via `first` method,\n/// and position can be shifted forward via `bump` method.\npub struct Cursor\u003c'a\u003e {\n    /// Iterator over chars. Slightly faster than a \u0026str.\n    chars: Chars\u003c'a\u003e,\n    initial_len: usize,\n\n    pub idx: usize,\n\n    #[cfg(debug_assertions)]\n    prev: char,\n}\n\n/// The end of file character.\npub const EOF_CHAR: char = '\\0';\n\nimpl\u003c'a\u003e Cursor\u003c'a\u003e {\n    pub fn new(input: \u0026'a str, start_idx: usize) -\u003e Cursor\u003c'a\u003e {\n        Cursor {\n            initial_len: input.len(),\n            chars: input.chars(),\n\n            idx: start_idx,\n\n            #[cfg(debug_assertions)]\n            prev: EOF_CHAR,\n        }\n    }\n\n    /// Returns the last eaten symbol (or `'\\0'` in release builds).\n    /// (For debug assertions only.)\n    pub fn prev(\u0026self) -\u003e char {\n        #[cfg(debug_assertions)]\n        {\n            self.prev\n        }\n\n        #[cfg(not(debug_assertions))]\n        {\n            EOF_CHAR\n        }\n    }\n\n    /// Peeks the next symbol from the input stream without consuming it.\n    /// If requested position doesn't exist, `EOF_CHAR` is returned.\n    /// However, getting `EOF_CHAR` doesn't always mean actual end of file,\n    /// it should be checked with `is_eof` method.\n    pub fn first(\u0026self) -\u003e char {\n        // `.next()` optimizes better than `.nth(0)`\n        self.chars.clone().next().unwrap_or(EOF_CHAR)\n    }\n\n    /// Peeks the second symbol from the input stream without consuming it.\n    pub fn second(\u0026self) -\u003e char {\n        // `.next()` optimizes better than `.nth(1)`\n        let mut iter = self.chars.clone();\n        iter.next();\n        iter.next().unwrap_or(EOF_CHAR)\n    }\n\n    /// Checks if there is nothing more to consume.\n    pub fn is_eof(\u0026self) -\u003e bool {\n        self.chars.as_str().is_empty()\n    }\n\n    /// Returns amount of already consumed symbols.\n    pub fn len_consumed(\u0026self) -\u003e usize {\n        self.initial_len - self.chars.as_str().len()\n    }\n\n    /// Resets the number of bytes consumed to 0.\n    pub fn reset_len_consumed(\u0026mut self) {\n        self.initial_len = self.chars.as_str().len();\n    }\n\n    /// Moves to the next character.\n    pub fn bump(\u0026mut self) -\u003e Option\u003cchar\u003e {\n        let c = self.chars.next()?;\n\n        #[cfg(debug_assertions)]\n        {\n            self.prev = c;\n        }\n\n        Some(c)\n    }\n\n    /// Eats symbols while predicate returns true or until the end of file is reached.\n    pub fn eat_while(\u0026mut self, mut predicate: impl FnMut(char) -\u003e bool) {\n        // It was tried making optimized version of this for eg. line comments, but\n        // LLVM can inline all of this and compile it down to fast iteration over bytes.\n        while predicate(self.first()) \u0026\u0026 !self.is_eof() {\n            let _ = self.chars.next();\n        }\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":538},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":538},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":538},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":18175},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":18175},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":18175},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":66760},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":66760},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":732},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":732},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":732},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":732},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":64362},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":64362},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":51690},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":51690},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":25424},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":25424},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":27092},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":54184},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":16528},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":131728},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":38400},"fn_name":null}],"covered":23,"coverable":25},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","lexer","mod.rs"],"content":"use self::LiteralKind::*;\nuse self::TokenKind::*;\nuse cursor::Cursor;\n\nmod cursor;\n\n#[cfg(test)]\nmod tests;\n\n/// Creates an iterator that produces tokens from the input string.\npub fn tokenize(input: \u0026str, start_idx: usize) -\u003e impl Iterator\u003cItem = Token\u003e + '_ {\n    let mut cursor = Cursor::new(input, start_idx);\n    std::iter::from_fn(move || {\n        if cursor.is_eof() {\n            None\n        } else {\n            cursor.reset_len_consumed();\n            Some(cursor.advance_token())\n        }\n    })\n}\n\n///\n/// A raw syntactical element in of the given source asset.\n/// Note that the [Loc] always references the [SourceMap] buffer\n/// not the relative position in the current asset.\n///\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct Token {\n    /// The type of token encountered.\n    pub kind: TokenKind,\n    /// The location of the token in the source asset.\n    pub len: usize,\n}\n\nimpl Token {\n    ///\n    /// Creates a new token from the given raw parameters.\n    ///\n    pub fn new(kind: TokenKind, len: usize) -\u003e Self {\n        Self { kind, len }\n    }\n}\n\n///\n/// The tokens type.\n///\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum TokenKind {\n    // A single line comment\n    Comment,\n    /// Any whitespace characters sequence.\n    Whitespace,\n    /// Any token that can be either type, var name or keyqord\n    Ident,\n    /// Any token that is a ident, prefixed by an @.\n    Annotation,\n    /// A invalid identifer.\n    InvalidIdent,\n    /// A nonterminated token prefix.\n    UnknownPrefix,\n    /// A literal value.\n    Literal {\n        kind: LiteralKind,\n        suffix_start: usize,\n    },\n\n    /// \";\"\n    Semi,\n    /// \",\"\n    Comma,\n    /// \".\"\n    Dot,\n    /// \"(\"\n    OpenParen,\n    /// \")\"\n    CloseParen,\n    /// \"{\"\n    OpenBrace,\n    /// \"}\"\n    CloseBrace,\n    /// \"[\"\n    OpenBracket,\n    /// \"]\"\n    CloseBracket,\n    /// \"@\"\n    At,\n    /// \"#\"\n    Pound,\n    /// \"~\"\n    Tilde,\n    /// \"?\"\n    Question,\n    /// \":\"\n    Colon,\n    /// \"$\"\n    Dollar,\n    /// \"=\"\n    Eq,\n    /// \"!\"\n    Bang,\n    /// \"\u003c\"\n    Lt,\n    /// \"\u003e\"\n    Gt,\n    /// \"-\"\n    Minus,\n    /// \"\u0026\"\n    And,\n    /// \"|\"\n    Or,\n    /// \"+\"\n    Plus,\n    /// \"*\"\n    Star,\n    /// \"/\"\n    Slash,\n    /// \"^\"\n    Caret,\n    /// \"%\"\n    Percent,\n\n    /// Unknown token, not expected by the lexer, e.g. \"\"\n    Unknown,\n}\n\nimpl TokenKind {\n    pub(super) fn is_delim_open(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            TokenKind::OpenParen | TokenKind::OpenBrace | TokenKind::OpenBracket\n        )\n    }\n}\n\n///\n/// A literal value definition token.\n///\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum LiteralKind {\n    Int { base: Base, empty_int: bool },\n    Float { base: Base, empty_exp: bool },\n    Str { terminated: bool },\n}\n\n///\n/// The numeric bases numbers can be wirtten in.\n///\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum Base {\n    Binary,\n    Octal,\n    Hexadecimal,\n    Decimal,\n}\n\n// impl Base {\n//     pub(crate) fn radix(\u0026self) -\u003e u32 {\n//         match self {\n//             Base::Binary =\u003e 2,\n//             Base::Octal =\u003e 8,\n//             Base::Decimal =\u003e 10,\n//             \u0026Base::Hexadecimal =\u003e 16,\n//         }\n//     }\n// }\n\n/// True if `c` is considered a whitespace.\npub fn is_whitespace(c: char) -\u003e bool {\n    matches!(\n        c,\n        // Usual ASCII suspects\n        '\\u{0009}'   // \\t\n        | '\\u{000A}' // \\n\n        | '\\u{000B}' // vertical tab\n        | '\\u{000C}' // form feed\n        | '\\u{000D}' // \\r\n        | '\\u{0020}' // space\n\n        // NEXT LINE from latin1\n        | '\\u{0085}'\n\n        // Bidi markers\n        | '\\u{200E}' // LEFT-TO-RIGHT MARK\n        | '\\u{200F}' // RIGHT-TO-LEFT MARK\n\n        // Dedicated whitespace characters from Unicode\n        | '\\u{2028}' // LINE SEPARATOR\n        | '\\u{2029}' // PARAGRAPH SEPARATOR\n    )\n}\n\n/// True if `c` is valid as a first character of an identifier.\npub fn is_id_start(c: char) -\u003e bool {\n    // This is XID_Start OR '_' (which formally is not a XID_Start).\n    c == '_' || unicode_xid::UnicodeXID::is_xid_start(c)\n}\n\n/// True if `c` is valid as a non-first character of an identifier.\npub fn is_id_continue(c: char) -\u003e bool {\n    unicode_xid::UnicodeXID::is_xid_continue(c)\n}\n\n// /// The passed string is lexically an identifier.\n// pub fn is_ident(string: \u0026str) -\u003e bool {\n//     let mut chars = string.chars();\n//     if let Some(start) = chars.next() {\n//         is_id_start(start) \u0026\u0026 chars.all(is_id_continue)\n//     } else {\n//         false\n//     }\n// }\n\nimpl Cursor\u003c'_\u003e {\n    /// Parses a token from the input string.\n    fn advance_token(\u0026mut self) -\u003e Token {\n        let first_char = self.bump().unwrap();\n        let token_kind = match first_char {\n            // Slash, comment or block comment.\n            '/' =\u003e match self.first() {\n                '/' =\u003e self.line_comment(),\n                _ =\u003e Slash,\n            },\n\n            c if is_id_start(c) =\u003e self.ident_or_unknown_prefix(),\n\n            // Whitespace sequence.\n            c if is_whitespace(c) \u0026\u0026 c == '\\n' =\u003e self.whitespace(),\n            c if is_whitespace(c) =\u003e self.whitespace(),\n\n            // Numeric literal.\n            c @ '0'..='9' =\u003e {\n                let literal_kind = self.number(c);\n                let suffix_start = self.len_consumed();\n                self.eat_literal_suffix();\n                TokenKind::Literal {\n                    kind: literal_kind,\n                    suffix_start,\n                }\n            }\n            '@' =\u003e {\n                if is_id_start(self.first()) {\n                    let _ = self.bump();\n                    let token = self.ident_or_unknown_prefix();\n                    assert_eq!(token, TokenKind::Ident);\n                    TokenKind::Annotation\n                } else {\n                    At\n                }\n            }\n\n            // One-symbol tokens.\n            ';' =\u003e Semi,\n            ',' =\u003e Comma,\n            '.' =\u003e Dot,\n            '(' =\u003e OpenParen,\n            ')' =\u003e CloseParen,\n            '{' =\u003e OpenBrace,\n            '}' =\u003e CloseBrace,\n            '[' =\u003e OpenBracket,\n            ']' =\u003e CloseBracket,\n\n            '#' =\u003e Pound,\n            '~' =\u003e Tilde,\n            '?' =\u003e Question,\n            ':' =\u003e Colon,\n            '$' =\u003e Dollar,\n            '=' =\u003e Eq,\n            '!' =\u003e Bang,\n            '\u003c' =\u003e Lt,\n            '\u003e' =\u003e Gt,\n            '-' =\u003e Minus,\n            '\u0026' =\u003e And,\n            '|' =\u003e Or,\n            '+' =\u003e Plus,\n            '*' =\u003e Star,\n            '^' =\u003e Caret,\n            '%' =\u003e Percent,\n\n            // String literal.\n            '\"' =\u003e {\n                let terminated = self.double_quoted_string();\n                // let suffix_start = self.pos_within_token();\n                if terminated {\n                    self.eat_literal_suffix();\n                }\n                let kind = Str { terminated };\n                Literal {\n                    kind,\n                    suffix_start: self.len_consumed() - 1,\n                }\n            }\n\n            _ =\u003e Unknown,\n        };\n        self.idx += self.len_consumed();\n\n        Token::new(token_kind, self.len_consumed())\n    }\n\n    /// Eats double-quoted string and returns true\n    /// if string is terminated.\n    fn double_quoted_string(\u0026mut self) -\u003e bool {\n        debug_assert!(self.prev() == '\"');\n        while let Some(c) = self.bump() {\n            match c {\n                '\"' =\u003e {\n                    return true;\n                }\n                '\\\\' if self.first() == '\\\\' || self.first() == '\"' =\u003e {\n                    // Bump again to skip escaped character.\n                    self.bump();\n                }\n                _ =\u003e (),\n            }\n        }\n        // End of file reached.\n        false\n    }\n\n    fn line_comment(\u0026mut self) -\u003e TokenKind {\n        debug_assert!(self.prev() == '/' \u0026\u0026 self.first() == '/');\n        self.bump();\n\n        self.eat_while(|c| c != '\\n');\n        Comment\n    }\n\n    fn whitespace(\u0026mut self) -\u003e TokenKind {\n        debug_assert!(is_whitespace(self.prev()));\n        self.eat_while(is_whitespace);\n        Whitespace\n    }\n\n    fn ident_or_unknown_prefix(\u0026mut self) -\u003e TokenKind {\n        debug_assert!(is_id_start(self.prev()));\n        // Start is already eaten, eat the rest of identifier.\n        self.eat_while(is_id_continue);\n        // Known prefixes must have been handled earlier. So if\n        // we see a prefix here, it is definitely an unknown prefix.\n        match self.first() {\n            '#' | '\"' | '\\'' =\u003e UnknownPrefix,\n            c if !c.is_ascii() \u0026\u0026 unic_emoji_char::is_emoji(c) =\u003e {\n                self.fake_ident_or_unknown_prefix()\n            }\n            _ =\u003e Ident,\n        }\n    }\n\n    fn fake_ident_or_unknown_prefix(\u0026mut self) -\u003e TokenKind {\n        // Start is already eaten, eat the rest of identifier.\n        self.eat_while(|c| {\n            unicode_xid::UnicodeXID::is_xid_continue(c)\n                || (!c.is_ascii() \u0026\u0026 unic_emoji_char::is_emoji(c))\n                || c == '\\u{200d}'\n        });\n        // Known prefixes must have been handled earlier. So if\n        // we see a prefix here, it is definitely an unknown prefix.\n        match self.first() {\n            '#' | '\"' | '\\'' =\u003e UnknownPrefix,\n            _ =\u003e InvalidIdent,\n        }\n    }\n\n    fn number(\u0026mut self, first_digit: char) -\u003e LiteralKind {\n        debug_assert!('0' \u003c= self.prev() \u0026\u0026 self.prev() \u003c= '9');\n        let mut base = Base::Decimal;\n        if first_digit == '0' {\n            // Attempt to parse encoding base.\n            let has_digits = match self.first() {\n                'b' =\u003e {\n                    base = Base::Binary;\n                    self.bump();\n                    self.eat_decimal_digits()\n                }\n                'o' =\u003e {\n                    base = Base::Octal;\n                    self.bump();\n                    self.eat_decimal_digits()\n                }\n                'x' =\u003e {\n                    base = Base::Hexadecimal;\n                    self.bump();\n                    self.eat_hexadecimal_digits()\n                }\n                // Not a base prefix.\n                '0'..='9' | '_' | '.' | 'e' | 'E' =\u003e {\n                    self.eat_decimal_digits();\n                    true\n                }\n                // Just a 0.\n                _ =\u003e {\n                    return Int {\n                        base,\n                        empty_int: false,\n                    }\n                }\n            };\n            // Base prefix was provided, but there were no digits\n            // after it, e.g. \"0x\".\n            if !has_digits {\n                return Int {\n                    base,\n                    empty_int: true,\n                };\n            }\n        } else {\n            // No base prefix, parse number in the usual way.\n            self.eat_decimal_digits();\n        };\n\n        match self.first() {\n            // Don't be greedy if this is actually an\n            // integer literal followed by field/method access or a range pattern\n            // (`0..2` and `12.foo()`)\n            '.' if self.second() != '.' \u0026\u0026 !is_id_start(self.second()) =\u003e {\n                // might have stuff after the ., and if it does, it needs to start\n                // with a number\n                self.bump();\n                let mut empty_exp = false;\n                if self.first().is_ascii_digit() {\n                    self.eat_decimal_digits();\n                    match self.first() {\n                        'e' | 'E' =\u003e {\n                            self.bump();\n                            empty_exp = !self.eat_float_exponent();\n                        }\n                        _ =\u003e (),\n                    }\n                }\n                Float { base, empty_exp }\n            }\n            'e' | 'E' =\u003e {\n                self.bump();\n                let empty_exp = !self.eat_float_exponent();\n                Float { base, empty_exp }\n            }\n            _ =\u003e Int {\n                base,\n                empty_int: false,\n            },\n        }\n    }\n\n    fn eat_decimal_digits(\u0026mut self) -\u003e bool {\n        let mut has_digits = false;\n        loop {\n            match self.first() {\n                '_' =\u003e {\n                    self.bump();\n                }\n                '0'..='9' =\u003e {\n                    has_digits = true;\n                    self.bump();\n                }\n                _ =\u003e break,\n            }\n        }\n        has_digits\n    }\n\n    fn eat_hexadecimal_digits(\u0026mut self) -\u003e bool {\n        let mut has_digits = false;\n        loop {\n            match self.first() {\n                '_' =\u003e {\n                    self.bump();\n                }\n                '0'..='9' | 'a'..='f' | 'A'..='F' =\u003e {\n                    has_digits = true;\n                    self.bump();\n                }\n                _ =\u003e break,\n            }\n        }\n        has_digits\n    }\n\n    fn eat_float_exponent(\u0026mut self) -\u003e bool {\n        debug_assert!(self.prev() == 'e' || self.prev() == 'E');\n        if self.first() == '-' || self.first() == '+' {\n            self.bump();\n        }\n        self.eat_decimal_digits()\n    }\n\n    fn eat_literal_suffix(\u0026mut self) {\n        self.eat_identifier();\n    }\n    fn eat_identifier(\u0026mut self) {\n        if !is_id_start(self.first()) {\n            return;\n        }\n        self.bump();\n\n        self.eat_while(is_id_continue);\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":538},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":538},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":26500},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":25962},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":538},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":25424},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":25424},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":25441},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":12859},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":10889},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":12859},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":69068},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":27086},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":69068},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":32814},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":65604},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":27583},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":27583},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":25424},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":25424},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":39354},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":382},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":302},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":38150},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":37494},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":24594},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":7564},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":412},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":1230},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1701},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1701},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":263},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":261},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1218},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":176},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":484},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":665},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":9890},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":19780},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":9890},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":9890},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":6558},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":13116},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":6558},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":6558},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":6558},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":6558},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":2415},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":741},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":406},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":747},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":1098},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":1112},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":1112},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":2079},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":2079},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":2153},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":967},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":967},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":1112},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":1112},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":842},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":842},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":842},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":842},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":842},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":129,"coverable":172},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","lexer","tests.rs"],"content":"use crate::lexer::{Base, LiteralKind, Token, TokenKind};\n\nuse super::tokenize;\n\n#[test]\nfn token_examples() {\n    const EX_1: \u0026'static str = \"ident./@ \\t\\nA[]\";\n    let stream = tokenize(EX_1, 0).collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(\n        stream,\n        vec![\n            Token::new(TokenKind::Ident, 5),\n            Token::new(TokenKind::Dot, 1),\n            Token::new(TokenKind::Slash, 1),\n            Token::new(TokenKind::At, 1),\n            Token::new(TokenKind::Whitespace, 3),\n            Token::new(TokenKind::Ident, 1),\n            Token::new(TokenKind::OpenBracket, 1),\n            Token::new(TokenKind::CloseBracket, 1),\n        ]\n    );\n\n    const EX_2: \u0026'static str = \"123, ;#\\n// A \\t\\nident\";\n    let stream = tokenize(EX_2, 0).collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(\n        stream,\n        vec![\n            Token::new(\n                TokenKind::Literal {\n                    kind: LiteralKind::Int {\n                        base: Base::Decimal,\n                        empty_int: false\n                    },\n                    suffix_start: 3,\n                },\n                3\n            ),\n            Token::new(TokenKind::Comma, 1),\n            Token::new(TokenKind::Whitespace, 1),\n            Token::new(TokenKind::Semi, 1),\n            Token::new(TokenKind::Pound, 1),\n            Token::new(TokenKind::Whitespace, 1),\n            Token::new(TokenKind::Comment, 6),\n            Token::new(TokenKind::Whitespace, 1),\n            Token::new(TokenKind::Ident, 5),\n        ]\n    );\n}\n\n#[test]\nfn token_lex_literal() {\n    let token = tokenize(\"1234\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Int {\n                    base: Base::Decimal,\n                    empty_int: false\n                },\n                suffix_start: 4\n            },\n            len: 4,\n        }\n    );\n\n    let token = tokenize(\"0xa1234\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Int {\n                    base: Base::Hexadecimal,\n                    empty_int: false\n                },\n                suffix_start: 7\n            },\n            len: 7,\n        }\n    );\n\n    let token = tokenize(\"0b101010\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Int {\n                    base: Base::Binary,\n                    empty_int: false\n                },\n                suffix_start: 8\n            },\n            len: 8,\n        }\n    );\n\n    let token = tokenize(\"0x\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Int {\n                    base: Base::Hexadecimal,\n                    empty_int: true\n                },\n                suffix_start: 2\n            },\n            len: 2,\n        }\n    );\n\n    let token = tokenize(\"0.0\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Float {\n                    base: Base::Decimal,\n                    empty_exp: false\n                },\n                suffix_start: 3\n            },\n            len: 3,\n        }\n    );\n\n    let token = tokenize(\"1231231230.01231231236\", 0)\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Float {\n                    base: Base::Decimal,\n                    empty_exp: false\n                },\n                suffix_start: 22\n            },\n            len: 22,\n        }\n    );\n\n    let token = tokenize(\"0b0.0\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Float {\n                    base: Base::Binary,\n                    empty_exp: false\n                },\n                suffix_start: 5\n            },\n            len: 5,\n        }\n    );\n}\n\n#[test]\nfn token_lex_literal_str() {\n    let token = tokenize(\"\\\"ba@#123c\\\"\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Str { terminated: true },\n                suffix_start: 9\n            },\n            len: 10,\n        }\n    );\n}\n\n#[test]\nfn token_lex_ident() {\n    let token = tokenize(\"abc\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Ident,\n            len: 3,\n        }\n    );\n\n    let token = tokenize(\"abc1\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Ident,\n            len: 4,\n        }\n    );\n\n    let token = tokenize(\"_abc1\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Ident,\n            len: 5,\n        }\n    );\n}\n\n#[test]\nfn token_lex_annotation() {\n    let token = tokenize(\"@abc\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Annotation,\n            len: 4,\n        }\n    );\n\n    let token = tokenize(\"@abc1\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Annotation,\n            len: 5,\n        }\n    );\n\n    let token = tokenize(\"@_abc\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Annotation,\n            len: 5,\n        }\n    );\n\n    let token = tokenize(\"@ abc\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::At,\n            len: 1,\n        }\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","lib.rs"],"content":"#![allow(clippy::needless_range_loop)]\n\npub mod ast;\npub mod error;\npub mod ir;\n\npub(crate) mod context;\npub(crate) mod lexer;\npub(crate) mod resolve;\npub(crate) mod resource;\n\npub(crate) mod util;\n\npub use self::resource::Asset;\npub use self::resource::AssetIdentifier;\npub use self::resource::SourceMap;\npub use self::resource::Span;\n\npub use self::context::Context;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","ast_tables.rs"],"content":"use std::sync::Arc;\n\nuse crate::{\n    ast::{self, Item, LinkStmt, ModuleStmt, Spanned},\n    error::*,\n    resource::AssetIdentifier,\n    util::dfs_cycles,\n    Context, SourceMap, Span,\n};\n\n// # Links\n\n#[derive(Debug, Clone, PartialEq)]\npub struct LinkAstTable {\n    source: AssetIdentifier,\n    links: Vec\u003cArc\u003cLinkStmt\u003e\u003e,\n    ptr: usize,\n}\n\nimpl LinkAstTable {\n    /// Orders local deps in loadable order, returning true on success,\n    /// false on error. Errors are attached to the ErrorsMut object.\n    pub fn order_local_deps(\u0026mut self, errors: \u0026mut ErrorsMut) -\u003e bool {\n        let (local, nonlocal) = self.local_mut();\n        let mut s = 0;\n\n        // Generate topo;\n        let mut topo = vec![Vec::new(); local.len()];\n        for i in 0..local.len() {\n            let Some(ref inh) = local[i].inheritance else {\n                continue;\n            };\n\n            for dep in inh.symbols.iter() {\n                let ldep = local\n                    .iter()\n                    .position(|l| l.ident.raw == dep.raw);\n                if let Some(ldep) = ldep {\n                    topo[i].push(ldep);\n                } else {\n                    // ignore nonloca dep\n                }\n            }\n        }\n\n        if let Err(cycles) = dfs_cycles(\u0026topo) {\n            for cycle in cycles {\n                let s = cycle[0];\n\n                let mut fmt = vec![\u0026local[s].ident.raw[..]];\n                for \u0026e in cycle.iter().rev() {\n                    fmt.push(\u0026local[e].ident.raw[..]);\n                }\n\n                errors.add(\n                    Error::new(\n                        ErrorKind::LinkLocalCyclicDeps,\n                        format!(\n                            \"found cyclic definition of local links: {}\",\n                            fmt.join(\" \u003c- \")\n                        ),\n                    )\n                    .spanned(local[s].span()),\n                );\n            }\n\n            return false;\n        }\n\n        while s \u003c local.len() {\n            // let mut loadable = false;\n            let mut i = s;\n\n            'seacher: while i \u003c local.len() {\n                // check if i depents are in ..s\n                if let Some(ref inh) = local[i].inheritance {\n                    'inner: for dep in inh.symbols.iter() {\n                        let valid = local[..s].iter().any(|l| l.ident.raw == dep.raw);\n                        if !valid {\n                            let valid_nonlocal = nonlocal.iter().any(|l| l.ident.raw == dep.raw);\n                            if valid_nonlocal {\n                                continue 'inner;\n                            }\n\n                            i += 1;\n                            continue 'seacher;\n                        }\n                    }\n                    // all deps are valid\n                    // loadable = true;\n                    break;\n                } else {\n                    // loadable = true;\n                    break;\n                }\n            }\n\n            // not all deps may be loadable, since nonlocal deps are not repr\n            if s != i \u0026\u0026 i \u003c local.len() {\n                local.swap(s, i);\n            }\n\n            s += 1;\n        }\n\n        true\n    }\n\n    pub fn local(\u0026self) -\u003e \u0026[Arc\u003cLinkStmt\u003e] {\n        \u0026self.links[..self.ptr]\n    }\n\n    pub fn local_mut(\u0026mut self) -\u003e (\u0026mut [Arc\u003cLinkStmt\u003e], \u0026mut [Arc\u003cLinkStmt\u003e]) {\n        self.links.split_at_mut(self.ptr)\n    }\n\n    pub fn from_ctx(ctx: \u0026Context, asset: \u0026AssetIdentifier, errors: \u0026mut ErrorsMut) -\u003e Self {\n        let mut links = Vec::new();\n\n        let asts = ctx.asts_for_asset(asset);\n        let ptr = asts[0]\n            .1\n            .items\n            .iter()\n            .filter(|i| matches!(i, Item::Link(_)))\n            .count();\n\n        for (_, ast) in asts {\n            for item in \u0026ast.items {\n                if let Item::Link(link) = item {\n                    links.push(link.clone())\n                }\n            }\n        }\n\n        Self::check_dup(\u0026links, errors);\n\n        Self {\n            source: asset.clone(),\n            links,\n            ptr,\n        }\n    }\n\n    fn check_dup(links: \u0026[Arc\u003cLinkStmt\u003e], errors: \u0026mut ErrorsMut) {\n        if links.len() \u003c= 1 {\n            return;\n        }\n        for s in 0..(links.len() - 1) {\n            let mut dups = Vec::new();\n            for i in (s + 1)..links.len() {\n                if links[s].ident.raw == links[i].ident.raw {\n                    dups.push(i)\n                }\n            }\n\n            if !dups.is_empty() {\n                let mut e = Error::new(\n                    ErrorKind::SymbolDuplication,\n                    format!(\n                        \"found duplicated symbol '{}', with {} duplications\",\n                        links[s].ident.raw,\n                        dups.len()\n                    ),\n                )\n                .spanned(links[s].span());\n                for i in dups {\n                    e = e.add_hints(ErrorHint::Note(format!(\n                        \"duplicated symbol definition found at {:?}\",\n                        links[i].span()\n                    )));\n                }\n\n                errors.add(e)\n            }\n        }\n    }\n}\n\n// # Modules\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ModuleAstTable {\n    source: AssetIdentifier,\n    modules: Vec\u003cArc\u003cModuleStmt\u003e\u003e,\n    ptr: usize,\n}\n\nimpl ModuleAstTable {\n    pub fn order_local_deps(\u0026mut self, errors: \u0026mut ErrorsMut) -\u003e bool {\n        let (local, _) = self.local_mut();\n\n        // Generate topo\n        let mut topo = vec![Vec::new(); local.len()];\n        for i in 0..local.len() {\n            // 1) submodules links\n            let submodules = \u0026local[i].submodules;\n            for dep in submodules.iter().flat_map(|s| s.items.iter()) {\n                let ldep = local\n                    .iter()\n                    .position(|l| l.ident.raw == dep.typ.raw());\n                if let Some(ldep) = ldep {\n                    topo[i].push(ldep);\n                }\n            }\n\n            // 2) inheritance links\n            let Some(inh) = \u0026local[i].inheritance else { continue };\n            for dep in inh.symbols.iter() {\n                let ldep = local\n                    .iter()\n                    .position(|l| l.ident.raw == dep.raw);\n                if let Some(ldep) = ldep {\n                    topo[i].push(ldep)\n                }\n            }\n        }\n\n        if let Err(cycles) = dfs_cycles(\u0026topo) {\n            for cycle in cycles {\n                let s = cycle[0];\n\n                let mut fmt = vec![\u0026local[s].ident.raw[..]];\n                for \u0026e in cycle.iter().rev() {\n                    fmt.push(\u0026local[e].ident.raw[..]);\n                }\n\n                errors.add(\n                    Error::new(\n                        ErrorKind::ModuleLocalCyclicDeps,\n                        format!(\n                            \"found cyclic definition of local modules: {}\",\n                            fmt.join(\" \u003c- \")\n                        ),\n                    )\n                    .spanned(local[s].span()),\n                );\n            }\n            return false;\n        }\n\n        let mut topo_remapping = (0..topo.len()).collect::\u003cVec\u003c_\u003e\u003e();\n\n        let mut s = 0;\n        while s \u003c local.len() {\n            let mut i = s;\n            while i \u003c local.len() {\n                // Check whether i can be loaded with local[..s]\n                // use local topo\n                let edges = \u0026topo[i];\n                let local_valid = edges.iter().all(|\u0026e| topo_remapping[e] \u003c s);\n                if !local_valid {\n                    i += 1;\n                    continue;\n                }\n\n                break;\n            }\n\n            if s != i \u0026\u0026 i \u003c local.len() {\n                local.swap(s, i);\n                topo.swap(s, i);\n                topo_remapping.swap(s, i);\n            }\n            s += 1;\n        }\n\n        true\n    }\n\n    pub fn local(\u0026self) -\u003e \u0026[Arc\u003cModuleStmt\u003e] {\n        \u0026self.modules[..self.ptr]\n    }\n\n    pub fn local_mut(\u0026mut self) -\u003e (\u0026mut [Arc\u003cModuleStmt\u003e], \u0026mut [Arc\u003cModuleStmt\u003e]) {\n        self.modules.split_at_mut(self.ptr)\n    }\n\n    pub fn from_ctx(ctx: \u0026Context, asset: \u0026AssetIdentifier, errors: \u0026mut ErrorsMut) -\u003e Self {\n        let mut modules = Vec::new();\n\n        let asts = ctx.asts_for_asset(asset);\n        let ptr = asts[0]\n            .1\n            .items\n            .iter()\n            .filter(|i| matches!(i, Item::Module(_)))\n            .count();\n\n        // println!(\"{asts:#?}\");\n\n        for (_, ast) in asts {\n            for item in \u0026ast.items {\n                if let Item::Module(module) = item {\n                    modules.push(module.clone())\n                }\n            }\n        }\n\n        Self::check_dup(\u0026modules, errors);\n\n        Self {\n            source: asset.clone(),\n            modules,\n            ptr,\n        }\n    }\n\n    fn check_dup(modules: \u0026[Arc\u003cModuleStmt\u003e], errors: \u0026mut ErrorsMut) {\n        if modules.len() \u003c= 1 {\n            return;\n        }\n        for s in 0..(modules.len() - 1) {\n            let mut dups = Vec::new();\n            for i in (s + 1)..modules.len() {\n                if modules[s].ident.raw == modules[i].ident.raw {\n                    dups.push(i)\n                }\n            }\n\n            if !dups.is_empty() {\n                let mut e = Error::new(\n                    ErrorKind::SymbolDuplication,\n                    format!(\n                        \"Found duplicated symbol '{}', {} duplications\",\n                        modules[s].ident.raw,\n                        dups.len()\n                    ),\n                )\n                .spanned(modules[s].span());\n                for i in dups {\n                    e = e.add_hints(ErrorHint::Note(format!(\n                        \"duplicated symbol definition found at {:?}\",\n                        modules[i].span()\n                    )));\n                }\n\n                errors.add(e)\n            }\n        }\n    }\n}\n\npub struct GlobalAstTable\u003c'a\u003e {\n    this: AssetIdentifier,\n    smap: \u0026'a SourceMap,\n    modules: Vec\u003cArc\u003cModuleStmt\u003e\u003e,\n    links: Vec\u003cArc\u003cLinkStmt\u003e\u003e,\n}\n\nimpl\u003c'a\u003e GlobalAstTable\u003c'a\u003e {\n    pub fn new(ctx: \u0026'a Context, this: \u0026AssetIdentifier) -\u003e GlobalAstTable\u003c'a\u003e {\n        let mut modules = Vec::new();\n        let mut links = Vec::new();\n\n        for file in ctx.ast.values() {\n            for item in \u0026file.items {\n                match item {\n                    ast::Item::Module(module) =\u003e modules.push(module.clone()),\n                    ast::Item::Link(link) =\u003e links.push(link.clone()),\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        GlobalAstTable {\n            this: this.clone(),\n            smap: \u0026ctx.smap,\n            modules,\n            links,\n        }\n    }\n\n    pub fn err_resolve_symbol(\u0026self, symbol: \u0026str, expect_module: bool, mut error: Error) -\u003e Error {\n        for module in \u0026self.modules {\n            if module.ident.raw == symbol {\n                let target_asset = self.smap.asset_for(module.span()).unwrap();\n                let target = target_asset.ident.path().unwrap().to_str().unwrap();\n\n                if expect_module {\n                    error.hints.push(ErrorHint::Help(format!(\n                        \"similar symbol '{symbol}' was found, but not included ({target})\"\n                    )));\n\n                    let this = self.smap.asset(\u0026self.this).unwrap();\n                    let span = Span::new(this.offset, 0);\n                    if let Some(include) = this.include_for(target_asset) {\n                        let replacement = format!(\"include {};\", include);\n\n                        error.hints.push(ErrorHint::Solution(ErrorSolution {\n                            description: format!(\"try including '{symbol}' from '{include}'\"),\n                            span,\n                            replacement,\n                        }));\n                    }\n                } else {\n                    error.hints.push(ErrorHint::Note(format!(\n                        \"similar symbol '{symbol}' was found, but it is a module ({target})\"\n                    )));\n                }\n            }\n        }\n\n        for link in \u0026self.links {\n            if link.ident.raw == symbol {\n                let target_asset = self.smap.asset_for(link.span()).unwrap();\n                let target = target_asset.ident.path().unwrap().to_str().unwrap();\n\n                if !expect_module {\n                    error.hints.push(ErrorHint::Help(format!(\n                        \"similar symbol '{symbol}' was found, but not included\"\n                    )));\n\n                    let this = self.smap.asset(\u0026self.this).unwrap();\n                    let span = Span::new(this.offset, 0);\n\n                    if let Some(include) = this.include_for(target_asset) {\n                        let replacement = format!(\"include {};\", include);\n                        error.hints.push(ErrorHint::Solution(ErrorSolution {\n                            description: format!(\"try including '{symbol}' from '{include}'\"),\n                            span,\n                            replacement,\n                        }));\n                    }\n                } else {\n                    error.hints.push(ErrorHint::Note(format!(\n                        \"similar symbol '{symbol}' was found, but it is a link ({target})\"\n                    )));\n                }\n            }\n        }\n\n        error\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":408},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":228},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":204},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":132},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":2496},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":888},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2400},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":186},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":846},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":582},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1746},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":330},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1278},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":630},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1164},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":210},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":726},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":498},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":498},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":840},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":510},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":2496},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":888},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":2400},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":618},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":618},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":378},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":378},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1176},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":798},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":378},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":1320},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":5832},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1356},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":384},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":780},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":54},"fn_name":null}],"covered":182,"coverable":203},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","ir_tables.rs"],"content":"use std::sync::Arc;\n\nuse crate::{\n    context::Context,\n    error::*,\n    ir::{Item, Link, Module},\n    resource::AssetIdentifier,\n};\n\n#[derive(Debug)]\npub struct LinkIrTable {\n    links: Vec\u003cArc\u003cLink\u003e\u003e,\n}\n\nimpl LinkIrTable {\n    pub fn get(\u0026self, key: impl AsRef\u003cstr\u003e) -\u003e Option\u003cArc\u003cLink\u003e\u003e {\n        let key = key.as_ref();\n        self.links.iter().find(|v| v.ident.raw == key).cloned()\n    }\n\n    pub fn add(\u0026mut self, local: Arc\u003cLink\u003e) {\n        self.links.push(local)\n    }\n\n    pub fn from_ctx(\n        ctx: \u0026Context,\n        asset: \u0026AssetIdentifier,\n        _errors: \u0026mut ErrorsMut,\n        include_self: bool,\n    ) -\u003e Self {\n        let mut links = Vec::new();\n\n        for (_, ir) in ctx.ir_for_asset(asset, include_self) {\n            for item in ir.items.iter() {\n                if let Item::Link(link) = item {\n                    links.push(link.clone())\n                }\n            }\n        }\n\n        // no dup checking nessecary since done in ast stage\n\n        Self { links }\n    }\n}\n\n#[derive(Debug)]\npub struct ModuleIrTable {\n    modules: Vec\u003cArc\u003cModule\u003e\u003e,\n}\n\nimpl ModuleIrTable {\n    pub fn get(\u0026self, key: impl AsRef\u003cstr\u003e) -\u003e Option\u003cArc\u003cModule\u003e\u003e {\n        let key = key.as_ref();\n        self.modules.iter().find(|v| v.ident.raw == key).cloned()\n    }\n\n    pub fn add(\u0026mut self, local: Arc\u003cModule\u003e) {\n        self.modules.push(local)\n    }\n\n    pub fn from_ctx(\n        ctx: \u0026Context,\n        asset: \u0026AssetIdentifier,\n        _errors: \u0026mut ErrorsMut,\n        include_self: bool,\n    ) -\u003e Self {\n        let mut modules = Vec::new();\n\n        for (_, ir) in ctx.ir_for_asset(asset, include_self) {\n            for item in ir.items.iter() {\n                if let Item::Module(module) = item {\n                    modules.push(module.clone())\n                }\n            }\n        }\n\n        // no dup checking nessecary since done in ast stage\n\n        Self { modules }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":312},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":492},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":492},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1866},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":540},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":546},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":672},"fn_name":null}],"covered":20,"coverable":20},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","link.rs"],"content":"use std::{collections::HashMap, sync::Arc};\n\nuse crate::{\n    ast::{LinkStmt, Spanned},\n    error::*,\n    ir::{Link, RawSymbol},\n    resolve::LinkIrTable,\n};\n\nuse super::GlobalAstTable;\n\nimpl Link {\n    pub fn from_ast(\n        link: Arc\u003cLinkStmt\u003e,\n        ir_links: \u0026LinkIrTable,\n        globals: \u0026GlobalAstTable,\n        errors: \u0026mut ErrorsMut,\n    ) -\u003e Link {\n        let errlen = errors.len();\n        // We can assume\n        // - no dup, valid fields (if existent)\n        let mut ir = Link {\n            ident: RawSymbol {\n                raw: link.ident.raw.clone(),\n            },\n\n            fields: HashMap::new(),\n            jitter: f64::NEG_INFINITY,\n            latency: f64::NEG_INFINITY,\n            bitrate: i32::MIN,\n\n            ast: link.clone(),\n\n            dirty: false,\n        };\n\n        // Apply inheritence in order\n        if let Some(ref inh) = link.inheritance {\n            for symbol in inh.symbols.iter() {\n                // Resolve ident\n                // All values in scope are allread in IR table\n                // - local elements are non-nessecary in scope, but in order\n                let Some(dep) = ir_links.get(symbol) else {\n                    errors.add(Error::new(\n                        ErrorKind::SymbolNotFound,\n                        format!(\"did not find link symbol '{}', not in scope\", symbol.raw)\n                    ).spanned(inh.span()).map(|e| globals.err_resolve_symbol(\u0026symbol.raw, false, e)));\n                    continue;\n                };\n                ir.apply(\u0026dep);\n            }\n        }\n\n        for field in link.data.items.iter() {\n            match field.key.raw.as_str() {\n                \"jitter\" =\u003e ir.jitter = field.value.as_float(),\n                \"latency\" =\u003e ir.latency = field.value.as_float(),\n                \"bitrate\" =\u003e ir.bitrate = field.value.as_integer(),\n                other =\u003e {\n                    let _ = ir\n                        .fields\n                        .insert(other.to_string(), field.value.clone().into());\n                }\n            }\n        }\n\n        if ir.jitter == f64::NEG_INFINITY {\n            errors.add(\n                Error::new(\n                    ErrorKind::LinkMissingRequiredFields,\n                    \"missing required field 'jitter', was not defined locally or in prototypes\",\n                )\n                .spanned(ir.ast.span()),\n            );\n        }\n        if ir.latency == f64::NEG_INFINITY {\n            errors.add(\n                Error::new(\n                    ErrorKind::LinkMissingRequiredFields,\n                    \"missing required field 'latency', was not defined locally or in prototypes\",\n                )\n                .spanned(ir.ast.span()),\n            );\n        }\n        if ir.bitrate == i32::MIN {\n            errors.add(\n                Error::new(\n                    ErrorKind::LinkMissingRequiredFields,\n                    \"missing required field 'bitrate', was not defined locally or in prototypes\",\n                )\n                .spanned(ir.ast.span()),\n            );\n        }\n\n        if errlen \u003c errors.len() {\n            ir.dirty = true;\n        }\n\n        ir\n    }\n\n    fn apply(\u0026mut self, other: \u0026Link) {\n        self.jitter = other.jitter;\n        self.latency = other.latency;\n        self.bitrate = other.bitrate;\n        for (k, v) in other.fields.iter() {\n            let _ = self.fields.insert(k.clone(), v.clone());\n        }\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":390},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":378},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":186},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":138},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":12},"fn_name":null}],"covered":44,"coverable":49},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","local_tables.rs"],"content":"use super::IterIter;\nuse crate::{\n    ast::{LocalModuleGateReference, ModuleGateReference, NonlocalModuleGateReference, Spanned},\n    error::*,\n    ir::*,\n};\nuse std::iter;\n\npub struct LocalGatesTable\u003c'a\u003e {\n    gates: \u0026'a [Gate],\n}\n\nimpl\u003c'a\u003e LocalGatesTable\u003c'a\u003e {\n    pub fn new(gates: \u0026'a [Gate]) -\u003e Self {\n        Self { gates }\n    }\n\n    pub fn resolve(\n        \u0026self,\n        gatec_def: \u0026'a LocalModuleGateReference,\n    ) -\u003e Result\u003cBox\u003cdyn Iterator\u003cItem = GateRef\u003c'a\u003e\u003e + 'a\u003e\u003e {\n        let Some(def) = self\n            .gates\n            .iter()\n            .find(|g| g.ident.raw == gatec_def.gate.raw) else {\n                return Err(Error::new(\n                    ErrorKind::SymbolNotFound,\n                    format!(\"did not find gate symbol '{}', not in scope\", gatec_def.gate.raw)\n                ))\n            };\n        match (\u0026gatec_def.gate_cluster, def.cluster) {\n            (None, Cluster::Standalone) =\u003e Ok(Box::new(iter::once(GateRef {\n                def,\n                pos: None,\n                submod: None,\n            }))),\n            (None, Cluster::Clusted(cl)) =\u003e Ok(Box::new((0..cl).map(|pos| GateRef {\n                def,\n                pos: Some(pos),\n                submod: None,\n            }))),\n            (Some(c), Cluster::Clusted(cl)) if (c.lit.as_integer() as usize) \u003c cl =\u003e {\n                Ok(Box::new(iter::once(GateRef {\n                    def,\n                    pos: Some(c.lit.as_integer() as usize),\n                    submod: None,\n                })))\n            }\n            (Some(c), Cluster::Clusted(cl)) =\u003e Err(Error::new(\n                ErrorKind::InvalidConClusterIndex,\n                format!(\n                    \"cannot index into gate cluster of size {} with index {}\",\n                    cl,\n                    c.lit.as_integer()\n                ),\n            )),\n            (Some(_), Cluster::Standalone) =\u003e Err(Error::new(\n                ErrorKind::InvalidConClusterIndex,\n                format!(\n                    \"cannot index into gate '{}' since it is not a cluster\",\n                    def.ident.raw\n                ),\n            )),\n        }\n    }\n}\n\npub struct SharedGatesTable\u003c'a\u003e {\n    local: \u0026'a LocalGatesTable\u003c'a\u003e,\n    submodules: \u0026'a LocalSubmoduleTable\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e SharedGatesTable\u003c'a\u003e {\n    pub fn new(local: \u0026'a LocalGatesTable\u003c'a\u003e, submodules: \u0026'a LocalSubmoduleTable\u003c'a\u003e) -\u003e Self {\n        Self { local, submodules }\n    }\n\n    pub fn resolve(\n        \u0026self,\n        def: \u0026'a ModuleGateReference,\n    ) -\u003e Result\u003cBox\u003cdyn Iterator\u003cItem = GateRef\u003c'a\u003e\u003e + 'a\u003e\u003e {\n        match def {\n            ModuleGateReference::Local(gatec_def) =\u003e self.local.resolve(gatec_def),\n            ModuleGateReference::Nonlocal(submodgate_def) =\u003e {\n                let submodules = self.submodules.resolve(submodgate_def)?;\n                let mut gates_iters = Vec::new();\n                for submodule_ref in submodules {\n                    let Some(submodule) = submodule_ref.def.typ.as_module() else {\n                        // type of submodule is not specified, thus ignore this error as transitent.\n                        unimplemented!()\n                    };\n                    let tbl = LocalGatesTable::new(\u0026submodule.gates);\n                    let mut gates = tbl.resolve(\u0026submodgate_def.gate)?.collect::\u003cVec\u003c_\u003e\u003e();\n                    for gate in \u0026mut gates {\n                        gate.submod = Some((\n                            submodule_ref.pos,\n                            submodule_ref.def.ident.raw.clone(),\n                            submodule_ref.def.cluster,\n                        ));\n                    }\n\n                    gates_iters.push(gates.into_iter());\n                }\n\n                Ok(Box::new(IterIter::new(gates_iters.into_iter())))\n            }\n        }\n    }\n}\n\npub struct LocalSubmoduleTable\u003c'a\u003e {\n    modules: \u0026'a [Submodule],\n}\n\nimpl\u003c'a\u003e LocalSubmoduleTable\u003c'a\u003e {\n    pub fn new(modules: \u0026'a [Submodule]) -\u003e Self {\n        Self { modules }\n    }\n\n    pub fn resolve(\n        \u0026self,\n        submodgate_def: \u0026'a NonlocalModuleGateReference,\n    ) -\u003e Result\u003cBox\u003cdyn Iterator\u003cItem = SubmoduleRef\u003c'a\u003e\u003e + 'a\u003e\u003e {\n        let Some(def) = self\n            .modules\n            .iter()\n            .find(|def| def.ident.raw == submodgate_def.submodule.raw) else {\n                return Err(Error::new(\n                    ErrorKind::SymbolNotFound,\n                    format!(\"did not find submodule symbol '{}', not in scope\", submodgate_def.submodule.raw)\n                ).spanned(submodgate_def.span()))\n        };\n\n        match (\u0026submodgate_def.submodule_cluster, def.cluster) {\n            (None, Cluster::Standalone) =\u003e Ok(Box::new(iter::once(SubmoduleRef { def, pos: 0 }))),\n            (None, Cluster::Clusted(cl)) =\u003e {\n                Ok(Box::new((0..cl).map(|pos| SubmoduleRef { def, pos })))\n            }\n            (Some(c), Cluster::Clusted(cl)) if (c.lit.as_integer() as usize) \u003c cl =\u003e {\n                Ok(Box::new(iter::once(SubmoduleRef {\n                    def,\n                    pos: c.lit.as_integer() as usize,\n                })))\n            }\n            (Some(c), Cluster::Clusted(cl)) =\u003e Err(Error::new(\n                ErrorKind::InvalidConClusterIndex,\n                format!(\n                    \"cannot index into submdoule cluster of size {} with index {}\",\n                    cl,\n                    c.lit.as_integer()\n                ),\n            )),\n            (Some(_), Cluster::Standalone) =\u003e Err(Error::new(\n                ErrorKind::InvalidConClusterIndex,\n                format!(\n                    \"cannot index into submodule '{}' since it is not a cluster\",\n                    def.ident.raw\n                ),\n            )),\n        }\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":858},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":396},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":792},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":396},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":396},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1404},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1008},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1776},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":870},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":43,"coverable":82},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","mod.rs"],"content":"use std::path::PathBuf;\nuse std::sync::Arc;\n\nuse crate::ast;\nuse crate::context::Context;\nuse crate::error::*;\nuse crate::ir;\nuse crate::resource::AssetIdentifier;\n\nmod ast_tables;\nmod ir_tables;\nmod link;\nmod local_tables;\nmod module;\nmod util;\n\npub use self::ast_tables::*;\npub use self::ir_tables::*;\n// pub use self::link::*;\npub use self::local_tables::*;\n// pub use self::module::*;\n\npub(crate) use self::util::*;\n\nimpl Context {\n    pub(super) fn load_ir(\u0026mut self, errors: \u0026mut ErrorsMut) {\n        let order = self.ir_load_order();\n        for asset in order {\n            let asset_str = asset.alias().to_string();\n            let asset_path = asset.path().unwrap_or(\u0026PathBuf::new()).clone();\n\n            // Add asset info to all errors.\n            errors.with_mapping(\n                move |e| {\n                    e.add_hints(ErrorHint::Note(format!(\n                        \"found in assset '{}' ({:?})\",\n                        asset_str, asset_path\n                    )))\n                },\n                |errors| {\n                    // Collect all defined items.\n                    let mut items = Vec::new();\n\n                    // Link deriving uses ast-link defs for local info, ir_links allready symbolised in\n                    // dependencies and a global ast context for symbol resoloution.\n                    let mut ast_links = LinkAstTable::from_ctx(self, \u0026asset, errors);\n                    let mut ir_links = LinkIrTable::from_ctx(self, \u0026asset, errors, false);\n                    let global_ast = GlobalAstTable::new(self, \u0026asset);\n\n                    // Resolve links\n                    // - all nonlocal dependencies are allready ir\n                    // - local dependencies may be out of order\n                    if ast_links.order_local_deps(errors) {\n                        for link in ast_links.local() {\n                            let ident = link.ident.raw.clone();\n                            errors.with_mapping(\n                                move |e| {\n                                    e.add_hints(ErrorHint::Note(format!(\n                                        \"found in link definition '{}'\",\n                                        ident\n                                    )))\n                                },\n                                |errors| {\n                                    // Use the link_specific symboliser to parse a link;\n                                    let ir = ir::Link::from_ast(\n                                        link.clone(),\n                                        \u0026ir_links,\n                                        \u0026global_ast,\n                                        errors,\n                                    );\n                                    let ir = Arc::new(ir);\n\n                                    // Add the link to the local ir_table to ensure that other links\n                                    // in this link can use it in later iterations.\n                                    // order is ensure by order_local_deps\n                                    ir_links.add(ir.clone());\n                                    items.push(ir::Item::Link(ir));\n                                },\n                            );\n                        }\n                    }\n\n                    // Modules use local ast info, and dependency ir info, with global ast-debug info\n                    let mut ast_modules = ModuleAstTable::from_ctx(self, \u0026asset, errors);\n                    let mut ir_modules = ModuleIrTable::from_ctx(self, \u0026asset, errors, false);\n                    let global_ast = GlobalAstTable::new(self, \u0026asset);\n\n                    // Resolve mdoules\n                    // - same\n                    if ast_modules.order_local_deps(errors) {\n                        // println!(\"{:#?}\", ast_modules.local());\n                        for module in ast_modules.local() {\n                            let ident = module.ident.raw.clone();\n                            errors.with_mapping(\n                                move |e| {\n                                    e.add_hints(ErrorHint::Note(format!(\n                                        \"found in module definition '{}'\",\n                                        ident\n                                    )))\n                                },\n                                |errors| {\n                                    // Use the local symboliser for modules.\n                                    let ir = ir::Module::from_ast(\n                                        module.clone(),\n                                        \u0026ir_modules,\n                                        \u0026ir_links,\n                                        \u0026global_ast,\n                                        errors,\n                                    );\n\n                                    let ir = Arc::new(ir);\n\n                                    // Add the module to the local ir_table to ensure that other modules\n                                    // in this module can use it in later iterations.\n                                    // order is ensure by order_local_deps\n                                    ir_modules.add(ir.clone());\n                                    items.push(ir::Item::Module(ir));\n                                },\n                            )\n                        }\n                    }\n\n                    // Address collected items with asset identifier\n                    self.ir.insert(asset, ir::Items { items });\n                },\n            );\n        }\n    }\n\n    fn ir_load_order(\u0026self) -\u003e Vec\u003cAssetIdentifier\u003e {\n        let mut order = Vec::new();\n        let mut rem = self.assets.clone();\n        while !rem.is_empty() {\n            for i in 0..rem.len() {\n                let deps = self.deps.get(\u0026rem[i]).unwrap();\n                let mut loadable = true;\n                for dep in deps {\n                    if !order.contains(dep) {\n                        loadable = false;\n                        break;\n                    }\n                }\n\n                if loadable {\n                    let asset = rem.remove(i);\n                    order.push(asset);\n                    break;\n                }\n            }\n        }\n\n        order\n    }\n\n    pub(super) fn load_entry_and_check_dyn(\u0026mut self, errors: \u0026mut ErrorsMut) {\n        let ir_table = ModuleIrTable::from_ctx(self, \u0026self.root, errors, true);\n\n        let asts = self.asts_for_asset(\u0026self.root);\n        for ast in \u0026asts {\n            for item in \u0026ast.1.items {\n                let ast::Item::Entry(entry) = item else {\n                    continue;\n                };\n\n                let Some(symbol) = ir_table.get(\u0026entry.symbol.raw) else {\n                    errors.add(Error::new(\n                        ErrorKind::SymbolNotFound,\n                        format!(\"defined entry symbol '{}' not in scope\", entry.symbol.raw)\n                    ));\n                    return;\n                };\n                self.check_dyn(symbol.clone(), errors);\n                self.entry = Some(symbol);\n                return;\n            }\n        }\n\n        errors.add(Error::new(\n            ErrorKind::MissingEntryPoint,\n            \"missing entry point to ndl topology\",\n        ));\n    }\n\n    #[allow(clippy::only_used_in_recursion)]\n    fn check_dyn(\u0026self, arc: Arc\u003cir::Module\u003e, errors: \u0026mut ErrorsMut) {\n        let arc2 = arc.clone();\n        errors.with_mapping(\n            move |e| e.add_hints(ErrorHint::Note(format!(\"in module '{}'\", arc.ident.raw))),\n            move |errors| {\n                for submodule in arc2.submodules.iter() {\n                    if submodule.dynamic {\n                        unreachable!();\n                    }\n\n                    if let Some(sub) = submodule.typ.as_module_arc() {\n                        self.check_dyn(sub, errors)\n                    }\n                }\n            },\n        )\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1008},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":726},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":558},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":972},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":480},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":576},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":312},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":312},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":492},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":312},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":876},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":330},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":552},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":552},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":444},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":168},"fn_name":null}],"covered":88,"coverable":96},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","module.rs"],"content":"use std::sync::Arc;\n\nuse crate::{\n    ast::{ModuleStmt, Spanned},\n    error::*,\n    ir::{\n        Cluster, Connection, ConnectionEndpoint, Gate, Module, RawSymbol,\n        Submodule, Symbol,\n    },\n    resolve::{LinkIrTable, LocalGatesTable, LocalSubmoduleTable, ModuleIrTable, SharedGatesTable},\n};\n\nuse super::GlobalAstTable;\n\nimpl Module {\n    pub fn from_ast(\n        ast: Arc\u003cModuleStmt\u003e,\n        modules: \u0026ModuleIrTable,\n        links: \u0026LinkIrTable,\n        global: \u0026GlobalAstTable,\n        errors: \u0026mut ErrorsMut,\n    ) -\u003e Module {\n        let errlen = errors.len();\n\n        // load deps;\n        // TODO: check for dirty deps.\n        let mut deps = Vec::new();\n        let mut inherited = Vec::new();\n        if let Some(ref inh) = ast.inheritance {\n            for dep in inh.symbols.iter() {\n                let typ = match modules.get(dep) {\n                    Some(v) =\u003e v,\n                    None =\u003e {\n                        errors.add(\n                            Error::new(\n                                ErrorKind::SymbolNotFound,\n                                format!(\n                                    \"did not find inheritance symbol '{}', not in scope\",\n                                    dep.raw\n                                ),\n                            )\n                            .spanned(dep.span())\n                            .map(|e| global.err_resolve_symbol(\u0026dep.raw, true, e)),\n                        );\n                        inherited.push(Symbol::Unresolved(RawSymbol {\n                            raw: dep.raw.clone(),\n                        }));\n                        continue;\n                    }\n                };\n                deps.push(typ.clone());\n                inherited.push(Symbol::from(typ));\n            }\n        }\n\n        // Include gate definitions\n        let mut ir_gates: Vec\u003cGate\u003e = Vec::with_capacity(ast.gates.len());\n        for inh in \u0026deps {\n            ir_gates.extend(inh.gates.iter().cloned());\n        }\n        for gate in ast.gates.iter().flat_map(|stmt| stmt.items.iter()) {\n            if ir_gates.iter().any(|d| d.ident.raw == gate.ident.raw) {\n                errors.add(\n                    Error::new(\n                        ErrorKind::SymbolDuplication,\n                        format!(\n                            \"gate(-cluster) '{}' was defined multiple times\",\n                            gate.ident.raw\n                        ),\n                    )\n                    .spanned(gate.span()),\n                );\n                continue;\n            }\n            ir_gates.push(Gate {\n                ident: RawSymbol {\n                    raw: gate.ident.raw.clone(),\n                },\n                cluster: gate\n                    .cluster\n                    .as_ref()\n                    .map(Cluster::from)\n                    .unwrap_or(Cluster::Standalone),\n            });\n        }\n\n        // Include submodule definition\n        let mut ir_submodules: Vec\u003cSubmodule\u003e = Vec::with_capacity(ast.submodules.len());\n        for inh in \u0026deps {\n            ir_submodules.extend(inh.submodules.iter().cloned());\n        }\n        for submodule_ast in ast.submodules.iter().flat_map(|stmt| stmt.items.iter()) {\n            if ir_submodules\n                .iter()\n                .any(|d| d.ident.raw == submodule_ast.ident.raw)\n            {\n                errors.add(\n                    Error::new(\n                        ErrorKind::SymbolDuplication,\n                        format!(\n                            \"submodule(-cluster) '{}' was defined multiple times\",\n                            submodule_ast.ident.raw\n                        ),\n                    )\n                    .spanned(submodule_ast.span()),\n                );\n                continue;\n            }\n\n            let cluster = Cluster::from(\u0026submodule_ast.cluster);\n\n            // Confirm existence of symbol\n            let typ = modules\n                .get(\u0026submodule_ast.typ.raw())\n                .map(Symbol::from)\n                .unwrap_or_else(|| {\n                    println!(\"seaching: {}\", submodule_ast.typ.raw());\n                    println!(\"modules: {modules:#?}\");\n\n                    errors.add(\n                        Error::new(\n                            ErrorKind::SymbolNotFound,\n                            format!(\n                                \"did not find submodule symbol '{}', not in scope\",\n                                submodule_ast.typ.raw()\n                            ),\n                        )\n                        .spanned(submodule_ast.typ.span())\n                        .map(|e| global.err_resolve_symbol(\u0026submodule_ast.typ.raw(), true, e)),\n                    );\n                    Symbol::Unresolved(RawSymbol {\n                        raw: submodule_ast.typ.raw(),\n                    })\n                });\n\n            let submod_ir = if let Some(ref specs) = submodule_ast.dyn_spec {\n                // since we not monomorphise a new entry, create a new instance\n                if let Some(mut override_ir) = typ.as_module().cloned() {\n                    // override the existing specs.\n                    for spec in specs.items.iter() {\n                        // found overide \u003cdyn_field\u003e = \u003cvalue\u003e\n                        let dyn_field = \u0026spec.key.raw;\n                        let Some(dyn_field) = override_ir.submodules.iter_mut().find(|d| d.ident.raw == *dyn_field) else {\n                            // \u003cdyn_field\u003e pointed to an unknown submodule (of the submodule)\n                            errors.add(Error::new(\n                                ErrorKind::SymbolNotFound,\n                                format!(\"did not find submodule symbol for dyn-spec '{}', not in scope\", dyn_field)\n                            ).spanned(spec.key.span()));\n                            continue;\n                        };\n\n                        let typ = modules.get(\u0026spec.value.raw);\n                        if let Some(ref typ) = typ {\n                            if let Some(expected_proto) = dyn_field.typ.as_module_arc() {\n                                // check wheter the provided type is really\n                                // implementing the expected proto\n                                let valid = typ.inherited.iter().any(|s| {\n                                    Arc::ptr_eq(\u0026s.as_module_arc().unwrap(), \u0026expected_proto)\n                                });\n                                if !valid {\n                                    errors.add(\n                                        Error::new(\n                                            ErrorKind::ModuleDynConstraintsBroken,\n                                            format!(\"module '{}' does not inherit '{}', thus cannot be assigned to dyn field '{}'\", typ.ident.raw, expected_proto.ident.raw, spec.key.raw)\n                                        ).spanned(spec.span())\n                                    )\n                                }\n                            }\n                        }\n\n                        let typ = typ.map(Symbol::from).unwrap_or_else(|| {\n                            errors.add(\n                                Error::new(\n                                    ErrorKind::SymbolNotFound,\n                                    format!(\n                                        \"did not find dyn-spec submodule symbol '{}', not in scope\",\n                                        spec.value.raw\n                                    ),\n                                )\n                                .spanned(spec.value.span())\n                                .map(|e| global.err_resolve_symbol(\u0026spec.value.raw, true, e)),\n                            );\n                            Symbol::Unresolved(RawSymbol {\n                                raw: submodule_ast.typ.raw(),\n                            })\n                        });\n\n                        dyn_field.dynamic = false;\n                        dyn_field.typ = typ;\n                    }\n\n                    let ident = RawSymbol {\n                        raw: submodule_ast.ident.raw.clone(),\n                    };\n                    Submodule {\n                        span: override_ir.ast.span(),\n                        ident,\n                        cluster,\n                        typ: Symbol::from(Arc::new(override_ir)),\n                        dynamic: submodule_ast.typ.is_dyn(),\n                    }\n                } else {\n                    // if the symbol is not resolved either way just add it in its incomplete form\n                    let ident = RawSymbol {\n                        raw: submodule_ast.ident.raw.clone(),\n                    };\n                    Submodule {\n                        span: submodule_ast.span(),\n                        ident,\n                        cluster,\n                        typ,\n                        dynamic: submodule_ast.typ.is_dyn(),\n                    }\n                }\n            } else {\n                let ident = RawSymbol {\n                    raw: submodule_ast.ident.raw.clone(),\n                };\n                Submodule {\n                    span: submodule_ast.span(),\n                    ident,\n                    cluster,\n                    typ,\n                    dynamic: submodule_ast.typ.is_dyn(),\n                }\n            };\n\n            if let Some(s) = submod_ir.typ.as_module() {\n                let mut missing = Vec::new();\n                for dep in s.submodules.iter() {\n                    if dep.dynamic {\n                        missing.push(\u0026dep.ident.raw[..])\n                    }\n                }\n\n                if !missing.is_empty() {\n                    let s = missing.join(\", \");\n                    errors.add(Error::new(\n                        ErrorKind::ModuleDynNotResolved,\n                        format!(\n                            \"missing specification for dynamic members of submodule '{}': missing fields '{}'\",\n                            submod_ir.ident.raw, s\n                        ),\n                    ).spanned(submod_ir.span))\n                }\n            }\n\n            ir_submodules.push(submod_ir);\n        }\n\n        let local_gtable = LocalGatesTable::new(\u0026ir_gates);\n        let sm_table = LocalSubmoduleTable::new(\u0026ir_submodules);\n        let shared_gtable = SharedGatesTable::new(\u0026local_gtable, \u0026sm_table);\n\n        let mut ir_connections: Vec\u003cConnection\u003e = Vec::with_capacity(ast.connections.len());\n        for inh in \u0026deps {\n            ir_connections.extend(inh.connections.iter().cloned());\n        }\n        for con in ast.connections.iter().flat_map(|s| s.items.iter()) {\n            let delay = if let Some(link) = \u0026con.link {\n                let Some(link) = links.get(\u0026link.raw) else {\n                        errors.add(Error::new(\n                            ErrorKind::SymbolNotFound,\n                            format!(\"did not find link symbol '{}', not in scope\", link.raw)\n                        ).spanned(con.span()).map(|e| global.err_resolve_symbol(\u0026link.raw, false, e)));\n                        continue\n                    };\n                Some(Symbol::from(link))\n            } else {\n                None\n            };\n\n            let lhs = shared_gtable.resolve(\u0026con.lhs);\n            let rhs = shared_gtable.resolve(\u0026con.rhs);\n\n            let (lhs, rhs) = match (lhs, rhs) {\n                (Ok(lhs), Ok(rhs)) =\u003e (lhs, rhs),\n                (Err(e), Ok(_)) =\u003e {\n                    errors.add(e);\n                    continue;\n                }\n                (Ok(_), Err(e)) =\u003e {\n                    errors.add(e);\n                    continue;\n                }\n                (Err(e1), Err(e2)) =\u003e {\n                    errors.add(e1);\n                    errors.add(e2);\n                    continue;\n                }\n            };\n\n            let mut lhs = lhs.collect::\u003cVec\u003c_\u003e\u003e();\n            let mut rhs = rhs.collect::\u003cVec\u003c_\u003e\u003e();\n\n            let n = lhs.len().min(rhs.len());\n            for _ in 0..n {\n                let l = lhs.pop().unwrap();\n                let r = rhs.pop().unwrap();\n\n                // TODO: Topo check whether the gates can hold connections\n\n\n                // if l.def.service_typ == GateServiceType::Input {\n                //     errors.add(Error::new(\n                //             ErrorKind::InvalidConGateServiceTyp,\n                //             format!(\"Gate '{}' cannot serve as connection source, since it is of serivce type '{:?}'\", l.def.ident.raw, l.def.service_typ)\n                //         ));\n                // }\n\n                // if r.def.service_typ == GateServiceType::Output {\n                //     errors.add(Error::new(\n                //             ErrorKind::InvalidConGateServiceTyp,\n                //             format!(\"Gate '{}' cannot serve as connection target, since it is of serivce type '{:?}'\", r.def.ident.raw, r.def.service_typ)\n                //     ));\n                // }\n\n                ir_connections.push(Connection {\n                    lhs: ConnectionEndpoint::from(l),\n                    rhs: ConnectionEndpoint::from(r),\n                    delay: delay.clone(),\n                });\n            }\n\n            if !lhs.is_empty() {\n                errors.add(Error::new(\n                        ErrorKind::InvalidConDefSizes,\n                        format!(\"Invalid connection statement, source domain is bigger than target domain (by {} gates)\", lhs.len())\n                    ))\n            }\n            if !rhs.is_empty() {\n                errors.add(Error::new(\n                        ErrorKind::InvalidConDefSizes,\n                        format!(\"Invalid connection statement, target domain is bigger than source domain (by {} gates)\", rhs.len())\n                    ))\n            }\n        }\n\n        let ident = RawSymbol {\n            raw: ast.ident.raw.clone(),\n        };\n        Module {\n            ast,\n            ident,\n            inherited,\n            gates: ir_gates,\n            submodules: ir_submodules,\n            connections: ir_connections,\n            dirty: errlen \u003c errors.len(),\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":564},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":702},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":996},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":906},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":702},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":972},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":690},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":702},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":720},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":396},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":486},"fn_name":null}],"covered":149,"coverable":170},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","util.rs"],"content":"use std::marker::PhantomData;\n\npub struct IterIter\u003cI, I2, T\u003e {\n    iter: I,\n    subiter: Option\u003cI2\u003e,\n    phantom: PhantomData\u003c(I2, T)\u003e,\n}\n\nimpl\u003cI, I2, T\u003e IterIter\u003cI, I2, T\u003e\nwhere\n    I: Iterator\u003cItem = I2\u003e,\n    I2: Iterator\u003cItem = T\u003e,\n{\n    pub fn new(mut iter: I) -\u003e Self {\n        let subiter = iter.next();\n        Self {\n            iter,\n            subiter,\n            phantom: PhantomData,\n        }\n    }\n}\n\nimpl\u003cI, I2, T\u003e Iterator for IterIter\u003cI, I2, T\u003e\nwhere\n    I: Iterator\u003cItem = I2\u003e,\n    I2: Iterator\u003cItem = T\u003e,\n{\n    type Item = T;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if let Some(subiter) = \u0026mut self.subiter {\n            if let Some(item) = subiter.next() {\n                Some(item)\n            } else {\n                self.subiter = self.iter.next();\n                self.next()\n            }\n        } else {\n            None\n        }\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1104},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1944},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":264},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resource","fs.rs"],"content":"use std::path::{Component, Path, PathBuf};\n\npub(crate) fn common_path(lhs: impl AsRef\u003cPath\u003e, rhs: impl AsRef\u003cPath\u003e) -\u003e PathBuf {\n    let lhs = lhs.as_ref().components();\n    let rhs = rhs.as_ref().components();\n\n    let mut result = PathBuf::new();\n\n    for (l, r) in lhs.zip(rhs) {\n        if l == r {\n            match l {\n                Component::ParentDir =\u003e {\n                    assert!(result.pop(), \"cannot escape scope\");\n                }\n                l =\u003e result.push(l),\n            }\n        } else {\n            break;\n        }\n    }\n\n    result\n}\n\n#[allow(clippy::while_let_on_iterator)]\npub(crate) fn strip_prefix(path: impl AsRef\u003cPath\u003e, prefix: impl AsRef\u003cPath\u003e) -\u003e PathBuf {\n    let mut lhs = prefix.as_ref().components();\n    let mut rhs = path.as_ref().components();\n\n    while let Some(l) = lhs.next() {\n        let r = rhs.next().unwrap();\n        assert_eq!(l, r);\n    }\n\n    canon(PathBuf::from_iter(rhs))\n}\n\npub(crate) fn canon(path: impl AsRef\u003cPath\u003e) -\u003e PathBuf {\n    let comps = path.as_ref().components();\n    let mut result = PathBuf::new();\n    for comp in comps {\n        match comp {\n            Component::ParentDir =\u003e {\n                assert!(result.pop())\n            }\n            other =\u003e result.push(other),\n        }\n    }\n    result\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn no_parent_path() {\n        assert_eq!(common_path(\"a/b/c/d\", \"a/b/o/p\"), PathBuf::from(\"a/b\"));\n\n        assert_eq!(\n            common_path(\"lookup/a/b\", \"lookup/c/d\"),\n            PathBuf::from(\"lookup\")\n        );\n\n        assert_eq!(common_path(\"a/b/c/d\", \"a/b/c/d\"), PathBuf::from(\"a/b/c/d\"));\n\n        assert_eq!(common_path(\"a/b/c/d\", \"e/a/b/o/p\"), PathBuf::from(\"\"));\n        assert_eq!(common_path(\"a/b/c/d\", \"\"), PathBuf::from(\"\"));\n    }\n\n    #[test]\n    fn parent_steps() {\n        assert_eq!(common_path(\"a/../a/d\", \"a/../o/p\"), PathBuf::from(\"\"));\n\n        assert_eq!(\n            common_path(\"lookup/../b\", \"lookup/a/../d\"),\n            PathBuf::from(\"lookup\")\n        );\n\n        assert_eq!(common_path(\"a/../c/d\", \"a/../c/d\"), PathBuf::from(\"c/d\"));\n\n        assert_ne!(common_path(\"a/../c/d\", \"/c/d\"), PathBuf::from(\"/c/d\"));\n    }\n\n    #[test]\n    fn strip_no_parent_prefix() {\n        assert_eq!(strip_prefix(\"a/b/c/d\", \"a/b\"), PathBuf::from(\"c/d\"));\n        assert_eq!(strip_prefix(\"a/b/c/d\", \"a/b/c\"), PathBuf::from(\"d\"));\n        assert_eq!(strip_prefix(\"a/b/c/d\", \"\"), PathBuf::from(\"a/b/c/d\"));\n    }\n\n    #[test]\n    fn strip_parent_steps() {\n        assert_eq!(strip_prefix(\"a/b/c/../d\", \"a/b\"), PathBuf::from(\"d\"));\n    }\n\n    #[test]\n    fn canon_paths() {\n        assert_eq!(canon(\"a/../b\"), PathBuf::from(\"b\"));\n        assert_eq!(canon(\"a/c/../../b\"), PathBuf::from(\"b\"));\n        assert_eq!(canon(\"a/c/../b\"), PathBuf::from(\"a/b\"));\n    }\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":4,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":293},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":218},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1341},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":551},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":229},"fn_name":null}],"covered":23,"coverable":23},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resource","mod.rs"],"content":"#![allow(unused)]\n\nuse std::{\n    fs::File,\n    io::{Error, ErrorKind, Read, Result},\n    path::{Path, PathBuf},\n};\n\npub(crate) mod fs;\n\nmod span;\npub use self::span::*;\n\n#[cfg(test)]\nmod tests;\n\n#[derive(Debug)]\npub struct SourceMap {\n    pub(crate) buffer: String,\n    pub(crate) assets: Vec\u003cSourceMappedAsset\u003e,\n}\n\n#[derive(Debug)]\npub(crate) struct SourceMappedAsset {\n    pub offset: usize,\n    pub len: usize,\n    pub ident: AssetIdentifier,\n    pub line_pos_mapping: Vec\u003cusize\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub enum AssetIdentifier {\n    Raw {\n        alias: String,\n    },\n    Root {\n        path: PathBuf,\n        alias: String,\n    },\n    Included {\n        path: PathBuf,\n        alias: String,\n        include: Span,\n    },\n}\n\nimpl AssetIdentifier {\n    fn root_path(\u0026self) -\u003e Option\u003c\u0026Path\u003e {\n        match self {\n            Self::Raw { .. } =\u003e None,\n            Self::Root { path, .. } =\u003e Some(path),\n            Self::Included { path, .. } =\u003e Some(path),\n        }\n    }\n}\n\nimpl From\u003c\u0026str\u003e for AssetIdentifier {\n    fn from(value: \u0026str) -\u003e Self {\n        if value.starts_with(\"raw:\") {\n            return AssetIdentifier::Raw {\n                alias: value[5..].to_string(),\n            };\n        }\n\n        let path = PathBuf::from(\u0026value[9..]);\n        if value.starts_with(\"include:\") {\n            return AssetIdentifier::Included {\n                alias: path.to_str().unwrap().to_string(),\n                path,\n                include: Span::new(0, 0),\n            };\n        }\n\n        AssetIdentifier::Root {\n            alias: path.to_str().unwrap().to_string(),\n            path,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\npub struct Asset\u003c'a\u003e {\n    map: \u0026'a SourceMap,\n    mapping: \u0026'a SourceMappedAsset,\n}\n\nimpl SourceMap {\n    pub fn new() -\u003e Self {\n        Self {\n            buffer: String::new(),\n            assets: Vec::new(),\n        }\n    }\n\n    pub fn load_file(\u0026mut self, ident: impl Into\u003cAssetIdentifier\u003e) -\u003e Result\u003cAsset\u003c'_\u003e\u003e {\n        let ident = ident.into();\n        let mut file = File::open(ident.path()?)?;\n        let offset = self.buffer.len();\n        let n = file.read_to_string(\u0026mut self.buffer)?;\n\n        let mapping = SourceMappedAsset::new(ident, offset, n, self);\n        self.assets.push(mapping);\n\n        Ok(Asset {\n            map: self,\n            mapping: self.assets.last().unwrap(),\n        })\n    }\n\n    pub fn load_raw(\u0026mut self, ident: impl Into\u003cAssetIdentifier\u003e, raw: \u0026str) -\u003e Asset\u003c'_\u003e {\n        let ident = ident.into();\n        assert!(matches!(ident, AssetIdentifier::Raw { .. }));\n\n        let offset = self.buffer.len();\n        let n = raw.len();\n        self.buffer.push_str(raw);\n\n        let mapping = SourceMappedAsset::new(ident, offset, n, self);\n        self.assets.push(mapping);\n\n        Asset {\n            map: self,\n            mapping: self.assets.last().unwrap(),\n        }\n    }\n\n    pub(crate) fn span_for(\u0026self, asset: \u0026AssetIdentifier) -\u003e Option\u003cSpan\u003e {\n        self.assets\n            .iter()\n            .find(|a| a.ident == *asset)\n            .map(|v| v.span())\n    }\n\n    pub(crate) fn slice_for(\u0026self, span: Span) -\u003e \u0026str {\n        \u0026self.buffer[span.pos..(span.pos + span.len)]\n    }\n\n    pub(crate) fn slice_padded_for(\u0026self, span: Span) -\u003e (\u0026str, usize) {\n        // println!(\"{span:?}\");\n\n        let asset = self\n            .asset_for(span)\n            .expect(\"Failed to assign asset to span\");\n        let bounds = (asset.offset, asset.offset + asset.len);\n        // println!(\"{}: {:?}\", asset.offset, asset.line_pos_mapping);\n\n        let line_start = asset.line_for(span.pos);\n        let line_end = asset.line_for(span.pos + span.len);\n        let len = line_end - line_start + 1;\n        let pad = if len \u003e 2 { 1 } else { 2 };\n\n        let lso = line_start;\n\n        let line_start = line_start.saturating_sub(pad);\n        let line_end = line_end\n            .saturating_add(pad)\n            .min(asset.line_pos_mapping.len() - 1);\n\n        let line_offset = if line_start != 0 {\n            lso - line_start\n        } else {\n            lso - line_start - 1\n        };\n\n        let start = *asset\n            .line_pos_mapping\n            .get(line_start.saturating_sub(1))\n            .unwrap_or(\u0026bounds.0)\n            .max(\u0026bounds.0);\n        let end = (asset.line_pos_mapping[line_end] - 1).min(bounds.1);\n\n        (\u0026self.buffer[start..end], line_offset)\n    }\n\n    pub(crate) fn asset(\u0026self, ident: \u0026AssetIdentifier) -\u003e Option\u003c\u0026SourceMappedAsset\u003e {\n        self.assets.iter().find(|a| a.ident == *ident)\n    }\n\n    pub(crate) fn asset_for(\u0026self, span: Span) -\u003e Option\u003c\u0026SourceMappedAsset\u003e {\n        self.assets.iter().find(|asset| asset.contains(span))\n    }\n\n    pub(crate) fn line_for(\u0026self, span: Span) -\u003e Option\u003cusize\u003e {\n        let asset = self.asset_for(span)?;\n        Some(asset.line_for(span.pos))\n    }\n}\n\nimpl Default for SourceMap {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl SourceMappedAsset {\n    pub(crate) fn new(ident: AssetIdentifier, offset: usize, len: usize, map: \u0026SourceMap) -\u003e Self {\n        let data = \u0026map.buffer[offset..(offset + len)];\n\n        // pos is a mapping line-start-index --\u003e line-number (index)\n\n        let mut idx = 0;\n        let mut pos = vec![0];\n\n        for c in data.chars() {\n            if c == '\\n' {\n                pos.push(offset + idx + 1);\n            }\n            idx += c.len_utf8();\n        }\n\n        Self {\n            ident,\n            offset,\n            len,\n            line_pos_mapping: pos,\n        }\n    }\n\n    pub fn include_for(\u0026self, other: \u0026SourceMappedAsset) -\u003e Option\u003cString\u003e {\n        let s = self.ident.alias();\n        let o = other.ident.alias();\n\n        let s = s.split('/').collect::\u003cVec\u003c_\u003e\u003e();\n        let o = o.split('/').collect::\u003cVec\u003c_\u003e\u003e();\n\n        let n = s.len().min(o.len());\n        for i in 0..n {\n            if s[i] != o[i] {\n                let mut include = String::new();\n                let up = n - i;\n                for _ in 0..up {\n                    include.push_str(\"../\");\n                }\n                for \u0026e in o.iter().skip(i) {\n                    include.push_str(e);\n                    include.push('/');\n                }\n                include.pop();\n                return Some(include);\n            }\n        }\n\n        None\n    }\n\n    pub(crate) fn span(\u0026self) -\u003e Span {\n        Span::new(self.offset, self.len)\n    }\n\n    pub(crate) fn contains(\u0026self, span: Span) -\u003e bool {\n        let end = span.pos + span.len;\n        self.offset \u003c= span.pos \u0026\u0026 end \u003c= self.offset + self.len\n    }\n\n    pub(crate) fn line_for(\u0026self, pos: usize) -\u003e usize {\n        for i in 0..self.line_pos_mapping.len() {\n            if self.line_pos_mapping[i] \u003e pos {\n                return i;\n            }\n        }\n\n        self.line_pos_mapping.len()\n    }\n}\n\nimpl AssetIdentifier {\n    pub fn raw(s: \u0026str) -\u003e Self {\n        Self::Raw {\n            alias: s.to_string(),\n        }\n    }\n\n    pub fn alias(\u0026self) -\u003e \u0026str {\n        match self {\n            Self::Raw { alias } | Self::Root { alias, .. } | Self::Included { alias, .. } =\u003e alias,\n        }\n    }\n\n    pub(crate) fn relative_asset_alias(\u0026self, path: \u0026Path) -\u003e String {\n        let common = fs::common_path(self.path().unwrap(), path);\n        let sub = fs::strip_prefix(path, common);\n        let sub = sub.with_extension(\"\").to_string_lossy().to_string();\n        sub\n    }\n\n    pub(crate) fn path(\u0026self) -\u003e Result\u003c\u0026PathBuf\u003e {\n        match self {\n            Self::Raw { .. } =\u003e Err(Error::new(ErrorKind::Other, \"asset is not io-bound\")),\n            Self::Included { path, .. } =\u003e Ok(path),\n            Self::Root { path, .. } =\u003e Ok(path),\n        }\n    }\n}\n\nimpl\u003c'a\u003e Asset\u003c'a\u003e {\n    pub(crate) fn new(map: \u0026'a SourceMap, mapping: \u0026'a SourceMappedAsset) -\u003e Self {\n        Self { map, mapping }\n    }\n\n    pub(crate) fn alias(\u0026self) -\u003e \u0026str {\n        self.mapping.ident.alias()\n    }\n\n    pub(crate) fn source_span(\u0026self) -\u003e Span {\n        Span::new(self.mapping.offset, self.mapping.len)\n    }\n\n    pub(crate) fn source(\u0026self) -\u003e \u0026'a str {\n        \u0026self.map.buffer[self.mapping.offset..(self.mapping.offset + self.mapping.len)]\n    }\n\n    pub(crate) fn slice_for(\u0026self, span: Span) -\u003e \u0026str {\n        self.map.slice_for(span)\n    }\n\n    pub(crate) fn slice_padded_for(\u0026self, span: Span) -\u003e (\u0026str, usize) {\n        self.map.slice_padded_for(span)\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":403},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":403},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":403},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":864},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":864},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":186},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":7376},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":7376},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":243},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":281},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":900},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":525},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":525},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":525},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":525},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":66086},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":71009},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":5448},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":65561},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":674},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":3710},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":3464},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":696},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":1332},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":1332},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":330},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1002},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":524},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":524},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":524},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":524},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":7376},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":7376},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":99,"coverable":125},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resource","span.rs"],"content":"use std::fmt;\n\n#[derive(Clone, Copy, PartialEq, Eq, Hash)]\npub struct Span {\n    pub(crate) pos: usize,\n    pub(crate) len: usize,\n}\n\nimpl Span {\n    pub fn new(pos: usize, len: usize) -\u003e Self {\n        // assert!(len \u003e 0);\n        Span { pos, len }\n    }\n\n    pub fn fromto(mut lhs: Span, mut rhs: Span) -\u003e Self {\n        if lhs.pos \u003e rhs.pos {\n            std::mem::swap(\u0026mut lhs, \u0026mut rhs);\n        }\n        let len = (rhs.pos + rhs.len) - lhs.pos;\n        Self { pos: lhs.pos, len }\n    }\n\n    pub fn after(\u0026self) -\u003e Span {\n        Self {\n            pos: self.pos + self.len,\n            len: 0,\n        }\n    }\n}\n\nimpl fmt::Debug for Span {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\u0026format!(\"Span[{}..(+{})]\", self.pos, self.len))\n            // .field(\"pos\", \u0026self.pos)\n            // .field(\"len\", \u0026self.len)\n            .finish()\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":16154},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":4024},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":4024},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":4024},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":4024},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":31},"fn_name":null}],"covered":7,"coverable":10},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resource","tests.rs"],"content":"use super::*;\n\nconst FILE_A: \u0026'static str = \"0123456789\"; // 10 bytes, 1 line\nconst FILE_B: \u0026'static str = \"A\\nBB\\nCCC\\nDDDD\\nEEE\\nFF\\nG\"; // 22 bytes, 7 lines\nconst FILE_C: \u0026'static str = \"module A {\\nB\\n}\\n\"; // 15 bytes, 4 lines\n\n#[test]\nfn source_map_loading() {\n    let mut map = SourceMap::new();\n\n    let a = map.load_raw(AssetIdentifier::raw(\"a\"), FILE_A);\n    assert_eq!(a.alias(), \"a\");\n    assert_eq!(a.source(), FILE_A);\n    assert_eq!(a.source_span(), Span::new(0, 10));\n\n    assert_eq!(\n        map.asset_for(Span::new(0, 7)).map(|v| v.ident.alias()),\n        Some(\"a\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(3, 2)).map(|v| v.ident.alias()),\n        Some(\"a\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(5, 5)).map(|v| v.ident.alias()),\n        Some(\"a\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(5, 7)).map(|v| v.ident.alias()),\n        None\n    );\n\n    let b = map.load_raw(AssetIdentifier::raw(\"b\"), FILE_B);\n    assert_eq!(b.alias(), \"b\");\n    assert_eq!(b.source(), FILE_B);\n    assert_eq!(b.source_span(), Span::new(10, 22));\n\n    assert_eq!(\n        map.asset_for(Span::new(10, 7)).map(|v| v.ident.alias()),\n        Some(\"b\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(15, 10)).map(|v| v.ident.alias()),\n        Some(\"b\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(20, 12)).map(|v| v.ident.alias()),\n        Some(\"b\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(5, 20)).map(|v| v.ident.alias()),\n        None\n    );\n    assert_eq!(\n        map.asset_for(Span::new(31, 5)).map(|v| v.ident.alias()),\n        None\n    );\n\n    let c = map.load_raw(AssetIdentifier::raw(\"c\"), FILE_C);\n    assert_eq!(c.alias(), \"c\");\n    assert_eq!(c.source(), FILE_C);\n    assert_eq!(c.source_span(), Span::new(32, 15));\n\n    assert_eq!(\n        map.asset_for(Span::new(32, 7)).map(|v| v.ident.alias()),\n        Some(\"c\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(37, 8)).map(|v| v.ident.alias()),\n        Some(\"c\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(32, 12)).map(|v| v.ident.alias()),\n        Some(\"c\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(32, 20)).map(|v| v.ident.alias()),\n        None\n    );\n    assert_eq!(\n        map.asset_for(Span::new(31, 5)).map(|v| v.ident.alias()),\n        None\n    );\n}\n\nconst EX0: \u0026'static str = \"include str;\ninclude x;\n\nmodule M {\n    gates {\n        in[5] @input\n    }\n\n    connections {\n        in --\u003e\n    }\n}\n\nentry M;\n// Comment befor EOF\n\";\n\n#[test]\nfn source_map_padded_span() {\n    let mut smap = SourceMap::new();\n    smap.load_raw(\"raw:ex0\", EX0);\n\n    // Full padding.\n    let span = EX0.bytes().position(|c| c == b'5').unwrap();\n    let span = Span::new(span, 1);\n\n    let (padded_slice, offset) = smap.slice_padded_for(span);\n    assert_eq!(offset, 2);\n    assert_eq!(\n        padded_slice,\n        \"module M {\\n    gates {\\n        in[5] @input\\n    }\\n\"\n    );\n\n    // Trunc end\n    let span = EX0.bytes().position(|c| c == b'y').unwrap();\n    let span = Span::new(span, 1);\n\n    let (padded_slice, offset) = smap.slice_padded_for(span);\n    assert_eq!(offset, 2);\n    assert_eq!(padded_slice, \"}\\n\\nentry M;\\n// Comment befor EOF\");\n\n    // Trunc start (offset 1)\n    let span = EX0.bytes().position(|c| c == b'x').unwrap();\n    let span = Span::new(span, 1);\n\n    let (padded_slice, offset) = smap.slice_padded_for(span);\n    assert_eq!(offset, 1);\n    assert_eq!(padded_slice, \"include str;\\ninclude x;\\n\\nmodule M {\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","util.rs"],"content":"// calculates the cyles in a dependency graph\npub fn dfs_cycles(topo: \u0026[Vec\u003cusize\u003e]) -\u003e std::result::Result\u003cVec\u003cVec\u003cbool\u003e\u003e, Vec\u003cVec\u003cusize\u003e\u003e\u003e {\n    // inner dfs to seach for all cycles back to the root.\n    fn _dfs(\n        i: usize,\n        s: usize,\n        v: \u0026mut [bool],\n        p: \u0026mut Vec\u003cusize\u003e,\n        t: \u0026[Vec\u003cusize\u003e],\n        c: \u0026mut Vec\u003cVec\u003cusize\u003e\u003e,\n    ) {\n        if v[i] {\n            // Node allready visited\n            if i == s {\n                c.push(p.clone())\n            }\n        } else {\n            v[i] = true;\n            p.push(i);\n            for \u0026e in \u0026t[i] {\n                _dfs(e, s, v, p, t, c);\n            }\n            p.pop();\n        }\n    }\n\n    // iterate over all possible routes, and find all route specific cyless\n    let mut cycles = Vec::new();\n    let mut reachability = Vec::new();\n    for s in 0..topo.len() {\n        let mut visited = vec![false; topo.len()];\n        let mut prev = Vec::with_capacity(topo.len());\n        _dfs(s, s, \u0026mut visited, \u0026mut prev, topo, \u0026mut cycles);\n        reachability.push(visited);\n    }\n\n    if cycles.is_empty() {\n        return Ok(reachability);\n    }\n\n    // dedup the found cylces\n    let mut i = 0;\n    while i \u003c cycles.len() {\n        // Consider i unquie, remove all duplicates of cycle i\n        let s = cycles[i][0];\n\n        // Iteate over all remaining elements, maybe dropping them if dup\n        let mut k = i + 1;\n        'outer: while k \u003c cycles.len() {\n            // Cyles sizes must match, is assumed in the following\n            if cycles[i].len() != cycles[k].len() {\n                k += 1;\n                continue 'outer;\n            }\n\n            // Find the start point of the cycle\n            // by using index 0 of the first occurence, we ensure that nodes lower i\n            // tend to be the start point of cycles\n            let Some(p) = cycles[k].iter().position(|\u0026v| s == v) else {\n                k += 1;\n                continue 'outer;\n            };\n\n            // If all elements (at offset) match remove the cyles\n            // else it is a different cylce with shared nodes.\n            let n = cycles[i].len();\n            for o in 1..n {\n                if cycles[i][o] != cycles[k][(p + o) % n] {\n                    k += 1;\n                    continue 'outer;\n                }\n            }\n\n            cycles.remove(k);\n        }\n\n        i += 1;\n    }\n\n    Err(cycles)\n}\n","traces":[{"line":2,"address":[],"length":0,"stats":{"Line":750},"fn_name":null},{"line":4,"address":[],"length":0,"stats":{"Line":2598},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":2598},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":978},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2370},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":2370},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2418},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1584},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2370},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":750},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":750},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2778},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1014},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1014},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1014},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1014},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":750},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":708},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":42},"fn_name":null}],"covered":33,"coverable":37},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","common.rs"],"content":"#[macro_export]\nmacro_rules! check_err {\n    ($e:expr =\u003e $code:expr, $msg:literal) =\u003e {\n        let e = $e.unwrap();\n        assert_eq!(e.kind, $code);\n        assert!(e.span.is_some());\n        assert_eq!(format!(\"{}\", e.internal), $msg);\n        assert!(e.solution().is_none())\n    };\n    ($e:expr =\u003e $code:expr, $msg:literal, $solution:expr) =\u003e {\n        let e = $e.unwrap();\n        assert_eq!(e.kind, $code);\n        assert!(e.span.is_some());\n        assert_eq!(format!(\"{}\", e.internal), $msg);\n        assert_eq!(e.solution().unwrap().description, $solution);\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","cyclic.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn cyclic_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/cyclic_baseline/main.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.submodules[0].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[1].typ.as_module().unwrap().ident.raw, \"B\");\n\n    Ok(())\n}\n\n#[test]\nfn cyclic_includes() {\n    let err = Context::load(\"tests/cyclic_includes/main.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::CyclicDeps,\n        \"found cyclic includes: sub1 \u003c- sub2 \u003c- sub3 \u003c- sub1\"\n    );\n}\n\n#[test]\nfn cyclic_local_links() {\n    let err = Context::load(\"tests/cyclic_local_links.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::LinkLocalCyclicDeps,\n        \"found cyclic definition of local links: A \u003c- B \u003c- C \u003c- A\"\n    );\n}\n\n#[test]\nfn cyclic_local_modules() {\n    let err = Context::load(\"tests/cyclic_local_modules.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleLocalCyclicDeps,\n        \"found cyclic definition of local modules: A \u003c- B \u003c- C \u003c- A\"\n    );\n}\n\n#[test]\nfn cyclic_local_selfreferential() {\n    let err = Context::load(\"tests/cyclic_local_selfreferential.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 4);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::LinkLocalCyclicDeps,\n        \"found cyclic definition of local links: LDirect \u003c- LDirect\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::LinkLocalCyclicDeps,\n        \"found cyclic definition of local links: LIndirect1 \u003c- LIndirect2 \u003c- LIndirect1\"\n    );\n\n    check_err!(errs.get(2) =\u003e\n        ErrorKind::ModuleLocalCyclicDeps,\n        \"found cyclic definition of local modules: Direct \u003c- Direct\"\n    );\n\n    check_err!(errs.get(3) =\u003e\n        ErrorKind::ModuleLocalCyclicDeps,\n        \"found cyclic definition of local modules: IndirectA \u003c- IndirectB \u003c- IndirectA\"\n    );\n}\n\n#[test]\nfn cyclic_module_inh() {\n    let err = Context::load(\"tests/cyclic_module_inh.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleLocalCyclicDeps,\n        \"found cyclic definition of local modules: A \u003c- C \u003c- B \u003c- A\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::ModuleLocalCyclicDeps,\n        \"found cyclic definition of local modules: H1 \u003c- H2 \u003c- H1\"\n    );\n}\n\n#[test]\nfn cyclic_dependable() {\n    let err = Context::load(\"tests/cyclic_dependable/main.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleLocalCyclicDeps,\n        \"found cyclic definition of local modules: A \u003c- B \u003c- A\"\n    );\n\n    // cause cyclic will not be loaded\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find inheritance symbol 'B', not in scope\",\n        \"try including 'B' from '../sub'\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","dyn.rs"],"content":"use des_ndl::ast::ModuleTypus;\nuse des_ndl::error::*;\nuse des_ndl::ir::Item;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn dyn_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/dyn_baseline.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n    let ir = \u0026ctx.ir.values().collect::\u003cVec\u003c_\u003e\u003e()[0].items;\n    let Item::Module(ref basic) = ir[0] else {\n        unreachable!()\n    };\n    assert_eq!(basic.ident.raw, \"Basic\");\n    assert_eq!(\n        basic\n            .inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        Vec::\u003cString\u003e::new()\n    );\n    assert_eq!(basic.ast.typus(), ModuleTypus::Primal);\n\n    let Item::Module(ref a) = ir[1] else {\n        unreachable!()\n    };\n    assert_eq!(a.ident.raw, \"A\");\n    assert_eq!(\n        a.inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        vec![\"Basic\".to_string()]\n    );\n    assert_eq!(a.ast.typus(), ModuleTypus::Inherited);\n\n    let Item::Module(ref b) = ir[2] else {\n        unreachable!()\n    };\n    assert_eq!(b.ident.raw, \"B\");\n    assert_eq!(\n        b.inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        vec![\"Basic\".to_string()]\n    );\n    assert_eq!(b.ast.typus(), ModuleTypus::Inherited);\n\n    let Item::Module(ref dyn_m) = ir[3] else {\n        unreachable!()\n    };\n    assert_eq!(dyn_m.ident.raw, \"Dyn\");\n    assert_eq!(\n        dyn_m\n            .inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        Vec::\u003cString\u003e::new()\n    );\n    assert_eq!(dyn_m.ast.typus(), ModuleTypus::Dynamic);\n\n    // follow entry\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.gates.len(), 0);\n    assert_eq!(entry.submodules[0].dynamic, false);\n\n    let sub1 = entry.submodules[0].typ.as_module_arc().unwrap();\n    assert_eq!(sub1.ident.raw, \"Dyn\");\n    assert_eq!(sub1.gates.len(), 0);\n    assert_eq!(sub1.submodules[0].dynamic, false);\n\n    let sub2 = sub1.submodules[0].typ.as_module_arc().unwrap();\n    assert_eq!(sub2.ident.raw, \"A\");\n    assert_eq!(sub2.gates.len(), 2);\n    // assert_eq!(sub2.submodules[0].dynamic, false);\n\n    Ok(())\n}\n\n#[test]\nfn dyn_constraint_broken() {\n    let err = Context::load(\"tests/dyn_constraint_broken.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleDynConstraintsBroken,\n        \"module 'A' does not inherit 'Basic', thus cannot be assigned to dyn field 'sub'\"\n    );\n}\n\n#[test]\nfn dyn_non_resovle_dyn_spec() {\n    let err = Context::load(\"tests/dyn_non_resovle_dyn_spec.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find submodule symbol 'WrongSymbol', not in scope\"\n    );\n\n    // This test ensures that the dyn clause is completely ignored, thus throwing no errors\n    // additionally the symbol M should still exist\n\n    // thus T whould be fully valid\n}\n\n#[test]\nfn dyn_unknown_key() {\n    let err = Context::load(\"tests/dyn_unknown_key.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find submodule symbol for dyn-spec 'wrongkey', not in scope\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::ModuleDynNotResolved,\n        \"missing specification for dynamic members of submodule 'd': missing fields 'sub'\"\n    );\n}\n\n#[test]\nfn dyn_unknown_value() {\n    let err = Context::load(\"tests/dyn_unknown_value.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find dyn-spec submodule symbol 'Wrong', not in scope\"\n    );\n}\n\n#[test]\nfn dyn_extending_override() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/dyn_extending_override.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n    let ir = \u0026ctx.ir.values().collect::\u003cVec\u003c_\u003e\u003e()[0].items;\n    let Item::Module(ref basic) = ir[0] else {\n        unreachable!()\n    };\n    assert_eq!(basic.ident.raw, \"Basic\");\n    assert_eq!(\n        basic\n            .inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        Vec::\u003cString\u003e::new()\n    );\n    assert_eq!(basic.ast.typus(), ModuleTypus::Primal);\n\n    let Item::Module(ref a) = ir[1] else {\n        unreachable!()\n    };\n    assert_eq!(a.ident.raw, \"A\");\n    assert_eq!(\n        a.inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        vec![\"Basic\".to_string()]\n    );\n    assert_eq!(a.ast.typus(), ModuleTypus::Inherited);\n\n    let Item::Module(ref b) = ir[2] else {\n        unreachable!()\n    };\n    assert_eq!(b.ident.raw, \"B\");\n    assert_eq!(\n        b.inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        vec![\"Basic\".to_string()]\n    );\n    assert_eq!(b.ast.typus(), ModuleTypus::Inherited);\n\n    let Item::Module(ref dyn_m) = ir[3] else {\n        unreachable!()\n    };\n    assert_eq!(dyn_m.ident.raw, \"Dyn\");\n    assert_eq!(\n        dyn_m\n            .inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        Vec::\u003cString\u003e::new()\n    );\n    assert_eq!(dyn_m.ast.typus(), ModuleTypus::Dynamic);\n\n    // follow entry\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.gates.len(), 0);\n    assert_eq!(entry.submodules[0].dynamic, false);\n\n    let sub1 = entry.submodules[0].typ.as_module_arc().unwrap();\n    assert_eq!(sub1.ident.raw, \"Dyn\");\n    assert_eq!(sub1.gates.len(), 0);\n    assert_eq!(sub1.submodules[0].dynamic, false);\n\n    let sub2 = sub1.submodules[0].typ.as_module_arc().unwrap();\n    assert_eq!(sub2.ident.raw, \"A\");\n    assert_eq!(sub2.gates.len(), 3);\n    // assert_eq!(sub2.submodules[0].dynamic, false);\n\n    Ok(())\n}\n\n#[test]\nfn dyn_not_resolved() {\n    let err = Context::load(\"tests/dyn_not_resolved.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleDynNotResolved,\n        \"missing specification for dynamic members of submodule 'd': missing fields 'sub'\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::ModuleDynNotResolved,\n        \"missing specification for dynamic members of submodule 'b': missing fields 'a, c'\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","gates_ast.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::Cluster;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn gates_ast_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/gates_ast_baseline.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.gates.len(), 4);\n\n    assert_eq!(entry.gates[0].ident.raw, \"in\");\n    assert_eq!(entry.gates[0].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.gates[1].ident.raw, \"out\");\n    assert_eq!(entry.gates[1].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.gates[2].ident.raw, \"influx\");\n    assert_eq!(entry.gates[2].cluster, Cluster::Clusted(5));\n\n    assert_eq!(entry.gates[3].ident.raw, \"outflow\");\n    assert_eq!(entry.gates[3].cluster, Cluster::Clusted(1));\n\n    Ok(())\n}\n\n#[test]\nfn gates_ast_nodelim() {\n    let err = Context::load(\"tests/gates_ast_nodelim.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ExpectedDelimited,\n        \"expected delimited sequence, found ';'\"\n    );\n}\n\n#[test]\nfn gates_ast_wrong_delim() {\n    let err = Context::load(\"tests/gates_ast_wrong_delim.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedDelim,\n        \"expected delimited sequence '{ ... }', found delimited sequence '[ ... ]'\"\n    );\n}\n\n\n#[test]\nfn gates_ast_symbol_dup() {\n    let err = Context::load(\"tests/gates_ast_symbol_dup.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleGatesDuplicatedSymbols,\n        \"gate(-cluster) 'influx' was defined multiple times\"\n    );\n}\n\n#[test]\nfn gates_ast_invalid_cluster() {\n    let err = Context::load(\"tests/gates_ast_invalid_cluster.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 4);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::InvalidLitTyp,\n        \"cannot create gate-cluster with literal of type float, expected literal of type integer\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::InvalidLitTyp,\n        \"cannot create gate-cluster with literal of type string, expected literal of type integer\"\n    );\n\n    check_err!(errs.get(2) =\u003e\n        ErrorKind::ModuleGatesInvalidClusterSize,\n        \"cannot create gate-cluster of size '0', requires positiv integer\"\n    );\n\n    check_err!(errs.get(3) =\u003e\n        ErrorKind::ModuleGatesInvalidClusterSize,\n        \"cannot create gate-cluster of size '-1', requires positiv integer\"\n    );\n}\n\n#[test]\nfn gates_ast_invalid_punct() {\n    let err = Context::load(\"tests/gates_ast_invalid_punct.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"expected \u003cident\u003e, found ','\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","gates_ir.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::Cluster;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn gates_ir_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/gates_ir_baseline.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.gates.len(), 4);\n\n    assert_eq!(entry.gates[0].ident.raw, \"in\");\n    assert_eq!(entry.gates[0].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.gates[1].ident.raw, \"out\");\n    assert_eq!(entry.gates[1].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.gates[2].ident.raw, \"influx\");\n    assert_eq!(entry.gates[2].cluster, Cluster::Clusted(5));\n\n    assert_eq!(entry.gates[3].ident.raw, \"outflow\");\n    assert_eq!(entry.gates[3].cluster, Cluster::Clusted(1));\n\n    Ok(())\n}\n\n#[test]\nfn gates_ir_local_dup() {\n    let err = Context::load(\"tests/gates_ir_local_dup.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolDuplication,\n        \"gate(-cluster) 'in' was defined multiple times\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","link_ast.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::{Item, Literal};\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn link_ast_baseline() -\u003e RootResult\u003c()\u003e {\n    let ctx = Context::load(\"tests/link_ir_baseline.ndl\")?;\n    let ir = ctx.ir.values().collect::\u003cVec\u003c_\u003e\u003e()[0];\n\n    assert!(matches!(ir.items[0], Item::Link(_)));\n    assert!(matches!(ir.items[1], Item::Link(_)));\n    assert!(matches!(ir.items[2], Item::Link(_)));\n\n    let a = ir.link(\"A\").unwrap();\n    let b = ir.link(\"B\").unwrap();\n    let c = ir.link(\"C\").unwrap();\n\n    assert_eq!(a.ident.raw, \"A\");\n    assert_eq!(b.ident.raw, \"B\");\n    assert_eq!(c.ident.raw, \"C\");\n\n    assert_eq!(a.jitter, 0.2);\n    assert_eq!(b.jitter, 0.2);\n    assert_eq!(c.jitter, 1.0);\n\n    assert_eq!(a.fields.get(\"bparam\"), None);\n    assert_eq!(\n        b.fields.get(\"bparam\"),\n        Some(\u0026Literal::String(\"string\".to_string()))\n    );\n    assert_eq!(\n        c.fields.get(\"bparam\"),\n        Some(\u0026Literal::String(\"strong\".to_string()))\n    );\n\n    Ok(())\n}\n\n#[test]\nfn link_ast_noident() {\n    let err = Context::load(\"tests/link_ast_noident.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"unexpected token for link symbol: expected \u003cident\u003e, found delim\"\n    );\n}\n\n#[test]\nfn link_ast_invalid_inh() {\n    let err = Context::load(\"tests/link_ast_invalid_inh.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"failed to parse value in joined statement: expected \u003cident\u003e, found delim\"\n    );\n}\n\n#[test]\nfn link_ast_invalid_kv() {\n    let err = Context::load(\"tests/link_ast_invalid_kv.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"missing delimiter in key-value pair: expected ':', found \u003cliteral\u003e\"\n    );\n}\n\n#[test]\nfn link_ast_invalid_kv2() {\n    let err = Context::load(\"tests/link_ast_invalid_kv2.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"missing value in key-value pair: expected \u003cliteral\u003e, found \u003cident\u003e\"\n    );\n}\n\n#[test]\nfn link_ast_nodelim() {\n    let err = Context::load(\"tests/link_ast_nodelim.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ExpectedDelimited,\n        \"expected delimited sequence, found 'module'\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","link_ir.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::{Item, Literal};\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn link_ir_baseline() -\u003e RootResult\u003c()\u003e {\n    let ctx = Context::load(\"tests/link_ir_baseline.ndl\")?;\n    let ir = ctx.ir.values().collect::\u003cVec\u003c_\u003e\u003e()[0];\n\n    assert!(matches!(ir.items[0], Item::Link(_)));\n    assert!(matches!(ir.items[1], Item::Link(_)));\n    assert!(matches!(ir.items[2], Item::Link(_)));\n\n    let a = ir.link(\"A\").unwrap();\n    let b = ir.link(\"B\").unwrap();\n    let c = ir.link(\"C\").unwrap();\n\n    assert_eq!(a.ident.raw, \"A\");\n    assert_eq!(b.ident.raw, \"B\");\n    assert_eq!(c.ident.raw, \"C\");\n\n    assert_eq!(a.jitter, 0.2);\n    assert_eq!(b.jitter, 0.2);\n    assert_eq!(c.jitter, 1.0);\n\n    assert_eq!(a.fields.get(\"bparam\"), None);\n    assert_eq!(\n        b.fields.get(\"bparam\"),\n        Some(\u0026Literal::String(\"string\".to_string()))\n    );\n    assert_eq!(\n        c.fields.get(\"bparam\"),\n        Some(\u0026Literal::String(\"strong\".to_string()))\n    );\n\n    Ok(())\n}\n\n#[test]\nfn link_ir_inh() {\n    let err = Context::load(\"tests/link_ir_inh.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find link symbol 'C', not in scope\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find link symbol 'C', not in scope\"\n    );\n}\n\n#[test]\nfn link_ir_inh_with_solutions() {\n    let err = Context::load(\"tests/link_ir_inh2/main.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find link symbol 'C', not in scope\",\n        \"try including 'C' from '../sub1'\"\n\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find link symbol 'C', not in scope\",\n        \"try including 'C' from '../sub1'\"\n    );\n}\n\n#[test]\nfn link_ir_inh_dup() {\n    let err = Context::load(\"tests/link_ir_inh_dup.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::LinkInheritanceDuplicatedSymbols,\n        \"found duplicated symbol 'C' in link inheritance statement\"\n    );\n}\n\n#[test]\nfn link_ir_known_values() {\n    let err = Context::load(\"tests/link_ir_known_values.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::LinkKnownKeysInvalidValue,\n        \"known key 'jitter' expects a value of type float\"\n    );\n}\n\n#[test]\nfn link_ir_local_dup() {\n    let err = Context::load(\"tests/link_ir_local_dup.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolDuplication,\n        \"cannot create new symbol 'A', was allready defined\"\n    );\n}\n\n#[test]\nfn link_ir_nonlocal_dup() {\n    let err = Context::load(\"tests/link_ir_nonlocal_dup/main.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolDuplication,\n        \"found duplicated symbol 'A', with 1 duplications\"\n    );\n}\n\n#[test]\nfn link_ir_requried_values() {\n    let err = Context::load(\"tests/link_ir_required_values.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::LinkMissingRequiredFields,\n        \"missing required field 'latency', was not defined locally or in prototypes\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::LinkMissingRequiredFields,\n        \"missing required field 'bitrate', was not defined locally or in prototypes\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","module_ast.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::Cluster;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn module_ast_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/module_ast_baseline.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n\n    assert_eq!(entry.ident.raw, \"Main\");\n\n    assert_eq!(entry.gates.len(), 4);\n    // inh\n    assert_eq!(entry.gates[0].ident.raw, \"in\");\n    assert_eq!(entry.gates[0].cluster, Cluster::Standalone);\n    assert_eq!(entry.gates[1].ident.raw, \"out\");\n    assert_eq!(entry.gates[1].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.gates[2].ident.raw, \"uplink\");\n    assert_eq!(entry.gates[2].cluster, Cluster::Clusted(2));\n    assert_eq!(entry.gates[3].ident.raw, \"downlink\");\n    assert_eq!(entry.gates[3].cluster, Cluster::Clusted(2));\n\n    assert_eq!(\n        entry.submodules[0].typ.as_module().unwrap().ident.raw,\n        \"Sub\"\n    );\n    let sub = entry.submodules[0].typ.as_module().unwrap();\n    assert_eq!(sub.connections, vec![]);\n    assert_eq!(sub.submodules, vec![]);\n\n    assert_eq!(sub.gates.len(), 2);\n\n    assert_eq!(sub.gates[0].ident.raw, \"in\");\n    assert_eq!(sub.gates[0].cluster, Cluster::Standalone);\n    assert_eq!(sub.gates[1].ident.raw, \"out\");\n    assert_eq!(sub.gates[1].cluster, Cluster::Standalone);\n\n    Ok(())\n}\n\n#[test]\nfn module_ast_noident() {\n    let err = Context::load(\"tests/module_ast_noident.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"unexpected token for module symbol: expected \u003cident\u003e, found delim\"\n    );\n}\n\n#[test]\nfn module_ast_noident2() {\n    let err = Context::load(\"tests/module_ast_noident2.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"unexpected token for module symbol: expected \u003cident\u003e, found \u003cliteral\u003e\"\n    );\n}\n\n#[test]\nfn module_ast_nodelim() {\n    let err = Context::load(\"tests/module_ast_nodelim.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ExpectedDelimited,\n        \"expected delimited sequence, found EOF\"\n    );\n}\n\n#[test]\nfn module_ast_nodelim2() {\n    let err = Context::load(\"tests/module_ast_nodelim2.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ExpectedDelimited,\n        \"expected delimited sequence, found ';'\"\n    );\n}\n\n#[test]\nfn module_ast_invalid_inh() {\n    let err = Context::load(\"tests/module_ast_invalid_inh.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"failed to parse value in joined statement: expected \u003cident\u003e, found delim\"\n    );\n}\n\n#[test]\nfn module_ast_invalid_inh2() {\n    let err = Context::load(\"tests/module_ast_invalid_inh2.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleInheritanceDuplicatedSymbols,\n        \"found duplicated symbol 'A' in module inheritance statement\"\n    );\n}\n\n#[test]\nfn module_ast_inh_dyn() {\n    let err = Context::load(\"tests/module_ast_inh_dyn.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleBothInheritanceAndDyn,\n        \"module is defined with both inheritance and dyn members: not supported\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","submodules_ast.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::Cluster;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn submodules_ast_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/submodules_ast_baseline.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.submodules.len(), 3);\n\n    assert_eq!(entry.submodules[0].ident.raw, \"a\");\n    assert_eq!(entry.submodules[0].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[0].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.submodules[1].ident.raw, \"b\");\n    assert_eq!(entry.submodules[1].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[1].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.submodules[2].ident.raw, \"c\");\n    assert_eq!(entry.submodules[2].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[2].cluster, Cluster::Clusted(4));\n\n    Ok(())\n}\n\n#[test]\nfn submodules_ast_nodelim() {\n    let err = Context::load(\"tests/submodules_ast_nodelim.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ExpectedDelimited,\n        \"expected delimited sequence, found ';'\"\n    );\n}\n\n#[test]\nfn submodules_ast_wrong_delim() {\n    let err = Context::load(\"tests/submodules_ast_wrong_delim.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedDelim,\n        \"expected delimited sequence '{ ... }', found delimited sequence '( ... )'\"\n    );\n}\n\n#[test]\nfn submodules_ast_symbol_dup() {\n    let err = Context::load(\"tests/submodules_ast_symbol_dup.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleSubDuplicatedSymbols,\n        \"submodule(-cluster) 'a' was defined multiple times\"\n    );\n}\n\n#[test]\nfn submodules_ast_missing_ty() {\n    let err = Context::load(\"tests/submodules_ast_missing_ty.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"expected \u003cident\u003e, found ','\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","submodules_ir.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::Cluster;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn submodules_ir_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/submodules_ir_baseline.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.submodules.len(), 3);\n\n    assert_eq!(entry.submodules[0].ident.raw, \"a\");\n    assert_eq!(entry.submodules[0].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[0].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.submodules[1].ident.raw, \"b\");\n    assert_eq!(entry.submodules[1].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[1].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.submodules[2].ident.raw, \"c\");\n    assert_eq!(entry.submodules[2].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[2].cluster, Cluster::Clusted(4));\n\n    Ok(())\n}\n\n#[test]\nfn submodules_ir_local_dup() {\n    let err = Context::load(\"tests/submodules_ir_local_dup.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolDuplication,\n        \"submodule(-cluster) 'a' was defined multiple times\"\n    );\n}\n\n#[test]\nfn submodules_ir_unknown_ty() {\n    let err = Context::load(\"tests/submodules_ir_unknown_ty.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find submodule symbol 'A', not in scope\"\n    );\n}\n\n#[test]\nfn submodules_ir_unknown_ty_soloution() {\n    let err = Context::load(\"tests/submodules_ir_unknown_ty_solution/main.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find submodule symbol 'A', not in scope\",\n        \"try including 'A' from '../sub1'\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","cqueue","main.rs"],"content":"use des::prelude::*;\n\nstruct App {\n    event_delay: Duration,\n    num_events: usize,\n}\nimpl Application for App {\n    type EventSet = EvSet;\n    type Lifecycle = App;\n}\n\nimpl EventLifecycle\u003cApp\u003e for App {\n    fn at_sim_start(rt: \u0026mut Runtime\u003cSelf\u003e) {\n        let mut delay = Duration::ZERO;\n        for _ in 0..rt.app.num_events {\n            rt.add_event_in(EvSet {}, delay);\n            let offset = random::\u003cf64\u003e() * 2.0 * rt.app.event_delay.as_secs_f64();\n            delay += Duration::from_secs_f64(offset);\n        }\n    }\n}\n\nstruct EvSet {}\nimpl EventSet\u003cApp\u003e for EvSet {\n    fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {\n        rt.add_event_in(EvSet {}, rt.app.event_delay);\n        // NOP\n    }\n}\n\nfn main() {\n    let args = std::env::args().collect::\u003cVec\u003c_\u003e\u003e();\n\n    let event_delay: Duration = args\n        .iter()\n        .find(|v| v.starts_with(\"delay=\"))\n        .map(|s| s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1].parse::\u003cf64\u003e().unwrap())\n        .map(Duration::from_secs_f64)\n        .unwrap_or(Duration::from_secs(1));\n\n    let num_events: usize = args\n        .iter()\n        .find(|v| v.starts_with(\"num=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(400);\n\n    let rt = Builder::seeded(123).max_time(100_000.0.into()).build(App {\n        event_delay,\n        num_events,\n    });\n\n    let _ = rt.run();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","droptest","main.rs"],"content":"use des::{prelude::*, registry};\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\nmod modules;\npub use modules::*;\n\nstatic MODULE_LEN: AtomicUsize = AtomicUsize::new(0);\n\nfn main() {\n    let app = Sim::ndl(\"examples/droptest/main.ndl\", registry![Network, Bob, Alice])\n        .map_err(|e| println!(\"{e}\"))\n        .unwrap();\n\n    let rt = Builder::seeded(0x123).build(app);\n\n    let (app, time, p) = rt.run().unwrap();\n    let globals = app.globals();\n    drop(app);\n\n    // println!(\"{:?}\", globals);\n\n    drop(globals);\n\n    // // Assume full drop.\n    assert_eq!(MODULE_LEN.load(Ordering::SeqCst), 0);\n\n    assert_eq!(p.event_count, 6);\n    assert_eq!(time.as_millis(), 387)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","droptest","modules.rs"],"content":"use std::sync::atomic::Ordering;\n\nuse crate::MODULE_LEN;\nuse des::prelude::*;\n\n#[derive(Default)]\npub struct Alice();\n\nimpl Module for Alice {\n    fn at_sim_start(\u0026mut self, _: usize) {\n        let msg = Message::new().kind(1).content(42usize).build();\n        send(msg, (\"netOut\", 0));\n\n        println!(\"SimStared\");\n        let prev = MODULE_LEN.fetch_add(1, Ordering::SeqCst);\n        println!(\"Alice simstared: MODULE_LEN := {}\", prev + 1)\n    }\n\n    fn handle_message(\u0026mut self, _: Message) {\n        // let (msg, head) = msg.cast::\u003cusize\u003e();\n        // println!(\"Received msg: {} - {:?}\", msg, head);\n    }\n}\n\nimpl Drop for Alice {\n    fn drop(\u0026mut self) {\n        println!(\"\u003cDROP\u003e Alice\");\n        MODULE_LEN.fetch_sub(1, Ordering::SeqCst);\n    }\n}\n\n#[derive(Default)]\npub struct Bob();\n\nimpl Module for Bob {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        let prev = MODULE_LEN.fetch_add(1, Ordering::SeqCst);\n        println!(\"Bob simstared: MODULE_LEN := {}\", prev + 1)\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        let (msg, _) = msg.cast::\u003cusize\u003e();\n\n        // println!(\"Received msg: {} - {:?}\", msg, head);\n\n        let msg = Message::new().kind(2).content(msg).build();\n        send(msg, (\"netOut\", 0))\n    }\n}\n\nimpl Drop for Bob {\n    fn drop(\u0026mut self) {\n        println!(\"\u003cDROP\u003e Bob\");\n        MODULE_LEN.fetch_sub(1, Ordering::SeqCst);\n    }\n}\n\n#[derive(Default)]\npub struct Network();\n\nimpl Module for Network {\n    fn at_sim_start(\u0026mut self, _: usize) {\n        let prev = MODULE_LEN.fetch_add(1, Ordering::SeqCst);\n        println!(\"Network simstared: MODULE_LEN := {}\", prev + 1);\n    }\n\n    fn handle_message(\u0026mut self, _: Message) {\n        unimplemented!()\n    }\n}\n\nimpl Drop for Network {\n    fn drop(\u0026mut self) {\n        println!(\"\u003cDROP\u003e Network\");\n        MODULE_LEN.fetch_sub(1, Ordering::SeqCst);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","multisim","main.rs"],"content":"use std::sync::atomic::Ordering::SeqCst;\nuse std::sync::{atomic::AtomicUsize, Arc, Barrier};\nuse std::thread;\n\nuse des::prelude::*;\n\nfn main() {\n    let n = 5;\n    let mut handles = Vec::with_capacity(n);\n\n    let barrier = Arc::new(Barrier::new(n));\n    let active = Arc::new(AtomicUsize::new(0));\n    let counter = Arc::new(AtomicUsize::new(0));\n\n    for _ in 0..n {\n        let barrier_c = barrier.clone();\n        let active_c = active.clone();\n        let counter_c = counter.clone();\n\n        handles.push(thread::spawn(move || {\n            create_runtime_and_wait(barrier_c, active_c, counter_c)\n        }))\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    assert_eq!(active.load(SeqCst), 0);\n    assert_eq!(counter.load(SeqCst), n)\n}\n\nfn create_runtime_and_wait(\n    barrier: Arc\u003cBarrier\u003e,\n    active: Arc\u003cAtomicUsize\u003e,\n    counter: Arc\u003cAtomicUsize\u003e,\n) {\n    barrier.wait();\n\n    // Create runtime\n    let app = Sim::new(());\n\n    let rt = Builder::new().build(app);\n    let prev = active.fetch_add(1, SeqCst);\n    assert_eq!(prev, 0);\n    counter.fetch_add(1, SeqCst);\n\n    // Do work\n    thread::sleep(Duration::from_millis(500));\n\n    // Deregister\n    let prev = active.fetch_sub(1, SeqCst);\n    assert_eq!(prev, 1);\n\n    drop(rt);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","ndl","main.rs"],"content":"use des::{prelude::*, registry};\n\nmod members;\nuse members::*;\n\n#[derive(Debug, Default)]\nstruct A;\n\nimpl Module for A {}\n\nfn main() {\n    let app = Sim::ndl(\"examples/ndl/main.ndl\", registry![A, Alice, Bob]).unwrap();\n\n    let rt = Builder::seeded(0x123).build(app);\n\n    let (_, time, profile) = rt.run().unwrap();\n\n    // assert_eq!(tie, 18224.956482853);\n\n    assert_eq!(time.as_secs(), 12279);\n    assert_eq!(profile.event_count, 18_001_000);\n\n    // profile\n    //     .write_to(\"examples/ndl/bench\")\n    //     .expect(\"Failed to write bench\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","ndl","members.rs"],"content":"use std::ops::Deref;\n\nuse des::prelude::*;\nuse tracing::info;\n\n#[derive(Default)]\npub struct Alice();\n\nimpl Module for Alice {\n    fn handle_message(\u0026mut self, msg: Message) {\n        let mut pkt = msg;\n        info!(\n            \"Received at {}: Message with content: {}\",\n            SimTime::now(),\n            pkt.content::\u003cString\u003e().deref()\n        );\n\n        if pkt.header().id \u003e 60_000 {\n            // TERMINATE\n        } else {\n            pkt.header_mut().id += 1;\n            send(pkt, (\"netOut\", 0))\n        }\n    }\n}\n\n#[derive(Default)]\npub struct Bob();\n\nimpl Module for Bob {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        schedule_in(\n            Message::new()\n                .kind(0xff)\n                .content(\"Init\".to_string())\n                .build(),\n            Duration::ZERO,\n        )\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        if msg.header().kind == 0xff {\n            info!(target: \"Bob\", \"Initalizing\");\n            drop(msg);\n            info!(target: \"Bob\", \"Dropped init msg\");\n            send(\n                Message::new()\n                    .kind(1)\n                    // .src(0x7f_00_00_01, 80)\n                    // .dest(0x7f_00_00_02, 80)\n                    .id(0)\n                    .content(\"Ping\".to_string())\n                    .build(),\n                (\"netOut\", 2),\n            );\n        } else {\n            let mut pkt = msg;\n            pkt.header_mut().id += 1;\n\n            info!(\n                \"Received at {}: Message with content: {}\",\n                SimTime::now(),\n                pkt.content::\u003cString\u003e().deref()\n            );\n\n            pkt.content_mut::\u003cString\u003e().push('#');\n\n            send(pkt, (\"netOut\", 2));\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","ndl2","main.rs"],"content":"use des::{prelude::*, registry};\n\n#[derive(Default)]\nstruct Sub;\nimpl Module for Sub {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        if current().name() == \"a\" {\n            send(Message::new().build(), \"out\");\n        }\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        send(msg, \"out\");\n        tracing::info!(\"EY\");\n    }\n}\n\n#[derive(Default)]\nstruct Main;\nimpl Module for Main {\n    fn at_sim_end(\u0026mut self) {\n        tracing::info!(target: \"custom\", \"at sim end\")\n    }\n}\n\nfn main() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Debug)\n    //     .set_logger();\n\n    let app = match Sim::ndl(\"examples/ndl2/main.ndl\", registry![Main, Sub]) {\n        Ok(v) =\u003e v,\n        Err(e) =\u003e {\n            println!(\"{e}\");\n            panic!(\"exiting due to previouis error\")\n        }\n    };\n    let rt = Builder::seeded(123).max_itr(10).build(app);\n    let _ = rt.run();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","plugin","main.rs"],"content":"use des::{\n    net::{\n        module::{set_setup_fn, ModuleContext},\n        processing::ProcessingElement,\n    },\n    prelude::*,\n    registry,\n};\n\n#[derive(Default)]\nstruct A {}\n\nimpl Module for A {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        send(Message::new().content(42).build(), \"out\");\n        send(Message::new().content(69).build(), \"out\");\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        let span = ::tracing::span!(::tracing::Level::INFO, \"a-recv\", age = 2, size = 3);\n        let _g = span.enter();\n        tracing::info!(\"recv: {} {}\", msg.str(), msg.content::\u003ci32\u003e())\n    }\n}\n\n#[derive(Default)]\nstruct PacketCounter {\n    count: usize,\n}\n\nimpl ProcessingElement for PacketCounter {\n    fn incoming(\u0026mut self, msg: Message) -\u003e Option\u003cMessage\u003e {\n        self.count += 1;\n        Some(msg)\n    }\n}\n\nimpl Drop for PacketCounter {\n    fn drop(\u0026mut self) {\n        assert_eq!(self.count, 2);\n    }\n}\n\n#[derive(Default)]\nstruct B {}\n\nimpl Module for B {\n    fn stack(\u0026self) -\u003e impl ProcessingElement + 'static\n    where\n        Self: Sized,\n    {\n        PacketCounter::default()\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        send(msg, \"out\")\n    }\n}\n\n#[derive(Default)]\nstruct Main;\nimpl Module for Main {}\n\nfn empty(_: \u0026ModuleContext) {}\n\nfn main() {\n    // Logger::new().set_logger();\n    // tracing_subscriber::fmt()\n    //     .with_max_level(LevelFilter::TRACE)\n    //     .init();\n\n    des::tracing::init();\n\n    // Subscriber::default().init().unwrap();\n\n    set_setup_fn(empty);\n\n    let app = Sim::ndl(\"examples/plugin/main.ndl\", registry![A, B, Main]).unwrap();\n    let rt = Builder::new().build(app);\n    let _res = rt.run();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","proto","main.rs"],"content":"use des::{prelude::*, registry};\n\n#[derive(Debug, Default)]\nstruct AppA {}\n\nimpl Module for AppA {\n    fn handle_message(\u0026mut self, _msg: Message) {\n        println!(\"A: [{}] {:?}\", SimTime::now(), _msg);\n        assert_eq!(SimTime::now(), 1.0);\n    }\n}\n\n#[derive(Debug, Default)]\nstruct AppB {}\n\nimpl Module for AppB {\n    fn handle_message(\u0026mut self, _msg: Message) {\n        println!(\"B: [{}] {:?}\", SimTime::now(), _msg);\n        assert_eq!(SimTime::now(), 2.0);\n    }\n}\n\n#[derive(Debug, Default)]\nstruct Runner {}\n\nimpl Module for Runner {\n    fn handle_message(\u0026mut self, _msg: Message) {}\n}\n\n#[derive(Debug, Default)]\nstruct MultiRunner {}\n\nimpl Module for MultiRunner {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        schedule_at(Message::new().kind(42).build(), 1.0.into());\n    }\n\n    fn handle_message(\u0026mut self, mut msg: Message) {\n        // println!(\"M: [{}] {:?}\", SimTime::now(), msg);\n        if msg.header().kind == 42 {\n            let mut dup = msg.dup::\u003c()\u003e();\n            dup.header_mut().kind = 123;\n            send(dup, (\"toAppl\", 0));\n            // processing_time(Duration::new(1, 0));\n            // println!(\"AAA\");\n            msg.header_mut().kind = 69;\n            send_in(msg, (\"toAppl\", 1), Duration::from_secs(1));\n            schedule_in(Message::new().kind(69).build(), Duration::new(2, 0));\n        } else {\n            // Send at 1.0 with processing 1.0 and delay 1.0\n            assert_eq!(SimTime::now(), 3.0);\n        }\n    }\n}\n\n#[derive(Debug, Default)]\nstruct Main;\nimpl Module for Main {}\n\nfn main() {\n    // Logger::new().try_set_logger().unwrap();\n    let app = Sim::ndl(\n        \"examples/proto/main.ndl\",\n        registry![AppA, AppB, Runner, MultiRunner, Main],\n    )\n    .unwrap();\n\n    // println!(\"{:?}\", app.globals().parameters);\n\n    let rt = Builder::seeded(0x123).build(app);\n    let (app, _time, _event_count) = rt.run().unwrap();\n\n    let _ = app\n        .globals()\n        .topology\n        .lock()\n        .unwrap()\n        .write_to_svg(\"examples/proto/graph\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","ptrhell","main.rs"],"content":"use des::{prelude::*, registry};\n\nmod modules;\npub use modules::*;\n\nfn main() {\n    // Logger::new().try_set_logger().unwrap();\n\n    let app = Sim::ndl(\"examples/ptrhell/main.ndl\", registry![Bob, Alice, Network]).unwrap();\n\n    let rt = Builder::seeded(0x123).build(app);\n\n    let (_, time, p) = rt.run().unwrap();\n\n    assert_eq!(p.event_count, 6);\n    assert_eq!(time.as_millis(), 387)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","ptrhell","modules.rs"],"content":"use des::prelude::*;\n\n#[derive(Debug, Default)]\npub struct Alice();\n\nimpl Module for Alice {\n    fn at_sim_start(\u0026mut self, _: usize) {\n        let msg = Message::new().kind(1).content(42usize).build();\n        send(msg, (\"netOut\", 0));\n\n        tracing::info!(\"SimStared\");\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        let (msg, head) = msg.cast::\u003cusize\u003e();\n        tracing::info!(target: \"inet\", \"Received msg: {} - {:?}\", msg, head);\n    }\n}\n\n#[derive(Debug, Default)]\npub struct Bob();\n\nimpl Module for Bob {\n    fn handle_message(\u0026mut self, msg: Message) {\n        let (msg, head) = msg.cast::\u003cusize\u003e();\n\n        println!(\"Received msg: {} - {:?}\", msg, head);\n\n        let msg = Message::new().kind(2).content(msg).build();\n        send(msg, (\"netOut\", 0))\n    }\n}\n\n#[derive(Debug, Default)]\npub struct Network();\n\nimpl Module for Network {\n    fn handle_message(\u0026mut self, _: Message) {\n        unimplemented!()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","test-bin","main.rs"],"content":"use des::net::AsyncFn;\nuse des::prelude::*;\nuse des::time;\n\nfn main() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|_| async move {\n            tokio::select! {\n                _ = time::sleep(Duration::from_secs(10)) =\u003e unreachable!(),\n                _ = time::sleep(Duration::from_secs(5)) =\u003e println!(\"resolved\"),\n            }\n        })\n        .require_join(),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n    todo!()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","utils","main.rs"],"content":"use des::{prelude::*, registry};\n\nmod members;\nuse members::*;\n\n#[derive(Debug, Default)]\nstruct A;\nimpl Module for A {}\n\nfn main() {\n    let mut app = Sim::ndl(\"examples/utils/main.ndl\", registry![A, Alice, Bob])\n        .map_err(|e| println!(\"{e}\"))\n        .unwrap();\n    app.include_par_file(\"examples/utils/init.par\").unwrap();\n\n    let rt = Builder::seeded(0x123).quiet().build(app);\n    let (app, time, p) = rt.run().unwrap();\n\n    let topo = app.globals().topology.lock().unwrap().clone();\n\n    assert_eq!(topo.nodes().len(), 4 + 1);\n    assert_eq!(topo.edges(), 14);\n\n    let _ = topo.write_to_svg(\"examples/utils/graph\");\n\n    assert_eq!(p.event_count, 48);\n    assert_eq!(time.as_secs(), 83)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","utils","members.rs"],"content":"use std::ops::Deref;\n\nuse des::prelude::*;\n\nuse tracing::info;\n\n#[derive(Debug, Default)]\npub struct Alice();\n\nimpl Module for Alice {\n    fn handle_message(\u0026mut self, msg: Message) {\n        let pkt = msg;\n        info!(\n            \"Received at {}: Message with content: {}\",\n            SimTime::now(),\n            pkt.content::\u003cString\u003e().deref()\n        );\n\n        if pkt.content::\u003cString\u003e().len() \u003e par(\"limit\").unwrap().parse::\u003cusize\u003e().unwrap() {\n            // TERMINATE\n        } else {\n            // pkt.content_mut::\u003cString\u003e().push('#');\n            send(pkt, (\"netOut\", 0))\n        }\n    }\n}\n\n#[derive(Debug, Default)]\npub struct Bob();\n\nimpl Module for Bob {\n    fn num_sim_start_stages(\u0026self) -\u003e usize {\n        2\n    }\n\n    fn at_sim_start(\u0026mut self, stage: usize) {\n        match stage {\n            0 =\u003e {\n                info!(\"Initalizing\");\n                send(\n                    Message::new()\n                        .kind(1)\n                        // .src(0x7f_00_00_01, 80)\n                        // .dest(0x7f_00_00_02, 80)\n                        .content(\"Ping\".to_string())\n                        .build(),\n                    (\"netOut\", 2),\n                );\n            }\n            1 =\u003e {\n                // Nothing\n            }\n            _ =\u003e unreachable!(),\n        }\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        let mut pkt = msg;\n\n        info!(\n            \"Received at {}: Message with content: {}\",\n            SimTime::now(),\n            pkt.content::\u003cString\u003e().deref()\n        );\n\n        pkt.content_mut::\u003cString\u003e().push_str(\u0026par(\"char\").unwrap());\n\n        send(pkt, (\"netOut\", 2));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","waiter","main.rs"],"content":"use rand::distributions::Standard;\nuse std::{collections::VecDeque, fmt::Debug};\n\nuse des::prelude::*;\n\n#[derive(Debug, Clone)]\nstruct Customer {\n    pub arrived: SimTime,\n    pub duration: Duration,\n}\n\n#[derive(Debug)]\nstruct Application {\n    // Params\n    n: usize,\n    l: f64,\n    m: f64,\n    queue: VecDeque\u003cCustomer\u003e,\n    busy: bool,\n\n    // Metrics\n    wait_times: Vec\u003cDuration\u003e,\n    busy_time: SimTime,\n}\n\nimpl Application {\n    fn eval(\u0026self, t: SimTime) {\n        let busy_perc = self.busy_time / t;\n\n        let avg_wait = self\n            .wait_times\n            .iter()\n            .fold(Duration::ZERO, |acc, \u0026i| acc + i)\n            / self.wait_times.len() as u32;\n\n        println!(\"=== Simulation finished ===\");\n        println!(\"l = {} \\tm = {}\", self.l, self.m);\n        println!();\n        println!(\"Finshed at t := {}\", t);\n        println!(\"Busy := {}\", busy_perc);\n        println!(\"(avg) waittime := {:?}\", avg_wait);\n\n        assert!((busy_perc - 0.4996535454771872).abs() \u003c 0.01);\n        assert_eq!(avg_wait, Duration::from_secs_f64(1.002135171))\n    }\n}\n\nimpl des::runtime::Application for Application {\n    type EventSet = Events;\n    type Lifecycle = ();\n}\n\n#[derive(Debug)]\n#[allow(clippy::large_enum_variant)]\nenum Events {\n    ServerDone(ServerDone),\n    CustomerArrival(CustomerArrival),\n}\n\nimpl EventSet\u003cApplication\u003e for Events {\n    fn handle(self, rt: \u0026mut Runtime\u003cApplication\u003e) {\n        match self {\n            Self::ServerDone(event) =\u003e event.handle(rt),\n            Self::CustomerArrival(event) =\u003e event.handle(rt),\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct ServerDone {\n    started: SimTime,\n    _pad: [u8; 300],\n}\n\nimpl ServerDone {\n    fn handle(self, rt: \u0026mut Runtime\u003cApplication\u003e) {\n        let busy_interval = rt.sim_time() - self.started;\n        rt.app.busy_time += busy_interval;\n\n        let customer = rt.app.queue.pop_front();\n        match customer {\n            Some(customer) =\u003e {\n                // log wait time\n                rt.app.busy = true;\n                rt.app.wait_times.push(rt.sim_time() - customer.arrived);\n                rt.add_event_in(\n                    Events::ServerDone(ServerDone {\n                        started: rt.sim_time(),\n                        _pad: [0; 300],\n                    }),\n                    customer.duration,\n                )\n            }\n            None =\u003e {\n                rt.app.busy = false;\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct CustomerArrival {\n    idx: usize,\n}\n\nimpl CustomerArrival {\n    fn handle(self, rt: \u0026mut Runtime\u003cApplication\u003e) {\n        if self.idx \u003e rt.app.n {\n            return;\n        }\n\n        // Gen next event\n        let duration = expdist(rt, 1.0 / rt.app.l);\n        let next = expdist(rt, 1.0 / rt.app.m);\n\n        let customer = Customer {\n            arrived: rt.sim_time(),\n            duration: Duration::from_secs_f64(duration),\n        };\n\n        if rt.app.busy {\n            rt.app.queue.push_back(customer);\n        } else {\n            rt.app.busy = true;\n            rt.app.wait_times.push(Duration::ZERO);\n            rt.add_event_in(\n                Events::ServerDone(ServerDone {\n                    started: rt.sim_time(),\n                    _pad: [0; 300],\n                }),\n                customer.duration,\n            );\n        }\n\n        rt.add_event_in(\n            Events::CustomerArrival(CustomerArrival { idx: self.idx + 1 }),\n            Duration::from_secs_f64(next),\n        );\n    }\n}\n\nfn expdist\u003cA: des::runtime::Application\u003e(rt: \u0026mut Runtime\u003cA\u003e, p: f64) -\u003e f64 {\n    let x: f64 = rt.rng_sample(Standard);\n    x.ln() / -p\n}\n\nfn main() {\n    let app = Application {\n        n: 100_000,\n        l: 1.0,\n        m: 2.0,\n\n        queue: VecDeque::new(),\n        busy: false,\n\n        wait_times: Vec::new(),\n        busy_time: SimTime::ZERO,\n    };\n\n    let mut rt = Builder::seeded(0x42069).build(app);\n    // Create first event\n    let l = rt.app.l;\n    let dur = Duration::from_secs_f64(expdist(\u0026mut rt, l));\n    rt.add_event_in(Events::CustomerArrival(CustomerArrival { idx: 0 }), dur);\n\n    let (app, t_max, _) = rt.run().unwrap();\n    app.eval(t_max);\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","Users","mk","Developer","rust","des","des","src","doc","mod.rs"],"content":"//! Guide-level documentation\n//!\n//! DES offers multiple levels of abstraction to create\n//! discrete event-simulations. To illustrate the thoses\n//! tools a simple Ping-Pong simulation will be implemented using\n//! all three levels of abstraction:\n//!\n//! - A simple discrete-event-simulation using a custom event set [see here](pingpong_1),\n//! - A network-simulation using a generic network layer [see here](pingpong_2),\n//!\n\npub mod pingpong_1;\npub mod pingpong_2;\n// pub mod pingpong_3;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","doc","pingpong_1.rs"],"content":"//! Ping-Pong as a simple event simulation\n//!\n//! # The task\n//!\n//! Two nodes 'Ping' and 'Pong' can communicate with each other\n//! using a bidirection channel. 'Ping' sends 30 ping-messages\n//! with at an interval of 1s. 'Pong' receives the messages and\n//! responds with a pong-message, that 'Ping' receives. Both\n//! 'Ping' and 'Pong' count the number of messages received and send\n//! by them.\n//!\n//! # The simulation\n//!\n//! ### An event-set\n//!\n//! When constructing a simple event simulation, an event set must be provided.\n//! This event-set should be able to represent all activity that can happen\n//! within the scope of the simulation. If this cast this encompasses:\n//!\n//! - The 1s interval to send ping-messages\n//! - The ping-messages that will be received by 'Pong'\n//! - The pong-message that will be received by 'Ping'\n//!\n//! Accordingly an event set can be constructed:\n//!\n//! ```rust\n//! use des::prelude::*;\n//! use des::event_set;\n//!\n//! event_set!(\n//!     enum PingPongEventSet {\n//!         type App = PingPongApp;\n//!     \n//!         IntervalEvent(IntervalEvent),\n//!         PingArrival(PingArrival),\n//!         PongArrival(PongArrival),\n//!     };\n//! );\n//!\n//! struct IntervalEvent;\n//! struct PingArrival;\n//! struct PongArrival;\n//! #\n//! # struct PingPongApp { /* ... */ }\n//! # impl Application for PingPongApp {\n//! #    type EventSet = PingPongEventSet;\n//! #    type Lifecycle = ();\n//! # }\n//! # impl Event\u003cPingPongApp\u003e for IntervalEvent { fn handle(self, _rt: \u0026mut Runtime\u003cPingPongApp\u003e) {} }\n//! # impl Event\u003cPingPongApp\u003e for PingArrival { fn handle(self, _rt: \u0026mut Runtime\u003cPingPongApp\u003e) {} }\n//! # impl Event\u003cPingPongApp\u003e for PongArrival { fn handle(self, _rt: \u0026mut Runtime\u003cPingPongApp\u003e) {} }\n//! ```\n//!\n//! ### An application\n//!\n//! However to define an event-set you must define an application first.\n//! This application serves as a global persistent storage point that manages\n//! the lifecycle of the simulation. To define a application define a\n//! abitray type that implements the trait [Application](crate::runtime::Application).\n//! In this example we will use the application to record messages and check the number\n//! of messages after the simulation has concluded:\n//!\n//! ```rust\n//! # use des::prelude::*;\n//! #[derive(Debug)]\n//! struct PingPongApp {\n//!     pings_send: usize,\n//!     pings_recv: usize,\n//!     pongs_send: usize,\n//!     pongs_recv: usize,\n//! }\n//!\n//! impl Application for PingPongApp {\n//!     type EventSet = PingPongEventSet;\n//!     type Lifecycle = Self;\n//! }\n//! impl EventLifecycle for PingPongApp {\n//!     fn at_sim_end(rt: \u0026mut Runtime\u003cSelf\u003e) {\n//!         assert_eq!(rt.app.pings_send, 30);\n//!         assert_eq!(rt.app.pings_recv, 30);\n//!         assert_eq!(rt.app.pongs_send, 30);\n//!         assert_eq!(rt.app.pongs_recv, 30);    \n//!     }\n//! }\n//! # struct PingPongEventSet;\n//! # impl EventSet\u003cPingPongApp\u003e for PingPongEventSet { fn handle(self, _: \u0026mut Runtime\u003cPingPongApp\u003e) {} }\n//! ```\n//!\n//! ### The event handlers\n//!\n//! Now we have to specify what happens when a event is executed. Therefor each event in the event set\n//! must implement the trait [Event](crate::runtime::Event). This trait includes a handler that consumes\n//! the event itself, while holding a reference to the runtime to create new event if nessecary. In\n//! out example we shall first define the interval event which sends messages from 'Ping' to\n//! 'Pong':\n//!\n//! ```rust\n//! # use des::prelude::*;\n//! # struct IntervalEvent;\n//! impl Event\u003cPingPongApp\u003e for IntervalEvent {\n//!     fn handle(self, rt: \u0026mut Runtime\u003cPingPongApp\u003e) {\n//!         // Send a ping message, that will arrive in 20ms\n//!         rt.add_event_in(PingArrival, Duration::from_millis(20));\n//!         rt.app.pings_send += 1;\n//!         // reschedule the interval event\n//!         if SimTime::now().as_secs() \u003c 30 {\n//!             rt.add_event_in(self, Duration::from_secs(1));\n//!         }\n//!     }\n//! }\n//! # struct PingPongApp { pings_send: usize }\n//! # struct PingPongEventSet {}\n//! # impl Application for PingPongApp { type EventSet = PingPongEventSet; type Lifecycle = (); }\n//! # impl EventSet\u003cPingPongApp\u003e for PingPongEventSet { fn handle(self, _: \u0026mut Runtime\u003cPingPongApp\u003e) {}}\n//! # impl From\u003cIntervalEvent\u003e for PingPongEventSet { fn from(_: IntervalEvent) -\u003e Self { todo!() }}\n//! # struct PingArrival;\n//! # impl From\u003cPingArrival\u003e for PingPongEventSet { fn from(_: PingArrival) -\u003e Self { todo!() }}\n//! ```\n//!\n//! After that lets, define what happens once the ping-message arrives:\n//!\n//! ```rust\n//! # use des::prelude::*;\n//! # struct PingArrival;\n//! impl Event\u003cPingPongApp\u003e for PingArrival {\n//!     fn handle(self, rt: \u0026mut Runtime\u003cPingPongApp\u003e) {\n//!         // Bounce back a pong message, that will arrive in 20ms\n//!         rt.add_event_in(PongArrival, Duration::from_millis(20));\n//!         rt.app.pings_recv += 1;\n//!         rt.app.pongs_send += 1;\n//!     }\n//! }\n//! # struct PingPongApp { pings_recv: usize, pongs_send: usize }\n//! # struct PingPongEventSet {}\n//! # impl Application for PingPongApp { type EventSet = PingPongEventSet; type Lifecycle = (); }\n//! # impl EventSet\u003cPingPongApp\u003e for PingPongEventSet { fn handle(self, _: \u0026mut Runtime\u003cPingPongApp\u003e) {}}\n//! # impl From\u003cPingArrival\u003e for PingPongEventSet { fn from(_: PingArrival) -\u003e Self { todo!() }}\n//! # struct PongArrival;\n//! # impl From\u003cPongArrival\u003e for PingPongEventSet { fn from(_: PongArrival) -\u003e Self { todo!() }}\n//! ```\n//!\n//! And finally lets define what happens once the pong arrives:\n//!\n//! ```rust\n//! # use des::prelude::*;\n//! # struct PongArrival;\n//! impl Event\u003cPingPongApp\u003e for PongArrival {\n//!     fn handle(self, rt: \u0026mut Runtime\u003cPingPongApp\u003e) {\n//!         rt.app.pongs_recv += 1;\n//!     }\n//! }\n//! # struct PingPongApp { pongs_recv: usize }\n//! # struct PingPongEventSet {}\n//! # impl Application for PingPongApp { type EventSet = PingPongEventSet;type Lifecycle = ();  }\n//! # impl EventSet\u003cPingPongApp\u003e for PingPongEventSet { fn handle(self, _: \u0026mut Runtime\u003cPingPongApp\u003e) {}}\n//! ```\n//!\n//! # The main function\n//!\n//! Now we have createa all that is nessecary to perform our event simulation.\n//! Thus we must define the main function and provide the inital event that is nessecary.\n//!\n//! ````rust\n//! # use des::prelude::*;\n//! fn main() {\n//!     # return;\n//!     let app = PingPongApp {\n//!         pings_send: 0, pings_recv: 0,\n//!         pongs_send: 0, pongs_recv: 0,\n//!     };\n//!     let mut rt = Builder::new().build(app);\n//!     rt.add_event(IntervalEvent, SimTime::ZERO);\n//!     let result = rt.run();\n//!     println!(\"{:?}\", result);\n//! }\n//! # #[derive(Debug)]\n//! # struct PingPongApp { pings_send: usize, pings_recv: usize, pongs_send: usize, pongs_recv: usize }\n//! # struct PingPongEventSet {}\n//! # struct IntervalEvent;\n//! # impl Application for PingPongApp { type EventSet = PingPongEventSet;type Lifecycle = ();  }\n//! # impl EventSet\u003cPingPongApp\u003e for PingPongEventSet { fn handle(self, _: \u0026mut Runtime\u003cPingPongApp\u003e) {}}\n//! # impl From\u003cIntervalEvent\u003e for PingPongEventSet { fn from(_: IntervalEvent) -\u003e Self { todo!()}}\n//! ````\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","doc","pingpong_2.rs"],"content":"//! Ping-Pong as a generic network-simulation\n//!\n//! # The task\n//!\n//! Two nodes 'Ping' and 'Pong' want to communicate with each other\n//! using a bidirection channel. 'Ping' sends a total of 30 `Ping`-messages\n//! in intervals of 1s. 'Pong' receives these messages and\n//! responds with a `Pong`-Message, that 'Ping' receives. Both\n//! 'Ping' and 'Pong' count the number of messages received and send\n//! by them.\n//!\n//! # The simulation\n//!\n//! This network-simulation is created by using the features `net` and `ndl`.\n//!\n//! ### NDL\n//!\n//! The feature `net` provides the core abstractions for a network-like\n//! simulation. These are Modules, Gates and Channels. Modules represent\n//! network nodes with custom state and behaviour. They are user defined\n//! and can be created by implementing the [`Module`](crate::net::module::Module)\n//! trait on a type. Gates act as physical (or logical) ports on a module. They can be\n//! chained together into gate-chains, thus connecting multiple modules.\n//! By default gate-chains act as link with infinite bandwith and zero latency.\n//! If a gate-chain should act as a real physical link would do, Channels\n//! can be attached to a gate chain to define the delay / drop metric of the link.\n//!\n//! While the feature `net` provides the appropiate base abstractions, creating\n//! a network can be tiresome. However, using the feature `ndl`, users\n//! can automatically create networks by defining just the networks\n//! topology using the `NetworkDescriptionLanguage`. Such definitions\n//! can be placed in files ending in '.ndl'. This language desribes networks\n//! as a topology of modules, gates and links, without requiring any custom\n//! logic that will later be associated with the modules. At first let's\n//! describe the network at hand:\n//!\n//! ```text\n//! // 'Main.ndl'\n//! module Ping {\n//!     gates {\n//!         in @input,\n//!         out @output,\n//!     }\n//! }\n//!\n//! module Pong {\n//!     gates {\n//!         in @input,\n//!         out @output,\n//!     }\n//! }\n//! ```\n//!\n//! We define two module, 'Ping' and 'Pong' that both possesing two gates.\n//! Links in NDL are unidirectional so each modules requires two to facilitate bidirectional\n//! communication. Gates can also be annotated with their typ (input or output) to prevent\n//! unwanted topologies. Using this definition, both modules can be sure, that all incoming\n//! packets must come via the 'in' gate. Now using the basic definition of our two modules\n//! we may create our network.\n//!\n//! ```text\n//! // 'Main.ndl'\n//! link MyLink {\n//!     bitrate: 100000\n//!     latency: 0.1\n//!     jitter: 0.0\n//! }\n//!\n//! module MyNetwork {\n//!     submodules {\n//!         ping: Ping,\n//!         pong: Pong,\n//!     }\n//!     connections {\n//!         ping/out --\u003e MyLink --\u003e pong/in,\n//!         pong/out --\u003e MyLink --\u003e ping/in,\n//!     }\n//! }\n//!\n//! entry MyNetwork;\n//! ```\n//!\n//! The module `MyNetwork` represents the entry point to our simulation. While `MyNetwork` itself could\n//! act as a network node, it is more of an abstract composite node in this example. By declaring\n//! two submodules 'ping' and 'pong' we declare, that each instance of `MyNetwork` should contain\n//! a `Ping` and a `Pong` instance. In the connections section we define a link (gate-chain)\n//! between the output gate of 'ping' and the input gate if 'pong' (and vice versa).\n//! This gate chain will be augmented using a Channel with the characteristics defined\n//! on `MyLink`. Finally we declare the module `MyNetwork` to be the entry point / root of\n//! our network.\n//!\n//! # The Modules\n//!\n//! Once we have defined the network topology, modules can be defined in rust code.\n//! For that you may define a struct or enum of the with the same name as the described\n//! module.\n//!\n//! ```\n//! # use des::prelude::*;\n//! struct Ping {\n//!     pongs_recv: usize,\n//!     pings_send: usize,\n//! }\n//! struct Pong {\n//!     pings_recv: usize,\n//!     pongs_send: usize,\n//! }\n//! ```\n//!\n//! This trait provides a number of available functions.\n//! This function should be used to create a new instance of the custom state for a\n//! network node. Note that this function is not nessecryly executed within the context\n//! of an event, so dont put complex custom logic here.\n//!\n//! ```rust\n//! # use des::prelude::*;\n//! # struct Ping { pongs_recv: usize, pings_send: usize }\n//! # struct Pong { pings_recv: usize, pongs_send: usize }\n//! /* ... */\n//!\n//! impl Module for Ping {\n//!     /* ... */\n//! }\n//!\n//! impl Module for Pong {\n//!     /* ... */\n//! }\n//! ```\n//!\n//! The `Module` trait also provide some other useful functions, that can be overrided.\n//! [`Module::handle_message`](crate::net::module::Module::handle_message)\n//!  is called when a packet arrives at the module. This function\n//! is the heart of most network simulations.\n//! [`Module::at_sim_start`](crate::net::module::Module::at_sim_start) provides a way to\n//! handle more complex logic when the simulation is stared, but now within a fully constructed\n//! topology.  [`Module::at_sim_end`](crate::net::module::Module::at_sim_end)\n//! can be used to make module-specific actions once the simulation is finished,\n//! such as writing metrics to a file, or deallocating internal containers.\n//!\n//! ```\n//! # use des::prelude::*;\n//! # struct Ping { pongs_recv: usize, pings_send: usize }\n//! # struct Pong { pings_recv: usize, pongs_send: usize }\n//! const PING: MessageKind = 10;\n//! const PONG: MessageKind = 42;\n//! const WAKEUP: MessageKind = 69;\n//!\n//! impl Module for Ping {\n//!     /* ... */\n//!\n//!     fn at_sim_start(\u0026mut self, _stage: usize) {\n//!         // Create the inital wakeup event.\n//!         schedule_at(Message::new().kind(WAKEUP).build(), SimTime::ZERO)\n//!     }\n//!\n//!     fn handle_message(\u0026mut self, msg: Message) {\n//!         match msg.header().kind {\n//!             WAKEUP =\u003e {\n//!                 // Send a PING every 1s, for the first 30s\n//!                 send(Message::new().kind(PING).build(), \"out\");\n//!                 self.pings_send += 1;\n//!                 if SimTime::now().as_secs() \u003c 30 {\n//!                     schedule_in(msg, Duration::from_secs(1));\n//!                 }\n//!             },\n//!             PONG =\u003e self.pongs_recv += 1,\n//!             _ =\u003e todo!()\n//!         }    \n//!     }\n//!\n//!     fn at_sim_end(\u0026mut self) {\n//!         assert_eq!(self.pongs_recv, 30);\n//!         assert_eq!(self.pings_send, 30);\n//!     }\n//! }\n//!\n//! impl Module for Pong {\n//!     /* ... */\n//!\n//!     fn handle_message(\u0026mut self, msg: Message) {\n//!         assert_eq!(msg.header().kind, PING);\n//!         self.pings_recv += 1;\n//!         send(Message::new().kind(PONG).build(), \"out\");\n//!         self.pongs_send += 1;\n//!     }\n//!\n//!     fn at_sim_end(\u0026mut self) {\n//!         assert_eq!(self.pings_recv, 30);\n//!         assert_eq!(self.pongs_send, 30);\n//!     }\n//! }\n//! ```\n//!\n//! ### The app\n//!\n//! Now that we have defined the **real** modules we can do the same with the  more abstract modules.\n//! Since we dont have any intersting buisness logic for this module, we just\n//! insert some placeholder code.\n//!\n//! ```\n//! # use des::prelude::*;\n//! /* ... */\n//!\n//! struct MyTestCase;\n//! impl Module for MyTestCase {\n//! }\n//! ```\n//!\n//! Now we have defined everything to create the simulation. To do that create an\n//! NDL simulation to load our network topology. This application requies\n//! a [`Registry`](crate::ndl::Registry) of all known modules types, to link the Ndl-Modules to their rust struct.\n//! This application can be used to instantiate a [`Sim`](crate::net::Sim)\n//! (provided by feature `net`),\n//! which in turn can be passed to the core [`Runtime`](crate::runtime::Runtime) of [`des`](crate).\n//! This runtime can than be executed, to run the simulation to its end.\n//!\n//! ```\n//! # use des::prelude::*;\n//! # use des::registry;\n//! # #[derive(Default)]\n//! # struct Ping;\n//! # impl Module for Ping {}\n//! # #[derive(Default)]\n//! # struct Pong;\n//! # impl Module for Pong {}\n//! # #[derive(Default)]\n//! # struct MyTestCase;\n//! # impl Module for MyTestCase {}\n//! /* ... */\n//!\n//! fn main() {\n//!     # return;\n//!     let app = Sim::ndl(\"main.ndl\", registry![Ping, Pong, MyTestCase]).unwrap();\n//!     let rt = Builder::new().build(app);\n//!     let result = rt.run();\n//!     println!(\"{:?}\", result);\n//! }\n//! ```\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","doc","pingpong_3.rs"],"content":"//! Ping-Pong as an asynchronous network-simulation with TCP socket\n//!\n//!\n//!\n//! ```\n//! use des::prelude::*;\n//! use des::registry;\n//! use inet::interface::*;\n//!\n//! struct Ping;\n//!\n//! \n//! impl AsyncModule for Ping {\n//!     fn new() -\u003e Ping {\n//!         Ping\n//!     }\n//!\n//!     async fn at_sim_start(\u0026mut self, _: usize) {\n//!         add_interface(\n//!             Interface::ethv4(\n//!                 NetworkDevice::eth(),\n//!                 Ipv4Addr::new(209, 0, 3, 103)\n//!             )\n//!         );\n//!\n//!         let sock = inet::UdpSocket::bind(\"0.0.0.0:0\").await.unwrap();\n//!         /* ... */\n//!     }\n//! }\n//!\n//! fn main() {\n//!     # return;\n//!     inet::init();\n//!     let app = NdlApplication::new(\"path/to/ndl\", registry![Ping])\n//!         .map_err(|e| println!(\"{e}\"))\n//!         .unwrap();\n//!     let rt = Runtime::new(NetworkApplication::new(app));\n//!     let _  = rt.run();\n//! }\n//! ```\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","lib.rs"],"content":"// Lints\n#![deny(unused_must_use)]\n#![warn(clippy::pedantic)]\n#![warn(missing_docs, missing_debug_implementations, unreachable_pub)]\n#![allow(\n    clippy::needless_doctest_main,\n    clippy::module_name_repetitions,\n    clippy::arc_with_non_send_sync\n)]\n\n//!\n//! A discrete event simulator.\n//!\n//! DES is a discrete event simulation tool that makes building simulations for\n//! networks easy. DES provides the tools to build a event simulation from the\n//! groud up, with a implemented module system or with a asynchronous context in\n//! mind.\n//!\n//! # Building a simple event simulation\n//!\n//! At its core DES provides the tools to easily and efficently build an event simulation\n//! with completely generic event set. This can be done independent of features used,\n//! but usually only optimization features like `cqueue` or montioring tools like `metrics`\n//! are used in this context.\n//!\n//! ```\n//! use des::prelude::*;\n//!\n//! enum MyEventSet {\n//!     EventA { what_happend: String },\n//!     EventB { ack: bool },\n//! }\n//!\n//! impl EventSet\u003cMyApp\u003e for MyEventSet {\n//!     fn handle(self, _rt: \u0026mut Runtime\u003cMyApp\u003e) {\n//!         // Do something\n//!     }\n//! }\n//!\n//! #[derive(Default)]\n//! struct MyApp {\n//!     global_value: usize,\n//!     logs: Vec\u003cString\u003e,\n//! }\n//!\n//! impl Application for MyApp {\n//!     type EventSet = MyEventSet;\n//!     type Lifecycle = ();\n//! }\n//!\n//! fn main() {\n//!     let app = MyApp::default();\n//!     let rt = Builder::new().build(app);\n//!     let result = rt.run();\n//! }\n//! ```\n//!\n//! This simulation will now provide a [`runtime`] with\n//! [`time`] managment and a future event set to execute events.\n//! If a event is executed [`MyEventSet::handle`](crate::runtime::EventSet::handle)\n//! will be called with the runtime as parameter. If new events are to be created\n//! as result of a event execution this mutable reference can be used\n//! to add new events to the future event set.\n//!\n//! The [`Application`](crate::runtime::Application) object (in this case `MyApp`) is used as a global context handle that\n//! it stored inside the runtime. It can be accessed via 'rt.app' and can be used\n//! to record state during the simulation. Note that the [`EventSet`](crate::runtime::EventSet)\n//! and the [`Application`](crate::runtime::Application) are linked via a trait with generic parameters. This means\n//! that `MyEvents` could implement [`EventSet`](crate::runtime::EventSet) a second time for another application.\n//!\n//! # Using a module oriented system\n//!\n//! DES is able to provide tools for simulating network-like structures with [Modules](crate::net::module::Module).\n//! These modules are self contained units with their own state, connected via [Channels](crate::net::channel::Channel)\n//! (network links) that are attached to [Gates](crate::net::gate::Gate) (physical ports) on modules.\n//! Modules can send messages (packtes) through these gates / channels to communicated\n//! with other modules. Additionally modules can be created in a tree like structure,\n//! providing links like [`parent`] or [`child`].\n//!\n//! These tools are available in the [`net`] module\n//! when the feature `net` is active.\n//!\n//! ```toml\n//! des = { version = \"*\", features = [ \"net\" ] }\n//! ```\n//!\n//! # Asynchrounous simulation\n//!\n//! As a final addition DES provides tools for dealing with the simulation of\n//! asynchronous systems through the feature `async`.\n//! These tools are build onto of the feature `net` and\n//! help with asynchronously managing module activity. With this feature\n//! active, network-primitives like `TcpListener` or `UdpSocket`,\n//! as well as time-primitives like `des::time::sleep` can be\n//! used.\n//!\n//! ```toml\n//! des = { version = \"*\", features = [ \"net\", \"async\" ] }\n//! ```\n//!\n//! While this feature activates smaller additions to the existing functionallity of\n//! [`net`], it also contains a full reexport of [tokio](https://docs.rs/tokio) with modifications\n//! to fit the simulation context. This version of tokio is implicitly reexported with the\n//! newly added feature sim to integrate into a simulation context and thus does NOT\n//! provide access to the [`fs`](https://docs.rs/tokio/latest/tokio/fs/index.html),\n//! [`signal`](https://docs.rs/tokio/latest/tokio/signal/index.html) or modules.\n//! Additionally this version only supports current-thread runtimes.\n//!\n//! However it supports all synchronisation primitives (excluding Barrier)\n//! through the [`sync`](tokio::sync) module, asynchronous green tasks\n//! through [`task`](tokio::task), custom runtimes through [`runtime`](tokio::runtime)\n//! and simulation specific time primitives through [`time`] replacing the\n//! standart [`time`](https://docs.rs/tokio/latest/tokio/time/index.html) module,\n//! aswell as simulation specifc network primitives replacing the standart\n//! [`net`](https://docs.rs/tokio/latest/tokio/net/index.html) module.\n//!\n//! [`time`]: crate::time\n//! [`net`]: crate::net\n//! [`runtime`]: crate::runtime\n//! [`parent`]: crate::net::module::ModuleContext::parent\n//! [`child`]: crate::net::module::ModuleContext::child\n\n#[macro_use]\n#[doc(hidden)]\npub mod macros;\n\npub(crate) mod sync;\n\npub mod prelude;\n\npub mod doc;\npub mod runtime;\npub mod time;\n\ncfg_net! {\n    pub mod net;\n    pub mod tracing;\n}\n\ncfg_ndl! {\n    pub mod ndl;\n}\n\ncfg_macros! {\n    pub use des_macros::*;\n}\n\n// # Features\n//\n// | Feature          | Description                                                              |\n// |------------------|--------------------------------------------------------------------------|\n// | net              | Adds a module oriented design-abstraction that provides its own events.  |\n// | cqueue           | Configures the runtime to use a calender queue for better performance.   |\n// | metrics | Collects internal metrics about the runtime, to improve parametrization. |\n// | async            | Provides utilites and modifications for simulating asynchronous systems including a full reexport of safe tokio funtions. |\n//\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","macros","cfg.rs"],"content":"#![allow(unused_macros)]\n\nmacro_rules! cfg_net {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(feature = \"net\")]\n            #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_ndl {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(feature = \"ndl\")]\n            #[cfg_attr(docsrs, doc(cfg(feature = \"ndl\")))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_macros {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(feature = \"macros\")]\n            #[cfg_attr(docsrs, doc(cfg(feature = \"macros\")))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_async {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(feature = \"async\")]\n            #[cfg_attr(docsrs, doc(cfg(feature = \"async\")))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_not_async {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(not(feature = \"async\"))]\n            #[cfg_attr(docsrs, doc(cfg(not(feature = \"async\"))))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_multi_threaded {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(feature = \"multi-threaded\")]\n            #[cfg_attr(docsrs, doc(cfg(feature = \"multi-threaded\")))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_not_multi_threaded {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(not(feature = \"multi-threaded\"))]\n            #[cfg_attr(docsrs, doc(cfg(not(feature = \"multi-threaded\"))))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_cqueue {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(feature = \"cqueue\")]\n            #[cfg_attr(docsrs, doc(cfg(feature = \"cqueue\")))]\n            $item\n        )*\n    }\n}\n\nmacro_rules! cfg_not_cqueue {\n    ($($item:item)*) =\u003e {\n        $(\n            #[cfg(not(feature = \"cqueue\"))]\n            #[cfg_attr(docsrs, doc(cfg(not(feature = \"cqueue\"))))]\n            $item\n        )*\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","macros","event_set.rs"],"content":"///\n/// A declaritive macro for generating event sets.\n///\n/// This macro combines an number of types that implement [`Event`](crate::runtime::Event)\n/// into an `EventSet` for an application 'App'.\n///\n/// ```rust\n/// # use des::prelude::*;\n/// # use des::event_set;\n/// struct PingEvent;\n/// struct PongEvent;\n/// /* ... */\n/// # impl Event\u003cApp\u003e for PingEvent { fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) { } }\n/// # impl Event\u003cApp\u003e for PongEvent { fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) { } }\n///\n/// struct App;\n/// impl Application for App {\n///     /* ... */\n/// #   type EventSet = Events;\n/// #   type Lifecycle = ();\n/// }\n///\n/// event_set! {\n///     #[derive(Debug)]\n///     pub enum Events {\n///         type App = App;\n///         \n///         PingEvent(PingEvent),\n///         PongEvent(PongEvent),\n///     };\n/// }\n/// ```\n#[macro_export]\nmacro_rules! event_set {\n\n    (\n        $(#[$outer:meta])*\n        $vis: vis enum $ident: ident {\n            type App = $ty:ident \u003c $( $N:ident $(: $b0:ident $(+$b:ident)* )? ),* \u003e;\n\n            $(\n                $variant:ident($variant_ty: ty),\n            )+\n        };\n    ) =\u003e {\n        $(#[$outer])*\n        $vis enum $ident {\n            $(\n                $variant($variant_ty),\n            )+\n        }\n\n        impl\u003c $( $N $(: $b0 $(+$b)* )? ),* \u003e EventSet\u003c$ty\u003c $( $N ),* \u003e\u003e for $ident {\n            fn handle(self, rt: \u0026mut Runtime\u003c$ty\u003c $( $N ),* \u003e\u003e) {\n                match self {\n                    $(\n                        Self::$variant(event) =\u003e event.handle(rt),\n                    )+\n                }\n            }\n        }\n\n        $(\n            impl From\u003c$variant_ty\u003e for $ident {\n                fn from(variant: $variant_ty) -\u003e Self {\n                    Self::$variant(variant)\n                }\n            }\n        )+\n    };\n    (\n        $(#[$outer:meta])*\n        $vis: vis enum $ident: ident {\n            type App = $ty:ident;\n\n            $(\n                $variant: ident($variant_ty: ty),\n            )+\n        };\n    ) =\u003e {\n        $crate::event_set!(\n            $vis enum $ident {\n                type App = $ty\u003c\u003e;\n\n                $(\n                    $variant($variant_ty),\n                )+\n            };\n        );\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","macros","mod.rs"],"content":"#[macro_use]\nmod cfg;\n\n#[doc(hidden)]\npub mod support;\n\ncfg_macros! {\n    #[macro_use]\n    mod event_set;\n\n    cfg_ndl! {\n        mod registry;\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","macros","registry.rs"],"content":"/// Creates a registry of types that implement [`Module`](crate::net::module::Module),\n/// to link rust structs to NDL modules.\n///\n/// The listing of types can be optionally suffixed with\n/// `else \u003csome_type\u003e`  to declare a fallback module\n/// in the [`Registry`](crate::ndl::Registry). The suffix `else _`\n/// declarse the default fallback module.\n///\n/// # Example\n///\n/// ```rust\n/// # use des::prelude::*;\n/// # use des::registry;\n/// #[derive(Default)]\n/// struct DnsServer;\n/// /* ... */\n/// # impl Module for DnsServer {}\n/// #[derive(Default)]\n/// struct Client;\n/// /* ... */\n/// # impl Module for Client {}\n/// #[derive(Default)]\n/// struct Server;\n/// # impl Module for Server {}\n/// /* ... */\n///\n/// # use des_ndl::error::RootResult as Result;\n/// fn main() -\u003e Result\u003c()\u003e {\n///     let registry = registry![DnsServer, Client, Server, else _];\n///     # return Ok(());\n///     let app = Sim::ndl(\"path/to/ndl\", registry)?;\n///     let rt = Builder::new().build(app);\n///     let r = rt.run();\n/// }\n/// ```\n#[macro_export]\nmacro_rules! registry {\n    ($($t:ty),*) =\u003e {{\n        use $crate::ndl::RegistryCreatable;\n        use $crate::net::module::Module;\n\n        let mut registry = $crate::ndl::Registry::new();\n        $(\n            registry = registry.symbol(stringify!($t), |path| \u003c$t as RegistryCreatable\u003e::create(path, stringify!($t)));\n        )*\n\n        registry\n    }};\n\n    ($($t:ty),*, else _) =\u003e {{\n        use $crate::ndl::RegistryCreatable;\n        use $crate::net::module::Module;\n\n        let mut registry = $crate::ndl::Registry::new();\n        $(\n            registry = registry.symbol(stringify!($t), |path| \u003c$t as RegistryCreatable\u003e::create(path, stringify!($t)));\n        )*\n\n        registry.with_default_fallback()\n    }};\n\n    ($($t:ty),*, else $f:ty) =\u003e {{\n        use $crate::ndl::RegistryCreatable;\n        use $crate::net::module::Module;\n\n        let mut registry = $crate::ndl::Registry::new();\n        $(\n            registry = registry.symbol(stringify!($t), |path| \u003c$t as RegistryCreatable\u003e::create(path, stringify!($t)));\n        )*\n\n        registry.with_fallback(|| \u003c$f as std::default::Default\u003e::default())\n    }};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","macros","support.rs"],"content":"use std::ops::{Deref, DerefMut};\n\npub(crate) struct SyncWrap\u003cT\u003e {\n    inner: T,\n}\n\nimpl\u003cT\u003e SyncWrap\u003cT\u003e {\n    pub(crate) const fn new(item: T) -\u003e Self {\n        Self { inner: item }\n    }\n}\n\nimpl\u003cT\u003e Deref for SyncWrap\u003cT\u003e {\n    type Target = T;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.inner\n    }\n}\n\nimpl\u003cT\u003e DerefMut for SyncWrap\u003cT\u003e {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.inner\n    }\n}\n\n// SAFTY:\n// This wrapper should only be used to make statics thread safe,\n// since by design event simulation is single-threded (in the same context).\nunsafe impl\u003cT\u003e Sync for SyncWrap\u003cT\u003e {}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":422524},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":422524},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":5},{"path":["/","Users","mk","Developer","rust","des","des","src","ndl","mod.rs"],"content":"//! Integration of the Network-Description-Language (NDL).\n//!\n//! # What is NDL ?\n//!\n//! NDL is a decriptory language for defining network topologies.\n//! Refer to [`des_ndl`] for more information.\n//!\n//! # How to use it ?\n//!\n//! This submodule provides an [`Sim::ndl`] that can create a simulation\n//! that builsd a network based on a given topology.\n//! Users can create such an application by providing the path to the\n//! root file of the NDL description, and by providing a registry of modules.\n//! This registry is used to link names of network nodes in NDL to associated\n//! structs that implmenent [`Module`](crate::net::module::Module).\n//! By proving both parameters, the application will load the topology and check\n//! whether the network can be build. If not an descriptive error will be returned.\n//!\n//! ```\n//! # use des::prelude::*;\n//! # use des::ndl::*;\n//! # use des::registry;\n//! #[derive(Default)]\n//! struct ModuleA;\n//! /* ... */\n//!\n//! #[derive(Default)]\n//! struct ModuleB;\n//! /* ... */\n//!\n//! # impl Module for ModuleA {}\n//! # impl Module for ModuleB {}\n//! fn main() {\n//!     # return;\n//!     let app = match Sim::ndl(\"path/to/ndl.ndl\", registry![ModuleA, ModuleB]) {\n//!         Ok(v) =\u003e v,\n//!         Err(e) =\u003e {\n//!             println!(\"{e}\");\n//!             return;\n//!         },\n//!     };\n//!     let rt = Builder::new().build(app);\n//!     let _ = rt.run();\n//! }\n//! ```\n\nuse crate::{\n    net::{channel::ChannelDropBehaviour, module::ModuleContext, ScopedSim, Sim},\n    prelude::{Channel, ChannelMetrics, ModuleRef, ObjectPath},\n    time::Duration,\n};\nuse des_ndl::{\n    error::{Error, ErrorKind, Errors, ErrorsMut, RootError, RootResult},\n    ir::{self, ConnectionEndpoint},\n    Context,\n};\nuse std::{path::Path, sync::Arc};\n\nmod registry;\npub use self::registry::*;\n\nimpl Sim\u003c()\u003e {\n    /// Creates a NDL application with the inner application `()`.\n    ///\n    /// See [`Sim::ndl_with`] for more information.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error, if the provided NDL topology is\n    /// erronous, or the software requirements cannot be fulfilled by the registry.\n    pub fn ndl(path: impl AsRef\u003cPath\u003e, registry: impl AsRef\u003cRegistry\u003e) -\u003e RootResult\u003cSelf\u003e {\n        Self::ndl_with(path, registry, ())\n    }\n}\n\nimpl\u003cA\u003e Sim\u003cA\u003e {\n    /// Creates an NDL application from a topology description at `path`, with\n    /// software defined by `registry` and an inner application `inner`.\n    ///\n    /// The NDL topology desciption found at `path` describes a module tree\n    /// including a root module at the path `\"\"`. Each node in this tree\n    /// is derived from a NDL Module. The name of this module prototype\n    /// is the symbol used in accessed to the registry. The NDL topology\n    /// additionally includes gate and gate-chain definitions.\n    ///\n    /// The tree is initalized depth first. This means for each module:\n    /// - First the gate of the current module are created\n    /// - Then all children are created, including gates **and** connections\n    /// - Then all connections are resolved, since connections statements may depend\n    ///   on the existence of gates in child nodes\n    ///\n    /// The provided parameter `registry` is resposible for attaching software\n    /// to the nodes defined by the topology description. Should the registry\n    /// fail to provide software for a node, this function will fail.\n    ///\n    /// The inner application `inner` is equivalent the inner application\n    /// object of a network simulation, which can be used to define custom\n    /// actions at sim start / end.\n    ///\n    /// **NOTE** that the nodes will be created with a call to this function.\n    ///\n    /// # Errors\n    ///\n    /// Some Errors\n    pub fn ndl_with(\n        path: impl AsRef\u003cPath\u003e,\n        registry: impl AsRef\u003cRegistry\u003e,\n        inner: A,\n    ) -\u003e RootResult\u003cSelf\u003e {\n        let mut this = Sim::new(inner);\n        this.build_ndl(path, registry)?;\n        Ok(this)\n    }\n\n    /// Builds a NDL based application with onto an allready existing [`Sim`] object.\n    ///\n    /// See [`Sim::ndl_with`] for more infomation.\n    ///\n    /// # Errors\n    ///\n    /// This function will fail if either:\n    /// a) some NDL error occures when parsing the NDL tree defined at `path`,\n    /// b) or the registry fails to provide software for some NDL-defined module.\n    pub fn build_ndl(\n        \u0026mut self,\n        path: impl AsRef\u003cPath\u003e,\n        registry: impl AsRef\u003cRegistry\u003e,\n    ) -\u003e RootResult\u003c()\u003e {\n        let mut ctx = Context::load(path)?;\n        let tree = ctx\n            .entry\n            .take()\n            .expect(\"internal NDL error: entry point must be provided on Ok(Context)\");\n\n        let mut errors = Errors::new().as_mut();\n\n        let scoped = ScopedSim::new(self, ObjectPath::default());\n        let _ = scoped.ndl(tree, \u0026mut errors, registry.as_ref());\n\n        if errors.is_empty() {\n            Ok(())\n        } else {\n            Err(RootError::new(errors.into_inner(), ctx.smap))\n        }\n    }\n\n    fn raw_ndl(\n        \u0026mut self,\n        path: \u0026ObjectPath,\n        ty: \u0026str,\n        registry: \u0026Registry,\n        errors: \u0026mut ErrorsMut,\n    ) -\u003e ModuleRef {\n        // Check dup\n        assert!(\n            self.modules().get(path).is_none(),\n            \"cannot crate module at {path}, allready exists\"\n        );\n\n        // Check node path location\n        let ctx = if let Some(parent) = path.parent() {\n            // (a) Check that the parent exists\n            let parent = self\n                .get(\u0026parent)\n                .expect(\"cannot create module, parent missing in NDL build\");\n\n            ModuleContext::child_of(path.name(), parent)\n        } else {\n            ModuleContext::standalone(path.clone())\n        };\n        ctx.activate();\n\n        if let Some(software) = registry.lookup(path, ty) {\n            ctx.upgrade_dummy(software);\n        } else {\n            errors.add(Error::new(\n                ErrorKind::SymbolNotFound,\n                format!(\"symbol '{ty}' at '{path}' could not be resolved by the registry\"),\n            ));\n        }\n\n        // TODO: deactivate module\n        self.modules_mut().add(ctx.clone());\n        ctx\n    }\n}\n\nimpl\u003c'a, A\u003e ScopedSim\u003c'a, A\u003e {\n    #[allow(clippy::needless_pass_by_value)]\n    fn ndl(\n        mut self,\n        ir: Arc\u003cir::Module\u003e,\n        errors: \u0026mut ErrorsMut,\n        registry: \u0026Registry,\n    ) -\u003e Option\u003cModuleRef\u003e {\n        let ty = ir.ident.raw.clone();\n        let scope = \u0026self.scope;\n\n        let ctx = self.base.raw_ndl(scope, \u0026ty, registry, errors);\n\n        for gate in \u0026ir.gates {\n            let _ = ctx.create_gate_cluster(\u0026gate.ident.raw, gate.cluster.as_size());\n        }\n\n        for submod in \u0026ir.submodules {\n            let sir = submod.typ.as_module_arc().expect(\n                \"invalid NDL tree: submodule typ referes does not refer to a module object\",\n            );\n\n            match submod.cluster {\n                ir::Cluster::Standalone =\u003e {\n                    // Resue current struct better for stack\n                    let subscope = self.subscope(\u0026submod.ident.raw);\n                    subscope.ndl(sir, errors, registry);\n                }\n                ir::Cluster::Clusted(n) =\u003e {\n                    for k in 0..n {\n                        let ident = \u0026submod.ident.raw;\n                        let subscope = self.subscope(format!(\"{ident}[{k}]\"));\n                        subscope.ndl(sir.clone(), errors, registry);\n                    }\n                }\n            }\n        }\n\n        for con in \u0026ir.connections {\n            let from = match \u0026con.lhs {\n                ConnectionEndpoint::Local(gate, pos) =\u003e ctx.gate(\u0026gate.raw, pos.as_index()),\n                ConnectionEndpoint::Nonlocal(submod, pos, gate) =\u003e {\n                    let c = ctx\n                        .child(\u0026format!(\"{}{}\", submod.raw, pos))\n                        .expect(\"invalid NDL tree: connection refer to child that does not exist\");\n                    c.gate(\u0026gate.0.raw, gate.1.as_index())\n                }\n            }\n            .expect(\"invalid NDL tree: connections refer to gate(-cluster) not defined by NDL\");\n\n            let to = match \u0026con.rhs {\n                ConnectionEndpoint::Local(gate, pos) =\u003e ctx.gate(\u0026gate.raw, pos.as_index()),\n                ConnectionEndpoint::Nonlocal(submod, pos, gate) =\u003e {\n                    let c = ctx\n                        .child(\u0026format!(\"{}{}\", submod.raw, pos))\n                        .expect(\"invalid NDL tree: connection refer to child that does not exist\");\n                    c.gate(\u0026gate.0.raw, gate.1.as_index())\n                }\n            }\n            .expect(\"invalid NDL tree: connections refer to gate(-cluster) not defined by NDL\");\n\n            from.connect_dedup(\n                to,\n                if let Some(delay) = \u0026con.delay {\n                    let link = delay\n                        .as_link_arc()\n                        .expect(\"invalid NDL tree: link typ does not refer to a link object\");\n                    Some(Channel::new(ChannelMetrics::from(\u0026*link)))\n                } else {\n                    None\n                },\n            );\n        }\n\n        Some(ctx)\n    }\n}\n\nimpl From\u003c\u0026ir::Link\u003e for ChannelMetrics {\n    #[allow(clippy::cast_sign_loss)]\n    fn from(value: \u0026ir::Link) -\u003e Self {\n        ChannelMetrics {\n            bitrate: value.bitrate as usize,\n            jitter: Duration::from_secs_f64(value.jitter),\n            latency: Duration::from_secs_f64(value.latency),\n            drop_behaviour: ChannelDropBehaviour::Queue(Some(\n                value\n                    .fields\n                    .get(\"queuesize\")\n                    .map_or(0, ir::Literal::as_integer_casted) as usize,\n            )),\n        }\n    }\n}\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":131},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":26},"fn_name":null}],"covered":59,"coverable":76},{"path":["/","Users","mk","Developer","rust","des","des","src","ndl","registry.rs"],"content":"use fxhash::{FxBuildHasher, FxHashMap};\nuse std::fmt;\n\nuse crate::{\n    net::processing::{IntoProcessingElements, ProcessingElements},\n    prelude::{Module, ObjectPath},\n};\n\n/// A type that can be created based on the nodes path and a\n/// NDL symbol.\n///\n/// This trait is used in combination with the [`registry`](crate::registry)\n/// macro, when creating a software registry. Note that this type\n/// is automatically derived for any type that implements [`Default`].\npub trait RegistryCreatable {\n    /// Creates a instance of `Self` from a path and symbol.\n    ///\n    /// This function if called by [`Sim::ndl`](crate::net::Sim) will be called\n    /// within node-context.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::ndl::*;\n    /// # use des::registry;\n    /// # fn extract_dns_from_oid(path: \u0026ObjectPath) {}\n    /// struct Server { /* ... */ }\n    ///\n    /// impl RegistryCreatable for Server {\n    ///     fn create(path: \u0026ObjectPath, symbol: \u0026str) -\u003e Self {\n    ///         let dns_name = extract_dns_from_oid(path);\n    ///         Self { /* ... */ }\n    ///     }\n    /// }\n    ///\n    /// impl Module for Server {\n    ///     /* ... */\n    /// }\n    ///\n    /// # return;\n    /// let mut sim = Sim::ndl(\n    ///     \"path/to/ndl\",\n    ///     registry![Server, else _]\n    /// );\n    /// ```\n    fn create(path: \u0026ObjectPath, symbol: \u0026str) -\u003e Self;\n}\n\nimpl\u003cT: Default\u003e RegistryCreatable for T {\n    fn create(_: \u0026ObjectPath, _: \u0026str) -\u003e Self {\n        Self::default()\n    }\n}\n\n/// A registry to attache user-defined software to nodes in\n/// a simulation.\n///\n/// When creating a simulation from a NDL like structure,\n/// that only defines the topological layout of the simulation,\n/// user-defined software must be attached to created nodes to\n/// make the setup complete.\n///\n/// This registry effectivly acts as a `fn (ObjectPath, Symbol) -\u003e Module`\n/// to assign software to each node that will be created. Since these\n/// nodes are related to a NDL-Module the modules name is also provided\n/// as a parameter.\n#[must_use]\npub struct Registry {\n    symbols: FxHashMap\u003cString, Box\u003cGenByObjectPath\u003e\u003e,\n    custom: Vec\u003cBox\u003cGenByObjectPathAndSymbol\u003e\u003e,\n    fallback: Option\u003cBox\u003cFallback\u003e\u003e,\n}\n\ntype GenByObjectPath = dyn Fn(\u0026ObjectPath) -\u003e ProcessingElements;\ntype GenByObjectPathAndSymbol = dyn Fn(\u0026ObjectPath, \u0026str) -\u003e Option\u003cProcessingElements\u003e;\ntype Fallback = dyn Fn() -\u003e ProcessingElements;\n\nimpl Registry {\n    /// Creates a new empty registry.\n    ///\n    /// Registrys can be populated using the builder pattern or using\n    /// the [`registry`](crate::registry) macro.\n    ///\n    /// # Examples\n    ///\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::ndl::*;\n    /// # struct HostModule;\n    /// # impl Module for HostModule {}\n    /// let registry = Registry::new()\n    ///     .symbol(\"Host\", |_| HostModule)\n    ///     .custom(|path, symbol| {\n    ///         /* ... */\n    ///         # Option::\u003cHostModule\u003e::None\n    ///     })\n    ///     .with_default_fallback();\n    /// ```\n    ///\n    /// Or create a registry using macros. Note that the macro returns a `Registry` so\n    /// the builder pattner can still be used. Note that types passed to the macro\n    /// **must** implement the `RegistryCreatable` trait.\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::ndl::*;\n    /// # use des::registry;\n    /// # #[derive(Default)]\n    /// # struct HostModule;\n    /// # impl Module for HostModule {}\n    /// type Host = HostModule; // symbol names and type names must match\n    /// let registry = registry![Host].with_default_fallback();\n    /// ```\n    pub fn new() -\u003e Registry {\n        Self {\n            symbols: FxHashMap::with_hasher(FxBuildHasher::default()),\n            custom: Vec::new(),\n            fallback: None,\n        }\n    }\n\n    /// Sets the `DefaultFallbackModule` as a fallback.\n    ///\n    /// The default fallback module will behave as follows:\n    /// - `at_sim_start` and `t_sim_end` are NOP with 1 sim start stage\n    /// - `reset` is a NOP\n    /// - `handle_message` will log any incoming messages to stderr\n    /// - `DefaultFallbackModule` is **not** async\n    /// - `DefaulfFallbackModule` will **not** load common plugins\n    ///\n    /// See [`Registry::with_fallback`] for more infomation.\n    pub fn with_default_fallback(self) -\u003e Self {\n        self.with_fallback(|| DefaultFallbackModule)\n    }\n\n    /// Sets a fallback module, that will be used if no other\n    /// directive matched.\n    ///\n    /// # Why have a fallback module ?\n    ///\n    /// By their very nature fallback modules all share the same software.\n    /// Additionally the `fallback` function does not take any parameters\n    /// so any fallback solution should not be dependent on any parameters.\n    ///\n    /// Accordingly fallback modules rarely have any meaningful software\n    /// in them, they rather are just dummys for nodes that are not expected\n    /// to receive any message. Such nodes often occur as structual elements in\n    /// topologies to encapsualte certain subtopologies. E.g. a NDL topology\n    /// may include a module `LAN` that internally contains hosts, switches and routers.\n    /// All internal components will have meeaninful software attached, but the `LAN` object\n    /// itself should not, since it only exposes gate chains from child modules. In this\n    /// case `LAN` will never receive any messages itself, so a fallback dummy can be used.\n    ///\n    /// Fallback modules should be used with care, since the existence of a fallback\n    /// solution within a registry implies, that any given topology can be\n    /// populated with this registry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::ndl::*;\n    /// # use des::prelude::*;\n    /// # struct HostModule;\n    /// # impl Module for HostModule {}\n    /// # struct SwitchModule;\n    /// # impl Module for SwitchModule {}\n    /// # struct RouterModule;\n    /// # impl Module for RouterModule {}\n    /// # struct NOP;\n    /// # impl Module for NOP {}\n    /// let registry = Registry::new()\n    ///     .symbol(\"Host\", |_| HostModule)\n    ///     .symbol(\"Switch\", |_| SwitchModule)\n    ///     .symbol(\"Router\", |_| RouterModule)\n    ///     .with_fallback(|| NOP);\n    ///\n    /// # return;\n    /// let mut sim = Sim::ndl(\"path/to/ndl\", registry);\n    /// /* ... */\n    /// ```\n    pub fn with_fallback\u003cM: Module\u003e(mut self, fallback: impl Fn() -\u003e M + 'static) -\u003e Self {\n        self.fallback = Some(Box::new(move || fallback().to_processing_chain()));\n        self\n    }\n\n    /// Adds a symbol mapping to the registry.\n    ///\n    /// All nodes with the symbol `ty` will now use the provided genertator\n    /// function `f` to generate software. This function is thus only parameterized\n    /// by the objects path.\n    ///\n    /// Newer assigments will override older assigments to the same symbol.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::ndl::*;\n    /// # use des::prelude::*;\n    /// struct Host { /* ... */ }\n    ///\n    /// impl Host {\n    ///     fn new(path: \u0026ObjectPath) -\u003e Self {\n    ///         /* .. */\n    /// #       Host {}\n    ///     }\n    /// }\n    ///\n    /// impl Module for Host {\n    ///     /* ... */\n    /// }\n    ///\n    /// /* ... */\n    /// # struct Router;\n    /// # impl Router { fn new(path: \u0026ObjectPath) -\u003e Self { Self } }\n    /// # impl Module for Router {}\n    ///\n    /// let registry = Registry::new()\n    ///     .symbol(\"Host\", |path| Host::new(path))\n    ///     .symbol(\"Router\", |path| Router::new(path));\n    ///\n    /// # return;\n    /// let mut sim = Sim::ndl(\"path/to/ndl\", registry);\n    /// /* ... */\n    /// ```\n    pub fn symbol\u003cM: Module\u003e(\n        mut self,\n        ty: impl AsRef\u003cstr\u003e,\n        f: impl for\u003c'a\u003e Fn(\u0026'a ObjectPath) -\u003e M + 'static,\n    ) -\u003e Self {\n        self.symbols.insert(\n            ty.as_ref().to_string(),\n            Box::new(move |path| f(path).to_processing_chain()),\n        );\n        self\n    }\n\n    /// Adds a custom directive to the registry.\n    ///\n    /// A custom directive is a function that optionally returns a module.\n    /// If `None` is returned that indicates that the directive is not responsible for\n    /// generating software for this node. Custom directive are executed in order\n    /// of definition.\n    ///\n    /// Note that a custom directive that allways returns `Some(...)` is equivalent\n    /// to a fallback module.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::ndl::*;\n    /// # struct GoogleGeneralHost;\n    /// # impl GoogleGeneralHost { fn new(_: \u0026ObjectPath) -\u003e Self { Self }}\n    /// # impl Module for GoogleGeneralHost {}\n    /// let symbols = [\"Host\", \"Client\", \"Server\"];\n    ///\n    /// let registry = Registry::new()\n    ///     .custom(move |path, symbol| {\n    ///         if symbols.contains(\u0026symbol) {\n    ///             if path.as_str().starts_with(\"google\") {\n    ///                 Some(GoogleGeneralHost::new(path))\n    ///             } else {\n    ///                 None\n    ///             }\n    ///         } else {\n    ///             None\n    ///         }\n    ///     });\n    ///\n    /// # return;\n    /// let mut sim = Sim::ndl(\"path/to/ndl\", registry);\n    /// /* ... */\n    /// ```\n    pub fn custom\u003cM: Module\u003e(\n        mut self,\n        f: impl Fn(\u0026ObjectPath, \u0026str) -\u003e Option\u003cM\u003e + 'static,\n    ) -\u003e Self {\n        self.custom.push(Box::new(move |path, symbol| {\n            Some(f(path, symbol)?.to_processing_chain())\n        }));\n        self\n    }\n\n    /// Lookup\n    pub(super) fn lookup(\u0026self, path: \u0026ObjectPath, ty: \u0026str) -\u003e Option\u003cProcessingElements\u003e {\n        // (0) Symbol resolve\n        if let Some(resolver) = self.symbols.get(ty) {\n            return Some(resolver(path));\n        }\n\n        // (1) Check custom handlers\n        for handler in \u0026self.custom {\n            if let Some(resolved) = handler(path, ty) {\n                return Some(resolved);\n            }\n        }\n\n        // (2) Fallback\n        self.fallback.as_ref().map(|fallback| fallback())\n    }\n}\n\nimpl fmt::Debug for Registry {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"Registry\").finish()\n    }\n}\n\nimpl AsRef\u003cRegistry\u003e for Registry {\n    fn as_ref(\u0026self) -\u003e \u0026Registry {\n        self\n    }\n}\n\nimpl Default for Registry {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[derive(Default)]\nstruct DefaultFallbackModule;\nimpl Module for DefaultFallbackModule {\n    fn stack(\u0026self) -\u003e impl IntoProcessingElements {}\n\n    fn handle_message(\u0026mut self, msg: crate::prelude::Message) {\n        tracing::error!(\n            ?msg,\n            \"received message: fallback dummy should never receive any messages\"\n        );\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":34,"coverable":35},{"path":["/","Users","mk","Developer","rust","des","des","src","net","channel.rs"],"content":"//! Physical link abstractions.\n#![allow(clippy::cast_precision_loss)]\n\nuse rand::distributions::Uniform;\nuse rand::prelude::StdRng;\nuse rand::{Rng, RngCore};\nuse std::collections::VecDeque;\nuse std::fmt::{Debug, Display};\nuse std::sync::{Arc, RwLock};\n\nuse crate::net::{\n    message::Message, runtime::ChannelUnbusyNotif, MessageExitingConnection, NetEvents,\n};\nuse crate::runtime::{rng, EventSink};\nuse crate::time::{Duration, SimTime};\n\nuse super::gate::Connection;\n\n/// A readonly reference to a channel.\npub type ChannelRef = Arc\u003cChannel\u003e;\n\n/// A representation of a one directional delayed link,.\npub struct Channel {\n    inner: RwLock\u003cChannelInner\u003e,\n}\n\nstruct ChannelInner {\n    metrics: ChannelMetrics,\n    busy: bool,\n    transmission_finish_time: SimTime,\n    buffer: Buffer,\n    probe: Box\u003cdyn ChannelProbe\u003e,\n}\n\n#[derive(Default)]\nstruct Buffer {\n    packets: VecDeque\u003c(Message, Connection)\u003e,\n    acc_bytes: usize,\n}\n\nimpl Buffer {\n    fn enqueue(\u0026mut self, msg: Message, con: Connection) {\n        self.acc_bytes += msg.length();\n        self.packets.push_back((msg, con));\n    }\n\n    fn dequeue(\u0026mut self) -\u003e Option\u003c(Message, Connection)\u003e {\n        let (msg, gate) = self.packets.pop_front()?;\n        self.acc_bytes -= msg.length();\n        Some((msg, gate))\n    }\n}\n\n/// Metrics that define a channels capabilitites.\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct ChannelMetrics {\n    /// The maximum throughput of the channel in bit/s\n    pub bitrate: usize,\n    /// The latency a message endures while transversing a channel.\n    pub latency: Duration,\n    /// The variance in latency.\n    pub jitter: Duration,\n    /// The size of the channels queue in bytes.\n    pub drop_behaviour: ChannelDropBehaviour,\n}\n\n/// The behaviour a link should follow, if it is oversubscribed\n#[derive(Debug, Default, Clone, Copy, PartialEq)]\npub enum ChannelDropBehaviour {\n    /// If a link is currently busy, drop packets\n    #[default]\n    Drop,\n    /// If a link is currently busy, queue packets up to a\n    /// provided queuelength (None means infinite queuelength)\n    Queue(Option\u003cusize\u003e),\n}\n\nimpl ChannelInner {\n    fn dup(\u0026self) -\u003e Self {\n        Self {\n            metrics: self.metrics,\n            busy: false,\n            transmission_finish_time: SimTime::ZERO,\n            buffer: Buffer::default(),\n            probe: Box::new(DummyChannelProbe),\n        }\n    }\n}\n\nimpl Channel {\n    pub(super) fn dup(\u0026self) -\u003e Self {\n        Channel {\n            inner: RwLock::new(self.inner.read().unwrap().dup()),\n        }\n    }\n\n    /// A description of the channels capabilities,\n    /// independent from its current state.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the simulation core was poisoned.\n    #[must_use]\n    pub fn metrics(\u0026self) -\u003e ChannelMetrics {\n        self.inner.read().unwrap().metrics\n    }\n\n    /// A indicator whether a channel is currently busy transmissting a\n    /// packet onto the medium.\n    ///\n    /// Note that being non-busy does not mean that no packet is currently on the medium\n    /// it just means that all bits have been put onto the medium.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the simulation core was poisoned.\n    #[must_use]\n    pub fn is_busy(\u0026self) -\u003e bool {\n        self.inner.read().unwrap().busy\n    }\n\n    /// Attaches a probe\n    ///\n    /// # Panics\n    ///\n    /// Panics if the channel mutex was poisoned.\n    pub fn attach_probe(\u0026self, probe: impl ChannelProbe) {\n        let mut chan = self\n            .inner\n            .write()\n            .expect(\"failed to get inner channel lock\");\n        let probe = Box::new(probe);\n        chan.probe = probe;\n    }\n\n    /// Sets the channel busy, announcing that the message will be trabsmitted\n    /// in '`sim_time`' time units.\n    pub(crate) fn set_busy_until(\u0026self, sim_time: SimTime) {\n        let mut chan = self.inner.write().unwrap();\n        chan.busy = true;\n        chan.transmission_finish_time = sim_time;\n    }\n\n    /// Returns the time when the packet currently being transmitted onto the medium\n    /// has been fully transmitted, or [`SimTime::ZERO`] if no packet is currently being transmitted.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the simulation core was poisoned.\n    #[must_use]\n    pub fn transmission_finish_time(\u0026self) -\u003e SimTime {\n        self.inner.read().unwrap().transmission_finish_time\n    }\n\n    /// Creates a new channel using the given metrics,\n    /// with an initially unbusy state.\n    #[must_use]\n    pub fn new(metrics: ChannelMetrics) -\u003e ChannelRef {\n        ChannelRef::new(Channel {\n            inner: RwLock::new(ChannelInner {\n                metrics,\n                busy: false,\n                transmission_finish_time: SimTime::ZERO,\n                buffer: Buffer::default(),\n                probe: Box::new(DummyChannelProbe),\n            }),\n        })\n    }\n\n    /// Calcualtes the packet travel duration using the\n    /// underlying metric.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the simulation core was poisoned.\n    pub fn calculate_duration(\u0026self, msg: \u0026Message, rng: \u0026mut StdRng) -\u003e Duration {\n        self.inner\n            .read()\n            .unwrap()\n            .metrics\n            .calculate_duration(msg, rng)\n    }\n\n    /// Calcualtes the busy time of the channel using\n    /// the underlying metric.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the simulation core was poisoned.\n    #[must_use]\n    pub fn calculate_busy(\u0026self, msg: \u0026Message) -\u003e Duration {\n        self.inner.read().unwrap().metrics.calculate_busy(msg)\n    }\n\n    pub(super) fn send_message\u003cS: EventSink\u003cNetEvents\u003e\u003e(\n        self: Arc\u003cSelf\u003e,\n        msg: Message,\n        via: Connection,\n        sink: \u0026mut S,\n    ) {\n        let rng_ref = rng();\n        let mut chan = self.inner.write().unwrap();\n\n        if chan.busy {\n            let ChannelInner {\n                metrics, buffer, ..\n            } = \u0026mut *chan;\n\n            metrics.drop_behaviour.handle(buffer, msg, via);\n        } else {\n            let ChannelInner { probe, metrics, .. } = \u0026mut *chan;\n            probe.on_message_transmit(metrics, \u0026msg);\n\n            let dur = metrics.calculate_duration(\u0026msg, rng_ref);\n            let busy = metrics.calculate_busy(\u0026msg);\n\n            if busy != Duration::ZERO {\n                let transmissin_finish = SimTime::now() + busy;\n\n                drop(chan);\n                self.set_busy_until(transmissin_finish);\n\n                sink.add(\n                    NetEvents::ChannelUnbusyNotif(ChannelUnbusyNotif {\n                        channel: self.clone(),\n                    }),\n                    transmissin_finish,\n                );\n            }\n\n            let next_event_time = SimTime::now() + dur;\n\n            sink.add(\n                NetEvents::MessageExitingConnection(MessageExitingConnection {\n                    con: via.clone(),\n                    msg,\n                }),\n                next_event_time,\n            );\n\n            // must break iteration,\n            // but not perform on-module handling\n        }\n    }\n\n    /// Resets the busy state of a channel.\n    pub(crate) fn unbusy\u003cS: EventSink\u003cNetEvents\u003e\u003e(self: Arc\u003cSelf\u003e, sink: \u0026mut S) {\n        let mut chan = self.inner.write().unwrap();\n\n        chan.busy = false;\n        chan.transmission_finish_time = SimTime::ZERO;\n\n        if let Some((msg, next_gate)) = chan.buffer.dequeue() {\n            drop(chan);\n            self.send_message(msg, next_gate, sink);\n        }\n    }\n}\n\nimpl ChannelDropBehaviour {\n    fn handle(\u0026self, buffer: \u0026mut Buffer, msg: Message, via: Connection) {\n        match self {\n            Self::Drop =\u003e {\n                #[cfg(feature = \"tracing\")]\n                tracing::warn!(\n                    \"Gate '{}' dropping message [{}] pushed onto busy channel\",\n                    via.prev_hop().unwrap().name(),\n                    msg.str(),\n                );\n                drop(msg);\n            }\n            Self::Queue(limit) =\u003e {\n                if buffer.acc_bytes + msg.length() \u003e limit.unwrap_or(usize::MAX) {\n                    #[cfg(feature = \"tracing\")]\n                    tracing::warn!(\n                        \"Gate '{}' dropping message [{}] pushed onto busy channel\",\n                        via.prev_hop().unwrap().name(),\n                        msg.str(),\n                    );\n                    drop(msg);\n                } else {\n                    #[cfg(feature = \"tracing\")]\n                    tracing::trace!(\n                        \"Gate '{}' added message [{}] to queue of channel\",\n                        via.prev_hop().unwrap().name(),\n                        msg.str(),\n                    );\n                    buffer.enqueue(msg, via);\n                }\n            }\n        }\n    }\n}\n\nimpl Debug for Channel {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        #[derive(Debug)]\n        #[allow(unused)]\n        enum FmtChannelState {\n            Idle,\n            Busy {\n                until: SimTime,\n                bytes: usize,\n                packets: usize,\n            },\n        }\n\n        impl FmtChannelState {\n            fn from(channel: \u0026ChannelInner) -\u003e Self {\n                if channel.busy {\n                    Self::Busy {\n                        until: channel.transmission_finish_time,\n                        bytes: channel.buffer.acc_bytes,\n                        packets: channel.buffer.packets.len(),\n                    }\n                } else {\n                    Self::Idle\n                }\n            }\n        }\n\n        let this = self.inner.read().unwrap();\n\n        f.debug_struct(\"Channel\")\n            .field(\"metrics\", \u0026this.metrics)\n            .field(\"state\", \u0026FmtChannelState::from(\u0026this))\n            .finish()\n    }\n}\n\nimpl ChannelMetrics {\n    /// Creates a new instance of channel metrics.\n    #[must_use]\n    pub const fn new(\n        bitrate: usize,\n        latency: Duration,\n        jitter: Duration,\n        drop_behaviour: ChannelDropBehaviour,\n    ) -\u003e Self {\n        Self {\n            bitrate,\n            latency,\n            jitter,\n            drop_behaviour,\n        }\n    }\n\n    /// Calcualtes the duration a message travels on a link.\n    #[allow(clippy::if_same_then_else)]\n    pub fn calculate_duration(\u0026self, msg: \u0026Message, rng: \u0026mut dyn RngCore) -\u003e Duration {\n        let transmission_time = self.calculate_busy(msg);\n        if self.jitter == Duration::ZERO {\n            self.latency + transmission_time\n        } else {\n            let perc = rng.sample(Uniform::new(0.0f64, self.jitter.as_secs_f64()));\n            self.latency + transmission_time + Duration::from_secs_f64(perc)\n        }\n    }\n\n    /// Calculate the duration the channel is busy transmitting the\n    /// message onto the channel.\n    #[must_use]\n    pub fn calculate_busy(\u0026self, msg: \u0026Message) -\u003e Duration {\n        if self.bitrate == 0 {\n            Duration::ZERO\n        } else {\n            let len = msg.length() * 8;\n            Duration::from_secs_f64(len as f64 / self.bitrate as f64)\n        }\n    }\n}\n\nimpl Display for ChannelMetrics {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"ChannelMetrics\")\n            .field(\"bitrate (bit/s)\", \u0026self.bitrate)\n            .field(\"lateny\", \u0026self.latency)\n            .field(\"jitter\", \u0026self.jitter)\n            .finish()\n    }\n}\n\nimpl Eq for ChannelMetrics {}\n\n/// A trait to define channel probing.\npub trait ChannelProbe: 'static {\n    /// Reacts to a message\n    fn on_message_transmit(\u0026mut self, chan: \u0026ChannelMetrics, msg: \u0026Message);\n}\n\nstruct DummyChannelProbe;\nimpl ChannelProbe for DummyChannelProbe {\n    #[inline]\n    fn on_message_transmit(\u0026mut self, _: \u0026ChannelMetrics, _: \u0026Message) {}\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4132},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2079},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2079},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":2079},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2082},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":4142},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":2067},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":4156},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":4156},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":4136},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":4136},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":2074},"fn_name":null}],"covered":116,"coverable":125},{"path":["/","Users","mk","Developer","rust","des","des","src","net","gate.rs"],"content":"//! Module-specific network ports.\n\nuse crate::net::channel::ChannelRef;\nuse std::fmt::Debug;\nuse std::sync::{Arc, Mutex, Weak};\n\nuse super::module::{ModuleContext, ModuleRef, ModuleRefWeak};\nuse super::ObjectPath;\n\n///\n/// A  reference to a gate.\n///\npub type GateRef = Arc\u003cGate\u003e;\n///\n/// A weak reference to a gate.\n///\npub(crate) type GateRefWeak = Weak\u003cGate\u003e;\n\n///\n/// A gate, a message insertion or extraction point used for handeling channels.\n///\n/// * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\npub struct Gate {\n    owner: ModuleRefWeak,\n    name: String,\n\n    size: usize,\n    pos: usize,\n\n    connections: Mutex\u003cConnections\u003e,\n}\n\n/// A kinds of operations supported on a gate.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum GateKind {\n    /// Standalone gates are not connected to any gate chain\n    /// at all. They act as start and endpoint of a gatechain of\n    /// length 0. Messages send onto these gates will never leave\n    /// the sending module.\n    Standalone,\n    /// Endpoint gates are at the start or end of gate chains.\n    /// These gates can be used to send messages onto a gate chain.\n    /// Each endpoint acts as the starting point for one direction.\n    Endpoint,\n    /// Transit gates are in the middle of a gate chain, connected\n    /// to two other gates. These gates cannot be used to start\n    /// a message sending process.\n    Transit,\n}\n\nstruct Connections {\n    connections: [Option\u003cConnection\u003e; 2],\n}\n\n/// A connection to a peering gate\n#[derive(Debug, Clone)]\npub struct Connection {\n    /// The endpoint from the view of the owning gate\n    pub endpoint: GateRef,\n    /// The index of the slot used at the endpoint\n    pub endpoint_id: usize,\n    /// A channel to slow down the connection.\n    pub channel: Option\u003cChannelRef\u003e,\n}\n\nimpl Connection {\n    /// Crease a new pseudo connection, channeling into the\n    /// provided gate\n    ///\n    /// # Panics\n    ///\n    /// Panics if the provided gate is not an endpoint.\n    pub fn new(gate: GateRef) -\u003e Self {\n        assert!(\n            gate.connections\n                .lock()\n                .expect(\"locking failure: GateRef seems to be active on another thread\")\n                .len()\n                \u003c= 1\n        );\n        Self::new_unchecked(gate)\n    }\n\n    ///\n    pub fn new_unchecked(gate: GateRef) -\u003e Self {\n        Self {\n            endpoint: gate,\n            endpoint_id: 1, // TODO: smarter ??\n            channel: None,\n        }\n    }\n\n    /// NEXT\n    ///\n    /// # Panics\n    ///\n    /// May panic on lock poisoning\n    #[must_use]\n    pub fn next_hop(\u0026self) -\u003e Option\u003cConnection\u003e {\n        let idx = [1, 0][self.endpoint_id];\n        let lock = self\n            .endpoint\n            .connections\n            .lock()\n            .expect(\"failed to get lock\");\n        lock.connections[idx].clone()\n    }\n\n    /// PREV\n    /// # Panics\n    ///\n    /// May panic on lock poisoning\n    #[must_use]\n    pub fn prev_hop(\u0026self) -\u003e Option\u003cGateRef\u003e {\n        let lock = self\n            .endpoint\n            .connections\n            .lock()\n            .expect(\"failed to get lock\");\n        Some(\n            lock.connections[self.endpoint_id]\n                .as_ref()?\n                .endpoint\n                .clone(),\n        )\n    }\n\n    /// Retrieves a handle to a channel attached to the connection\n    #[must_use]\n    pub fn channel(\u0026self) -\u003e Option\u003cChannelRef\u003e {\n        self.channel.clone()\n    }\n}\n\nimpl Connections {\n    fn new() -\u003e Self {\n        Self {\n            connections: [None, None],\n        }\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.connections.iter().filter(|v| v.is_some()).count()\n    }\n\n    fn put(\u0026mut self, connection: Connection) {\n        for i in 0..2 {\n            if self.connections[i].is_none() {\n                self.connections[i] = Some(connection);\n                return;\n            }\n        }\n        unreachable!()\n    }\n}\n\nstruct PathIter {\n    con: Option\u003cConnection\u003e,\n}\n\nimpl Iterator for PathIter {\n    type Item = Connection;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let next = self.con.as_ref()?.next_hop()?;\n        self.con = Some(next.clone());\n        Some(next)\n    }\n}\n\nimpl Gate {\n    ///\n    /// Indicator whether a descriptor describes a cluster\n    /// or a single gate\n    ///\n    #[must_use]\n    pub fn is_cluster(\u0026self) -\u003e bool {\n        self.size != 1\n    }\n\n    ///\n    /// The position index of the gate within the descriptor cluster.\n    ///\n    #[must_use]\n    pub fn pos(\u0026self) -\u003e usize {\n        self.pos\n    }\n\n    ///\n    /// The size of the gate cluster.\n    ///\n    #[must_use]\n    pub fn size(\u0026self) -\u003e usize {\n        self.size\n    }\n\n    ///\n    /// The human-readable name for the allocated gate cluster.\n    ///\n    #[must_use]\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    fn name_with_pos(\u0026self) -\u003e String {\n        if self.is_cluster() {\n            format!(\"{}[{}]\", self.name(), self.pos())\n        } else {\n            self.name().to_string()\n        }\n    }\n\n    ///\n    /// Returns a short identifcator that holds all nessecary information.\n    ///\n    #[must_use]\n    pub fn str(\u0026self) -\u003e String {\n        self.name_with_pos()\n    }\n\n    ///\n    /// The full tree path of the gate.\n    ///\n    #[must_use]\n    pub fn path(\u0026self) -\u003e ObjectPath {\n        self.owner().ctx.path.appended_gate(self.name_with_pos())\n    }\n\n    /// Returns the kind of operations allowed on this gate.\n    ///\n    /// # Panics\n    ///\n    /// Panics when accessed during teardown\n    pub fn kind(\u0026self) -\u003e GateKind {\n        match self\n            .connections\n            .try_lock()\n            .expect(\"failed to get lock\")\n            .len()\n        {\n            0 =\u003e GateKind::Standalone,\n            1 =\u003e GateKind::Endpoint,\n            _ =\u003e GateKind::Transit,\n        }\n    }\n\n    /// Connects two gates into a gate chain element.\n    ///\n    /// Gates can be organized into a bidirectional gate chain, that\n    /// forwards messages two the other end. Using this function two gates\n    /// are connected and both gates save their connection state. A gate\n    /// can have up to two other gates connected to it, forming a full gate\n    /// chain in response.\n    ///\n    /// If a channel was provided to enable message delaying on this chain element\n    /// both direction will have unique instances of the channel, with identical\n    /// configuration.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # fn a() -\u003e Option\u003c()\u003e{\n    /// # return None;\n    /// let a = current().gate(\"out\", 0)?;\n    /// let b = current().parent().ok()?.gate(\"in\", 0)?;\n    /// a.connect(b, None);\n    /// # Some(())\n    /// # }\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// This function panic if either of the two gates is allready fully connected in a chain.\n    /// This function also panics if only one gate is provided\n    #[allow(clippy::needless_pass_by_value)]\n    pub fn connect(self: GateRef, other: GateRef, channel: Option\u003cChannelRef\u003e) {\n        assert!(\n            !Arc::ptr_eq(\u0026self, \u0026other),\n            \"Cannot connect gate to itself.\"\n        );\n\n        let mut conns = self.connections.try_lock().expect(\"Failed to get lock\");\n        let mut other_conns = other.connections.try_lock().expect(\"failed to get lock\");\n\n        let conns_pos = conns.len();\n        let other_conns_pos = other_conns.len();\n        assert!(\n            conns_pos \u003c 2 \u0026\u0026 other_conns_pos \u003c 2,\n            \"Cannot add connection, gates allready connected to multiple points\"\n        );\n\n        let ch1 = channel.as_ref().map(|c| Arc::new(c.dup()));\n        let ch2 = channel;\n\n        conns.put(Connection {\n            endpoint: other.clone(),\n            endpoint_id: other_conns_pos,\n            channel: ch1,\n        });\n        other_conns.put(Connection {\n            endpoint: self.clone(),\n            endpoint_id: conns_pos,\n            channel: ch2,\n        });\n    }\n\n    /// DEDUP\n    /// # Panics\n    ///\n    /// May panic when accessed during teardown\n    pub fn connect_dedup(self: GateRef, other: GateRef, channel: Option\u003cChannelRef\u003e) {\n        // Check whether the target is allready connected\n        let conns = self.connections.try_lock().expect(\"failed lock\");\n        for i in 0..2 {\n            if let Some(ref con) = conns.connections[i] {\n                if Arc::ptr_eq(\u0026con.endpoint, \u0026other) {\n                    return;\n                }\n            }\n        }\n\n        drop(conns);\n        self.connect(other, channel);\n    }\n\n    /// CHAN\n    pub fn channel(self: \u0026GateRef) -\u003e Option\u003cChannelRef\u003e {\n        self.path_iter()?.nth(0).and_then(|con| con.channel)\n    }\n\n    /// ITER\n    pub fn path_iter(self: \u0026GateRef) -\u003e Option\u003cimpl Iterator\u003cItem = Connection\u003e\u003e {\n        if self.kind() == GateKind::Transit {\n            None\n        } else {\n            Some(PathIter {\n                con: Some(Connection::new_unchecked(self.clone())),\n            })\n        }\n    }\n\n    /// NEXT GATE\n    pub fn next_gate(self: \u0026GateRef) -\u003e Option\u003cGateRef\u003e {\n        self.path_iter()?.nth(0).map(|c| c.endpoint)\n    }\n\n    /// END\n    pub fn path_end(self: \u0026GateRef) -\u003e Option\u003cGateRef\u003e {\n        self.path_iter()?.last().map(|c| c.endpoint)\n    }\n\n    ///\n    /// Returns the owner module by reference of this gate.\n    ///\n    /// # Panics\n    ///\n    /// May panic when called in Drop, since the owner may allready\n    /// be dropped.\n    ///\n    #[must_use]\n    pub fn owner(\u0026self) -\u003e ModuleRef {\n        self.owner\n            .upgrade()\n            .expect(\"cannot refer to gate owner during drop\")\n    }\n\n    ///\n    /// Creats a new gate using the given values.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the provided size is not real positive.\n    #[must_use]\n    pub fn new(owner: \u0026ModuleRef, name: impl AsRef\u003cstr\u003e, size: usize, pos: usize) -\u003e GateRef {\n        assert!(size \u003e= 1, \"Cannot create with a non-postive size\");\n\n        let this = GateRef::new(Self {\n            owner: ModuleRefWeak::new(owner),\n            name: name.as_ref().to_string(),\n            size,\n            pos,\n            connections: Mutex::new(Connections::new()),\n        });\n\n        this\n    }\n}\n\n#[allow(clippy::missing_fields_in_debug)]\nimpl Debug for Gate {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"Gate\")\n            .field(\"path\", \u0026self.path().as_str())\n            .finish()\n    }\n}\n\n// SAFTY:\n// Gates are never exposed by value to the user so they will be marked\n// as `Send` to fulfill the trait bound for Ptr\u003cGate\u003e to be `Send`.\nunsafe impl Send for Gate {}\n\n// SOLVED ISSUE: stack overflow when comaring circular ptr\n// next_gate \u0026 previous_gate --\u003e Custim PartialEq impl\nimpl PartialEq for Gate {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.name == other.name\n            \u0026\u0026 self.owner().ctx.id == other.owner().ctx.id\n            \u0026\u0026 self.size == other.size\n            \u0026\u0026 self.pos == other.pos\n    }\n}\nimpl Eq for Gate {}\n\nmod private {\n    pub trait Sealed {}\n}\n\n///\n/// A trait for a type to refrence a module specific gate.\n///\npub trait IntoModuleGate: private::Sealed {\n    ///\n    /// Extracts a gate identifier from a module using the given\n    /// value as implicit reference.\n    ///\n    fn as_gate(\u0026self, module: \u0026ModuleContext) -\u003e Option\u003cGateRef\u003e;\n}\n\nimpl\u003cT: IntoModuleGate\u003e IntoModuleGate for \u0026T {\n    fn as_gate(\u0026self, module: \u0026ModuleContext) -\u003e Option\u003cGateRef\u003e {\n        T::as_gate(self, module)\n    }\n}\nimpl\u003cT: IntoModuleGate\u003e private::Sealed for \u0026T {}\n\nimpl IntoModuleGate for GateRef {\n    fn as_gate(\u0026self, _: \u0026ModuleContext) -\u003e Option\u003cGateRef\u003e {\n        Some(self.clone())\n    }\n}\nimpl private::Sealed for GateRef {}\n\nimpl IntoModuleGate for GateRefWeak {\n    fn as_gate(\u0026self, _: \u0026ModuleContext) -\u003e Option\u003cGateRef\u003e {\n        self.upgrade()\n    }\n}\nimpl private::Sealed for GateRefWeak {}\n\nimpl IntoModuleGate for (\u0026str, usize) {\n    fn as_gate(\u0026self, module: \u0026ModuleContext) -\u003e Option\u003cGateRef\u003e {\n        module\n            .gates\n            .read()\n            .iter()\n            .find(|\u0026g| g.name() == self.0 \u0026\u0026 g.pos() == self.1)\n            .cloned()\n    }\n}\nimpl private::Sealed for (\u0026str, usize) {}\n\nimpl IntoModuleGate for \u0026str {\n    fn as_gate(\u0026self, module: \u0026ModuleContext) -\u003e Option\u003cGateRef\u003e {\n        module\n            .gates\n            .read()\n            .iter()\n            .find(|\u0026g| g.name() == *self \u0026\u0026 g.size() == 1)\n            .cloned()\n    }\n}\nimpl private::Sealed for \u0026str {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn fmt() {\n        let owner = ModuleContext::standalone(\"root\".into());\n        let gate = Gate::new(\u0026owner, \"port\", 4, 1);\n        assert_eq!(format!(\"{gate:?}\"), \"Gate { path: \\\"root.port[1]\\\" }\");\n        assert_eq!(gate.str(), \"port[1]\");\n        assert_eq!(gate.path().as_str(), \"root.port[1]\");\n    }\n\n    #[test]\n    fn kind_and_iter() {\n        let owner = ModuleContext::standalone(\"root\".into());\n        let gate_a = Gate::new(\u0026owner, \"port-a\", 1, 0);\n        assert_eq!(gate_a.kind(), GateKind::Standalone);\n\n        let gate_b = Gate::new(\u0026owner, \"port-b\", 1, 0);\n        gate_a.clone().connect(gate_b.clone(), None);\n        assert_eq!(gate_a.kind(), GateKind::Endpoint);\n\n        let gate_c = Gate::new(\u0026owner, \"port-c\", 1, 0);\n        gate_a.clone().connect(gate_c.clone(), None);\n        assert_eq!(gate_a.kind(), GateKind::Transit);\n\n        // Chain chould be c -- a -- b\n        assert_eq!(gate_c.next_gate(), Some(gate_a.clone()));\n        assert_eq!(gate_c.path_end(), Some(gate_b));\n\n        let mut iter = gate_c.path_iter().unwrap();\n        let ca = iter.next().unwrap();\n        assert_eq!(ca.prev_hop(), Some(gate_c));\n        let ab = iter.next().unwrap();\n        assert_eq!(ab.prev_hop(), Some(gate_a));\n    }\n\n    #[test]\n    fn dedup() {\n        let owner = ModuleContext::standalone(\"root\".into());\n        let gate = Gate::new(\u0026owner, \"port\", 1, 0);\n        assert_eq!(gate.kind(), GateKind::Standalone);\n\n        let gate_b = Gate::new(\u0026owner, \"port-b\", 1, 0);\n        gate.clone().connect_dedup(gate_b.clone(), None);\n        assert_eq!(gate.kind(), GateKind::Endpoint);\n\n        gate.clone().connect_dedup(gate_b, None);\n        assert_eq!(gate.kind(), GateKind::Endpoint);\n    }\n\n    #[test]\n    fn into_gate() {\n        let ctx = ModuleContext::standalone(\"root\".into());\n        let gate_a = ctx.create_gate(\"port-a\");\n\n        assert_eq!((\u0026gate_a).as_gate(\u0026ctx.ctx), Some(gate_a.clone()));\n        assert_eq!(\n            Arc::downgrade(\u0026gate_a).as_gate(\u0026ctx.ctx),\n            Some(gate_a.clone())\n        );\n    }\n}\n","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2242},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4438},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4438},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4438},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":4438},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":4438},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":4438},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2195},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":2195},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2340},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":9360},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":186},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":582},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1579},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1579},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1625},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1625},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":7138},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":7138},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":162},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":111},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":111},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":109},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":109},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":10863},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":10863},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":451},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":451},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":1625},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":1625},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":1625},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":11237},"fn_name":null}],"covered":113,"coverable":121},{"path":["/","Users","mk","Developer","rust","des","des","src","net","message","api.rs"],"content":"use crate::{\n    net::{\n        gate::IntoModuleGate,\n        message::Message,\n        module::with_mod_ctx,\n        runtime::{buf_schedule_at, buf_send_at},\n    },\n    time::{Duration, SimTime},\n};\n\n/// Sends a message onto a given gate. The effects of this sending operation\n/// will be observable directly, so an attached channel will be busy right after\n/// the the call to `send`.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// struct MyModule;\n///\n/// impl Module for MyModule {\n///     fn handle_message(\u0026mut self, _msg: Message) {\n///         send(\n///             Message::new().id(123).content(\"Hello world\").build(),\n///             \"out\"\n///         );\n///     }\n/// }\n///\n/// let mut sim = Sim::new(());\n/// sim.node(\"alice\", MyModule);\n/// sim.gate(\"alice\", \"out\");\n/// /* ... */\n///\n/// let _ = Builder::new().build(sim).run();\n/// ```\n#[allow(clippy::needless_pass_by_value)]\npub fn send(msg: impl Into\u003cMessage\u003e, gate: impl IntoModuleGate) {\n    self::send_at(msg, gate, SimTime::now());\n}\n\n/// Sends a message onto a given gate with a delay. If the delay is nonzero\n/// the effects will only be observable later on.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// # struct SomeOtherModule;\n/// # impl Module for SomeOtherModule {}\n/// struct MyModule;\n///\n/// impl Module for MyModule {\n///     fn at_sim_start(\u0026mut self, _: usize) {\n///         send_in(Message::new().kind(42).build(), \"out\", Duration::from_secs(2));\n///         assert!(\n///             !current()\n///                 .gate(\"out\", 0).unwrap()\n///                 .path_iter().unwrap() // an iter can NOT be created for transit gates, no direction info provided\n///                 .next().unwrap() // get next iter element\n///                 .channel().unwrap() // channels attached to connections are optional\n///                 .is_busy()     \n///        );\n///     }\n/// }\n///\n/// let mut sim = Sim::new(());\n/// sim.node(\"alice\", MyModule);\n/// let out_gate = sim.gate(\"alice\", \"out\");\n///\n/// sim.node(\"bob\", SomeOtherModule);\n/// let in_gate = sim.gate(\"bob\", \"in\");\n///\n/// out_gate.connect(in_gate, Some(\n///     /* Channel definition */\n///     # Channel::new(ChannelMetrics { bitrate: 10000, jitter: Duration::ZERO, latency: Duration::from_millis(10), drop_behaviour: ChannelDropBehaviour::Drop })\n/// ));\n///\n/// let _ = Builder::new().build(sim).run();\n///\n/// ```\n#[allow(clippy::needless_pass_by_value)]\npub fn send_in(msg: impl Into\u003cMessage\u003e, gate: impl IntoModuleGate, dur: Duration) {\n    let deadline = SimTime::now() + dur;\n    self::send_at(msg, gate, deadline);\n}\n/// Sends a message onto a given gate at the specific time. This operation is\n/// equivalent to [`send_in`].\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// # Panics\n///\n/// Panics if the send time is in the past.\n#[allow(clippy::needless_pass_by_value)]\npub fn send_at(msg: impl Into\u003cMessage\u003e, gate: impl IntoModuleGate, send_time: SimTime) {\n    assert!(send_time \u003e= SimTime::now());\n    // (0) Cast the message.\n    let msg: Message = msg.into();\n\n    let gate = with_mod_ctx(|ctx| {\n        // (1) Cast the gate\n        #[allow(clippy::explicit_auto_deref)] // IS RIGHT ?\n        gate.as_gate(ctx)\n    });\n\n    if let Some(gate) = gate {\n        // plugin capture\n        // let Some(msg) = plugin::plugin_output_stream(msg) else {\n        //     return\n        // };\n\n        buf_send_at(msg, gate, send_time);\n    } else {\n        #[cfg(feature = \"tracing\")]\n        tracing::error!(\"Error: Could not find gate in current module\");\n    }\n}\n\n/// Enqueues a event that will trigger the\n/// [`Module::handle_message`](crate::net::module::Module::handle_message)\n/// function in duration seconds, shifted by the processing time delay.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// struct Timer { period: Duration }\n/// impl Module for Timer {\n///     fn at_sim_start(\u0026mut self, _: usize) {\n///         schedule_in(Message::new().content(\"wakeup\").build(), self.period);\n///     }\n///\n///     fn handle_message(\u0026mut self, msg: Message) {\n///         assert_eq!(msg.try_content::\u003c\u0026str\u003e(), Some(\u0026\"wakeup\"));\n///         /* Do something periodicly */\n///         schedule_in(msg, self.period);\n///     }\n/// }\n///\n/// let mut sim = Sim::new(());\n/// sim.node(\"timer\", Timer { period: Duration::from_secs(5) });\n/// /* ... */\n///\n/// let _ = Builder::new().max_time(100.0.into()).build(sim).run();\n/// ```\npub fn schedule_in(msg: impl Into\u003cMessage\u003e, dur: Duration) {\n    self::schedule_at(msg, SimTime::now() + dur);\n}\n\n/// Enqueues a event that will trigger the\n/// [`Module::handle_message`](crate::net::module::Module::handle_message)\n/// function at the given `SimTime`. This operation is equivalent to [`schedule_in`].\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// # Panics\n///\n/// Panics if the specified time is in the past.\npub fn schedule_at(msg: impl Into\u003cMessage\u003e, arrival_time: SimTime) {\n    assert!(arrival_time \u003e= SimTime::now());\n    let msg: Message = msg.into();\n\n    // plugin capture\n    // let Some(msg) = plugin::plugin_output_stream(msg) else {\n    //     return\n    // };\n\n    buf_schedule_at(msg, arrival_time);\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":2075},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2075},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":4170},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":4170},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1114},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1114},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null}],"covered":18,"coverable":21},{"path":["/","Users","mk","Developer","rust","des","des","src","net","message","body.rs"],"content":"/// A trait that allows a type to be mesured in bits / bytes.\n///\n/// * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\npub trait MessageBody {\n    /// The length of the message body in bytes.\n    fn byte_len(\u0026self) -\u003e usize;\n}\n\n// # Primitives\n\nmacro_rules! msg_body_primitiv {\n    ($t: ty) =\u003e {\n        impl MessageBody for $t {\n            fn byte_len(\u0026self) -\u003e usize {\n                std::mem::size_of::\u003cSelf\u003e()\n            }\n        }\n    };\n}\n\nmsg_body_primitiv!(());\n\nmsg_body_primitiv!(u8);\nmsg_body_primitiv!(u16);\nmsg_body_primitiv!(u32);\nmsg_body_primitiv!(u64);\nmsg_body_primitiv!(u128);\nmsg_body_primitiv!(usize);\n\nmsg_body_primitiv!(i8);\nmsg_body_primitiv!(i16);\nmsg_body_primitiv!(i32);\nmsg_body_primitiv!(i64);\nmsg_body_primitiv!(i128);\nmsg_body_primitiv!(isize);\n\nmsg_body_primitiv!(f64);\nmsg_body_primitiv!(f32);\n\nmsg_body_primitiv!(bool);\nmsg_body_primitiv!(char);\n\nmacro_rules! msg_body_lenable {\n    ($t: ty) =\u003e {\n        impl MessageBody for $t {\n            fn byte_len(\u0026self) -\u003e usize {\n                self.len()\n            }\n        }\n    };\n}\n\nmsg_body_lenable!(\u0026'static str);\nmsg_body_lenable!(String);\n\n// # Basic types\n\nimpl\u003cT: MessageBody\u003e MessageBody for Box\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        use std::ops::Deref;\n\n        self.deref().byte_len()\n    }\n}\n\nimpl\u003cT: MessageBody\u003e MessageBody for Option\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        match self {\n            Some(ref content) =\u003e content.byte_len(),\n            None =\u003e 0,\n        }\n    }\n}\n\nimpl\u003cT: MessageBody, E: MessageBody\u003e MessageBody for Result\u003cT, E\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        match self {\n            Ok(ref val) =\u003e val.byte_len(),\n            Err(ref err) =\u003e err.byte_len(),\n        }\n    }\n}\n\n// # Collections\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, LinkedList, VecDeque};\n\nimpl\u003cT: MessageBody\u003e MessageBody for Vec\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        self.iter().fold(0, |acc, v| acc + v.byte_len())\n    }\n}\n\nimpl\u003cT: MessageBody\u003e MessageBody for VecDeque\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        self.iter().fold(0, |acc, v| acc + v.byte_len())\n    }\n}\n\nimpl\u003cT: MessageBody\u003e MessageBody for LinkedList\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        self.iter().fold(0, |acc, v| acc + v.byte_len())\n    }\n}\n\nimpl\u003cT: MessageBody, const N: usize\u003e MessageBody for [T; N] {\n    fn byte_len(\u0026self) -\u003e usize {\n        let mut sum = 0;\n        for element in self {\n            sum += element.byte_len();\n        }\n        sum\n    }\n}\n\nimpl\u003cT: MessageBody\u003e MessageBody for \u0026[T] {\n    fn byte_len(\u0026self) -\u003e usize {\n        self.iter().fold(0, |acc, v| acc + v.byte_len())\n    }\n}\n\nimpl\u003cK: MessageBody, V: MessageBody, S\u003e MessageBody for HashMap\u003cK, V, S\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        let mut sum = 0;\n        for (k, v) in self {\n            sum += k.byte_len() + v.byte_len();\n        }\n        sum\n    }\n}\n\nimpl\u003cK: MessageBody, V: MessageBody\u003e MessageBody for BTreeMap\u003cK, V\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        let mut sum = 0;\n        for (k, v) in self {\n            sum += k.byte_len() + v.byte_len();\n        }\n        sum\n    }\n}\n\nimpl\u003cT: MessageBody, S\u003e MessageBody for HashSet\u003cT, S\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        let mut sum = 0;\n        for v in self {\n            sum += v.byte_len();\n        }\n        sum\n    }\n}\n\nimpl\u003cT: MessageBody\u003e MessageBody for BTreeSet\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        let mut sum = 0;\n        for v in self {\n            sum += v.byte_len();\n        }\n        sum\n    }\n}\n\nimpl\u003cT: MessageBody\u003e MessageBody for BinaryHeap\u003cT\u003e {\n    fn byte_len(\u0026self) -\u003e usize {\n        let mut sum = 0;\n        for v in self {\n            sum += v.byte_len();\n        }\n        sum\n    }\n}\n\n// # std::net\nuse std::net;\n\nimpl MessageBody for net::Ipv4Addr {\n    fn byte_len(\u0026self) -\u003e usize {\n        4\n    }\n}\n\nimpl MessageBody for net::Ipv6Addr {\n    fn byte_len(\u0026self) -\u003e usize {\n        16\n    }\n}\n\nimpl MessageBody for net::IpAddr {\n    fn byte_len(\u0026self) -\u003e usize {\n        match self {\n            Self::V4(v4) =\u003e v4.byte_len(),\n            Self::V6(v6) =\u003e v6.byte_len(),\n        }\n    }\n}\n\nimpl MessageBody for net::SocketAddrV4 {\n    fn byte_len(\u0026self) -\u003e usize {\n        4 + 2\n    }\n}\n\nimpl MessageBody for net::SocketAddrV6 {\n    fn byte_len(\u0026self) -\u003e usize {\n        16 + 2\n    }\n}\n\nimpl MessageBody for net::SocketAddr {\n    fn byte_len(\u0026self) -\u003e usize {\n        match self {\n            Self::V4(v4) =\u003e v4.byte_len(),\n            Self::V6(v6) =\u003e v6.byte_len(),\n        }\n    }\n}\n\n// # Time\nuse crate::time;\n\nimpl MessageBody for time::Duration {\n    fn byte_len(\u0026self) -\u003e usize {\n        16\n    }\n}\n\nimpl MessageBody for time::SimTime {\n    fn byte_len(\u0026self) -\u003e usize {\n        16\n    }\n}\n\n// # Tuples\n\nimpl\u003cA, B\u003e MessageBody for (A, B)\nwhere\n    A: MessageBody,\n    B: MessageBody,\n{\n    fn byte_len(\u0026self) -\u003e usize {\n        self.0.byte_len() + self.1.byte_len()\n    }\n}\n\nimpl\u003cA, B, C\u003e MessageBody for (A, B, C)\nwhere\n    A: MessageBody,\n    B: MessageBody,\n    C: MessageBody,\n{\n    fn byte_len(\u0026self) -\u003e usize {\n        self.0.byte_len() + self.1.byte_len() + self.2.byte_len()\n    }\n}\n\nimpl\u003cA, B, C, D\u003e MessageBody for (A, B, C, D)\nwhere\n    A: MessageBody,\n    B: MessageBody,\n    C: MessageBody,\n    D: MessageBody,\n{\n    fn byte_len(\u0026self) -\u003e usize {\n        self.0.byte_len() + self.1.byte_len() + self.2.byte_len() + self.3.byte_len()\n    }\n}\n\nimpl\u003cA, B, C, D, E\u003e MessageBody for (A, B, C, D, E)\nwhere\n    A: MessageBody,\n    B: MessageBody,\n    C: MessageBody,\n    D: MessageBody,\n    E: MessageBody,\n{\n    fn byte_len(\u0026self) -\u003e usize {\n        self.0.byte_len()\n            + self.1.byte_len()\n            + self.2.byte_len()\n            + self.3.byte_len()\n            + self.4.byte_len()\n    }\n}\n\nimpl\u003cA, B, C, D, E, F\u003e MessageBody for (A, B, C, D, E, F)\nwhere\n    A: MessageBody,\n    B: MessageBody,\n    C: MessageBody,\n    D: MessageBody,\n    E: MessageBody,\n    F: MessageBody,\n{\n    fn byte_len(\u0026self) -\u003e usize {\n        self.0.byte_len()\n            + self.1.byte_len()\n            + self.2.byte_len()\n            + self.3.byte_len()\n            + self.4.byte_len()\n            + self.5.byte_len()\n    }\n}\n\n///\n/// A message body that does mimics a custom size\n/// independet of actualy size.\n///\n#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct CustomSizeBody\u003cT\u003e {\n    byte_len: usize,\n    inner: T,\n}\n\nimpl\u003cT\u003e CustomSizeBody\u003cT\u003e {\n    ///\n    /// Creates a new instance of `Self`.\n    ///\n    #[must_use]\n    pub fn new(byte_len: usize, inner: T) -\u003e Self {\n        Self { byte_len, inner }\n    }\n\n    ///\n    /// Returns a reference to the real contained body.\n    ///\n    pub fn inner(\u0026self) -\u003e \u0026T {\n        \u0026self.inner\n    }\n\n    ///\n    /// Returns a mutable reference to the real contained body.\n    ///\n    pub fn inner_mut(\u0026mut self) -\u003e \u0026mut T {\n        \u0026mut self.inner\n    }\n\n    ///\n    /// Returns the body, consuming `self`.\n    ///\n    #[must_use]\n    pub fn into_inner(self) -\u003e T {\n        self.inner\n    }\n}\n\nimpl\u003cT\u003e MessageBody for CustomSizeBody\u003cT\u003e\nwhere\n    T: Clone,\n{\n    fn byte_len(\u0026self) -\u003e usize {\n        self.byte_len\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{super::*, *};\n\n    #[test]\n    fn custom_message_body() {\n        let slice = \"Hello world!\";\n\n        let mut body = CustomSizeBody::new(16, slice);\n        assert_eq!(body.inner(), \u0026\"Hello world!\");\n        assert_eq!(body.inner_mut(), \u0026mut \"Hello world!\");\n\n        let msg = Message::new().content(body).build();\n        assert_eq!(msg.length(), 16 + 64);\n\n        let content = msg.content::\u003cCustomSizeBody\u003c\u0026str\u003e\u003e();\n        assert_eq!((*content.inner()).as_ptr(), slice.as_ptr());\n\n        let content = content.clone();\n        assert_eq!(content.into_inner(), \"Hello world!\");\n    }\n\n    #[test]\n    fn auto_impl() {\n        assert_eq!(\n            [1, 2, 3, 4u8]\n                .into_iter()\n                .collect::\u003cVecDeque\u003c_\u003e\u003e()\n                .byte_len(),\n            4\n        );\n\n        assert_eq!(\n            [1, 2, 3, 4u8]\n                .into_iter()\n                .collect::\u003cLinkedList\u003c_\u003e\u003e()\n                .byte_len(),\n            4\n        );\n\n        assert_eq!(\n            [1, 2, 3, 4u8]\n                .into_iter()\n                .collect::\u003cHashSet\u003c_\u003e\u003e()\n                .byte_len(),\n            4\n        );\n\n        assert_eq!(\n            [1, 2, 3, 4u8]\n                .into_iter()\n                .collect::\u003cBTreeSet\u003c_\u003e\u003e()\n                .byte_len(),\n            4\n        );\n\n        assert_eq!(\n            [1, 2, 3, 4u8]\n                .into_iter()\n                .collect::\u003cBinaryHeap\u003c_\u003e\u003e()\n                .byte_len(),\n            4\n        );\n\n        assert_eq!(\n            [(1, 1), (2, 2), (3, 3), (4u8, 4u16)]\n                .into_iter()\n                .collect::\u003cHashMap\u003c_, _\u003e\u003e()\n                .byte_len(),\n            12\n        );\n\n        assert_eq!(\n            [(1, 1), (2, 2), (3, 3), (4u8, 4u16)]\n                .into_iter()\n                .collect::\u003cBTreeMap\u003c_, _\u003e\u003e()\n                .byte_len(),\n            12\n        );\n\n        assert_eq!((\u0026[1, 2, 3, 4u8][..3]).byte_len(), 3);\n\n        assert_eq!(net::Ipv4Addr::new(1, 2, 3, 4).byte_len(), 4);\n        assert_eq!(net::Ipv6Addr::new(1, 2, 3, 4, 0, 0, 0, 0).byte_len(), 16);\n        assert_eq!(\n            net::IpAddr::V4(net::Ipv4Addr::new(1, 2, 3, 4)).byte_len(),\n            4\n        );\n        assert_eq!(\n            net::IpAddr::V6(net::Ipv6Addr::new(1, 2, 3, 4, 0, 0, 0, 0)).byte_len(),\n            16\n        );\n\n        assert_eq!(\n            net::SocketAddrV4::new(net::Ipv4Addr::new(1, 2, 3, 4), 0).byte_len(),\n            4 + 2\n        );\n        assert_eq!(\n            net::SocketAddrV6::new(net::Ipv6Addr::new(1, 2, 3, 4, 0, 0, 0, 0), 0, 0, 0).byte_len(),\n            16 + 2\n        );\n        assert_eq!(\n            net::SocketAddr::V4(net::SocketAddrV4::new(net::Ipv4Addr::new(1, 2, 3, 4), 0))\n                .byte_len(),\n            4 + 2\n        );\n        assert_eq!(\n            net::SocketAddr::V6(net::SocketAddrV6::new(\n                net::Ipv6Addr::new(1, 2, 3, 4, 0, 0, 0, 0),\n                0,\n                0,\n                0\n            ))\n            .byte_len(),\n            16 + 2\n        );\n\n        assert_eq!(time::Duration::from_secs(123).byte_len(), 16);\n        assert_eq!(\n            time::SimTime::from_duration(time::Duration::from_secs(123)).byte_len(),\n            16\n        );\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2623},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":2623},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4145},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4145},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":7685},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2560},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":81,"coverable":100},{"path":["/","Users","mk","Developer","rust","des","des","src","net","message","header.rs"],"content":"#![allow(dead_code)]\n\nuse super::MessageBody;\nuse crate::net::{gate::GateRef, module::ModuleId};\nuse crate::time::SimTime;\n\nuse std::fmt::Debug;\n\n///\n/// A ID that defines the meaning of the message in the simulation context.\n///\n///  * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\npub type MessageId = u16;\n\n///\n/// The type of messages, similar to the TOS field in IP packets.\n///\n///  * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\npub type MessageKind = u16;\n\n///\n/// The metadata attachted to a message, independent of its contents.\n///\n/// * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[allow(missing_docs)]\npub struct MessageHeader {\n    pub id: MessageId,     // Custom\n    pub kind: MessageKind, // Ethertype\n    pub creation_time: SimTime,\n    pub send_time: SimTime,\n\n    pub sender_module_id: ModuleId,   // MAC src\n    pub receiver_module_id: ModuleId, // MAC dest\n    pub last_gate: Option\u003cGateRef\u003e,   // Path info\n\n    pub src: [u8; 6],\n    pub dest: [u8; 6],\n\n    // The packet length in bytes.\n    pub length: u32,\n}\n\n// # DUP\nimpl MessageHeader {\n    pub(super) fn dup(\u0026self, now: SimTime) -\u003e Self {\n        Self {\n            id: self.id,\n            kind: self.kind,\n            creation_time: now,\n            send_time: SimTime::MIN,\n\n            sender_module_id: self.sender_module_id,\n            receiver_module_id: self.receiver_module_id,\n            last_gate: self.last_gate.clone(),\n\n            src: self.src,\n            dest: self.dest,\n\n            length: self.length,\n        }\n    }\n}\n\nimpl Default for MessageHeader {\n    fn default() -\u003e Self {\n        Self {\n            id: 0,\n            kind: 0,\n            creation_time: SimTime::now(),\n            send_time: SimTime::MIN,\n\n            sender_module_id: ModuleId::NULL,\n            receiver_module_id: ModuleId::NULL,\n            last_gate: None,\n\n            src: [0; 6],\n            dest: [0; 6],\n\n            length: 0,\n        }\n    }\n}\n\nimpl MessageBody for MessageHeader {\n    fn byte_len(\u0026self) -\u003e usize {\n        64 // TODO  compute correct header size\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn header_duplication() {\n        let header = MessageHeader {\n            id: 42,\n            kind: 69,\n            creation_time: 100.0.into(),\n            send_time: 150.0.into(),\n            sender_module_id: ModuleId(12),\n            receiver_module_id: ModuleId(14),\n            last_gate: None,\n            src: [1; 6],\n            dest: [2; 6],\n            length: 32,\n        };\n\n        assert_eq!(\n            header.dup(200.0.into()),\n            MessageHeader {\n                id: 42,\n                kind: 69,\n                creation_time: 200.0.into(),\n                send_time: SimTime::MIN,\n                sender_module_id: ModuleId(12),\n                receiver_module_id: ModuleId(14),\n                last_gate: None,\n                src: [1; 6],\n                dest: [2; 6],\n                length: 32,\n            }\n        )\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2325},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2325},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2325},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2325},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":4141},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":4141},"fn_name":null}],"covered":15,"coverable":15},{"path":["/","Users","mk","Developer","rust","des","des","src","net","message","mod.rs"],"content":"//! Generic network messages.\n\nuse crate::net::{gate::GateRef, module::ModuleId};\nuse crate::time::SimTime;\nuse std::fmt::Debug;\nuse std::panic::UnwindSafe;\n\nmod api;\npub use api::*;\n\nmod body;\npub use body::*;\n\nmod util;\nuse util::AnyBox;\n\nmod header;\npub use header::*;\n\n///\n/// A generic network message holding a payload.\n///\n/// * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\n#[derive(Debug)]\npub struct Message {\n    pub(crate) header: Box\u003cMessageHeader\u003e,\n    pub(crate) content: Option\u003cAnyBox\u003e,\n}\n\nimpl Message {\n    ///\n    /// Creates a new instance of self through a builder.\n    ///\n    #[allow(clippy::new_ret_no_self)]\n    #[must_use]\n    pub fn new() -\u003e MessageBuilder {\n        MessageBuilder::new()\n    }\n\n    /// Returns the length of the complete message\n    #[must_use]\n    pub fn length(\u0026self) -\u003e usize {\n        self.header.length as usize + self.header.byte_len()\n    }\n\n    ///\n    /// The metadata attached to the message.\n    ///\n    #[inline]\n    #[must_use]\n    pub fn header(\u0026self) -\u003e \u0026MessageHeader {\n        \u0026self.header\n    }\n\n    ///\n    /// The metadata attached to the message.\n    ///\n    #[inline]\n    #[must_use]\n    pub fn header_mut(\u0026mut self) -\u003e \u0026mut MessageHeader {\n        \u0026mut self.header\n    }\n\n    ///\n    /// A strinification function that reduces it to its identifering pars.\n    ///\n    #[must_use]\n    pub fn str(\u0026self) -\u003e String {\n        format!(\n            \"Message {{ {} bytes {}  }}\",\n            self.header.length,\n            self.content.as_ref().map_or(\"no content\", AnyBox::ty),\n        )\n    }\n}\n\n/// # Content Accessing\nimpl Message {\n    ///\n    /// Trys to return the content by reference casted to the given type T.\n    /// Returns [None] if the no content exists or the content is not of type T.\n    ///\n    #[must_use]\n    pub fn try_content\u003cT: 'static + MessageBody\u003e(\u0026self) -\u003e Option\u003c\u0026T\u003e {\n        Some(self.content.as_ref()?.try_cast_ref::\u003cT\u003e())?\n    }\n\n    ///\n    /// Trys to return the content by reference casted to the given type T.\n    /// Panics if the no content exists or the content is not of type T.\n    ///\n    /// # Panics\n    ///\n    /// Panics if he cast fails.\n    #[must_use]\n    pub fn content\u003cT: 'static + MessageBody\u003e(\u0026self) -\u003e \u0026T {\n        self.try_content().expect(\"Failed to unwrap\")\n    }\n\n    ///\n    /// Trys to return the content by mutable ref casted to the given type T.\n    /// Returns [None] if the no content exists or the content is not of type T.\n    ///\n    pub fn try_content_mut\u003cT: 'static + MessageBody\u003e(\u0026mut self) -\u003e Option\u003c\u0026mut T\u003e {\n        Some(self.content.as_mut()?.try_cast_mut())?\n    }\n\n    ///\n    /// Trys to return the content by mutable ref casted to the given type T.\n    /// Panics if the no content exists or the content is not of type T.\n    ///\n    /// # Panics\n    ///\n    /// Panics if he cast fails.\n    pub fn content_mut\u003cT: 'static + MessageBody\u003e(\u0026mut self) -\u003e \u0026mut T {\n        self.try_content_mut().expect(\"Failed to unwrap\")\n    }\n}\n\n/// # Content casting\nimpl Message {\n    ///\n    /// Indicates wheter a cast to a instance of type T ca\n    /// succeed.\n    ///\n    /// ## Safty\n    ///\n    /// Note that this only gurantees that a cast will result in UB\n    /// if it returns 'false'. Should this function return 'true' it indicates\n    /// that the underlying value was created as a instance of type 'T',\n    /// which does not gurantee that this is a internally valid instance\n    /// of 'T'.\n    ///\n    /// # Panics\n    ///\n    /// Panics if he cast fails.\n    #[inline]\n    #[must_use]\n    pub fn can_cast\u003cT: 'static + MessageBody\u003e(\u0026self) -\u003e bool {\n        self.content.as_ref().map_or(false, AnyBox::can_cast::\u003cT\u003e)\n    }\n\n    ///\n    /// Performs a [`try_cast`](Message::try_cast)unwraping the result.\n    ///\n    /// # Panics\n    ///\n    /// Panics if he cast fails.\n    #[must_use]\n    pub fn cast\u003cT: 'static + MessageBody + Send\u003e(self) -\u003e (T, MessageHeader) {\n        self.try_cast().expect(\"Could not cast to type T\")\n    }\n\n    ///\n    /// Consumes the message casting the stored ptr\n    /// into a Box of type T.\n    ///\n    /// ## Safety\n    ///\n    /// The caller must ensure that the stored data is a valid instance\n    /// of type T. If this cannot be guarnteed this is UB.\n    /// Note that DES guarntees that the data refernced by ptr will not\n    /// be freed until this function is called, and ownership is thereby moved..\n    ///D\n    /// # Errors\n    ///\n    /// Returns an error if either there is no content, or\n    /// the content is not of type T.\n    pub fn try_cast\u003cT: 'static + MessageBody + Send\u003e(self) -\u003e Result\u003c(T, MessageHeader), Self\u003e {\n        // SAFTY:\n        // Since T is 'Send' this is safe within the bounds of Messages safty contract\n        unsafe { self.try_cast_unsafe::\u003cT\u003e() }\n    }\n\n    ///\n    /// Performs a [`try_cast_unsafe`](Message::try_cast_unsafe) unwraping the result.\n    ///\n    /// # Safety\n    ///\n    /// See [`try_cast_unsafe`](Message::try_cast_unsafe)\n    ///\n    /// # Panics\n    ///\n    /// Panics if he cast fails.\n    #[must_use]\n    pub unsafe fn cast_unsafe\u003cT: 'static + MessageBody\u003e(self) -\u003e (T, MessageHeader) {\n        self.try_cast_unsafe().expect(\"Could not cast to type T\")\n    }\n\n    ///\n    /// Consumes the message casting the stored ptr\n    /// into a Box of type T.\n    ///\n    /// ## Safety\n    ///\n    /// The caller must ensure that the stored data is a valid instance\n    /// of type T. If this cannot be guarnteed this is UB.\n    /// Note that DES guarntees that the data refernced by ptr will not\n    /// be freed until this function is called, and ownership is thereby moved..\n    /// Note that this function allows T to be !Send. Be aware of safty problems arriving\n    /// from this.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if either there is no content,\n    /// or the content is not of type T.\n    ///\n\n    pub unsafe fn try_cast_unsafe\u003cT: 'static + MessageBody\u003e(\n        self,\n    ) -\u003e Result\u003c(T, MessageHeader), Self\u003e {\n        let Message { header, content } = self;\n        let content = match content.map(|c| c.try_cast_unsafe::\u003cT\u003e()) {\n            Some(Ok(c)) =\u003e c,\n            Some(Err(content)) =\u003e {\n                return Err(Self {\n                    header,\n                    content: Some(content),\n                })\n            }\n            None =\u003e {\n                return Err(Self {\n                    header,\n                    content: None,\n                })\n            }\n        };\n\n        Ok((content, *header))\n    }\n}\n\nimpl Message {\n    ///\n    /// Duplicates a message.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the contained value is not of type T.\n    ///\n    #[must_use]\n    pub fn dup\u003cT\u003e(\u0026self) -\u003e Self\n    where\n        T: 'static + Clone,\n    {\n        self.try_dup::\u003cT\u003e().expect(\"Failed to duplicate a message\")\n    }\n\n    ///\n    /// Tries to create a duplicate of the message, assuming its content is of type T.\n    ///\n    /// - If the messages body is of type T, the body will be cloned as specified by T\n    /// and the dup will succeed.\n    /// - If the message body is not of type T, this function will return `None`.\n    /// - If the message has no body it will succeed independent of T and clone only the\n    /// attached metadata.\n    ///\n    #[must_use]\n    pub fn try_dup\u003cT\u003e(\u0026self) -\u003e Option\u003cSelf\u003e\n    where\n        T: 'static + Clone,\n    {\n        let content: Option\u003cAnyBox\u003e = if let Some(ref content) = self.content {\n            Some(content.try_dup::\u003cT\u003e()?)\n        } else {\n            None\n        };\n\n        let header = Box::new(self.header.dup(SimTime::now()));\n\n        Some(Self { header, content })\n    }\n}\n\n// SAFTY:\n// A message only contains primitve data, ptrs that are threadsafe\n// and a untyped contained value.\nunsafe impl Send for Message {}\n\nimpl UnwindSafe for Message {}\n\n///\n/// A intermediary type for constructing messages.\n///\npub struct MessageBuilder {\n    pub(crate) header: Box\u003cMessageHeader\u003e,\n    pub(crate) content: Option\u003cAnyBox\u003e,\n}\n\nimpl MessageBuilder {\n    /// Creates a new builder.\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            header: Box::default(),\n            content: None,\n        }\n    }\n\n    /// Sets the field `header`.\n    ///\n    /// Note that the header may change the length field depending on the content\n    /// that may allready be set.\n    #[must_use]\n    pub fn header(mut self, meta: MessageHeader) -\u003e Self {\n        let old_len = self.header.length;\n        self.header = Box::new(meta);\n        self.header.length = old_len;\n        self\n    }\n\n    /// Sets the field `header.id`.\n    #[must_use]\n    pub fn id(mut self, id: MessageId) -\u003e Self {\n        self.header.id = id;\n        self\n    }\n\n    /// Sets the field `header.kind`.\n    #[must_use]\n    pub fn kind(mut self, kind: MessageKind) -\u003e Self {\n        self.header.kind = kind;\n        self\n    }\n\n    /// Sets the field `header.receiver_module_id`.\n    #[must_use]\n    pub fn receiver_module_id(mut self, receiver_module_id: ModuleId) -\u003e Self {\n        self.header.receiver_module_id = receiver_module_id;\n        self\n    }\n\n    /// Sets the field `header.sender_module_id`.\n    #[must_use]\n    pub fn sender_module_id(mut self, sender_module_id: ModuleId) -\u003e Self {\n        self.header.sender_module_id = sender_module_id;\n        self\n    }\n\n    /// Sets the source addr of the message (as eth)\n    #[must_use]\n    pub fn src(mut self, src: [u8; 6]) -\u003e Self {\n        self.header.src = src;\n        self\n    }\n\n    /// Sets the destination addr of the message (as eth)\n    #[must_use]\n    pub fn dest(mut self, dest: [u8; 6]) -\u003e Self {\n        self.header.dest = dest;\n        self\n    }\n\n    /// Sets the field `header.last_gate`.\n    #[must_use]\n    pub fn last_gate(mut self, last_gate: GateRef) -\u003e Self {\n        self.header.last_gate = Some(last_gate);\n        self\n    }\n\n    /// Sets the field `meta`.`creation_time`.\n    #[must_use]\n    pub fn creation_time(mut self, creation_time: SimTime) -\u003e Self {\n        self.header.creation_time = creation_time;\n        self\n    }\n\n    /// Sets the field `header.send_time`.\n    #[must_use]\n    pub fn send_time(mut self, send_time: SimTime) -\u003e Self {\n        self.header.send_time = send_time;\n        self\n    }\n\n    /// Sets the field `content`.\n    #[must_use]\n    #[allow(clippy::cast_possible_truncation)]\n    pub fn content\u003cT\u003e(mut self, content: T) -\u003e Self\n    where\n        T: 'static + MessageBody + Send,\n    {\n        self.header.length = content.byte_len() as u32;\n        self.content = Some(AnyBox::new(content));\n        self\n    }\n\n    /// Sets the field 'content' with a T that is not guarnteed to be Send.\n    pub unsafe fn content_unsafe\u003cT\u003e(mut self, content: T) -\u003e Self\n    where\n        T: 'static + MessageBody,\n    {\n        self.header.length = content.byte_len() as u32;\n        self.content = Some(AnyBox::new(content));\n        self\n    }\n\n    /// Builds a message from the builder.\n    #[must_use]\n    pub fn build(self) -\u003e Message {\n        let MessageBuilder { header, content } = self;\n\n        Message { header, content }\n    }\n}\n\nimpl Default for MessageBuilder {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Debug for MessageBuilder {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"MessageBuilder\")\n    }\n}\n\n// SAFTY:\n// Dervived from safty invariants of [Message].\nunsafe impl Send for MessageBuilder {}\n\n#[cfg(test)]\nmod tests {\n    use crate::{net::module::ModuleContext, prelude::Gate};\n\n    use super::*;\n    use std::{any::type_name, rc::Rc};\n\n    #[test]\n    fn message_fmt() {\n        let msg = Message::new()\n            .id(123)\n            .src([1; 6])\n            .dest([2; 6])\n            .content(String::from(\"Hello world!\"))\n            .build();\n\n        #[cfg(debug_assertions)]\n        assert_eq!(\n            msg.str(),\n            format!(\"Message {{ 12 bytes {}  }}\", type_name::\u003cString\u003e())\n        );\n\n        assert!(msg.can_cast::\u003cString\u003e());\n        assert_eq!(msg.content::\u003cString\u003e(), \"Hello world!\");\n    }\n\n    #[test]\n    fn message_builder_fmt() {\n        assert_eq!(format!(\"{:?}\", MessageBuilder::default()), \"MessageBuilder\");\n    }\n\n    #[test]\n    fn message_cast() {\n        struct A(i32);\n        impl MessageBody for A {\n            fn byte_len(\u0026self) -\u003e usize {\n                0\n            }\n        }\n\n        let msg = Message::new()\n            .header(MessageHeader::default())\n            .id(123)\n            .receiver_module_id(ModuleId(1))\n            .sender_module_id(ModuleId(2))\n            .content(A(42))\n            .build();\n        let (value, header) = msg.cast::\u003cA\u003e();\n        assert_eq!(header.id, 123);\n        assert_eq!(value.0, 42);\n    }\n\n    #[test]\n    fn message_cast_unsafe() {\n        // RC is not send\n        #[derive(Default)]\n        struct A {\n            rc: Rc\u003ci32\u003e,\n        }\n        impl MessageBody for A {\n            fn byte_len(\u0026self) -\u003e usize {\n                0\n            }\n        }\n\n        let module = ModuleContext::standalone(\"root\".into());\n        let gate = Gate::new(\u0026module, \"port\", 1, 0);\n\n        unsafe {\n            let msg = Message::new()\n                .creation_time(10.0.into())\n                .send_time(11.0.into())\n                .last_gate(gate)\n                .content_unsafe(A { rc: Rc::new(42) })\n                .build();\n\n            let msg = msg.try_cast_unsafe::\u003cString\u003e().unwrap_err();\n\n            let (value, _) = msg.cast_unsafe::\u003cA\u003e();\n            assert_eq!(*value.rc, 42);\n\n            // See with None\n\n            let msg = Message::new().build();\n            assert!(msg.try_cast_unsafe::\u003cString\u003e().is_err());\n        }\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":2323},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2323},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4141},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4141},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4846},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4846},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":2324},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":2324},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1121},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1121},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":1121},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":1999},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":1999},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":1999},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":2323},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":2323},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":88,"coverable":97},{"path":["/","Users","mk","Developer","rust","des","des","src","net","message","util.rs"],"content":"use std::{any::Any, fmt::Debug};\n\npub(crate) struct AnyBox {\n    inner: Box\u003cdyn Any\u003e,\n\n    #[cfg(debug_assertions)]\n    ty_info: \u0026'static str,\n}\n\nimpl AnyBox {\n    pub(crate) fn new\u003cT: 'static\u003e(val: T) -\u003e Self {\n        Self {\n            inner: Box::new(val),\n\n            #[cfg(debug_assertions)]\n            ty_info: std::any::type_name::\u003cT\u003e(),\n        }\n    }\n\n    #[cfg(debug_assertions)]\n    pub(crate) fn ty(\u0026self) -\u003e \u0026'static str {\n        self.ty_info\n    }\n\n    #[cfg(not(debug_assertions))]\n    pub(crate) fn ty(\u0026self) -\u003e \u0026'static str {\n        \"no ty info\"\n    }\n\n    pub(crate) fn try_dup\u003cT: 'static + Clone\u003e(\u0026self) -\u003e Option\u003cSelf\u003e {\n        self.inner.downcast_ref::\u003cT\u003e().map(|v| Self {\n            inner: Box::new(v.clone()),\n\n            #[cfg(debug_assertions)]\n            ty_info: std::any::type_name::\u003cT\u003e(),\n        })\n    }\n\n    pub(crate) fn can_cast\u003cT: 'static\u003e(\u0026self) -\u003e bool {\n        self.inner.is::\u003cT\u003e()\n    }\n\n    pub(crate) unsafe fn try_cast_unsafe\u003cT: 'static\u003e(self) -\u003e Result\u003cT, Self\u003e {\n        match self.inner.downcast::\u003cT\u003e() {\n            Ok(v) =\u003e Ok(*v),\n            Err(e) =\u003e Err(Self {\n                inner: e,\n                #[cfg(debug_assertions)]\n                ty_info: self.ty_info,\n            }),\n        }\n    }\n\n    pub(crate) fn try_cast_ref\u003cT: 'static\u003e(\u0026self) -\u003e Option\u003c\u0026T\u003e {\n        self.inner.downcast_ref::\u003cT\u003e()\n    }\n\n    pub(crate) fn try_cast_mut\u003cT: 'static\u003e(\u0026mut self) -\u003e Option\u003c\u0026mut T\u003e {\n        self.inner.downcast_mut::\u003cT\u003e()\n    }\n}\n\nimpl Debug for AnyBox {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        #[cfg(not(debug_assertions))]\n        return write!(f, \"AnyBox\");\n        #[cfg(debug_assertions)]\n        return write!(f, \"AnyBox {{ {} }}\", self.ty_info);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::any::type_name;\n\n    use super::*;\n\n    #[test]\n    #[cfg(debug_assertions)]\n    fn ty_debug_fmt() {\n        use std::any::type_name;\n\n        let boxed = AnyBox::new(String::from(\"Hello World!\"));\n        assert_eq!(boxed.ty(), type_name::\u003cString\u003e())\n    }\n\n    #[test]\n    fn ty_dup() {\n        let boxed = AnyBox::new(String::from(\"Hello World!\"));\n        let duped = boxed\n            .try_dup::\u003cString\u003e()\n            .expect(\"failed to dup as 'String'\");\n\n        assert_ne!(\n            boxed.inner.as_ref() as *const dyn Any,\n            duped.inner.as_ref() as *const dyn Any,\n        );\n    }\n\n    #[test]\n    fn can_cast() {\n        let boxed = AnyBox::new(1i64);\n        assert!(boxed.can_cast::\u003ci64\u003e());\n        assert!(!boxed.can_cast::\u003ci32\u003e());\n        assert!(!boxed.can_cast::\u003cString\u003e());\n        assert!(!boxed.can_cast::\u003c\u0026i64\u003e());\n    }\n\n    #[test]\n    fn fmt() {\n        #[cfg(debug_assertions)]\n        assert_eq!(\n            format!(\"{:?}\", AnyBox::new(String::from(\"Hello World!\"))),\n            format!(\"AnyBox {{ {} }}\", type_name::\u003cString\u003e())\n        );\n\n        #[cfg(not(debug_assertions))]\n        assert_eq!(\n            format!(\"{:?}\", AnyBox::new(String::from(\"Hello World!\"))),\n            \"AnyBox\"\n        );\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","Users","mk","Developer","rust","des","des","src","net","mod.rs"],"content":"//!\n//! Tools for building a module/net oriented simulation.\n//!\n\nmod par;\nmod path;\nmod runtime;\nmod topology;\n\npub mod channel;\npub mod gate;\npub mod message;\npub mod module;\npub mod processing;\n\npub(crate) use self::runtime::HandleMessageEvent;\npub(crate) use self::runtime::MessageExitingConnection;\npub(crate) use self::runtime::NetEvents;\n\npub use self::par::*;\npub use self::path::*;\npub use self::runtime::*;\npub use self::topology::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","api.rs"],"content":"use std::sync::Arc;\n\nuse super::{try_with_mod_ctx, ModuleContext, SETUP_FN};\nuse crate::{\n    net::runtime::buf_schedule_shutdown,\n    time::{Duration, SimTime},\n};\n\n/// Overwrite the setup fn all modules run.\n///\n/// All modules require common functionality based on the baseline setup of the\n/// simulation. Such common functionality is usually provided by plugins,\n/// but manually creating them on each module type is bothersome, and errorprone.\n/// To cirumvent that, a common setup function is provided that initalizes some plugins\n/// on all modules.\npub fn set_setup_fn(f: fn(\u0026ModuleContext)) {\n    *SETUP_FN.write() = f;\n}\n\n/// Retuns a handle to the context of the current module. This\n/// handle can be used on inspect and change the modules simulation\n/// properties, independent of the modules processing elements.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// **This handle is only fully valid, during the execution of the current event,\n/// thus is should never be stored.**\n///\n/// # Example\n///\n/// ```\n/// # use des::prelude::*;\n///\n/// struct MyModule;\n/// impl Module for MyModule {\n///     fn handle_message(\u0026mut self, msg: Message) {\n///         let id = current().id();\n///         if id == msg.header().sender_module_id {\n///             println!(\"Self message received\");\n///         }\n///     }\n/// }\n/// ```\n///\n/// # Panics\n///\n/// This function will panic if not called within a modules context.\n#[must_use]\npub fn current() -\u003e Arc\u003cModuleContext\u003e {\n    try_with_mod_ctx(Arc::clone)\n        .expect(\"cannot retrieve current module context, no module currently in scope\")\n}\n\n// BUF CTX based\n\n/// Shuts down all activity for the module.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// A module that is shut down, will not longer be able to\n/// handle incoming messages, or run any user-defined code.\n/// All plugin activity will be suspendend. However the\n/// custom state will be kept for debug purposes.\n///\n/// This function must be used within a module context\n/// otherwise its effects should be consider UB.\npub fn shutdown() {\n    buf_schedule_shutdown(None);\n}\n\n/// Shuts down all activity for the module.\n/// Restarts after the given duration.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// On restart the module will be reinitalized\n/// using `Module::reset`  and then `Module::at_sim_start`.\n/// Use the reset function to get the custom state to a resonable default\n/// state, which may or may not be defined by `Module::new`.\n/// However you can simulate persistent-beyond-shutdown data\n/// by not reseting this data in `Module::reset`.\n///\n/// ```\n/// # use des::prelude::*;\n/// # type Data = usize;\n/// struct MyModule {\n///     volatile: Data,\n///     persistent: Data,\n/// }\n///\n/// impl Module for MyModule {\n///     fn reset(\u0026mut self) {\n///         self.volatile = 0;\n///     }\n///\n///     fn at_sim_start(\u0026mut self, _: usize) {\n///         println!(\n///             \"Start at {} with volatile := {} and persistent := {}\",\n///             SimTime::now(),\n///             self.volatile,\n///             self.persistent\n///         );\n///\n///         self.volatile = 42;\n///         self.persistent = 1024;\n///\n///         if SimTime::now() == SimTime::ZERO {\n///             shutdow_and_restart_in(Duration::from_secs(10));\n///         }\n///     }\n/// }\n///\n/// fn main() {\n///     let app = /* ... */\n/// #    Sim::new(());\n///     let rt = Builder::new().build(app).run();\n///     // outputs 'Start at 0s with volatile := 0 and persistent := 0'\n///     // outputs 'Start at 10s with volatile := 0 and persistent := 1024'\n/// }\n/// ```\n///\n/// [`Module::new`]: crate::net::module::Module::new\n/// [`Module::reset`]: crate::net::module::Module::reset\n/// [`Module::at_sim_start`]: crate::net::module::Module::at_sim_start\npub fn shutdow_and_restart_in(dur: Duration) {\n    buf_schedule_shutdown(Some(SimTime::now() + dur));\n}\n\n/// Shuts down all activity for the module.\n/// Restarts at the given time.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// The user must ensure that the restart time\n/// point is greater or equal to the current simtime.\n///\n/// See [`shutdow_and_restart_in`] for more information.\npub fn shutdow_and_restart_at(restart_at: SimTime) {\n    buf_schedule_shutdown(Some(restart_at));\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":7268},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":7268},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":8,"coverable":10},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","ctx.rs"],"content":"use fxhash::{FxBuildHasher, FxHashMap};\nuse spin::RwLock;\n\nuse super::{\n    meta::Metadata, DummyModule, ModuleId, ModuleRef, ModuleRefWeak, ModuleReferencingError,\n};\nuse crate::{\n    prelude::{GateRef, ObjectPath},\n    sync::SwapLock,\n    tracing::{new_scope, ScopeToken},\n};\nuse std::{\n    any::Any,\n    fmt::Debug,\n    sync::{atomic::AtomicBool, Arc},\n};\n\n#[cfg(feature = \"async\")]\nuse crate::net::module::core::AsyncCoreExt;\n\npub(crate) static MOD_CTX: SwapLock\u003cOption\u003cArc\u003cModuleContext\u003e\u003e\u003e = SwapLock::new(None);\npub(crate) static SETUP_FN: RwLock\u003cfn(\u0026ModuleContext)\u003e = RwLock::new(_default_setup);\n\npub(crate) fn _default_setup(_: \u0026ModuleContext) {}\n\npub(crate) fn module_ctx_drop() {\n    MOD_CTX.swap(\u0026mut None);\n}\n\n/// The topological components of a module, not including the attached\n/// software.\n///\n/// The term `within node-context` refers to the presence of a `ModuleContext`\n/// in the global scope, that indicates that a module is currently active.\n///\n/// This type is internally used to create the simulations layout, but\n/// creating module contexts on your own is highly discouraged, since\n/// managing these structures is rather complicated. However the nessecary\n/// constructors are still available, so use them with care.\npub struct ModuleContext {\n    pub(crate) active: AtomicBool,\n    pub(crate) id: ModuleId,\n\n    pub(crate) path: ObjectPath,\n    pub(crate) gates: RwLock\u003cVec\u003cGateRef\u003e\u003e,\n\n    pub(super) meta: RwLock\u003cMetadata\u003e,\n    pub(crate) scope_token: ScopeToken,\n\n    #[cfg(feature = \"async\")]\n    pub(crate) async_ext: RwLock\u003cAsyncCoreExt\u003e,\n    pub(crate) parent: Option\u003cModuleRefWeak\u003e,\n    pub(crate) children: RwLock\u003cFxHashMap\u003cString, ModuleRef\u003e\u003e,\n}\n\nimpl ModuleContext {\n    /// Creates a new standalone instance of a new node.\n    ///\n    /// Note that this function returns a `ModuleRef`.\n    /// A `ModuleRef` contains both the topological properties of a node\n    /// if form of a `ModuleContext` as well as some attached software.\n    /// The sofware attched to the returned reference is a dummy module\n    /// that should be replaced before the simulation is started.\n    pub fn standalone(path: ObjectPath) -\u003e ModuleRef {\n        let this = ModuleRef::dummy(Arc::new(Self {\n            #[cfg(feature = \"async\")]\n            async_ext: RwLock::new(AsyncCoreExt::new()),\n\n            meta: RwLock::new(Metadata::new()),\n            scope_token: new_scope(path.clone()),\n\n            active: AtomicBool::new(true),\n            id: ModuleId::gen(),\n            path,\n\n            gates: RwLock::new(Vec::new()),\n\n            parent: None,\n            children: RwLock::new(FxHashMap::with_hasher(FxBuildHasher::default())),\n        }));\n\n        SETUP_FN.read()(\u0026this);\n\n        this\n    }\n\n    /// Creates a instance within a module tree.\n    ///  \n    /// Note that this function returns a `ModuleRef`.\n    /// A `ModuleRef` contains both the topological properties of a node\n    /// if form of a `ModuleContext` as well as some attached software.\n    /// The sofware attched to the returned reference is a dummy module\n    /// that should be replaced before the simulation is started.\n    #[allow(clippy::needless_pass_by_value)]\n    pub fn child_of(name: \u0026str, parent: ModuleRef) -\u003e ModuleRef {\n        let path = ObjectPath::appended(\u0026parent.ctx.path, name);\n        let this = ModuleRef::dummy(Arc::new(Self {\n            #[cfg(feature = \"async\")]\n            async_ext: RwLock::new(AsyncCoreExt::new()),\n\n            meta: RwLock::new(Metadata::new()),\n            scope_token: new_scope(path.clone()),\n\n            active: AtomicBool::new(true),\n\n            id: ModuleId::gen(),\n            path,\n\n            gates: RwLock::new(Vec::new()),\n\n            parent: Some(ModuleRefWeak::new(\u0026parent)),\n            children: RwLock::new(FxHashMap::with_hasher(FxBuildHasher::default())),\n        }));\n\n        SETUP_FN.read()(\u0026this);\n\n        parent\n            .ctx\n            .children\n            .write()\n            .insert(name.to_string(), this.clone());\n\n        this\n    }\n\n    pub(crate) fn place(self: Arc\u003cSelf\u003e) -\u003e Option\u003cArc\u003cModuleContext\u003e\u003e {\n        let mut this = Some(self);\n        MOD_CTX.swap(\u0026mut this);\n        this\n    }\n\n    pub(crate) fn take() -\u003e Option\u003cArc\u003cModuleContext\u003e\u003e {\n        let mut this = None;\n        MOD_CTX.swap(\u0026mut this);\n        this\n    }\n\n    /// Returns a runtime-unqiue identifier for the currently active module.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// struct MyModule;\n    /// impl Module for MyModule {\n    ///     fn handle_message(\u0026mut self, msg: Message) {\n    ///         let id = current().id();\n    ///         assert_eq!(id, msg.header().receiver_module_id);    \n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`Module`]: crate::net::module::Module\n    pub fn id(\u0026self) -\u003e ModuleId {\n        self.id\n    }\n\n    /// Returns a runtime-unqiue identifier for the currently active module,\n    /// based on its place in the module graph.\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// struct MyModule;\n    /// impl Module for MyModule {\n    ///     fn handle_message(\u0026mut self, msg: Message) {\n    ///         let path = current().path();\n    ///         println!(\"[{path}] recv message: {}\", msg.str())  \n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`Module`]: crate::net::module::Module\n    pub fn path(\u0026self) -\u003e ObjectPath {\n        self.path.clone()\n    }\n\n    /// Returns the name for the currently active module.\n    ///\n    /// Note that the module name is just the last component of the module\n    /// path.\n    pub fn name(\u0026self) -\u003e String {\n        self.path.name().to_string()\n    }\n\n    /// Returns a unstructured list of all gates from the current module.\n    pub fn gates(\u0026self) -\u003e Vec\u003cGateRef\u003e {\n        self.gates.read().clone()\n    }\n\n    /// Returns a ref to a gate of the current module dependent on its name and cluster position\n    /// if possible.\n    pub fn gate(\u0026self, name: \u0026str, pos: usize) -\u003e Option\u003cGateRef\u003e {\n        self.gates\n            .read()\n            .iter()\n            .find(|\u0026g| g.name() == name \u0026\u0026 g.pos() == pos)\n            .cloned()\n    }\n\n    /// Retrieves metadata about a module, based on a type.\n    ///\n    /// # Examples\n    ///\n    /// # Panics\n    ///\n    /// Panics when concurrently accessed from multiple threads.\n    pub fn meta\u003cT: Any + Clone\u003e(\u0026self) -\u003e Option\u003cT\u003e {\n        Some(\n            self.meta\n                .try_read()\n                .expect(\"Failed lock\")\n                .get::\u003cT\u003e()?\n                .clone(),\n        )\n    }\n\n    /// Sets a metadata object.\n    ///\n    /// # Panics\n    ///\n    /// Panics when concurrently accessed from multiple threads.\n    pub fn set_meta\u003cT: Any + Clone\u003e(\u0026self, value: T) {\n        self.meta.try_write().expect(\"Failed lock\").set(value);\n    }\n\n    /// Returns a reference to a parent module\n    ///\n    /// Use this handle to either access the parent modules topological\n    /// state, or cast it to access the custom state of the parent.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if no parent exists, or\n    /// the parent is currently shut down.\n    ///\n    /// # Panics\n    ///\n    /// May panic when the simulation is currently being dropped.\n    pub fn parent(\u0026self) -\u003e Result\u003cModuleRef, ModuleReferencingError\u003e {\n        if let Some(ref parent) = self.parent {\n            let strong = parent\n                .upgrade()\n                .expect(\"Failed to fetch parent, ptr missing in drop\");\n\n            if !strong.is_active() {\n                return Err(ModuleReferencingError::CurrentlyInactive(format!(\n                    \"The parent module of '{}' is currently shut down, thus cannot be accessed\",\n                    self.path,\n                )));\n            }\n\n            if strong.try_as_ref::\u003cDummyModule\u003e().is_some() {\n                Err(ModuleReferencingError::NotYetInitalized(\n                    format!(\"The parent ptr of module '{}' is existent but not yet initalized, according to the load order.\", self.path)\n                ))\n            } else {\n                Ok(strong)\n            }\n        } else {\n            Err(ModuleReferencingError::NoEntry(format!(\n                \"The module '{}' does not posses a parent ptr\",\n                self.path\n            )))\n        }\n    }\n\n    /// Returns a handle to the child element, with the provided module name.\n    ///\n    /// Use this handle to either access and modify the childs modules topological\n    /// state, or cast it to access its custom state .\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if no child was found under the given name,\n    /// or the child is currently shut down.\n    pub fn child(\u0026self, name: \u0026str) -\u003e Result\u003cModuleRef, ModuleReferencingError\u003e {\n        if let Some(child) = self.children.read().get(name) {\n            if !child.is_active() {\n                return Err(ModuleReferencingError::CurrentlyInactive(format!(\n                    \"The child module '{}' of '{}' is currently shut down, thus cannot be accessed\",\n                    name, self.path,\n                )));\n            }\n\n            Ok(child.clone())\n        } else {\n            Err(ModuleReferencingError::NoEntry(format!(\n                \"The module '{}' does not posses a child ptr with the name '{}'\",\n                self.path, name\n            )))\n        }\n    }\n}\n\nimpl Debug for ModuleContext {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"ModuleContext\").finish()\n    }\n}\n\nunsafe impl Send for ModuleContext {}\nunsafe impl Sync for ModuleContext {}\n\npub(crate) fn with_mod_ctx\u003cR\u003e(f: impl FnOnce(\u0026Arc\u003cModuleContext\u003e) -\u003e R) -\u003e R {\n    let lock = MOD_CTX.read();\n    let ctx = lock\n        .as_ref()\n        .expect(\"failed operation: no module currently in scope\");\n    let r = f(ctx);\n    drop(lock);\n    r\n}\n\npub(crate) fn try_with_mod_ctx\u003cR\u003e(f: impl FnOnce(\u0026Arc\u003cModuleContext\u003e) -\u003e R) -\u003e Option\u003cR\u003e {\n    let lock = MOD_CTX.read();\n    if let Some(ctx) = lock.as_real_inner() {\n        let r = f(ctx);\n        drop(lock);\n        Some(r)\n    } else {\n        None\n    }\n}\n\n// pub(crate) fn with_mod_ctx_lock() -\u003e SwapLockReadGuard\u003c'static, Option\u003cArc\u003cModuleContext\u003e\u003e\u003e {\n//     MOD_CTX.read()\n// }\n\ncfg_async! {\n    use tokio::runtime::Runtime;\n    use tokio::task::JoinHandle;\n    use tokio::task::LocalSet;\n    use tokio::sync::mpsc::{UnboundedReceiver, error::SendError};\n    use super::ext::WaitingMessage;\n    use std::rc::Rc;\n\n    pub(crate) fn async_get_rt() -\u003e Option\u003c(Arc\u003cRuntime\u003e, Rc\u003cLocalSet\u003e)\u003e {\n        with_mod_ctx(|ctx| ctx.async_ext.write().rt.current())\n    }\n\n    pub(super) fn async_ctx_reset() {\n        with_mod_ctx(|ctx| ctx.async_ext.write().reset());\n    }\n\n    // Wait queue\n\n    pub(super) fn async_wait_queue_tx_send(msg: WaitingMessage) -\u003e Result\u003c(), SendError\u003cWaitingMessage\u003e\u003e {\n        with_mod_ctx(|ctx| ctx.async_ext.write().wait_queue_tx.send(msg))\n    }\n\n    pub(super) fn async_wait_queue_rx_take() -\u003e Option\u003cUnboundedReceiver\u003cWaitingMessage\u003e\u003e {\n        with_mod_ctx(|ctx| ctx.async_ext.write().wait_queue_rx.take())\n    }\n\n    pub(super) fn async_set_wait_queue_join(join: JoinHandle\u003c()\u003e) {\n        with_mod_ctx(|ctx| ctx.async_ext.write().wait_queue_join = Some(join));\n    }\n\n    // Sim Staart\n\n    pub(super) fn async_sim_start_rx_take() -\u003e Option\u003cUnboundedReceiver\u003cusize\u003e\u003e {\n        with_mod_ctx(|ctx| ctx.async_ext.write().sim_start_rx.take())\n    }\n\n    pub(super) fn async_set_sim_start_join(join: JoinHandle\u003c()\u003e) {\n        with_mod_ctx(|ctx| ctx.async_ext.write().sim_start_join = Some(join));\n    }\n\n    pub(super) fn async_sim_start_tx_send(stage: usize) -\u003e Result\u003c(), SendError\u003cusize\u003e\u003e  {\n        with_mod_ctx(|ctx| ctx.async_ext.write().sim_start_tx.send(stage))\n    }\n\n    pub(super) fn async_sim_start_join_take() -\u003e Option\u003cJoinHandle\u003c()\u003e\u003e {\n        with_mod_ctx(|ctx| ctx.async_ext.write().sim_start_join.take())\n    }\n\n    // SIM END\n\n    pub(super) fn async_sim_end_join_set(join: JoinHandle\u003c()\u003e)  {\n        with_mod_ctx(|ctx| ctx.async_ext.write().sim_end_join = Some(join));\n    }\n\n    pub(super) fn async_sim_end_join_take() -\u003e Option\u003cJoinHandle\u003c()\u003e\u003e {\n        with_mod_ctx(|ctx| ctx.async_ext.write().sim_end_join.take())\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":261},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3416},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":3416},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4678},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":4678},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":564},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":564},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":10508},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":131},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":7268},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":7268},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":14535},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":844},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":2532},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":132},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":876},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":426},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":426},"fn_name":null}],"covered":114,"coverable":121},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","dummy.rs"],"content":"use super::Module;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub(crate) struct DummyModule {}\n\nimpl Module for DummyModule {\n    fn handle_message(\u0026mut self, _msg: crate::prelude::Message) {\n        panic!(\"A dummy module is only a placeholder in the load process. No `dyn Module` functions should be called.\")\n    }\n\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        panic!(\"A dummy module is only a placeholder in the load process. No `dyn Module` functions should be called.\")\n    }\n\n    fn num_sim_start_stages(\u0026self) -\u003e usize {\n        panic!(\"A dummy module is only a placeholder in the load process. No `dyn Module` functions should be called.\")\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        panic!(\"A dummy module is only a placeholder in the load process. No `dyn Module` functions should be called.\")\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","error.rs"],"content":"use std::{error::Error, fmt::Display};\n\n/// An error while resolving a reference to another module.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ModuleReferencingError {\n    /// No reference exists.\n    NoEntry(String),\n    /// The reference is not of the given type.\n    TypeError(String),\n    /// The load order dicates that the parent is not yet ready.\n    NotYetInitalized(String),\n    /// The reference module is currently inactive, so should not be accessed.\n    CurrentlyInactive(String),\n}\n\nimpl Display for ModuleReferencingError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::NoEntry(str)\n            | Self::TypeError(str)\n            | Self::NotYetInitalized(str)\n            | Self::CurrentlyInactive(str) =\u003e {\n                write!(f, \"{str}\")\n            }\n        }\n    }\n}\n\nimpl Error for ModuleReferencingError {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn fmt() {\n        assert_eq!(\n            ModuleReferencingError::NoEntry(\"Hello world!\".to_string()).to_string(),\n            \"Hello world!\"\n        );\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":7},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","ext","core.rs"],"content":"use std::{rc::Rc, sync::Arc};\n\nuse crate::{\n    net::message::Message,\n    prelude::random,\n    time::{Driver, SimTime},\n};\nuse tokio::{\n    runtime::{Builder, RngSeed, Runtime},\n    sync::mpsc::{unbounded_channel, UnboundedReceiver, UnboundedSender},\n    task::{JoinHandle, LocalSet},\n};\n\npub(crate) struct AsyncCoreExt {\n    pub(crate) rt: Rt,\n    pub(crate) driver: Option\u003cDriver\u003e,\n\n    pub(crate) wait_queue_tx: UnboundedSender\u003cWaitingMessage\u003e,\n    pub(crate) wait_queue_rx: Option\u003cUnboundedReceiver\u003cWaitingMessage\u003e\u003e,\n    pub(crate) wait_queue_join: Option\u003cJoinHandle\u003c()\u003e\u003e,\n\n    pub(crate) sim_start_tx: UnboundedSender\u003cusize\u003e,\n    pub(crate) sim_start_rx: Option\u003cUnboundedReceiver\u003cusize\u003e\u003e,\n    pub(crate) sim_start_join: Option\u003cJoinHandle\u003c()\u003e\u003e,\n\n    pub(crate) sim_end_join: Option\u003cJoinHandle\u003c()\u003e\u003e,\n}\n\n#[allow(clippy::large_enum_variant)]\npub(crate) enum Rt {\n    Builder(Builder),\n    Runtime((Arc\u003cRuntime\u003e, Rc\u003cLocalSet\u003e)),\n    Shutdown,\n}\n\nimpl AsyncCoreExt {\n    pub(crate) fn new() -\u003e AsyncCoreExt {\n        // let (tx, rx) = unbounded_channel();\n        let (wtx, wrx) = unbounded_channel();\n        let (stx, srx) = unbounded_channel();\n\n        #[allow(unused_mut)]\n        let mut builder = Builder::new_current_thread();\n\n        #[cfg(feature = \"unstable-tokio-enable-time\")]\n        builder.enable_time();\n\n        Self {\n            rt: Rt::Builder(builder),\n\n            driver: Some(Driver::new()),\n\n            wait_queue_tx: wtx,\n            wait_queue_rx: Some(wrx),\n            wait_queue_join: None,\n\n            sim_start_tx: stx,\n            sim_start_rx: Some(srx),\n            sim_start_join: None,\n\n            sim_end_join: None,\n        }\n    }\n\n    pub(crate) fn reset(\u0026mut self) {\n        self.rt = Rt::Runtime((\n            Arc::new(\n                Builder::new_current_thread()\n                    .rng_seed(RngSeed::from_bytes(\u0026random::\u003cu64\u003e().to_le_bytes()))\n                    .build()\n                    .expect(\"Failed to build tokio runtime\"),\n            ),\n            Rc::new(LocalSet::new()),\n        ));\n\n        // let (tx, rx) = unbounded_channel();\n        let (wtx, wrx) = unbounded_channel();\n        let (stx, srx) = unbounded_channel();\n\n        // self.buffers = rx;\n        // self.handle = tx;\n\n        self.wait_queue_tx = wtx;\n        self.wait_queue_rx = Some(wrx);\n        self.wait_queue_join = None;\n\n        self.sim_start_tx = stx;\n        self.sim_start_rx = Some(srx);\n        self.sim_start_join = None;\n\n        self.sim_end_join = None;\n    }\n}\n\nimpl Rt {\n    pub(crate) fn current(\u0026mut self) -\u003e Option\u003c(Arc\u003cRuntime\u003e, Rc\u003cLocalSet\u003e)\u003e {\n        match self {\n            Rt::Builder(builder) =\u003e {\n                let seed = RngSeed::from_bytes(\u0026random::\u003cu64\u003e().to_le_bytes());\n                *self = Rt::Runtime((\n                    Arc::new(\n                        builder\n                            .rng_seed(seed)\n                            .build()\n                            .expect(\"Failed to build tokio runtime\"),\n                    ),\n                    Rc::new(LocalSet::new()),\n                ));\n                self.current()\n            }\n            Rt::Runtime(tupel) =\u003e Some(tupel.clone()),\n            Rt::Shutdown =\u003e None,\n        }\n    }\n\n    pub(crate) fn shutdown(\u0026mut self) {\n        *self = Self::Shutdown;\n    }\n}\n\n#[derive(Debug)]\npub(crate) struct WaitingMessage {\n    pub(crate) msg: Message,\n    #[allow(dead_code)]\n    pub(crate) time: SimTime,\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":986},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":986},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":844},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":17},"fn_name":null}],"covered":41,"coverable":42},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","ext","mod.rs"],"content":"#![allow(clippy::unused_async)]\n\nuse crate::net::{message::Message, module::Module};\nuse crate::time::SimTime;\nuse tokio::task::yield_now;\n\npub(crate) mod core;\npub(crate) use self::core::WaitingMessage;\n\n/// A set of user defined functions for customizing the behaviour\n/// of an asynchronous module.\n///\n/// This trait is just a async version of [`Module`](crate::net::module::Module).\n#[allow(async_fn_in_trait)]\npub trait AsyncModule: Send {\n    /// Resets the custom state after shutdown.\n    fn reset(\u0026mut self) {}\n\n    ///\n    /// A message handler for receiving events, user defined.\n    ///\n    /// # Note\n    ///\n    /// The function may block beyond the evaluation of the current event.\n    /// If that happens, other messages that will be received will be queued\n    /// until the evaluation of this event has concluded. For non-blocking\n    /// event execution use [`tokio::spawn`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use des::prelude::*;\n    ///\n    /// struct MyAsyncModule {\n    ///     prop_1: f64,\n    ///     prop_2: String,\n    /// }\n    ///\n    ///\n    /// impl AsyncModule for MyAsyncModule {\n    ///     /* ... */    \n    ///\n    ///     async fn handle_message(\u0026mut self, msg: Message) {\n    ///         println!(\"Received {:?}\", msg);\n    ///     }\n    /// }\n    /// ```\n    async fn handle_message(\u0026mut self, _: Message) {}\n\n    ///\n    /// A function that is run at the start of each simulation, for each module.\n    /// The order in which modules are called is not guranteed but the stage numbers are.\n    /// That means that all stage-0 calls for all modules happen before the first (if any) stage-1 calls.\n    /// Generaly speaking, all stage-i calls finish before the first stage-i+1 call.\n    ///\n    /// # Note\n    ///\n    /// The user must ensure that all calls of `at_sim_start` will terminate at last\n    /// once all stages of `at_sim_start` of all modules have been called.\n    /// The stages will be executed in order.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use des::prelude::*;\n    ///\n    /// # type Config = ();\n    /// async fn fetch_config(id: ModuleId) -\u003e Config {\n    ///     // ...\n    /// }\n    ///\n    /// struct MyModule {\n    ///     config: Config,\n    ///     records: Vec\u003cf64\u003e,\n    /// }\n    ///\n    ///\n    /// impl AsyncModule for MyModule {\n    ///     /* ... */    \n    ///\n    ///     async fn handle_message(\u0026mut self, _: Message) {\n    ///         // ...\n    ///     }\n    ///\n    ///     async fn at_sim_start(\u0026mut self, _stage: usize) {\n    ///         self.config = fetch_config(current().id()).await;\n    ///         self.records.clear();\n    ///     }\n    /// }\n    ///\n    /// ```\n    async fn at_sim_start(\u0026mut self, _: usize) {}\n\n    ///\n    /// A function that is called once the simulation has terminated.\n    /// Any event created by this function will be ignored.\n    ///\n    async fn at_sim_end(\u0026mut self) {}\n\n    ///\n    /// A function that returns the number of required startup stages\n    /// of a module.\n    ///\n    fn num_sim_start_stages(\u0026self) -\u003e usize {\n        1\n    }\n}\n\nimpl\u003cT\u003e Module for T\nwhere\n    T: 'static + AsyncModule,\n{\n    fn __indicate_async(\u0026self) -\u003e bool {\n        true\n    }\n\n    fn reset(\u0026mut self) {\n        super::async_ctx_reset();\n\n        \u003cT as AsyncModule\u003e::reset(self);\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        // (1) Fetch the runtime and initial the time context.\n        let Some(rt) = super::async_get_rt() else {\n            return;\n        };\n\n        // (2) Ignore notifty message only relevant for a\n        // call to poll_until_idle\n        super::async_wait_queue_tx_send(WaitingMessage {\n            msg,\n            time: SimTime::now(),\n        })\n        .expect(\"Failed to forward message to 'handle_message'\");\n\n        rt.1.block_on(\u0026rt.0, yield_now());\n    }\n\n    fn at_sim_start(\u0026mut self, stage: usize) {\n        // time is 0\n        let Some(rt) = super::async_get_rt() else {\n            return;\n        };\n\n        // # Setup message receive handle.\n        if stage == 0 {\n            // SAFTEY:\n            // We can guarantee the validity of the pointer:\n            // 1) The module is pinned while the simulation is running.\n            // 2) The module is not dropped while the simulation is running.\n            // 3) While we may create mutiple \u0026mut T, handle_message is never run fully\n            //    async (current thread runtime) and mutiple calls of `handle_messsage`\n            //    wont overlap, since the queue rx synchronises and delays them.\n            // 4) References to at_sim_start have been droped since all futures of at_sim_start\n            //    must be resoved before event 1\n            let self_ref: \u0026'static mut T = {\n                let ptr: *mut T = self;\n                unsafe { \u0026mut *ptr }\n            };\n\n            let mut rx = super::async_wait_queue_rx_take().expect(\"We have been robbed\");\n\n            super::async_set_wait_queue_join(rt.1.spawn_local(async move {\n                while let Some(wmsg) = rx.recv().await {\n                    let WaitingMessage { msg, .. } = wmsg;\n                    \u003cT as AsyncModule\u003e::handle_message(self_ref, msg).await;\n                }\n            }));\n        }\n\n        // # Setup Sim-Start Task\n        if stage == 0 {\n            // SAFTEY:\n            // SimStart will complete before event id 1. thus this is quasai sync\n            let self_ref: \u0026'static mut T = {\n                let ptr: *mut T = self;\n                unsafe { \u0026mut *ptr }\n            };\n\n            let mut srx =\n                super::async_sim_start_rx_take().expect(\"We have been robbed at sim start\");\n\n            super::async_set_sim_start_join(rt.1.spawn_local(async move {\n                while let Some(stage) = srx.recv().await {\n                    if stage == usize::MAX {\n                        srx.close();\n                        break;\n                    }\n                    \u003cT as AsyncModule\u003e::at_sim_start(self_ref, stage).await;\n                }\n            }));\n        }\n\n        super::async_sim_start_tx_send(stage).expect(\"Failed to send to unbounded sender\");\n\n        rt.1.block_on(\u0026rt.0, yield_now());\n    }\n\n    fn finish_sim_start(\u0026mut self) {\n        let Some(rt) = super::async_get_rt() else {\n            return;\n        };\n\n        super::async_sim_start_tx_send(usize::MAX)\n            .expect(\"Failed to send close signal to sim_start_task\");\n\n        rt.1.block_on(\u0026rt.0, yield_now());\n\n        // The join must succeed else saftey invariant cannot be archived.\n        let handle = super::async_sim_start_join_take().expect(\"Crime\");\n        let _g = rt.0.enter();\n        assert!(handle.is_finished());\n        rt.0.block_on(handle)\n            .expect(\"could not finish all sim start stages without time progression\");\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        let Some(rt) = super::async_get_rt() else {\n            return;\n        };\n\n        // SAFTEY:\n        // Sim end means only this function will be executed before drop\n        // thus 'static can be assumed.\n        let self_ptr: *mut T = self;\n        let self_ref: \u0026'static mut T = unsafe { \u0026mut *self_ptr };\n\n        super::async_sim_end_join_set(rt.1.spawn_local(\u003cT as AsyncModule\u003e::at_sim_end(self_ref)));\n\n        rt.1.block_on(\u0026rt.0, yield_now());\n    }\n\n    fn finish_sim_end(\u0026mut self) {\n        let Some(rt) = super::async_get_rt() else {\n            return;\n        };\n\n        rt.1.block_on(\u0026rt.0, yield_now());\n\n        let handle = super::async_sim_end_join_take().expect(\"Crime\");\n        let _g = rt.0.enter();\n        assert!(\n            handle.is_finished(),\n            \"at_sim_end() could not complete, since it is stuck at some await point\"\n        );\n        rt.0.block_on(handle)\n            .expect(\"could not finish all sim end stages without time progession\");\n    }\n\n    fn num_sim_start_stages(\u0026self) -\u003e usize {\n        // Needs at least one sim_start stage to setup the recv handle\n        \u003cT as AsyncModule\u003e::num_sim_start_stages(self).max(1)\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":512},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":512},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":88},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":88},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":275},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":730},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":141},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":288},"fn_name":null}],"covered":47,"coverable":71},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","meta.rs"],"content":"use std::any::Any;\n\n/// Metadata exposed by a module.\n#[derive(Debug)]\npub(super) struct Metadata {\n    blobs: Vec\u003cBox\u003cdyn Any\u003e\u003e\n}\n\nimpl Metadata {\n    pub(super) fn new() -\u003e Self {\n        Self { blobs: Vec::new() }\n    }\n\n    /// Tries to retrieve a data object from the store.\n    pub(super) fn get\u003cT: Any\u003e(\u0026self) -\u003e Option\u003c\u0026T\u003e {\n        self.blobs.iter().find_map(|blob| blob.downcast_ref())\n    }\n\n    pub(super) fn set\u003cT: Any\u003e(\u0026mut self, value: T) {\n        self.blobs.retain(|v| !v.is::\u003cT\u003e());\n        self.blobs.push(Box::new(value));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn store_insert_and_retrive() {\n        let mut meta = Metadata { blobs: Vec::new() };\n        meta.set(String::from(\"Hello World!\"));\n        assert_eq!(meta.get::\u003cString\u003e(), Some(\u0026String::from(\"Hello World!\")));\n        assert_eq!(meta.get::\u003cu8\u003e(), None);\n    }\n}","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","mod.rs"],"content":"//! Network nodes with custom state.\n\nuse crate::net::message::Message;\nuse std::{\n    any::Any,\n    sync::atomic::{AtomicU16, Ordering},\n};\n\nmod ctx;\npub use self::ctx::ModuleContext;\npub(crate) use self::ctx::*;\n\nmod reference;\npub use reference::*;\n\nmod error;\npub use error::*;\n\nmod api;\npub use api::*;\n\nmod dummy;\npub(crate) use dummy::*;\n\nmod meta;\n\n#[cfg(test)]\nmod tests;\n\nuse super::processing::{BaseLoader, IntoProcessingElements, ProcessingElements};\n\ncfg_async! {\n    mod ext;\n    pub use self::ext::*;\n}\n\n/// A unique identifier for a module.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[repr(transparent)]\npub struct ModuleId(pub u16);\n\nstatic MODULE_ID: AtomicU16 = AtomicU16::new(0xff);\n\nimpl ModuleId {\n    /// A general purpose ID indicating None.\n    pub const NULL: ModuleId = ModuleId(0);\n\n    /// Generates a unique module ID.\n    pub fn gen() -\u003e Self {\n        Self(MODULE_ID.fetch_add(1, Ordering::SeqCst))\n    }\n}\n\n///\n/// A set of user defined functions for customizing the\n/// behaviour of a module.\n///\n/// * This type is only available of DES is build with the `\"net\"` feature.*\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\npub trait Module: Any {\n    /// Resets the custom state when a module is restarted.\n    fn reset(\u0026mut self) {\n        #[cfg(feature = \"tracing\")]\n        tracing::warn!(\"Module has been shutdown and restarted, but reset() was not defined. This may lead to invalid custom state.\");\n    }\n\n    /// Defines the required stack.\n    fn stack(\u0026self) -\u003e impl IntoProcessingElements\n    where\n        Self: Sized,\n    {\n        BaseLoader\n    }\n\n    /// BUILD\n    fn to_processing_chain(self) -\u003e ProcessingElements\n    where\n        Self: Sized + 'static,\n    {\n        let stack = \u003cSelf as Module\u003e::stack(\u0026self).to_processing_elements();\n        ProcessingElements::new(stack, self)\n    }\n\n    ///\n    /// A message handler for receiving events, user defined.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// struct MyModule {\n    ///     my_prop_1: f64,\n    ///     my_prop_2: String,\n    /// };\n    ///\n    /// impl Module for MyModule {\n    ///     /* ... */    \n    ///\n    ///     fn handle_message(\u0026mut self, msg: Message) {\n    ///         println!(\"Received {:?}\", msg);\n    ///     }\n    /// }\n    /// ```\n    ///\n    fn handle_message(\u0026mut self, _msg: Message) {}\n\n    ///\n    /// A function that is run at the start of each simulation,\n    /// for each module. The order in which modules are called is not guranteed\n    /// but the stage numbers are. That means that all stage-0 calls for all modules\n    /// happen before the first (if any) stage-1 calls. Generaly speaking, all stage-i\n    /// calls finish before the first stage-i+1 call.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use des::prelude::*;\n    /// # type Config = ();\n    /// # type Record = u8;\n    /// # fn fetch_config(s: \u0026str, id: ModuleId) -\u003e Config {}\n    ///\n    /// struct SomeModule {\n    ///     config: Config,\n    ///     records: Vec\u003cRecord\u003e,\n    /// };\n    ///\n    /// impl Module for SomeModule {\n    ///     /* ... */\n    ///     \n    ///     fn at_sim_start(\u0026mut self, _stage: usize) {\n    ///         self.config = fetch_config(\"https://mysimconfig.com/simrun1\", current().id());\n    ///         self.records.clear();\n    ///     }\n    ///\n    ///     fn handle_message(\u0026mut self, msg: Message) {\n    ///         todo!()\n    ///     }\n    /// }\n    /// ```\n    ///\n    fn at_sim_start(\u0026mut self, _stage: usize) {}\n\n    ///\n    /// A function that is called when all `sim_start` stages of all modules\n    /// are done. Used to resolve all async `sim_start_stages`.\n    ///\n    #[cfg(feature = \"async\")]\n    #[doc(hidden)]\n    fn finish_sim_start(\u0026mut self) {}\n\n    ///\n    /// The number of stages used for the module initalization.\n    ///\n    fn num_sim_start_stages(\u0026self) -\u003e usize {\n        1\n    }\n\n    ///\n    /// A callback function that is invoked should the simulation finish.\n    /// All events emitted by this function will NOT be processed.\n    ///\n    fn at_sim_end(\u0026mut self) {}\n\n    ///\n    /// A function that is called when all `sim_end` stages of all modules\n    /// are done. Used to resolve all async `sim_end_stages`.\n    ///\n    #[cfg(feature = \"async\")]\n    #[doc(hidden)]\n    fn finish_sim_end(\u0026mut self) {}\n\n    #[cfg(feature = \"async\")]\n    #[doc(hidden)]\n    fn __indicate_async(\u0026self) -\u003e bool {\n        false\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":454},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":454},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":469},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":469},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":469},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":155},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":155},"fn_name":null}],"covered":17,"coverable":19},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","reference.rs"],"content":"use crate::net::processing::ProcessingElements;\nuse crate::net::NetEvents;\nuse crate::prelude::{Gate, GateRef};\nuse crate::runtime::EventSink;\nuse crate::tracing::{enter_scope, leave_scope};\n\nuse super::{DummyModule, Module, ModuleContext};\nuse std::any::{Any, TypeId};\nuse std::cell::{Ref, RefCell, RefMut};\nuse std::fmt::Debug;\nuse std::ops::Deref;\nuse std::sync::{Arc, Weak};\n\n#[derive(Clone)]\npub(crate) struct ModuleRefWeak {\n    ctx: Weak\u003cModuleContext\u003e,\n    handler: Weak\u003cRefCell\u003cProcessingElements\u003e\u003e,\n    // handler_ptr: *mut u8,\n}\n\nimpl ModuleRefWeak {\n    pub(crate) fn new(strong: \u0026ModuleRef) -\u003e Self {\n        Self {\n            ctx: Arc::downgrade(\u0026strong.ctx),\n            handler: Arc::downgrade(\u0026strong.processing),\n            // handler_ptr: strong.handler_ptr,\n        }\n    }\n\n    pub(crate) fn upgrade(\u0026self) -\u003e Option\u003cModuleRef\u003e {\n        Some(ModuleRef {\n            ctx: self.ctx.upgrade()?,\n            processing: self.handler.upgrade()?,\n            // handler_ptr: self.handler_ptr,\n        })\n    }\n}\n\nimpl Debug for ModuleRefWeak {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"ModuleRefWeak\").finish()\n    }\n}\n\n/// A reference to a module\n#[derive(Clone)]\npub struct ModuleRef {\n    pub(crate) ctx: Arc\u003cModuleContext\u003e,\n    pub(crate) processing: Arc\u003cRefCell\u003cProcessingElements\u003e\u003e,\n}\n\nimpl Deref for ModuleRef {\n    type Target = ModuleContext;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.ctx\n    }\n}\n\nimpl ModuleRef {\n    #[allow(clippy::explicit_deref_methods)]\n    pub(crate) fn new\u003cT: Module\u003e(ctx: Arc\u003cModuleContext\u003e, module: T) -\u003e Self {\n        let procesing = module.to_processing_chain();\n        let handler = Arc::new(RefCell::new(procesing));\n        Self {\n            ctx,\n            processing: handler,\n        }\n    }\n\n    #[allow(unused)]\n    pub(crate) fn dummy(ctx: Arc\u003cModuleContext\u003e) -\u003e Self {\n        // Create the dummy module explicitly not with ::new since\n        // all dyn Module calls would panic\n        Self::new(ctx, DummyModule {})\n    }\n\n    #[allow(unused)]\n    // Caller must ensure that handler is indeed a dummy\n    #[doc(hidden)]\n    pub fn upgrade_dummy(\u0026self, module: ProcessingElements) {\n        let celled = RefCell::new(module);\n        let celled: RefCell\u003cProcessingElements\u003e = celled;\n        self.processing.swap(\u0026celled);\n    }\n\n    // NOTE / TODO\n    // Once feature(trait_upcasting) is stabalized, use traitupcasting for\n    // safe interactions with the v-table.\n    // For now us raw pointer casts.\n\n    /// Borrows the referenced module as a readonly reference\n    /// to the provided type T.\n    ///\n    /// # Panics\n    ///\n    /// Panics if either the module is not of type T,\n    /// or the module is allready borrowed mutably.\n    #[must_use]\n    pub fn as_ref\u003cT: Any\u003e(\u0026self) -\u003e Ref\u003cT\u003e {\n        self.try_as_ref::\u003cT\u003e()\n            .expect(\"Failed to cast ModuleRef to readonly reference to type T\")\n    }\n\n    ///\n    /// Tries to borrow the referenced module as an readonly\n    /// reference to the provided type T.\n    ///\n    /// This function will return `None` is the contained module\n    /// is not of type T.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the contained module is allready borrowed\n    /// mutably. This may be the case if another borrow has allready occured\n    /// or the reference module is `self` and a module-specific function is called.\n    ///\n    #[must_use]\n    pub fn try_as_ref\u003cT: Any\u003e(\u0026self) -\u003e Option\u003cRef\u003cT\u003e\u003e {\n        let brw = self.processing.borrow();\n        let rf = \u0026*brw.handler;\n        let ty = rf.type_id();\n        if ty == TypeId::of::\u003cT\u003e() {\n            // SAFTEY:\n            // The pointer 'handler_ptr' will allways point to the object\n            // refered to by the 'handler': Since 'handler' is owned through\n            // an 'Arc' its memory position will NOT changed. Thus 'handler_ptr'\n            // allways points to valid memory. Pointer aligment is guranteed.\n            //\n            // Since the created \u0026T is encapluslated in a Ref\u003c\u0026T\u003e this functions acts as\n            // a call of 'RefCell::borrow' thus upholding the borrowing invariants.\n            //\n            // Should the type check fail, the Ref is dropped so the borrow is freed.\n            Some(Ref::map(brw, |brw| unsafe {\n                let hpt: *const dyn Module = \u0026*brw.handler;\n                // hpt.cast::\u003cT\u003e()\n                // \u0026*(hpt as *const T)\n                \u0026*(hpt.cast::\u003cT\u003e())\n            }))\n        } else {\n            None\n        }\n    }\n\n    /// Borrows the referenced module as a mutable reference\n    /// to the provided type T.\n    ///\n    /// # Panics\n    ///\n    /// Panics if either the module is not of type T,\n    /// or the module is allready borrowed on any way.\n    #[must_use]\n    pub fn as_mut\u003cT: Any\u003e(\u0026self) -\u003e RefMut\u003cT\u003e {\n        self.try_as_mut()\n            .expect(\"Failed to cast ModuleRef to mutable reference to type T\")\n    }\n\n    ///\n    /// Tries to borrow the referenced module as an mutable\n    /// reference to the provided type T.\n    ///\n    /// This function will return `None` is the contained module\n    /// is not of type T.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the contained module is allready borrowed\n    /// in any way. This may be the case if another borrow has allready occured\n    /// or the reference module is `self` and a module-specific function is called.\n    ///\n    #[must_use]\n    pub fn try_as_mut\u003cT: Any\u003e(\u0026self) -\u003e Option\u003cRefMut\u003cT\u003e\u003e {\n        let brw = self.processing.borrow_mut();\n        let rf = \u0026*brw.handler;\n        let ty = rf.type_id();\n        if ty == TypeId::of::\u003cT\u003e() {\n            // SAFTEY:\n            // The pointer 'handler_ptr' will allways point to the object\n            // refered to by the 'handler': Since 'handler' is owned through\n            // an 'Arc' its memory position will NOT changed. Thus 'handler_ptr'\n            // allways points to valid memory. Pointer aligment is guranteed.\n            //\n            // Since the created \u0026T is encapluslated in a Ref\u003c\u0026T\u003e this functions acts as\n            // a call of 'RefCell::borrow' thus upholding the borrowing invariants.\n            //\n            // Should the type check fail, the Ref is dropped so the borrow is freed.\n            Some(RefMut::map(brw, |brw| unsafe {\n                let hpt: *mut dyn Module = \u0026mut *brw.handler;\n                \u0026mut *(hpt.cast::\u003cT\u003e())\n            }))\n        } else {\n            None\n        }\n    }\n}\n\nimpl ModuleRef {\n    pub(crate) fn is_active(\u0026self) -\u003e bool {\n        self.ctx.active.load(std::sync::atomic::Ordering::SeqCst)\n    }\n\n    pub(crate) fn as_str(\u0026self) -\u003e \u0026str {\n        self.ctx.path.as_str()\n    }\n\n    pub(crate) fn scope_token(\u0026self) -\u003e crate::tracing::ScopeToken {\n        self.ctx.scope_token\n    }\n\n    /// INTERNAL\n    #[doc(hidden)]\n    #[allow(unused)]\n    pub fn activate(\u0026self) {\n        enter_scope(self.scope_token());\n        let prev = ModuleContext::place(Arc::clone(\u0026self.ctx));\n\n        #[cfg(feature = \"async\")]\n        {\n            use crate::time::{Driver, SimTime, TimerSlot};\n\n            if let Some(prev) = prev {\n                prev.async_ext.write().driver = Driver::unset();\n            }\n\n            let driver = self.ctx.async_ext.write().driver.take();\n            if let Some(mut d) = driver {\n                let bumpable = d.bump();\n                if d.next_wakeup \u003c= SimTime::now() {\n                    d.next_wakeup = SimTime::MAX;\n                }\n                bumpable.into_iter().for_each(TimerSlot::wake_all);\n                d.set();\n            }\n        }\n    }\n\n    /// INTERNAL\n    #[doc(hidden)]\n    #[allow(unused)]\n    pub(crate) fn deactivate(\u0026self, rt: \u0026mut impl EventSink\u003cNetEvents\u003e) {\n        #[cfg(feature = \"async\")]\n        {\n            use crate::net::AsyncWakeupEvent;\n            use crate::time::Driver;\n\n            let mut ext = self.ctx.async_ext.write();\n            let Some(mut driver) = Driver::unset() else {\n                // Somebody stole our driver\n                #[cfg(feature = \"tracing\")]\n                tracing::error!(\"IO time driver missing after event execution\");\n\n                ext.driver = Some(Driver::new());\n                return;\n            };\n            if let Some(next_wakeup) = driver.next() {\n                if next_wakeup \u003c driver.next_wakeup {\n                    #[cfg(feature = \"tracing\")]\n                    tracing::trace!(\n                        \"scheduling new wakeup at {} (prev {})\",\n                        next_wakeup,\n                        driver.next_wakeup\n                    );\n\n                    println!(\"\u003e scheduling wakeup at {}\", next_wakeup);\n\n                    driver.next_wakeup = next_wakeup;\n                    rt.add(\n                        NetEvents::AsyncWakeupEvent(AsyncWakeupEvent {\n                            module: self.clone(),\n                        }),\n                        next_wakeup,\n                    );\n                }\n            }\n            ext.driver = Some(driver);\n        }\n\n        let _ = ModuleContext::take();\n        leave_scope();\n    }\n\n    /// Creates a gate on the current module, returning its ID.\n    ///\n    #[must_use]\n    pub fn create_gate(\u0026self, name: \u0026str) -\u003e GateRef {\n        self.create_gate_cluster(name, 1).remove(0)\n    }\n\n    ///\n    /// Createas a cluster of gates on the current module returning their IDs.\n    ///\n    #[must_use]\n    pub fn create_gate_cluster(\u0026self, name: \u0026str, size: usize) -\u003e Vec\u003cGateRef\u003e {\n        (0..size)\n            .map(|id| self.create_raw_gate(name, size, id))\n            .collect()\n    }\n\n    /// Creates a gate on the current module, returning its ID.\n    ///\n    #[must_use]\n    pub fn create_raw_gate(\u0026self, name: \u0026str, size: usize, pos: usize) -\u003e GateRef {\n        let gate = Gate::new(self, name, size, pos);\n        self.ctx.gates.write().push(gate.clone());\n        gate\n    }\n}\n\nimpl PartialEq for ModuleRef {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        Arc::ptr_eq(\u0026self.ctx, \u0026other.ctx)\n    }\n}\n\nimpl Debug for ModuleRef {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\u0026format!(\n            \"ModuleRef {{ name: {}, handler: {}, ctx: {} }}\",\n            self.ctx.path,\n            Arc::strong_count(\u0026self.processing),\n            Arc::strong_count(\u0026self.ctx),\n        ))\n        .finish()\n    }\n}\n\nunsafe impl Send for ModuleRef {}\nunsafe impl Send for ModuleRefWeak {}\n\nunsafe impl Sync for ModuleRef {}\nunsafe impl Sync for ModuleRefWeak {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn fmt() {\n        let module = ModuleContext::standalone(\"root.a.b\".into());\n        let m2 = module.clone();\n        let weak = ModuleRefWeak::new(\u0026module);\n\n        assert_eq!(module.as_str(), \"root.a.b\");\n        assert_eq!(\n            format!(\"{module:?}\"),\n            \"ModuleRef { name: root.a.b, handler: 2, ctx: 2 }\"\n        );\n        assert_eq!(format!(\"{weak:?}\"), \"ModuleRefWeak\");\n\n        assert_eq!(module, m2);\n    }\n\n    #[test]\n    fn as_typed_ref() {\n        #[derive(Debug, PartialEq)]\n        struct A {\n            inner: i32,\n        }\n        impl Module for A {}\n\n        let module = ModuleContext::standalone(\"root\".into());\n        module.upgrade_dummy(ProcessingElements::new(Vec::new(), A { inner: 42 }));\n\n        assert!(module.try_as_ref::\u003ci32\u003e().is_none());\n        assert!(module.try_as_mut::\u003ci32\u003e().is_none());\n\n        module.as_mut::\u003cA\u003e().inner += 1;\n        assert_eq!(*module.as_ref::\u003cA\u003e(), A { inner: 43 });\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":10868},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":10868},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":10868},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":10868},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1246},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1246},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":2195},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2195},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":14852},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":14852},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":4931},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":8952},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":267},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":420},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":93,"coverable":95},{"path":["/","Users","mk","Developer","rust","des","des","src","net","module","tests.rs"],"content":"use super::*;\n\n#[test]\n#[should_panic = \"cannot retrieve current module context, no module currently in scope\"]\nfn current_panic_outside_module_ctx() {\n    let _ = current();\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","net","par","api.rs"],"content":"use std::io;\n\nuse super::{Par, ParMap};\nuse crate::net::module::current;\n\n/// Retrieves a simulation parameter attached to the current node.\n///\n/// \u003e *This function requires a node-context within the simulation*\n///\n/// The retrieved [`Par`] object points to a potentially existent parameter\n/// assigned to the current node. If non-existent the `Par` object can be\n/// used to set a the parametern for the first time. Parameters are stored\n/// as strings internally.\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// struct MyModule;\n/// impl Module for MyModule {\n///     fn at_sim_start(\u0026mut self, stage: usize) {\n///         let hostname = par(\"hostname\");\n///         assert!(hostname.is_some());\n///     }\n/// }\n///\n/// let mut sim = Sim::new(());\n/// sim.node(\"alice\", MyModule);\n/// ```\n#[must_use]\npub fn par(key: impl AsRef\u003cstr\u003e) -\u003e Par {\n    Par::new(key.as_ref(), current().path().as_str())\n}\n\n/// Retrieves a simulation parameter from some node in the simulation.\n///\n/// \u003e *This function should only be called while the simulation is active*\n///\n/// The retrieved [`Par`] object behaves, as if retrived by [`par`] on the given\n/// node. See [`par`] for more information.\n#[must_use]\npub fn par_for(key: impl AsRef\u003cstr\u003e, module: impl AsRef\u003cstr\u003e) -\u003e Par {\n    Par::new(key.as_ref(), module.as_ref())\n}\n\n/// Exports the current simulation parameter tree to some output device.\n///\n/// The output will be encoded as a key-value list where each key-value\n/// pair is one line, sperated by a '='.\n///\n/// # Errors\n///\n/// This function may fail if write operations to the output\n/// fails.\npub fn par_export(mut into: impl io::Write) -\u003e io::Result\u003c()\u003e {\n    ParMap::shared().export(\u0026mut into)\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","Users","mk","Developer","rust","des","des","src","net","par","mod.rs"],"content":"use std::fmt::Display;\nuse std::io;\nuse std::marker::PhantomData;\nuse std::ops::Deref;\nuse std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nuse std::sync::{Arc, RwLock};\n\nmod api;\nuse fxhash::{FxBuildHasher, FxHashMap};\n\npub use self::api::*;\n\nuse super::globals;\n\n// # Internal mappings\n\n/// A storage for all parameters associated with a simulation.\n#[derive(Debug)]\npub struct ParMap {\n    tree: RwLock\u003cParTree\u003e,\n}\n\n#[derive(Debug)]\nstruct ParTree {\n    branches: Vec\u003cParTreeBranch\u003e,\n    pars: FxHashMap\u003cString, (String, AtomicUsize)\u003e,\n}\n\n#[derive(Debug)]\nstruct ParTreeBranch {\n    matching: ParTreePathMatching,\n    node: ParTree,\n}\n\n#[derive(Debug)]\nenum ParTreePathMatching {\n    Any,\n    Path(String),\n}\n\nimpl ParMap {\n    fn shared() -\u003e Arc\u003cParMap\u003e {\n        globals().parameters.clone()\n    }\n\n    /// Creates new entries from a raw input text.\n    ///\n    /// See [`Sim::include_par`](crate::net::Sim) for more infomation.\n    pub fn build(\u0026self, raw_text: \u0026str) {\n        for line in raw_text.lines() {\n            if let Some((key, value)) = line.split_once('=') {\n                self.insert(key.trim(), value.trim().to_string());\n            }\n        }\n    }\n\n    fn get_rlock(\u0026self, key: \u0026str, inc: usize) -\u003e Option\u003cString\u003e {\n        self.tree.read().unwrap().get_rlock(key, inc)\n    }\n\n    fn release_rlock(\u0026self, key: \u0026str) {\n        let done = self.tree.read().unwrap().release_rlock(key);\n        assert!(done);\n    }\n\n    fn insert(\u0026self, key: \u0026str, value: String) -\u003e bool {\n        self.tree.write().unwrap().insert(key, value)\n    }\n\n    fn remove(\u0026self, key: \u0026str) {\n        self.tree.write().unwrap().remove(key);\n    }\n\n    fn export(\u0026self, writer: \u0026mut impl io::Write) -\u003e io::Result\u003c()\u003e {\n        self.tree.read().unwrap().export(writer, \"\")\n    }\n}\n\nimpl ParTree {\n    fn new() -\u003e ParTree {\n        ParTree {\n            branches: Vec::new(),\n            pars: FxHashMap::with_hasher(FxBuildHasher::default()),\n        }\n    }\n\n    fn get_rlock(\u0026self, key: \u0026str, inc: usize) -\u003e Option\u003cString\u003e {\n        match key.split_once('.') {\n            Some((comp, remainder)) =\u003e {\n                for branch in self.branches.iter().filter(|b| b.matching.matches_r(comp)) {\n                    let Some(ret) = branch.node.get_rlock(remainder, inc) else {\n                        continue;\n                    };\n                    return Some(ret);\n                }\n                None\n            }\n            None =\u003e {\n                if let Some((value, lock)) = self.pars.get(key) {\n                    lock.fetch_add(inc, SeqCst);\n                    Some(value.clone())\n                } else {\n                    None\n                }\n            }\n        }\n    }\n\n    fn release_rlock(\u0026self, key: \u0026str) -\u003e bool {\n        match key.split_once('.') {\n            Some((comp, rem)) =\u003e {\n                for branch in self.branches.iter().filter(|b| b.matching.matches_r(comp)) {\n                    if branch.node.release_rlock(rem) {\n                        return true;\n                    }\n                }\n                false\n            }\n            None =\u003e {\n                if let Some((_, lock)) = self.pars.get(key) {\n                    lock.fetch_sub(1, SeqCst);\n                    true\n                } else {\n                    false\n                }\n            }\n        }\n    }\n\n    fn insert(\u0026mut self, key: \u0026str, value: String) -\u003e bool {\n        if let Some((comp, remainder)) = key.split_once('.') {\n            if let Some(branch) = self\n                .branches\n                .iter_mut()\n                .find(|b| b.matching.matches_w(comp))\n            {\n                branch.node.insert(remainder, value)\n            } else {\n                let mut node = ParTree::new();\n                let ret = node.insert(remainder, value);\n                if comp == \"*\" {\n                    self.branches.push(ParTreeBranch {\n                        matching: ParTreePathMatching::Any,\n                        node,\n                    });\n                } else {\n                    self.branches.push(ParTreeBranch {\n                        matching: ParTreePathMatching::Path(comp.to_string()),\n                        node,\n                    });\n                }\n                ret\n            }\n        } else {\n            // (0) Fetch the entry\n            let entry = self\n                .pars\n                .entry(key.to_string())\n                .or_insert((String::new(), AtomicUsize::new(0)));\n\n            // (1) try an inplace update (requires not readers)\n            if entry.1.load(SeqCst) == 0 {\n                entry.0 = value;\n                true\n            } else {\n                false\n            }\n        }\n    }\n\n    fn remove(\u0026mut self, key: \u0026str) -\u003e bool {\n        match key.split_once('.') {\n            Some((comp, rem)) =\u003e self\n                .branches\n                .iter_mut()\n                .find(|b| b.matching.matches_w(comp))\n                .is_some_and(|b| b.node.remove(rem)),\n            None =\u003e self.pars.remove(key).is_some(),\n        }\n    }\n\n    fn export(\u0026self, writer: \u0026mut impl io::Write, path: \u0026str) -\u003e io::Result\u003c()\u003e {\n        // Write pars directly\n        for (key, (value, _)) in \u0026self.pars {\n            writeln!(writer, \"{path}.{key} = {value}\")?;\n        }\n\n        // Recurse branches\n        for branch in \u0026self.branches {\n            let new_path = if path.is_empty() {\n                branch.matching.to_string()\n            } else {\n                format!(\"{path}.{}\", branch.matching)\n            };\n            branch.node.export(writer, \u0026new_path)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl ParTreePathMatching {\n    fn matches_w(\u0026self, key: \u0026str) -\u003e bool {\n        match self {\n            Self::Any =\u003e key == \"*\",\n            Self::Path(ref path) =\u003e path == key,\n        }\n    }\n\n    fn matches_r(\u0026self, key: \u0026str) -\u003e bool {\n        // dbg!(self, key);\n        match self {\n            Self::Any =\u003e true,\n            Self::Path(ref path) =\u003e path == key,\n        }\n    }\n}\n\nimpl Display for ParTreePathMatching {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Any =\u003e write!(f, \"*\"),\n            Self::Path(path) =\u003e write!(f, \"{path}\"),\n        }\n    }\n}\n\nimpl Default for ParMap {\n    fn default() -\u003e Self {\n        ParMap {\n            tree: RwLock::new(ParTree::new()),\n        }\n    }\n}\n\n// # External API\n\n/// A handle to a parameter associated to a node within the simulation.\n///\n/// This type is parameterized by a type-state parameter `S`.\n/// This parameter indicates whether the parameter is guaranteed to\n/// exist `S = Exists` or this remains in question `S = Optional`.\n///\n/// This type provides methods to read an write parameters, based on the\n/// type state. `Par\u003cExists\u003e` implement `Deref\u003cTarget = str\u003e` so parameters\n/// can be extracted and perhaps parsed, as soon as the existence of the parameter\n/// is confirmed.\n#[derive(Debug, PartialEq, Eq, Hash)]\npub struct Par\u003cS = Optional\u003e\nwhere\n    S: private::ParState,\n{\n    key: String,\n    value: Option\u003cString\u003e,\n\n    _phantom: PhantomData\u003cS\u003e,\n}\n\n/// The state of a [`Par`] where its not decided\n/// whether data is contained or not. Useful for writing data\n/// to not yet initalized parameters.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct Optional;\nimpl private::ParState for Optional {}\n\n/// The state of a [`Par`] where the contents are guaranteed\n/// to be there, thus allowing derefs on the handle.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct Exists;\nimpl private::ParState for Exists {}\n\n/// Errors that can occur in combination with [`Par`] objects.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum ParError {\n    /// This error occures if a write operation failed, since a write lock could\n    /// not be aquired.\n    CouldNotAquireWriteLock,\n}\n\nmod private {\n    pub trait ParState {}\n}\n\nimpl Par\u003cOptional\u003e {\n    fn new(key: \u0026str, module: \u0026str) -\u003e Par {\n        if module.is_empty() {\n            Par {\n                key: key.to_string(),\n                value: None,\n                _phantom: PhantomData,\n            }\n        } else {\n            Par {\n                key: format!(\"{module}.{key}\"),\n                value: None,\n                _phantom: PhantomData,\n            }\n        }\n    }\n}\n\nimpl\u003cS\u003e Par\u003cS\u003e\nwhere\n    S: private::ParState,\n{\n    /// Returns a handle allowing [`Deref`] on the contained\n    /// value, consuming self.\n    ///\n    /// # Examples\n    ///\n    /// This example would succeed:\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::net::*;\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", ModuleFn::new(\n    ///     || {\n    ///         let par = par(\"addr\")\n    ///             .expect(\"parameter 'addr' does not exist\")\n    ///             .parse::\u003cIpAddr\u003e()\n    ///             .expect(\"parameter 'addr' failed to be parsed\");\n    ///     },\n    ///     |_, _| {}\n    /// ));\n    /// sim.include_par(\"alice.addr = 198.168.2.1\\n\");\n    /// /* ... */\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    ///\n    /// While this would panic:\n    ///\n    /// ```should_panic\n    /// # use des::prelude::*;\n    /// # use des::net::*;\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", ModuleFn::new(\n    ///     || {\n    ///         let par = par(\"addr\")\n    ///             .expect(\"parameter 'addr' does not exist\")\n    ///             .parse::\u003cIpAddr\u003e()\n    ///             .expect(\"parameter 'addr' failed to be parsed\");\n    ///     },\n    ///     |_, _| {}\n    /// ));\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// This function panics of the Par points to no data.\n    ///\n    #[must_use]\n    pub fn expect(self, msg: \u0026str) -\u003e Par\u003cExists\u003e {\n        let map = ParMap::shared();\n        if let Some(value) = map.get_rlock(\u0026self.key, 1) {\n            Par {\n                key: self.key.clone(),\n                value: Some(value),\n                _phantom: PhantomData,\n            }\n        } else {\n            panic!(\"{msg}\");\n        }\n    }\n\n    /// Returns a handle allowing [`Deref`] on the contained\n    /// value, consuming self.\n    ///\n    /// See [`Par::expect`] for more information.\n    #[must_use]\n    pub fn unwrap(self) -\u003e Par\u003cExists\u003e {\n        self.expect(\"called `Par::unwrap` on a parameter that does not exist\")\n    }\n\n    /// Indicates whether the handle contains a value.\n    #[must_use]\n    pub fn is_some(\u0026self) -\u003e bool {\n        // (0) Shortciruit\n        if self.value.is_some() {\n            return true;\n        }\n\n        // (1) Long way around\n        let map = ParMap::shared();\n        map.get_rlock(\u0026self.key, 0).is_some()\n    }\n\n    /// Indicates whether the handle contains a value.\n    #[must_use]\n    pub fn is_none(\u0026self) -\u003e bool {\n        !self.is_some()\n    }\n\n    /// Returns the contained value optionaly, thereby losing the\n    /// ability to set the par. This does not create a permantent\n    /// read lock.\n    #[must_use]\n    pub fn as_option(self) -\u003e Option\u003cString\u003e {\n        let map = ParMap::shared();\n        map.get_rlock(\u0026self.key, 0)\n    }\n\n    /// Sets the parameter to the given value.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if other active locks exist for the datapoint.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::net::*;\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", ModuleFn::new(\n    ///     || {\n    ///         assert!(par(\"addr\").is_none());\n    ///         par(\"addr\").set(IpAddr::V4(Ipv4Addr::new(192, 168, 2, 110)));\n    ///         assert!(par(\"addr\").is_some());\n    ///         assert_eq!(\u0026*par(\"addr\").unwrap(), \"192.168.2.110\");\n    ///     },\n    ///     |_, _| {}\n    /// ));\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    #[allow(clippy::needless_pass_by_value)]\n    pub fn set(self, value: impl ToString) -\u003e Result\u003cPar\u003cExists\u003e, ParError\u003e {\n        let map = ParMap::shared();\n        let value = value.to_string();\n        if map.insert(\u0026self.key, value) {\n            Ok(Par {\n                key: self.key.clone(),\n                value: map.get_rlock(\u0026self.key, 1),\n                _phantom: PhantomData,\n            })\n        } else {\n            Err(ParError::CouldNotAquireWriteLock)\n        }\n    }\n\n    /// Remove the entry from the par storage.\n    ///\n    /// Returns a `Par` object with optional (in this case None) content.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::net::*;\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", ModuleFn::new(\n    ///     || {\n    ///         assert!(par(\"addr\").is_some());\n    ///         par(\"addr\").unset();\n    ///         assert!(par(\"addr\").is_none());\n    ///     },\n    ///     |_, _| {}\n    /// ));\n    /// sim.include_par(\"alice.addr = 192.168.2.110\");\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    #[must_use]\n    pub fn unset(self) -\u003e Par\u003cOptional\u003e {\n        let map = ParMap::shared();\n        map.remove(\u0026self.key);\n        Par {\n            value: None,\n            key: self.key.clone(),\n            _phantom: PhantomData,\n        }\n    }\n}\n\nimpl Par\u003cExists\u003e {\n    /// Uses a custom string parser to parse a string, timming\n    /// quotation marks in the process.\n    #[allow(clippy::missing_panics_doc)]\n    #[must_use]\n    pub fn into_inner(\u0026self) -\u003e String {\n        let mut parsed = self.value.clone().unwrap();\n        // Trim marks\n        let mut chars = parsed.chars();\n        let mut is_marked = parsed.len() \u003e= 2;\n        is_marked \u0026= chars.next() == Some('\"');\n        is_marked \u0026= chars.next_back() == Some('\"');\n\n        if is_marked {\n            parsed.pop();\n            parsed.remove(0);\n            parsed\n        } else {\n            parsed\n        }\n    }\n}\n\nimpl Deref for Par\u003cExists\u003e {\n    type Target = str;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        self.value.as_ref().unwrap()\n    }\n}\n\nimpl\u003cS\u003e Clone for Par\u003cS\u003e\nwhere\n    S: private::ParState,\n{\n    fn clone(\u0026self) -\u003e Self {\n        if self.value.is_some() {\n            ParMap::shared().get_rlock(\u0026self.key, 1);\n        }\n\n        Self {\n            key: self.key.clone(),\n            value: self.value.clone(),\n            _phantom: PhantomData,\n        }\n    }\n}\n\nimpl\u003cS\u003e Drop for Par\u003cS\u003e\nwhere\n    S: private::ParState,\n{\n    fn drop(\u0026mut self) {\n        // (0) Only if Par\u003cExists\u003e\n        if self.value.is_some() {\n            let map = ParMap::shared();\n            map.release_rlock(\u0026self.key);\n        }\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":151},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":151},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":107},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":219},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":219},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":121,"coverable":147},{"path":["/","Users","mk","Developer","rust","des","des","src","net","path.rs"],"content":"use core::fmt;\nuse std::sync::Arc;\n\n///\n/// A unqiue identifier for a object, indicating its parental inheritance.\n///\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct ObjectPath {\n    data: Arc\u003cstr\u003e,\n    last_element_offset: usize,\n    len: usize,\n    is_gate: bool,\n}\n\nimpl ObjectPath {\n    /// Indicates whether the path points to the simulation root.\n    #[must_use]\n    pub fn is_root(\u0026self) -\u003e bool {\n        self.len == 0\n    }\n\n    /// Indicates whether the path points to a module.\n    #[must_use]\n    pub fn is_module(\u0026self) -\u003e bool {\n        !self.is_gate\n    }\n\n    /// Returns the depth of the referenced object.\n    ///\n    /// Note that depth 0 indicates the root of the simulation.\n    #[must_use]\n    #[allow(clippy::len_without_is_empty)]\n    pub fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    /// Returns the last path component, the name of the current module.\n    #[must_use]\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.data[self.last_element_offset..]\n    }\n\n    /// Returns the entrie path as a \u0026str.\n    #[must_use]\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        \u0026self.data\n    }\n\n    /// Returns the entrie path as a \u0026str for declaring a logger scope\n    #[must_use]\n    pub fn as_logger_scope(\u0026self) -\u003e \u0026str {\n        if self.is_root() {\n            \"@root\"\n        } else {\n            self.as_str()\n        }\n    }\n\n    /// Returns the entrie path as a \u0026str.\n    #[must_use]\n    pub fn as_parent_str(\u0026self) -\u003e \u0026str {\n        \u0026self.data[..self.last_element_offset.saturating_sub(1)]\n    }\n\n    /// Constructs the path to the parent element, if there is any.\n    #[must_use]\n    pub fn parent(\u0026self) -\u003e Option\u003cObjectPath\u003e {\n        if self.len == 0 {\n            return None;\n        }\n\n        let mut data = self.data.to_string();\n        let mut last_element_offset = self.last_element_offset;\n        let mut len = self.len;\n\n        data.truncate(last_element_offset.saturating_sub(1));\n\n        if let Some(i) = data.rfind('.') {\n            last_element_offset = i + 1;\n        } else {\n            last_element_offset = 0;\n        }\n        len -= 1;\n\n        Some(Self {\n            data: data.into(),\n            last_element_offset,\n            len,\n            is_gate: false,\n        })\n    }\n\n    /// Returns a parent that is not root.\n    #[must_use]\n    pub fn nonzero_parent(\u0026self) -\u003e Option\u003cObjectPath\u003e {\n        let parent = self.parent()?;\n        if parent.is_root() {\n            None\n        } else {\n            Some(parent)\n        }\n    }\n\n    /// Returns a new instance with another module appended to the path.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the current path points to a gate.\n    #[must_use]\n    pub fn appended(\u0026self, module: impl AsRef\u003cstr\u003e) -\u003e Self {\n        let mut data = self.data.to_string();\n        let mut last_element_offset = self.last_element_offset;\n        let mut len = self.len;\n\n        assert!(\n            !self.is_gate,\n            \"cannot append to a path that points to a gate\"\n        );\n\n        let suffix = module.as_ref();\n        if !suffix.is_empty() {\n            if self.len != 0 {\n                last_element_offset = data.len() + 1;\n                data.push('.');\n            }\n            data.push_str(suffix);\n            len += 1;\n        }\n\n        Self {\n            data: data.into(),\n            last_element_offset,\n            len,\n            is_gate: false,\n        }\n    }\n\n    /// Retruns a new object path pointing to the gate on the current module.\n    #[must_use]\n    pub fn appended_gate(\u0026self, gate: impl AsRef\u003cstr\u003e) -\u003e Self {\n        let mut appended = self.appended(gate);\n        appended.is_gate = true;\n        appended\n    }\n}\n\nimpl fmt::Display for ObjectPath {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        self.data.fmt(f)\n    }\n}\n\nimpl AsRef\u003cstr\u003e for ObjectPath {\n    fn as_ref(\u0026self) -\u003e \u0026str {\n        self.as_str()\n    }\n}\n\nimpl From\u003c\u0026str\u003e for ObjectPath {\n    fn from(s: \u0026str) -\u003e Self {\n        let mut o = 0;\n        let mut last_element_offset = 0;\n        let mut len = 0;\n        for c in s.chars() {\n            if c == '.' {\n                last_element_offset = o + c.len_utf8();\n                len += 1;\n            }\n            o += c.len_utf8();\n        }\n        if o != last_element_offset {\n            len += 1;\n        }\n\n        Self {\n            data: s.to_string().into(),\n            last_element_offset,\n            len,\n            is_gate: false,\n        }\n    }\n}\n\nimpl From\u003c\u0026String\u003e for ObjectPath {\n    fn from(value: \u0026String) -\u003e Self {\n        Self::from(value.as_str())\n    }\n}\n\nimpl From\u003cString\u003e for ObjectPath {\n    fn from(value: String) -\u003e Self {\n        Self::from(value.as_str())\n    }\n}\n\nimpl Default for ObjectPath {\n    fn default() -\u003e Self {\n        Self {\n            data: String::new().into(),\n            last_element_offset: 0,\n            len: 0,\n            is_gate: false,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn manual_appending() {\n        let path = ObjectPath::default().appended(\"top\").appended(\"mid\");\n\n        assert_eq!(path.name(), \"mid\");\n        assert_eq!(path.as_parent_str(), \"top\");\n        assert_eq!(\n            path,\n            ObjectPath {\n                data: \"top.mid\".to_string().into(),\n                len: 2,\n                last_element_offset: 4,\n                is_gate: false,\n            }\n        );\n\n        let path = ObjectPath::default()\n            .appended(\"top\")\n            .appended(\"mid\")\n            .appended(\"low\");\n\n        assert_eq!(path.name(), \"low\");\n        assert_eq!(path.as_parent_str(), \"top.mid\");\n        assert_eq!(\n            path,\n            ObjectPath {\n                data: \"top.mid.low\".to_string().into(),\n                len: 3,\n                last_element_offset: 8,\n                is_gate: false,\n            }\n        );\n\n        let path = ObjectPath::default().appended(\"top\");\n        assert_eq!(path.name(), \"top\");\n        assert_eq!(path.as_parent_str(), \"\");\n        assert_eq!(\n            path,\n            ObjectPath {\n                data: \"top\".to_string().into(),\n                len: 1,\n                last_element_offset: 0,\n                is_gate: false,\n            }\n        );\n\n        let path = ObjectPath::default();\n        assert_eq!(path.name(), \"\");\n        assert_eq!(path.as_parent_str(), \"\");\n        assert!(path.is_root());\n        assert_eq!(\n            path,\n            ObjectPath {\n                data: \"\".to_string().into(),\n                len: 0,\n                last_element_offset: 0,\n                is_gate: false,\n            }\n        );\n    }\n\n    #[test]\n    fn parent_creation() {\n        let path = ObjectPath::default().appended(\"top\").appended(\"mid\");\n        let parent = path.parent();\n        assert_eq!(\n            parent,\n            Some(ObjectPath {\n                data: \"top\".to_string().into(),\n                len: 1,\n                last_element_offset: 0,\n                is_gate: false,\n            })\n        );\n\n        let path = ObjectPath::default()\n            .appended(\"top\")\n            .appended(\"mid\")\n            .appended(\"low\");\n\n        let parent = path.parent();\n        assert_eq!(\n            parent,\n            Some(ObjectPath {\n                data: \"top.mid\".to_string().into(),\n                len: 2,\n                last_element_offset: 4,\n                is_gate: false,\n            })\n        );\n\n        let path = ObjectPath::default().appended(\"top\");\n\n        let parent = path.parent();\n        assert_eq!(\n            parent,\n            Some(ObjectPath {\n                data: \"\".to_string().into(),\n                len: 0,\n                last_element_offset: 0,\n                is_gate: false,\n            })\n        );\n\n        let path = ObjectPath::default();\n\n        let parent = path.parent();\n        assert_eq!(parent, None);\n    }\n\n    #[test]\n    fn parsing() {\n        assert_eq!(\n            ObjectPath::from(\"top.mid\"),\n            ObjectPath {\n                data: \"top.mid\".to_string().into(),\n                len: 2,\n                last_element_offset: 4,\n                is_gate: false,\n            }\n        );\n\n        assert_eq!(\n            ObjectPath::from(\"top.mid.low\"),\n            ObjectPath {\n                data: \"top.mid.low\".to_string().into(),\n                len: 3,\n                last_element_offset: 8,\n                is_gate: false,\n            }\n        );\n\n        assert_eq!(\n            ObjectPath::from(\"top\"),\n            ObjectPath {\n                data: \"top\".to_string().into(),\n                len: 1,\n                last_element_offset: 0,\n                is_gate: false,\n            }\n        );\n\n        assert_eq!(\n            ObjectPath::from(\"\"),\n            ObjectPath {\n                data: \"\".to_string().into(),\n                len: 0,\n                last_element_offset: 0,\n                is_gate: false,\n            }\n        );\n\n        // emoji is a 4 byte character thus 7 + 4\n        assert_eq!(\n            ObjectPath::from(\"top.ab.low\"),\n            ObjectPath {\n                data: \"top.ab.low\".to_string().into(),\n                len: 3,\n                last_element_offset: 11,\n                is_gate: false,\n            }\n        );\n\n        assert!(ObjectPath::default().is_root());\n        assert!(ObjectPath::from(String::new()).is_module());\n        assert_eq!(ObjectPath::from(\u0026String::new()).as_logger_scope(), \"@root\");\n        assert_eq!(ObjectPath::from(\"abc\").as_logger_scope(), \"abc\");\n        assert!(!ObjectPath::from(\"a\").appended_gate(\"gate\").is_module());\n        assert!(ObjectPath::from(\"root.a.b.c\").as_ref().starts_with(\"root\"));\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":423},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":423},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":4724},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":4724},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":470},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":470},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":440},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":449},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":388},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":176},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1469},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1236},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1199},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":534},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":17},"fn_name":null}],"covered":76,"coverable":76},{"path":["/","Users","mk","Developer","rust","des","des","src","net","processing.rs"],"content":"//! Module-specific plugins.\n//!\n//! Plugins act as message stream manipulators between the\n//! main application and the network layer. They can be used\n//! to add shared behaviour (like Routing) to all modules,\n//! independent of the modules defined state and behaviour.\n//!\n//! All plugins must implement the `Plugin` trait. To install\n//! them on a module, use the `add_plugin`\n//! function and assign them a priority. The\n//! lower the priority value, the closer the plugin is to the network\n//! layer. Plugins can then be controlled and observed using the\n//! `PluginHandle` return by the install functions.\n//!\n//! # Stream manipulation \u0026 event lifecycle\n//!\n//! Plugins are intrinsicly linked to the event lifecycle of an\n//! arriving message. Accordingly they provide an API do react\n//! to lifecycle events like `Plugin::event_start` and `Plugin::event_end`.\n//!\n//! When a message arrives at a module, the `Plugin::event_start` method\n//! is called on all active plugins, in the order defined by the priorities\n//! (close to networklayer first). Then the incoming message is passed\n//! through the plugins in the same order. Plugins can capture messages\n//! using the `Plugin::capture_incoming` method. Using this method\n//! plugins can **modify**, **delete** or **pass through** messages.\n//! Should they delete a message, no further plugins will be called\n//! using `Plugin::capture_incoming`. Additionally no message will be\n//! passed to the main application (defined by the module).\n//!\n//! If the message still exist after passing all plugins, then\n//! it will be passed to the main application though `Module::handle_message`\n//!\n//! In the process of handeling an incoming message, each plugin and the main application\n//! may send new messages to the networklayer using `send`\n//! or `schedule_in`. This messages must pass through\n//! all plugins (in reverse priority order). In this process they can be\n//! captured and thus **modified** or **deleted** by all plugins, closer\n//! to the network layer, than the message origin. This is done\n//! using the `Plugin::capture_outgoing` method. If messages\n//! make it through all plugins they will be added to the networklayer,\n//! if not then not.\n//!\n//! After the main application has finished the message processing\n//! the plugins are going to be deactivated in reverse order.\n//! by calling `Plugin::event_end`. Sending messages at this stage will\n//! still create new output-streams through all plugins closer to the networklayer\n//! than the origin.\n//!\n//! # Plugin creation and removal\n//!  \n//! When plugins are created using e.g. `add_plugin` they are not active\n//! right away. Plugins only become active when the next event arrives.\n//! This is the case, because some plugins may depend on some action\n//! they should have performed in the incoming stream, when working on the\n//! outgoing stream. However plugins may be created in a position, where their place\n//! in the incoming stream should have allready been processed, but was not,\n//! since they were not existent back then. Accordingly plugins only become active once they\n//! can ensure that they existed at all relevent points in the event-lifecycle.\n//!\n//! Accordingly plugins the are removed using `PluginHandle::remove`\n//! still exists for the rest of the event cycle, and are only deleted\n//! once the next event arrives.\n//!  \n\nuse std::{any::Any, sync::RwLock};\n\nuse super::module::Module;\nuse crate::prelude::Message;\n\n/// A subprogramm between the module application and the network layer.\n///\n/// Processing elements can follow different patterns based on the provided\n/// API. Common patterns are:\n///\n/// - **Observer**: The element does not modifiy the message stream, it just observes it.\n///    This plugin can be used to get statistics over message streams or to log\n///    debug output.\n/// - **Scope-Provider**: This element provides some kind of scope to all items further\n///    from the network layer than itself. A scope can be defined using a static variable\n///    or just consist of a time meassurement between [`event_start`] / [`event_end`].\n/// - **Capture**: This kind of processing element captures parts of the input stream and redirects\n///     it in some abitraty way, using other APIs. This pattern can be used to implement buffering\n///     or mergeing of frameneted IP packets.\n/// - **Meta-Provider**: This kind of processing element attaches / modifies part of the incoming or\n///    outgoing message stream to provide some new level of abstraction e.g. a VPN\n///    or simulated network Interfaces.\n///\n/// [`event_start`]: ProcessingElement::event_start\n/// [`event_end`]: ProcessingElement::event_end\npub trait ProcessingElement: Any {\n    /// Defines the requires stack for this processing element.\n    ///\n    ///\n    fn stack(\u0026self) -\u003e impl IntoProcessingElements\n    where\n        Self: Sized,\n    {\n        BaseLoader\n    }\n\n    /// A handler for when an the event processing of a message starts.\n    ///\n    /// This function is called only once per event. If this function is called\n    /// this means all plugins closer to the network layer have allready been called\n    /// while all plugins further from the network layer are not yet called.\n    ///\n    /// Use this function to set up actions, required at the start of\n    /// a generic event.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use des::prelude::*;\n    /// struct LoggerPlugin {\n    ///     counter: usize,\n    /// }\n    ///\n    /// impl ProcessingElement for LoggerPlugin {\n    ///     fn event_start(\u0026mut self) {\n    ///         tracing::trace!(\"receiving {}th message\", self.counter);\n    ///         self.counter += 1;   \n    ///     }\n    /// }\n    /// ```\n    fn event_start(\u0026mut self) {}\n\n    /// A handler for when an the event processing of a message ends.\n    ///\n    /// This function is called only once per event. The call order\n    /// is the reverse to the call order of [`event_start`].\n    ///\n    /// Use this function to set up actions, associated\n    /// with the end of an event\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use des::prelude::*;\n    /// # use des::time::*;\n    /// struct Timer {\n    ///     started: SimTime,    \n    /// }\n    ///\n    /// impl ProcessingElement for Timer {\n    ///     fn event_start(\u0026mut self) {\n    ///        self.started = SimTime::now();\n    ///     }\n    ///     fn event_end(\u0026mut self) {\n    ///        let t = SimTime::now().duration_since(self.started);\n    ///        tracing::trace!(\"took {:?}\", t);   \n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`event_start`]: ProcessingElement::event_start\n    fn event_end(\u0026mut self) {}\n\n    /// A capture clause that can modify an incoming message.\n    ///\n    /// This function is called at most once per event, after all\n    /// plugins have called [`event_start`],\n    /// but before all the main application has processed its message.\n    ///\n    /// This function receives an incoming message, and can\n    /// modify, pass-through or delete a message.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// struct Filter {\n    ///    filter: Box\u003cdyn Fn(\u0026Message) -\u003e bool\u003e,    \n    /// }\n    ///\n    /// impl ProcessingElement for Filter {\n    ///     fn incoming(\u0026mut self, msg: Message) -\u003e Option\u003cMessage\u003e {\n    ///        let f = \u0026self.filter;\n    ///        if f(\u0026msg) {\n    ///            Some(msg)    \n    ///        } else {\n    ///            None\n    ///        }\n    ///     }    \n    /// }\n    /// ```\n    ///\n    /// [`event_start`]: ProcessingElement::event_start\n    fn incoming(\u0026mut self, msg: Message) -\u003e Option\u003cMessage\u003e {\n        Some(msg)\n    }\n}\n\n/// A type that can be interprested as a processing element chain.\npub trait IntoProcessingElements: 'static {\n    /// Convertes into processing elements\n    fn to_processing_elements(self) -\u003e Vec\u003cProcessorElement\u003e;\n}\n\nimpl\u003cP: ProcessingElement + 'static\u003e IntoProcessingElements for P {\n    fn to_processing_elements(self) -\u003e Vec\u003cProcessorElement\u003e {\n        let mut stack = self.stack().to_processing_elements();\n        stack.push(ProcessorElement::new(self));\n        stack\n    }\n}\n\nimpl\u003cT: Module\u003e ProcessingElement for T {\n    fn stack(\u0026self) -\u003e impl IntoProcessingElements {\n        \u003cSelf as Module\u003e::stack(self)\n    }\n\n    fn incoming(\u0026mut self, msg: Message) -\u003e Option\u003cMessage\u003e {\n        self.handle_message(msg);\n        None\n    }\n}\n\n/// A base module that is used to load the default processing elements\n/// onto a module.\n///\n/// It's common for simulations to share a set of basic processing elements\n/// accross all nodes. The baseLoader is a maker type, that attaches all default\n/// plugins to a node, that relies on `BaseLoader` in its processing stack.\n///\n/// Use [`set_default_processing_elements`] to set the default processing\n/// elements.\n#[derive(Debug)]\npub struct BaseLoader;\n\npub(crate) static SETUP_PROCESSING: RwLock\u003cfn() -\u003e Vec\u003cProcessorElement\u003e\u003e =\n    RwLock::new(_default_processing);\n\nfn _default_processing() -\u003e Vec\u003cProcessorElement\u003e {\n    Vec::new()\n}\n\nimpl IntoProcessingElements for BaseLoader {\n    fn to_processing_elements(self) -\u003e Vec\u003cProcessorElement\u003e {\n        SETUP_PROCESSING.try_read().expect(\"Cannot access fn\")()\n    }\n}\n\n/// Sets a handler to create the default processing element of a module\n///\n/// # Panics\n///\n/// May panic at interal misconfiguration\npub fn set_default_processing_elements(f: fn() -\u003e Vec\u003cProcessorElement\u003e) {\n    *SETUP_PROCESSING.try_write().expect(\"no lock\") = f;\n}\n\n/// A untyped set of processing elements, effectivly a processing stack.\n#[doc(hidden)]\n#[allow(missing_debug_implementations)]\npub struct ProcessingElements {\n    // last element is module\n    state: ProcessingState,\n    stack: Vec\u003cProcessorElement\u003e,\n    pub(super) handler: Box\u003cdyn Module\u003e,\n}\n\n/// A untyped processing element, using dynamic dispatch.\n#[allow(missing_debug_implementations)]\npub struct ProcessorElement {\n    inner: Box\u003cdyn ProcessingElement\u003e,\n}\n\nimpl ProcessorElement {\n    /// Creates a new type-erased wrapper around a concrete processing element.\n    pub fn new\u003cT: ProcessingElement\u003e(inner: T) -\u003e Self {\n        Self {\n            inner: Box::new(inner),\n        }\n    }\n}\n\nenum ProcessingState {\n    Upstream(usize), // next processing index\n    Peek,\n    Downstream(usize), // last processing index\n}\n\nimpl ProcessingState {\n    fn bump_upstream(\u0026mut self) {\n        match self {\n            ProcessingState::Upstream(ref mut idx) =\u003e *idx += 1,\n            _ =\u003e unreachable!(),\n        }\n    }\n\n    fn bump_downstream(\u0026mut self) {\n        match self {\n            ProcessingState::Downstream(ref mut idx) =\u003e *idx -= 1,\n            _ =\u003e unreachable!(),\n        }\n    }\n}\n\nimpl ProcessingElements {\n    pub(super) fn new(stack: Vec\u003cProcessorElement\u003e, handler: impl Module) -\u003e Self {\n        ProcessingElements {\n            state: ProcessingState::Upstream(0),\n            stack,\n            handler: Box::new(handler),\n        }\n    }\n\n    pub(super) fn incoming_upstream(\u0026mut self, msg: Option\u003cMessage\u003e) -\u003e Option\u003cMessage\u003e {\n        self.state = ProcessingState::Upstream(0);\n\n        let mut msg = msg;\n        for i in 0..self.stack.len() {\n            self.stack[i].inner.event_start();\n            if let Some(existing_msg) = msg {\n                msg = self.stack[i].inner.incoming(existing_msg);\n            }\n            self.state.bump_upstream();\n        }\n        msg\n    }\n\n    pub(super) fn incoming_downstream(\u0026mut self) {\n        self.state = ProcessingState::Downstream(self.stack.len());\n        for i in (0..self.stack.len()).rev() {\n            self.stack[i].inner.event_end();\n            self.state.bump_downstream();\n        }\n    }\n\n    pub(super) fn incoming(\u0026mut self, msg: Option\u003cMessage\u003e) {\n        // Upstream\n        let msg = self.incoming_upstream(msg);\n\n        // Peek\n        self.state = ProcessingState::Peek;\n        if let Some(msg) = msg {\n            self.handler.handle_message(msg);\n        } else {\n            #[cfg(feature = \"async\")]\n            if self.handler.__indicate_async() {\n                self.run_without_event();\n            }\n        }\n\n        // Downstream\n        self.incoming_downstream();\n    }\n\n    #[cfg(feature = \"async\")]\n    #[allow(clippy::unused_self)]\n    pub(super) fn run_without_event(\u0026self) {\n        use crate::net::module::async_get_rt;\n        use tokio::task::yield_now;\n        let Some(rt) = async_get_rt() else { return };\n        rt.1.block_on(\u0026rt.0, yield_now());\n    }\n}\n\nimpl IntoProcessingElements for () {\n    fn to_processing_elements(self) -\u003e Vec\u003cProcessorElement\u003e {\n        Vec::new()\n    }\n}\n\nmacro_rules! for_tuples {\n    (\n        $($i:ident),*\n    ) =\u003e {\n        impl\u003c$($i: ProcessingElement + 'static),*\u003e IntoProcessingElements for ($($i),*) {\n            #[allow(non_snake_case)]\n            fn to_processing_elements(self) -\u003e Vec\u003cProcessorElement\u003e {\n                let mut stack = self.0.stack().to_processing_elements();\n                let ($($i),*) = self;\n                $(\n                    stack.push(ProcessorElement::new($i));\n                )*\n                stack\n            }\n        }\n    };\n}\n\nfor_tuples!(A, B);\nfor_tuples!(A, B, C);\nfor_tuples!(A, B, C, D);\nfor_tuples!(A, B, C, D, E);\nfor_tuples!(A, B, C, D, E, F);\nfor_tuples!(A, B, C, D, E, F, G);\nfor_tuples!(A, B, C, D, E, F, G, H);\nfor_tuples!(A, B, C, D, E, F, G, H, I);\nfor_tuples!(A, B, C, D, E, F, G, H, I, J);\n","traces":[{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":131},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":131},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":451},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":451},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":457},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":457},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":470},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":470},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":470},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":4305},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":4305},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":4305},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":4742},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":859},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":4305},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":4301},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":4301},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":5175},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":3351},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":3351},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":3351},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":6700},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":3351},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":448},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":448},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":62,"coverable":63},{"path":["/","Users","mk","Developer","rust","des","des","src","net","runtime","api.rs"],"content":"use super::Globals;\nuse std::sync::Arc;\n\n/// Returns the globals of the runtime.\n///\n/// \u003e *This function should only be called within the simulation*\n///\n/// # Panics\n///\n/// This function panics if the no runtime is currently active.\n/// Note that a runtime is active if a instance of [`Sim`](super::Sim) exists.\n///\n#[must_use]\npub fn globals() -\u003e Arc\u003cGlobals\u003e {\n    Globals::current()\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":72},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","Users","mk","Developer","rust","des","des","src","net","runtime","blocks.rs"],"content":"use std::{error::Error, fmt::Formatter, pin::Pin, time::Duration};\n\nuse crate::{\n    net::{message::Message, module::Module},\n    prelude::{current, shutdow_and_restart_in},\n};\n\nuse super::ScopedSim;\n\n/// A trait that descibes that an object can be build into a block of modules\n/// at a given scope within the simulation.\n///\n/// Types that implement `ModuleBlock` should be treated as builders for the actual\n/// block of modules. They can contain abitrary information that may be relevent to the\n/// build process of the actual modules within the block.\n///\n/// A module block can consist of either:\n/// - no module at all\n/// - on module specifically at the position defined by the scope\n/// - on module at the scope position, an more as direct or indirect children of the first module.\n///\n/// See [`ScopedSim`] for more information.\npub trait ModuleBlock {\n    /// Build the described module block within the context of scoped part of\n    /// a simulation.\n    fn build\u003cA\u003e(self, sim: ScopedSim\u003c'_, A\u003e);\n}\n\nimpl\u003cM: Module\u003e ModuleBlock for M {\n    fn build\u003cA\u003e(self, sim: ScopedSim\u003c'_, A\u003e) {\n        sim.base.raw(sim.scope, self);\n    }\n}\n\n/// The policy that descibes how a module should proceeed, if a\n/// handler function returns an error.\n#[derive(Debug, Clone, Copy)]\npub enum FailabilityPolicy {\n    /// This option causes the module to panic with the error.\n    ///\n    /// Only use this option if errors indicate that something went so wrong,\n    /// the entire simulation should fail.\n    Panic,\n    /// This option causes the module to just continue as is. The error will be logged.\n    ///\n    /// Only use this option if you can ensure that the error has not caused an invalid\n    /// state, should the node be statefull.\n    Continue,\n    /// This option triggers a node restart as a result of an error.\n    ///\n    /// If set on a node without restart semantics this is equivalent to `Continue`\n    Restart,\n}\n\n/// A wrapper for treating a handler functions as a module.\n///\n/// This wrapper takes an `FnMut(Message) -\u003e ?` as input at uses this function\n/// as message handler, called by [`Module::handle_message`]. Use this wrapper\n/// if a node software is stateless, an can be simply described by a handler function\n/// alone.\n///\n/// Since this wrapper is stateless, restarting it will have no effect on the\n/// internals.\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// # use des::net::HandlerFn;\n/// let mut sim = Sim::new(());\n/// sim.node(\"alice\", HandlerFn::new(|msg| {\n///     /* Do something stateless (e.g. random routing) */\n/// }));\n///\n/// let _ = Builder::new().build(sim).run();\n/// ```\n#[derive(Debug)]\npub struct HandlerFn\u003cHandler\u003e {\n    inner: Handler,\n}\n\nimpl\u003cHandler\u003e HandlerFn\u003cHandler\u003e\nwhere\n    Handler: FnMut(Message),\n{\n    /// Creates a new wrapper for a function returning the unit type.\n    pub fn new(handler: Handler) -\u003e Self {\n        Self { inner: handler }\n    }\n}\n\nimpl\u003cHandler, Err\u003e HandlerFn\u003cHandler\u003e\nwhere\n    Handler: FnMut(Message) -\u003e Result\u003c(), Err\u003e,\n    Err: Error,\n{\n    /// Creates a new wrapper for a function returning some `Result`.\n    ///\n    /// The parameter `policy` defines how an error will be processed, should\n    /// one occur during the execution of the handler.\n    #[allow(clippy::missing_panics_doc)]\n    pub fn failable(\n        mut handler: Handler,\n        policy: FailabilityPolicy,\n    ) -\u003e HandlerFn\u003cimpl FnMut(Message)\u003e {\n        HandlerFn {\n            inner: move |msg| match handler(msg) {\n                Ok(()) =\u003e {}\n                Err(e) =\u003e match policy {\n                    FailabilityPolicy::Panic =\u003e panic!(\n                        \"node '{}' failed to process message, handler fn failed with: {e} \",\n                        current().path\n                    ),\n                    FailabilityPolicy::Continue | FailabilityPolicy::Restart =\u003e {\n                        tracing::error!(\"failed to process message, handler fn failed with: {e}\");\n                    }\n                },\n            },\n        }\n    }\n}\n\nimpl\u003cHandler\u003e Module for HandlerFn\u003cHandler\u003e\nwhere\n    Handler: FnMut(Message) + 'static,\n{\n    fn handle_message(\u0026mut self, msg: Message) {\n        (self.inner)(msg);\n    }\n}\n\n/// A wrapper for creating handler functions with state, treatable as a module.\n///\n/// This wrapper takes two functions, one to create some state `FnMut() -\u003e State` and\n/// a handler function that accepts the state as an additional parameter `FnMut(\u0026mut State, Message)`\n/// to create a module. The generator function will be executed once the simulation has been started,\n/// within module-scope. When a module is shut down, the generator function can be used to reinitalize the\n/// state. Note that `gen` can be used for other things than just initalizing the state.\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// # use des::net::ModuleFn;\n/// struct State {\n///     /* ...data */\n/// }\n///\n/// let mut sim = Sim::new(());\n/// sim.node(\"alice\", ModuleFn::new(\n///     || {\n///         /* Treat this as at_sim_start() */\n///         State { /* ...data */ }\n///     },\n///     |state, msg| {\n///         /* Do some message processing here */\n///     }\n/// ));\n///\n/// let _ = Builder::new().build(sim).run();\n/// ```\n#[derive(Debug)]\npub struct ModuleFn\u003cGen, State, Handler\u003e {\n    gen: Gen,\n    current: Option\u003cState\u003e,\n    handler: Handler,\n}\n\nimpl\u003cGen, State, Handler\u003e ModuleFn\u003cGen, State, Handler\u003e\nwhere\n    Gen: FnMut() -\u003e State,\n    Handler: FnMut(\u0026mut State, Message),\n{\n    /// Creates a wrapper over a function that returns the unit type.\n    pub fn new(gen: Gen, handler: Handler) -\u003e Self {\n        Self {\n            handler,\n            current: None,\n            gen,\n        }\n    }\n}\n\nimpl\u003cGen, State, Handler, Err\u003e ModuleFn\u003cGen, State, Handler\u003e\nwhere\n    Gen: FnMut() -\u003e State,\n    Handler: FnMut(\u0026mut State, Message) -\u003e Result\u003c(), Err\u003e + 'static,\n    Err: Error,\n{\n    /// Creates a new wrapper for a function returning some `Result`.\n    ///\n    /// The parameter `policy` defines how an error will be processed, should\n    /// one occur during the execution of the handler.\n    #[allow(clippy::missing_panics_doc)]\n    #[allow(clippy::complexity)]\n    pub fn failable(\n        gen: Gen,\n        mut handler: Handler,\n        policy: FailabilityPolicy,\n    ) -\u003e ModuleFn\u003cGen, State, Box\u003cdyn FnMut(\u0026mut State, Message)\u003e\u003e {\n        ModuleFn {\n            current: None,\n            gen,\n            handler: Box::new(move |state, msg| match handler(state, msg) {\n                Ok(()) =\u003e {}\n                Err(e) =\u003e match policy {\n                    FailabilityPolicy::Panic =\u003e panic!(\n                        \"node '{}' failed to process message, handler fn failed with: {e} \",\n                        current().path\n                    ),\n                    FailabilityPolicy::Continue =\u003e {\n                        tracing::error!(\"failed to process message, handler fn failed with: {e}\");\n                    }\n                    FailabilityPolicy::Restart =\u003e {\n                        tracing::error!(\"failed to process message, handler fn failed with: {e}\");\n                        shutdow_and_restart_in(Duration::ZERO);\n                    }\n                },\n            }),\n        }\n    }\n}\n\nimpl\u003cGen, State, Handler\u003e Module for ModuleFn\u003cGen, State, Handler\u003e\nwhere\n    Gen: FnMut() -\u003e State + 'static,\n    State: 'static,\n    Handler: FnMut(\u0026mut State, Message) + 'static,\n{\n    fn reset(\u0026mut self) {\n        self.current = None;\n    }\n\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        self.current = Some((self.gen)());\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        let Some(state) = \u0026mut self.current else {\n            unreachable!(\"handle_message cannot be called before at_sim_start\")\n        };\n        (self.handler)(state, msg);\n    }\n}\n\ncfg_async! {\n    use tokio::{\n        sync::mpsc::{self, Receiver, Sender},\n        task::JoinHandle,\n    };\n    use std::future::Future;\n    use crate::net::module::AsyncModule;\n\n\n    /// A helper that enables user to treat a module as a async stream of messages,\n    /// with state attached.\n    ///\n    /// This helper enables user to use `async FnMut(Receiver\u003cMessage\u003e)` as a\n    /// module. The provided function is called at the start of the simulation, within\n    /// module context. The provided receiver will stream incoming message to the\n    /// async clousure. Any user code should saturate the mpsc channel asap, since\n    /// it is bounded. Message buffering should be implemented manually.\n    ///\n    /// On module restarts, the generator function will be called again with a new\n    /// receiver.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::net::AsyncFn;\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", AsyncFn::new(|mut rx| {\n    ///     /* Do some setup / sim_start_stuff here */\n    ///     async move {\n    ///         while let Some(msg) = rx.recv().await {\n    ///             /* Message processing */\n    ///         }\n    ///     }\n    /// }));\n    /// /* ... */\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    pub struct AsyncFn\n    {\n        gen: BoxedGen,\n\n        join: Option\u003cJoinHandle\u003c()\u003e\u003e,\n        tx: Sender\u003cMessage\u003e,\n        rx: Option\u003cReceiver\u003cMessage\u003e\u003e,\n\n        require_join: bool,\n    }\n\n    type BoxedGen = Box\u003cdyn FnMut(Receiver\u003cMessage\u003e) -\u003e BoxedFuture + Send\u003e;\n    type BoxedFuture = Pin\u003cBox\u003cdyn Future\u003cOutput = ()\u003e + Send\u003e\u003e;\n\n    impl AsyncFn {\n        /// Sets the handler to require a join\n        #[must_use]\n        pub fn require_join(mut self) -\u003e Self {\n            self.require_join = true;\n            self\n        }\n\n        /// Creates a new instance using the generator function.\n        pub fn new\u003cGen, Fut\u003e(mut gen: Gen) -\u003e Self\n        where\n            Gen: FnMut(Receiver\u003cMessage\u003e) -\u003e Fut,\n            Gen: Send + 'static,\n            Fut: Future\u003cOutput = ()\u003e,\n            Fut: Send + 'static,\n        {\n            let (tx, rx) = mpsc::channel(8);\n            Self { gen: Box::new(move |rx| Box::pin(gen(rx))), join: None, tx, rx: Some(rx), require_join: false }\n        }\n\n        /// Creates a new instance using the generator function.\n        #[allow(clippy::missing_panics_doc)]\n        pub fn failable\u003cFailable, Fut, Err\u003e(mut gen: Failable) -\u003e Self\n        where\n            Failable: FnMut(Receiver\u003cMessage\u003e) -\u003e Fut,\n            Failable: Send + 'static,\n            Fut: Future\u003cOutput = Result\u003c(), Err\u003e\u003e,\n            Fut: Send + 'static,\n            Err: Error\n        {\n            let (tx, rx) = mpsc::channel(8);\n            Self {\n                gen: Box::new(move |rx| {\n                    let fut = gen(rx);\n                    Box::pin(async move {\n                        match fut.await {\n                            Ok(()) =\u003e {},\n                            Err(e) =\u003e {\n                                panic!(\"node {} paniced at failable operation: {e}\", current().path());\n                            },\n                        }\n                    })\n                }),\n                join: None,\n                tx,\n                rx: Some(rx),\n                require_join: false\n            }\n        }\n\n        /// Makes an io::error exepctor\n        pub fn io\u003cGen, Fut\u003e(gen: Gen) -\u003e Self\n        where\n            Gen: FnMut(Receiver\u003cMessage\u003e) -\u003e Fut,\n            Gen: Send + 'static,\n            Fut: Future\u003cOutput = std::io::Result\u003c()\u003e\u003e,\n            Fut: Send + 'static,\n        {\n            Self::failable(gen)\n        }\n    }\n\n    impl AsyncModule for AsyncFn {\n        fn reset(\u0026mut self) {\n            if let Some(ref join) = self.join { join.abort() }\n        }\n\n        async fn at_sim_start(\u0026mut self, _: usize) {\n            let rx = self.rx.take().unwrap_or_else(|| {\n                let (tx, rx) = mpsc::channel(8);\n                self.tx = tx;\n                rx\n            });\n\n            let fut = (self.gen)(rx);\n            self.join = Some(tokio::task::spawn(fut));\n        }\n\n        async fn handle_message(\u0026mut self, msg: Message) {\n            self.tx.try_send(msg).expect(\"async module blocked\");\n        }\n\n        async fn at_sim_end(\u0026mut self) {\n            if let Some(join) = self.join.take() {\n                if join.is_finished() || self.require_join {\n                    match join.await {\n                        Ok(_) =\u003e {},\n                        Err(e) if e.is_cancelled() =\u003e {}\n                        Err(e) =\u003e panic!(\"{e}\"),\n                    }\n                }\n            }\n        }\n    }\n\n    impl std::fmt::Debug for AsyncFn {\n        fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e std::fmt::Result {\n            write!(f, \"AsyncFn\")\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":74,"coverable":76},{"path":["/","Users","mk","Developer","rust","des","des","src","net","runtime","ctx.rs"],"content":"#![allow(missing_docs)]\n\nuse super::{Globals, HandleMessageEvent, MessageExitingConnection, Sim};\nuse crate::net::gate::Connection;\nuse crate::net::module::{current, with_mod_ctx, MOD_CTX, SETUP_FN};\nuse crate::net::ModuleRestartEvent;\nuse crate::net::{gate::GateRef, message::Message, NetEvents};\nuse crate::prelude::{EventLifecycle, ModuleRef};\nuse crate::runtime::Runtime;\nuse crate::sync::Mutex;\nuse crate::time::SimTime;\nuse std::sync::{Arc, Weak};\n\nstatic BUF_CTX: Mutex\u003cBufferContext\u003e = Mutex::new(BufferContext::new());\n\ntype LoopbackBuffer = Vec\u003c(Message, SimTime)\u003e;\n\nstruct BufferContext {\n    // All new events that will be scheduled\n    events: Vec\u003c(NetEvents, SimTime)\u003e,\n\n    // (Message, SendTime)\n    loopback: LoopbackBuffer,\n    // shudown,\n    #[allow(clippy::option_option)]\n    shutdown: Option\u003cOption\u003cSimTime\u003e\u003e,\n    // globals\n    globals: Option\u003cWeak\u003cGlobals\u003e\u003e,\n}\n\nimpl BufferContext {\n    const fn new() -\u003e Self {\n        Self {\n            events: Vec::new(),\n            loopback: Vec::new(),\n            shutdown: None,\n            globals: None,\n        }\n    }\n}\n\nunsafe impl Send for BufferContext {}\nunsafe impl Sync for BufferContext {}\n\nimpl Globals {\n    pub(crate) fn current() -\u003e Arc\u003cSelf\u003e {\n        let ctx = BUF_CTX.lock();\n        ctx.globals\n            .as_ref()\n            .expect(\"no globals attached to this event\")\n            .upgrade()\n            .expect(\"globals allready dropped: simulation shutting down\")\n    }\n}\n\npub(crate) fn buf_init(globals: Weak\u003cGlobals\u003e) {\n    let mut ctx = BUF_CTX.lock();\n    ctx.globals = Some(globals);\n\n    // TODO: remove ?\n    // SAFTEY:\n    // reseting the MOD_CTX is safe, since simulation lock is aquired.\n    unsafe {\n        MOD_CTX.reset(None);\n    }\n}\n\npub(crate) fn buf_drop() {\n    let mut ctx = BUF_CTX.lock();\n    *ctx = BufferContext::new();\n}\n\npub(crate) fn buf_send_at(mut msg: Message, gate: GateRef, send_time: SimTime) {\n    let mut ctx = BUF_CTX.lock();\n    msg.header.sender_module_id = current().id();\n\n    crate::tracing::enter_scope(gate.owner().scope_token());\n\n    // (0) If delayed send is active, dont skip gate_refs\n    if send_time \u003e SimTime::now() {\n        ctx.events.push((\n            NetEvents::MessageExitingConnection(MessageExitingConnection {\n                con: Connection::new(gate),\n                msg,\n            }),\n            send_time,\n        ));\n        return;\n    }\n\n    // (0) Else handle the event inlined, for instant effects on the associated\n    // channels.\n    let event = MessageExitingConnection {\n        con: Connection::new(gate),\n        msg,\n    };\n    event.handle_with_sink(\u0026mut ctx.events);\n\n    crate::tracing::enter_scope(with_mod_ctx(|ctx| ctx.scope_token));\n}\n\npub(crate) fn buf_schedule_at(msg: Message, arrival_time: SimTime) {\n    // continue to delay the delivery of event, since non other components are\n    // used, and we dont block any channels. additionally this ensures that\n    // timeouts are allways ordered later than packets, which is good\n    let mut ctx = BUF_CTX.lock();\n    ctx.loopback.push((msg, arrival_time));\n}\n\npub(crate) fn buf_schedule_shutdown(restart: Option\u003cSimTime\u003e) {\n    assert!(\n        restart.map_or(true, |r| r \u003e= SimTime::now()),\n        \"Restart point cannot be in the past\"\n    );\n\n    let mut ctx = BUF_CTX.lock();\n    ctx.shutdown = Some(restart);\n}\n\npub(crate) fn buf_process\u003cA\u003e(module: \u0026ModuleRef, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e)\nwhere\n    A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n{\n    let mut ctx = BUF_CTX.lock();\n\n    // (0) Add delayed events from 'send'\n    for (event, time) in ctx.events.drain(..) {\n        rt.add_event(event, time);\n    }\n\n    // (1) Send loopback events from 'scheduleAt'\n    for (message, time) in ctx.loopback.drain(..) {\n        rt.add_event(\n            NetEvents::HandleMessageEvent(HandleMessageEvent {\n                module: module.clone(),\n                message,\n            }),\n            time,\n        );\n    }\n\n    // (2) Handle shutdown if indicated\n    if let Some(restart) = ctx.shutdown.take() {\n        // Mark the modules state\n        #[cfg(feature = \"tracing\")]\n        tracing::debug!(\"Shuttind down module and restaring at {:?}\", restart);\n        module\n            .ctx\n            .active\n            .store(false, std::sync::atomic::Ordering::SeqCst);\n\n        // drop the rt, to prevent all async activity from happening.\n        #[cfg(feature = \"async\")]\n        module.ctx.async_ext.write().rt.shutdown();\n\n        // drop all hooks to ensure all messages reach the async impl\n        // module.ctx.hooks.borrow_mut().clear(); TODO: Plugin clean\n        SETUP_FN.read()(\u0026module.ctx);\n\n        // Reset the internal state\n        // Note that the module is not active, so it must be manually reactivated\n        module.activate();\n        module.reset();\n        module.deactivate(rt);\n\n        // Reschedule wakeup\n        if let Some(restart) = restart {\n            rt.add_event(\n                NetEvents::ModuleRestartEvent(ModuleRestartEvent {\n                    module: module.clone(),\n                }),\n                restart,\n            );\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2085},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2076},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":4152},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":4031},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":4031},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":12267},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":4118},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":6499},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1234},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":4048},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":11},"fn_name":null}],"covered":51,"coverable":62},{"path":["/","Users","mk","Developer","rust","des","des","src","net","runtime","events.rs"],"content":"use std::sync::atomic::Ordering::SeqCst;\n\nuse crate::{\n    net::{\n        channel::ChannelRef, gate::Connection, message::Message, module::ModuleRef,\n        runtime::buf_process, Sim,\n    },\n    runtime::{EventLifecycle, EventSet, EventSink, Runtime},\n    time::SimTime,\n    tracing::enter_scope,\n};\n\n///\n/// The event set for a [`NetworkApplication`].\n///\n/// * This type is only available of DES is build with the `\"net\"` feature.\n#[cfg_attr(doc_cfg, doc(cfg(feature = \"net\")))]\n#[derive(Debug)]\npub enum NetEvents {\n    MessageExitingConnection(MessageExitingConnection),\n    HandleMessageEvent(HandleMessageEvent),\n    ChannelUnbusyNotif(ChannelUnbusyNotif),\n    ModuleRestartEvent(ModuleRestartEvent),\n    #[cfg(feature = \"async\")]\n    AsyncWakeupEvent(AsyncWakeupEvent),\n}\n\nimpl\u003cA\u003e EventSet\u003cSim\u003cA\u003e\u003e for NetEvents\nwhere\n    A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n{\n    fn handle(self, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e) {\n        match self {\n            Self::MessageExitingConnection(event) =\u003e event.handle(rt),\n            Self::HandleMessageEvent(event) =\u003e event.handle(rt),\n            Self::ChannelUnbusyNotif(event) =\u003e event.handle(rt),\n            Self::ModuleRestartEvent(event) =\u003e event.handle(rt),\n            #[cfg(feature = \"async\")]\n            Self::AsyncWakeupEvent(event) =\u003e event.handle(rt),\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct MessageExitingConnection {\n    pub(crate) con: Connection, // exiting the following connecrtion\n    pub(crate) msg: Message,    // with this message\n}\n\nimpl MessageExitingConnection {\n    // This function executes an event with a sink not a runtime as an parameter.\n    // That allows for the executing of events not handles by the runtime itself\n    // aka. the calling with an abitrary event sink.\n    pub(crate) fn handle_with_sink(self, sink: \u0026mut impl EventSink\u003cNetEvents\u003e) {\n        let mut msg = self.msg;\n        msg.header.last_gate = Some(self.con.endpoint.clone());\n\n        // The connection that was exited.\n        // Current packet position: `cur.endpoint`\n        let mut cur = self.con;\n        while let Some(next) = cur.next_hop() {\n            enter_scope(cur.endpoint.owner().scope_token());\n\n            // Since a next gate exists log the current gate as\n            // transit complete. (do this before drop check to allow for better debugging at drop)\n            msg.header.last_gate = Some(next.endpoint.clone());\n\n            // Drop message is owner is not active, but notfiy since this is an irregularity.\n            if !cur.endpoint.owner().is_active() {\n                #[cfg(feature = \"tracing\")]\n                tracing::warn!(\n                    \"Gate '{}' dropped message [{}] since owner module {} is inactive\",\n                    cur.endpoint.name(),\n                    msg.str(),\n                    cur.endpoint.owner().path()\n                );\n\n                drop(msg);\n                return;\n            }\n\n            // Log the current transition to the internal log stream.\n            #[cfg(feature = \"tracing\")]\n            tracing::info!(\n                \"Gate '{}' forwarding message [{}] to next gate delayed: {}\",\n                cur.endpoint.name(),\n                msg.str(),\n                cur.channel().is_some()\n            );\n\n            if let Some(ch) = next.channel() {\n                ch.send_message(msg, next, sink);\n                return;\n            }\n\n            // No channel means next hop is on the same time slot,\n            // so continue.\n            cur = next;\n        }\n\n        // The loop has ended. This means we are at the end of a gate chain\n        // cur has not been checked for anything\n        enter_scope(cur.endpoint.owner().scope_token());\n\n        #[cfg(feature = \"tracing\")]\n        tracing::info!(\n            \"Gate '{}' forwarding message [{}] to module #{}\",\n            cur.endpoint.name(),\n            msg.str(),\n            cur.endpoint.owner().id()\n        );\n\n        let module = cur.endpoint.owner();\n        sink.add(\n            NetEvents::HandleMessageEvent(HandleMessageEvent {\n                module,\n                message: msg,\n            }),\n            SimTime::now(),\n        );\n    }\n}\n\nimpl MessageExitingConnection {\n    fn handle\u003cA\u003e(self, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e)\n    where\n        A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n    {\n        self.handle_with_sink(rt);\n    }\n}\n\n#[derive(Debug)]\npub struct HandleMessageEvent {\n    pub(crate) module: ModuleRef,\n    pub(crate) message: Message,\n}\n\nimpl HandleMessageEvent {\n    fn handle\u003cA\u003e(self, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e)\n    where\n        A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n    {\n        enter_scope(self.module.scope_token());\n\n        let mut message = self.message;\n        message.header.receiver_module_id = self.module.ctx.id;\n\n        #[cfg(feature = \"tracing\")]\n        tracing::info!(\"Handling message {:?}\", message.str());\n\n        let module = \u0026self.module;\n\n        module.activate();\n        module.handle_message(message);\n        module.deactivate(rt);\n\n        buf_process(module, rt);\n    }\n}\n\n#[derive(Debug)]\npub struct ModuleRestartEvent {\n    pub(crate) module: ModuleRef,\n}\n\nimpl ModuleRestartEvent {\n    fn handle\u003cA\u003e(self, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e)\n    where\n        A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n    {\n        enter_scope(self.module.scope_token());\n\n        #[cfg(feature = \"tracing\")]\n        tracing::info!(\"ModuleRestartEvent\");\n\n        let module = \u0026self.module;\n        module.activate();\n        module.module_restart();\n        module.deactivate(rt);\n\n        buf_process(module, rt);\n    }\n}\n\n#[cfg(feature = \"async\")]\n#[derive(Debug)]\npub struct AsyncWakeupEvent {\n    pub(crate) module: ModuleRef,\n}\n\n#[cfg(feature = \"async\")]\nimpl AsyncWakeupEvent {\n    fn handle\u003cA\u003e(self, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e)\n    where\n        A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n    {\n        enter_scope(self.module.scope_token());\n\n        #[cfg(feature = \"tracing\")]\n        tracing::info!(\"async wakeup\");\n\n        let module = \u0026self.module;\n        module.activate();\n        module.async_wakeup();\n        module.deactivate(rt);\n\n        buf_process(module, rt);\n    }\n}\n\n#[derive(Debug)]\npub struct ChannelUnbusyNotif {\n    pub(crate) channel: ChannelRef,\n}\n\nimpl ChannelUnbusyNotif {\n    fn handle\u003cA\u003e(self, rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e)\n    where\n        A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n    {\n        self.channel.unbusy(rt);\n    }\n}\n\nimpl ModuleRef {\n    pub(crate) fn num_sim_start_stages(\u0026self) -\u003e usize {\n        self.processing.borrow().handler.num_sim_start_stages()\n    }\n\n    pub(crate) fn reset(\u0026self) {\n        let mut brw = self.processing.borrow_mut();\n        brw.handler.reset();\n    }\n\n    #[cfg(feature = \"async\")]\n    pub(crate) fn async_wakeup(\u0026self) {\n        if self.ctx.active.load(SeqCst) {\n            self.processing.borrow_mut().incoming_upstream(None);\n            if self.processing.borrow().handler.__indicate_async() {\n                self.processing.borrow().run_without_event();\n            }\n            self.processing.borrow_mut().incoming_downstream();\n        } else {\n            #[cfg(feature = \"tracing\")]\n            tracing::debug!(\"Ignoring message since module is inactive\");\n        }\n    }\n\n    pub(crate) fn module_restart(\u0026self) {\n        #[cfg(feature = \"tracing\")]\n        tracing::debug!(\"Restarting module\");\n        // restart the module itself.\n        self.ctx.active.store(true, SeqCst);\n\n        // Do sim start procedure\n        let stages = self.num_sim_start_stages();\n        for stage in 0..stages {\n            self.at_sim_start(stage);\n        }\n\n        #[cfg(feature = \"async\")]\n        self.finish_sim_start();\n    }\n\n    pub(crate) fn handle_message(\u0026self, msg: Message) {\n        if self.ctx.active.load(SeqCst) {\n            // (0) Run upstream plugins.\n            self.processing.borrow_mut().incoming(Some(msg));\n        } else {\n            #[cfg(feature = \"tracing\")]\n            tracing::debug!(\"Ignoring message since module is inactive\");\n        }\n    }\n\n    pub(crate) fn at_sim_start(\u0026self, stage: usize) {\n        self.processing.borrow_mut().incoming_upstream(None);\n        self.processing.borrow_mut().handler.at_sim_start(stage);\n        self.processing.borrow_mut().incoming_downstream();\n    }\n\n    #[cfg(feature = \"async\")]\n    pub(crate) fn finish_sim_start(\u0026self) {\n        if self.processing.borrow().handler.__indicate_async() {\n            self.processing.borrow_mut().incoming_upstream(None);\n            self.processing.borrow_mut().handler.finish_sim_start();\n            self.processing.borrow_mut().incoming_downstream();\n        }\n    }\n\n    pub(crate) fn at_sim_end(\u0026self) {\n        self.processing.borrow_mut().incoming_upstream(None);\n        self.processing.borrow_mut().handler.at_sim_end();\n        self.processing.borrow_mut().incoming_downstream();\n    }\n\n    #[cfg(feature = \"async\")]\n    pub(crate) fn finish_sim_end(\u0026self) {\n        if self.processing.borrow().handler.__indicate_async() {\n            self.processing.borrow_mut().incoming_upstream(None);\n            self.processing.borrow_mut().handler.finish_sim_end();\n            self.processing.borrow_mut().incoming_downstream();\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":7799},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":7799},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4209},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4209},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":4209},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4209},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6369},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2078},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":2119},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":2066},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":444},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":444},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":448},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":3353},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":6704},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":3351},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":227},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":227},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":227},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":227},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":357},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":142},"fn_name":null}],"covered":107,"coverable":107},{"path":["/","Users","mk","Developer","rust","des","des","src","net","runtime","mod.rs"],"content":"use super::module::module_ctx_drop;\nuse super::Topology;\nuse super::{module::MOD_CTX, par::ParMap};\nuse crate::{\n    net::module::ModuleContext,\n    prelude::{Application, EventLifecycle, GateRef, Module, ModuleRef, ObjectPath, Runtime},\n    tracing::{enter_scope, leave_scope},\n};\nuse std::sync::{MutexGuard, TryLockError, Weak};\nuse std::{\n    fs, io, ops,\n    path::Path,\n    sync::{Arc, Mutex},\n};\n\nmod api;\npub use self::api::*;\n\nmod events;\npub(crate) use self::events::*;\n\nmod ctx;\npub(crate) use self::ctx::*;\n\nmod blocks;\npub use self::blocks::*;\n\nstatic GUARD: Mutex\u003c()\u003e = Mutex::new(());\n\n/// A networking simulation.\n///\n/// This type acts as both a builder for simulations, as well as the application object\n/// used in the [`Runtime`].\n///\n/// A networking simulation can internally contain an application `A`,\n/// that implements [`EventLifecycle`]. This type can be used attach\n/// custom global behaviour at the simulation launch and shutdown. The\n/// lifetime events will be applied after the simulation has started itself\n/// and before the simulation itself will shut down.\n///\n/// However networking simulations allways use events of type `NetEvents`,\n/// internally. These events do not interact with the inner application `A`.\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// # use des::net::HandlerFn;\n/// struct Inner;\n/// impl EventLifecycle\u003cSim\u003cInner\u003e\u003e for Inner {\n///     fn at_sim_start(rt: \u0026mut Runtime\u003cSim\u003cInner\u003e\u003e) {\n///         println!(\"Hello simulation\");\n///         /* Do something */\n///     }\n/// }\n///\n/// let mut sim = Sim::new(Inner);\n/// sim.node(\"alice\", HandlerFn::new(|msg| {\n///     /* Message processing */\n/// }));\n///\n/// let _ = Builder::new().build(sim).run(); // prints 'Hello simulation'\n/// ```\n#[derive(Debug)]\npub struct Sim\u003cA\u003e {\n    modules: ModuleTree,\n    globals: Arc\u003cGlobals\u003e,\n    /// A inner field of a network simulation that can be used to attach\n    /// custom lifetime handlers to a simulation\n    pub inner: A,\n\n    #[allow(unused)]\n    guard: SimStaticsGuard,\n}\n\n#[derive(Debug)]\nstruct SimStaticsGuard {\n    #[allow(unused)]\n    guard: MutexGuard\u003c'static, ()\u003e,\n}\n\nimpl SimStaticsGuard {\n    fn new(globals: Weak\u003cGlobals\u003e) -\u003e Self {\n        let guard = GUARD.try_lock();\n        let guard = match guard {\n            Ok(guard) =\u003e guard,\n            Err(e) =\u003e match e {\n                TryLockError::WouldBlock =\u003e GUARD.lock().unwrap_or_else(|e| {\n                    eprintln!(\"net-sim lock poisnoed: rebuilding lock\");\n                    e.into_inner()\n                }),\n                TryLockError::Poisoned(poisoned) =\u003e {\n                    eprintln!(\"net-sim lock poisoned: rebuilding lock\");\n                    poisoned.into_inner()\n                }\n            },\n        };\n\n        buf_init(globals);\n        Self { guard }\n    }\n}\n\nimpl Drop for SimStaticsGuard {\n    fn drop(\u0026mut self) {\n        buf_drop();\n        module_ctx_drop();\n    }\n}\n\n/// A helper to manage a scoped part of a networking simulation,\n/// exclusivly used when building the simulation.\n///\n/// This type is helpful in combination with the trait [`ModuleBlock`]\n/// to create reproducable blocks of modules at different\n/// locations within the simulation.\n///\n/// This builder acts comparable to [`Sim`], but with an automatically\n/// applied path prefix, the `scope`.\n///\n/// # Examples\n///\n/// ```\n/// # use des::prelude::*;\n/// # use des::net::{ModuleBlock, ModuleFn, HandlerFn};\n/// struct LAN {}\n/// impl ModuleBlock for LAN {\n///     fn build\u003cA\u003e(self, mut sim: ScopedSim\u003c'_, A\u003e) {\n///         sim.root(HandlerFn::new(|_| {}));\n///         let gates = sim.gates(\"\", \"port\", 5);\n///         for i in 0..5 {\n///             let host = format!(\"host-{i}\");\n///             sim.node(\u0026host, ModuleFn::new(\n///                 /* ... */\n///                 # || 123, |_, _| {}    \n///             ));\n///             let gate = sim.gate(\u0026host, \"port\");\n///             gate.connect(gates[i].clone(), None);\n///         }\n///     }\n/// }\n///\n/// let mut sim = Sim::new(());\n/// sim.node(\"google\", LAN {});\n/// sim.node(\"microsoft\", LAN {});\n/// sim.node(\"aws\", HandlerFn::new(|_| {}));\n/// sim.node(\"aws.us-east\", LAN {});\n///\n/// let _ = Builder::new().build(sim).run();\n/// ```\n#[derive(Debug)]\npub struct ScopedSim\u003c'a, A\u003e {\n    pub(crate) base: \u0026'a mut Sim\u003cA\u003e,\n    pub(crate) scope: ObjectPath,\n}\n\nimpl\u003cA\u003e Sim\u003cA\u003e {\n    #[inline]\n    pub(crate) fn modules(\u0026self) -\u003e \u0026ModuleTree {\n        \u0026self.modules\n    }\n\n    #[inline]\n    pub(crate) fn modules_mut(\u0026mut self) -\u003e \u0026mut ModuleTree {\n        \u0026mut self.modules\n    }\n\n    /// Creates a new network simulation, with an inner application `A`.\n    ///\n    /// This allready binds the simulation globals to this instance.\n    pub fn new(inner: A) -\u003e Self {\n        let globals = Arc::new(Globals::default());\n        let guard = SimStaticsGuard::new(Arc::downgrade(\u0026globals));\n        Self {\n            guard,\n            modules: ModuleTree::default(),\n            globals,\n            inner,\n        }\n    }\n\n    /// Includes raw parameter defintions in the simulation.\n    ///\n    /// If a parsing error is encountered, it will be silently\n    /// ignored. Only successful parses will be applied to the\n    /// module parameters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::net::ModuleFn;\n    /// use std::net::IpAddr;\n    ///\n    /// let mut sim = Sim::new(());\n    /// sim.include_par(\"alice.addr = 198.2.1.45\\nalice.role = host\");\n    /// sim.node(\"alice\", ModuleFn::new(\n    ///     || {\n    ///         let addr = par(\"addr\").unwrap().parse::\u003cIpAddr\u003e().unwrap();\n    ///         let role = par(\"role\").unwrap().to_string();\n    ///     },\n    ///     |_, _| {}\n    /// ));\n    /// /*\n    ///     Note that the order of the previous operations does not matter,\n    ///     since the setup code will only be executed when the simulation\n    ///     is startin, so on `Runtime::run`.\n    /// */\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    pub fn include_par(\u0026mut self, raw: \u0026str) {\n        self.globals.parameters.build(raw);\n    }\n\n    /// Tries to read and include parameters from a file into the simulation.\n    ///\n    /// See [`Sim::include_par`] for more infomation.\n    ///\n    /// # Errors\n    ///\n    /// This function may fail if the reading from a file fails.\n    pub fn include_par_file(\u0026mut self, path: impl AsRef\u003cPath\u003e) -\u003e io::Result\u003c()\u003e {\n        self.include_par(\u0026fs::read_to_string(path)?);\n        Ok(())\n    }\n\n    /// Returns a handle to the simulation globals.\n    pub fn globals(\u0026self) -\u003e Arc\u003cGlobals\u003e {\n        self.globals.clone()\n    }\n\n    /// Creates a new module block within the simulation.\n    ///\n    /// A \"node\" is a block of modules at a given `path`. This may include:\n    /// - no modules at all\n    /// - just one module exactly at the given `path`\n    /// - multiple modules, one at `path`, the others as direct or indirect children of this root module.\n    ///\n    /// The provided parameter `module_block` must be some type that implements the trait `ModuleBlock`.\n    /// This trait can be used to create all components of the required block, within the local scope\n    /// defined by `path`. Modules themself also implement `ModuleBlock` so modules themselfs can be\n    /// build into a block of size 1.\n    ///\n    /// Custom implementations of `ModuleBlock` can not only create modules based\n    /// on config data, but also gates and connections between these modules. Note\n    /// that `ModuleBlock::build` is confined to the scope defined by `path`, since\n    /// it uses a [`ScopedSim`] builder.\n    ///\n    /// See [`ScopedSim`] for more information.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// struct MyModule {\n    ///     state: i32,\n    /// }\n    /// impl Module for MyModule {\n    ///     fn handle_message(\u0026mut self, msg: Message) {\n    ///         /* Do something */\n    ///     }\n    /// }\n    ///\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", MyModule { state: 42 });\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    pub fn node(\u0026mut self, path: impl Into\u003cObjectPath\u003e, module_block: impl ModuleBlock) {\n        let scoped = ScopedSim::new(self, path.into());\n        module_block.build(scoped);\n    }\n\n    /// Retrieves a module by reference from the simulation.\n    pub fn get(\u0026self, path: \u0026ObjectPath) -\u003e Option\u003cModuleRef\u003e {\n        self.modules.get(path)\n    }\n\n    /// Creates a gate on a allready created module.\n    ///\n    /// The module will be defined `path` and the gate will be named `gate`.\n    /// Should such a gate allready exist, the allready existing gate will be\n    /// returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # struct SomeModule;\n    /// # impl Module for SomeModule {}\n    /// let mut sim = Sim::new(());\n    /// sim.node(\"alice\", SomeModule);\n    /// sim.node(\"bob\", SomeModule);\n    ///\n    /// let a = sim.gate(\"alice\", \"in\");\n    /// let b = sim.gate(\"bob\", \"out\");\n    ///\n    /// b.connect(a, None);\n    ///\n    /// let _ = Builder::new().build(sim).run();\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// This function panic if node modules exists at `path`.\n    pub fn gate(\u0026mut self, path: impl Into\u003cObjectPath\u003e, gate: \u0026str) -\u003e GateRef {\n        let path = path.into();\n        let Some(module) = self.get(\u0026path) else {\n            panic!(\"cannot create gate '{path}.{gate}', because node '{path}' does not exist\")\n        };\n        if let Some(gate) = module.gate(gate, 0) {\n            gate\n        } else {\n            module.create_gate(gate)\n        }\n    }\n\n    /// Creates a clust of gate gate on a allready created module.\n    ///\n    /// The module will be defined `path` and the gate cluster will be named `gate`.\n    /// Should such a gate cluster allready exist, the allready existing gate will be\n    /// returned.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if either, not module exists at `path`, or\n    /// some parts of the gate cluster allready exist, but others do not.\n    pub fn gates(\u0026mut self, path: impl Into\u003cObjectPath\u003e, gate: \u0026str, size: usize) -\u003e Vec\u003cGateRef\u003e {\n        let path = path.into();\n        let Some(module) = self.get(\u0026path) else {\n            panic!(\"cannot create gate '{path}.{gate}', because node '{path}' does not exist\")\n        };\n        let mut gates = Vec::new();\n        for k in 0..size {\n            if let Some(gate) = module.gate(gate, k) {\n                gates.push(gate);\n            } else {\n                break;\n            }\n        }\n        if gates.len() == size {\n            gates\n        } else {\n            assert!(\n                gates.is_empty(),\n                \"cannot create gate cluster from partial gate cluster\"\n            );\n            module.create_gate_cluster(gate, size)\n        }\n    }\n\n    fn raw(\u0026mut self, path: ObjectPath, module: impl Module) -\u003e ModuleRef {\n        // Check dup\n        assert!(\n            self.modules.get(\u0026path).is_none(),\n            \"cannot create node '{path}', node allready exists\"\n        );\n\n        // Check node path location\n        let ctx = if let Some(parent) = path.nonzero_parent() {\n            // (a) Check that the parent exists\n            let Some(parent) = self.get(\u0026parent) else {\n                panic!(\"cannot create node '{path}', since parent node '{parent}' is required, but does not exist\");\n            };\n\n            ModuleContext::child_of(path.name(), parent)\n        } else {\n            ModuleContext::standalone(path)\n        };\n        ctx.activate();\n\n        let pe = module.to_processing_chain();\n        ctx.upgrade_dummy(pe);\n\n        // TODO: deactivate module\n        self.modules.add(ctx.clone());\n        ctx\n    }\n}\n\nimpl\u003cA\u003e Drop for Sim\u003cA\u003e {\n    fn drop(\u0026mut self) {\n        // SAFETY: Remove ctxs, since the next use of a `Sim` may occur on\n        // a different thread\n        unsafe {\n            MOD_CTX.reset(None);\n        }\n    }\n}\n\nimpl\u003c'a, A\u003e ScopedSim\u003c'a, A\u003e {\n    pub(crate) fn new(base: \u0026'a mut Sim\u003cA\u003e, scope: ObjectPath) -\u003e Self {\n        Self { base, scope }\n    }\n\n    #[allow(unused)]\n    pub(crate) fn subscope(\u0026mut self, path: impl AsRef\u003cstr\u003e) -\u003e ScopedSim\u003c'_, A\u003e {\n        ScopedSim {\n            base: \u0026mut *self.base,\n            scope: self.scope.appended(path),\n        }\n    }\n\n    /// The current scope from an absoute prespective.\n    #[must_use]\n    pub fn scope(\u0026self) -\u003e \u0026ObjectPath {\n        \u0026self.scope\n    }\n\n    /// The inner application of the simulation `Sim\u003cA\u003e`.\n    #[must_use]\n    pub fn inner(\u0026self) -\u003e \u0026A {\n        \u0026self.base.inner\n    }\n\n    /// Sets the current scope module.\n    ///\n    /// This call is equivalent to `sim.node(scope, \u003cmodule_block\u003e)` on [`Sim`].\n    pub fn root(\u0026mut self, module_block: impl Module) {\n        self.base.raw(self.scope.clone(), module_block);\n    }\n\n    /// Creates a module block within the current scope.\n    ///\n    /// See [`Sim::node`] for more information.\n    pub fn node(\u0026mut self, path: impl Into\u003cObjectPath\u003e, module_block: impl ModuleBlock) {\n        self.base\n            .node(self.scope.appended(path.into().as_str()), module_block);\n    }\n\n    /// Creates a gate on an existing node within the current scope.\n    ///\n    /// See [`Sim::gate`] for more information.\n    pub fn gate(\u0026mut self, path: impl Into\u003cObjectPath\u003e, gate: \u0026str) -\u003e GateRef {\n        self.base.gate(self.scope.appended(path.into()), gate)\n    }\n\n    /// Creates a cluster gate on an existing node within the current scope.\n    ///\n    /// See [`Sim::gates`] for more information.\n    pub fn gates(\u0026mut self, path: impl Into\u003cObjectPath\u003e, gate: \u0026str, size: usize) -\u003e Vec\u003cGateRef\u003e {\n        self.base\n            .gates(self.scope.appended(path.into()), gate, size)\n    }\n}\n\nimpl\u003cA\u003e Application for Sim\u003cA\u003e\nwhere\n    A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n{\n    type EventSet = NetEvents;\n    type Lifecycle = SimLifecycle;\n}\n\n#[doc(hidden)]\n#[derive(Debug)]\npub struct SimLifecycle;\nimpl\u003cA\u003e EventLifecycle\u003cSim\u003cA\u003e\u003e for SimLifecycle\nwhere\n    A: EventLifecycle\u003cSim\u003cA\u003e\u003e,\n{\n    fn at_sim_start(rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e) {\n        rt.app\n            .globals\n            .topology\n            .lock()\n            .expect(\"could not get topology lock\")\n            .build(\u0026rt.app.modules);\n\n        // (2) Run network-node sim_starting stages\n        // - inline this to ensure this is run before any possible events\n\n        // This is a explicit for loop to prevent borrow rt only in the inner block\n        // allowing preemtive dropping of 'module' so that rt can be used in\n        // 'module_handle_jobs'.\n        let max_stage = rt\n            .app\n            .modules\n            .iter()\n            .fold(1, |acc, module| acc.max(module.num_sim_start_stages()));\n\n        // (2.1) Call the stages in order, parallel over all modules\n        for stage in 0..max_stage {\n            // Direct indexing since rt must be borrowed mutably in handle_buffers.\n            for module in rt.app.modules.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e() {\n                // Use cloned handles to appease the brwchk\n                if stage \u003c module.num_sim_start_stages() {\n                    module.activate();\n\n                    #[cfg(feature = \"tracing\")]\n                    tracing::info!(\"Calling at_sim_start({}).\", stage);\n\n                    module.at_sim_start(stage);\n                    module.deactivate(rt);\n\n                    super::buf_process(\u0026module, rt);\n                }\n            }\n        }\n\n        // (2.2) Ensure all sim_start stages have finished, in an async context\n        #[cfg(feature = \"async\")]\n        {\n            for module in rt.app.modules.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e() {\n                module.activate();\n                module.finish_sim_start();\n                module.deactivate(rt);\n\n                super::buf_process(\u0026module, rt);\n            }\n        }\n\n        leave_scope();\n\n        A::at_sim_start(rt);\n    }\n\n    fn at_sim_end(rt: \u0026mut Runtime\u003cSim\u003cA\u003e\u003e) {\n        A::at_sim_end(rt);\n\n        for module in rt.app.modules.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e() {\n            enter_scope(module.scope_token());\n\n            #[cfg(feature = \"tracing\")]\n            tracing::info!(\"Calling 'at_sim_end'\");\n            module.activate();\n            module.at_sim_end();\n            module.deactivate(rt);\n\n            // NOTE: no buf_process since no furthe events will be processed.\n        }\n\n        #[cfg(feature = \"async\")]\n        {\n            // Ensure all sim_start stages have finished\n            for module in rt.app.modules.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e() {\n                // enter_scope(module.scope_token());\n\n                module.activate();\n                module.finish_sim_end();\n                module.deactivate(rt);\n            }\n        }\n\n        leave_scope();\n    }\n}\n\n///\n/// The global parameters about a [`Sim`] that are publicly\n/// exposed.\n///\n#[derive(Debug)]\npub struct Globals {\n    ///\n    /// The current state of the parameter tree, derived from *.par\n    /// files and parameter changes at runtime.\n    ///\n    pub parameters: Arc\u003cParMap\u003e,\n\n    ///\n    /// The topology of the network from a module viewpoint.\n    ///\n    pub topology: Mutex\u003cTopology\u003e,\n}\n\nimpl Default for Globals {\n    fn default() -\u003e Self {\n        Self {\n            parameters: Arc::new(ParMap::default()),\n            topology: Mutex::new(Topology::new()),\n        }\n    }\n}\n\n#[derive(Debug, Default)]\npub(crate) struct ModuleTree {\n    modules: Vec\u003cModuleRef\u003e,\n}\n\nimpl ModuleTree {\n    pub(crate) fn get(\u0026self, path: \u0026ObjectPath) -\u003e Option\u003cModuleRef\u003e {\n        self.modules\n            .iter()\n            .find(|module| module.path == *path)\n            .cloned()\n    }\n\n    pub(crate) fn add(\u0026mut self, module: ModuleRef) {\n        if let Some(parent) = module.path.parent() {\n            if parent.is_root() {\n                // root either non existen or at index 0\n                self.modules.push(module);\n            } else {\n                let parent_depth = parent.len();\n\n                // search for parent insert at last possible position\n                let Some(mut pos) = self.modules.iter().rposition(|m| m.path == parent) else {\n                    panic!(\"cannot create node '{}', since parent node '{parent}' is required, but does not exist\", module.path)\n                };\n                pos += 1;\n\n                // (iter as long as we stay at path lengths \u003e parent)\n                while pos \u003c self.modules.len() \u0026\u0026 self.modules[pos].path.len() \u003e parent_depth {\n                    pos += 1;\n                }\n                self.modules.insert(pos, module);\n            }\n        } else {\n            // No parent\n            self.modules.push(module);\n        }\n    }\n}\n\nimpl ops::Deref for ModuleTree {\n    type Target = [ModuleRef];\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.modules\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn module_tree() {\n        let mut tree = ModuleTree::default();\n        fn module(path: \u0026str) -\u003e ModuleRef {\n            ModuleContext::standalone(path.into())\n        }\n\n        tree.add(module(\"alice\"));\n        tree.add(module(\"alice.alicent\"));\n        tree.add(module(\"alice.john\"));\n        tree.add(module(\"alice.john.previous\"));\n        tree.add(module(\"bob\"));\n        tree.add(module(\"eve\"));\n        tree.add(module(\"eve.trevor\"));\n        tree.add(module(\"eve.trevor.list\"));\n        tree.add(module(\"eve.mark\"));\n\n        assert_eq!(\n            tree.iter().map(|v| v.path.as_str()).collect::\u003cVec\u003c_\u003e\u003e(),\n            [\n                \"alice\",\n                \"alice.alicent\",\n                \"alice.john\",\n                \"alice.john.previous\",\n                \"bob\",\n                \"eve\",\n                \"eve.trevor\",\n                \"eve.trevor.list\",\n                \"eve.mark\"\n            ]\n        );\n    }\n}\n","traces":[{"line":83,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":356},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":159},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":195},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":195},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":195},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":195},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":195},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":195},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":403},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":203},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":555},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":386},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":434},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":600},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":167},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":167},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":597},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":597},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":165},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":320},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":320},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":873},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":464},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":1010},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":1010},"fn_name":null}],"covered":132,"coverable":146},{"path":["/","Users","mk","Developer","rust","des","des","src","net","topology.rs"],"content":"use super::{globals, ObjectPath};\nuse crate::{net::module::ModuleRef, prelude::GateRef};\nuse fxhash::{FxBuildHasher, FxHashMap};\n\n///\n/// A mapping of all connections in a module connection graph.\n///\n#[derive(Debug, Clone)]\npub struct Topology {\n    nodes: Vec\u003cTopoNode\u003e,\n    edges: Vec\u003cVec\u003cTopoEdge\u003e\u003e,\n}\n\n///\n/// A node in the module connection graph, representing a module and its\n/// connection state.\n///\n#[derive(Debug, Clone)]\npub struct TopoNode {\n    /// A reference to the module itself, including its custom state.\n    pub module: ModuleRef,\n    /// The number of connections. (not nessecarily the number of gates)\n    pub degree: usize,\n    /// An indicate whether the module is at all connected to the rest of of the network.\n    pub alive: bool,\n}\n\n///\n/// A connection in the module connection graph.\n///\n#[derive(Debug, Clone)]\n\npub struct TopoEdge {\n    ///\n    pub src: (GateRef, usize), //\n    ///\n    pub dst: (GateRef, usize),\n    ///\n    pub cost: f64,\n}\n\nimpl Topology {\n    /// Creates a new empty instance.\n    #[must_use]\n    pub const fn new() -\u003e Topology {\n        Self {\n            nodes: Vec::new(),\n            edges: Vec::new(),\n        }\n    }\n\n    /// Gets the current topology.\n    ///\n    /// # Panics\n    ///\n    /// Panics when called from outside a module context,\n    /// or when globals dont exist.\n    #[must_use]\n    pub fn current() -\u003e Topology {\n        globals()\n            .topology\n            .lock()\n            .expect(\"could not retrive current topology: simulation paniced and poisoned locks\")\n            .clone()\n    }\n\n    /// All nodes if the current topology.\n    #[must_use]\n    pub fn nodes(\u0026self) -\u003e \u0026[TopoNode] {\n        \u0026self.nodes\n    }\n\n    /// An iterator over all edges in the entries network, annotated with the\n    /// node-id of the starting node.\n    #[must_use]\n    pub fn edges(\u0026self) -\u003e usize {\n        self.edges\n            .iter()\n            .enumerate()\n            .flat_map(|(i, edges)| edges.iter().map(move |e| (i, e)))\n            .count()\n            / 2\n    }\n\n    /// All outgoing edges associated with a single\n    /// module.\n    #[must_use]\n    pub fn edges_for(\u0026self, i: usize) -\u003e \u0026[TopoEdge] {\n        \u0026self.edges[i]\n    }\n\n    /// Adds the given modules and their connections to the connection graph.\n    ///\n    /// Note that this only adds connections withing the new conenction set,\n    /// or from the new set to the old set.\n    /// To add connections from the old set to the new one, recreate\n    /// the topology from the ground up using the `ModuleRef` stored in the\n    /// node information.\n    #[allow(clippy::missing_panics_doc)]\n    pub fn build(\u0026mut self, modules: \u0026[ModuleRef]) {\n        for module in modules {\n            self.nodes.push(TopoNode {\n                module: module.clone(),\n                degree: 0,\n                alive: false,\n            });\n            self.edges.push(Vec::new());\n        }\n\n        for module in modules {\n            let gates = module.ctx.gates();\n            'outer: for gate in gates {\n                let mut cost = 0.0;\n                let mut dst = gate.clone();\n\n                let Some(iter) = gate.path_iter() else {\n                    // its a transit gate\n                    continue;\n                };\n                for con in iter.take(16) {\n                    if con.channel().is_some() {\n                        cost += 1.0;\n                    }\n\n                    let transit_id = con.endpoint.owner().id();\n                    let Some(transit) = self\n                        .nodes\n                        .iter_mut()\n                        .find(|k| k.module.ctx.id() == transit_id)\n                    else {\n                        break 'outer;\n                    };\n                    transit.alive |= true;\n\n                    dst = con.endpoint.clone();\n                }\n\n                let src_id = gate.owner().id();\n                let dst_id = dst.owner().id();\n                let (src_idx, src_node) = self\n                    .nodes\n                    .iter_mut()\n                    .enumerate()\n                    .find(|(_, m)| m.module.ctx.id() == src_id)\n                    .expect(\"failed to generate topology: corrupted module tree\");\n                src_node.degree += 1;\n                src_node.alive |= true;\n\n                let (dst_idx, dst_node) = self\n                    .nodes\n                    .iter_mut()\n                    .enumerate()\n                    .find(|(_, m)| m.module.ctx.id() == dst_id)\n                    .expect(\"failed to generate topology: corrupted module tree\");\n                dst_node.degree += 1;\n                dst_node.alive |= true;\n\n                let edge = TopoEdge {\n                    src: (gate, src_idx),\n                    dst: (dst, dst_idx),\n                    cost,\n                };\n\n                self.edges[src_idx].push(edge);\n            }\n        }\n\n        // Divide bc each connection was counted twice\n        self.nodes.iter_mut().for_each(|node| node.degree /= 2);\n    }\n\n    ///\n    /// Filters out nodes that do not comply with the given predicate.\n    ///\n    /// Note that this may change node-ids so all previouisly\n    /// compiled information that relies on node-ids is to be considered\n    /// invalid.\n    ///\n    pub fn filter_nodes\u003cP\u003e(\u0026mut self, predicate: P)\n    where\n        P: FnMut(\u0026TopoNode) -\u003e bool,\n    {\n        let keeps = self.nodes.iter().map(predicate).collect::\u003cVec\u003c_\u003e\u003e();\n        let n = keeps.len();\n\n        for (i, \u0026keep) in keeps.iter().enumerate() {\n            if keep {\n                // Do nothing this node will be kept so no links must be pruned\n            } else {\n                // Fix degrees\n\n                for edge in self.edges[i].drain(..) {\n                    self.nodes[edge.src.1].degree = self.nodes[edge.src.1].degree.saturating_sub(1);\n                    self.nodes[edge.dst.1].degree = self.nodes[edge.dst.1].degree.saturating_sub(1);\n                }\n\n                for j in 0..n {\n                    if j == i {\n                        continue;\n                    }\n                    self.edges[j].retain(|edge| edge.dst.1 != i);\n                }\n                debug_assert_eq!(self.nodes[i].degree, 0);\n            }\n        }\n\n        // Remove elements\n        let mut ptr = 0;\n        let mut mapping = (0..n).collect::\u003cVec\u003c_\u003e\u003e();\n        for (i, keep) in keeps.into_iter().enumerate() {\n            if keep {\n                mapping[i] = ptr;\n                ptr += 1;\n            } else {\n                self.nodes.remove(ptr);\n                self.edges.remove(ptr);\n                mapping[i] = usize::MAX;\n            }\n        }\n\n        // Update edge ids\n        for edges in \u0026mut self.edges {\n            for edge in edges {\n                edge.src.1 = mapping[edge.src.1];\n                edge.dst.1 = mapping[edge.dst.1];\n            }\n        }\n\n        assert_eq!(self.nodes.len(), self.edges.len())\n    }\n\n    ///\n    /// Filters out edges that do not comply with the given predicate.\n    ///\n    /// Note that this does NOT change node-ids, but may change the\n    /// alive-flag on nodes, as well as in-/outcounts.\n    ///\n    pub fn filter_edges\u003cP\u003e(\u0026mut self, mut predicate: P)\n    where\n        P: FnMut(\u0026TopoEdge) -\u003e bool,\n    {\n        for i in 0..self.edges.len() {\n            let mut j = 0;\n            while j \u003c self.edges[i].len() {\n                let keep = predicate(\u0026self.edges[i][j]);\n                if keep {\n                    j += 1;\n                } else {\n                    self.edges[i].remove(j);\n                    self.nodes[i].degree -= 1;\n                    self.nodes[self.edges[i][j].dst.1].degree -= 1;\n                }\n            }\n        }\n\n        for node in \u0026mut self.nodes {\n            if node.degree == 0 {\n                node.alive = false;\n            }\n        }\n    }\n\n    ///\n    /// Changes the costs of edges according to a given mapping.\n    ///\n    pub fn map_costs\u003cM\u003e(\u0026mut self, mut mapping: M)\n    where\n        M: FnMut(\u0026TopoEdge) -\u003e f64,\n    {\n        for edges in \u0026mut self.edges {\n            for edge in edges {\n                edge.cost = mapping(edge);\n            }\n        }\n    }\n\n    /// Generates a disjktra tree\n    ///\n    /// # Panics\n    ///\n    /// Panics when the specified nodes does not exist.\n    #[allow(clippy::needless_pass_by_value)]\n    #[must_use]\n    pub fn dijkstra(\u0026self, node: ObjectPath) -\u003e FxHashMap\u003cObjectPath, GateRef\u003e {\n        struct QE {\n            node: usize,\n            distance: usize,\n            next_hop: Option\u003cGateRef\u003e,\n        }\n\n        let mut visited = Vec::new();\n        let mut queue = Vec::new();\n        queue.push(QE {\n            node: self\n                .nodes\n                .iter()\n                .position(|n| n.module.path() == node)\n                .expect(\"no such node exists\"),\n            distance: 0,\n            next_hop: None,\n        });\n\n        let mut mapping = FxHashMap::with_hasher(FxBuildHasher::default());\n        while let Some(cur) = queue.pop() {\n            if visited.contains(\u0026cur.node) {\n                continue;\n            }\n\n            // travel along the edges\n            visited.push(cur.node);\n            if let Some(ref nh) = cur.next_hop {\n                mapping.insert(self.nodes[cur.node].module.path(), nh.clone());\n            }\n\n            for edge in self.edges_for(cur.node) {\n                if !visited.contains(\u0026edge.dst.1) {\n                    queue.push(QE {\n                        node: edge.dst.1,\n                        distance: cur.distance + 1,\n                        next_hop: Some(cur.next_hop.clone().unwrap_or(edge.src.0.clone())),\n                    });\n                }\n            }\n\n            // rev\n            queue.sort_by(|l, r| r.distance.cmp(\u0026l.distance));\n        }\n\n        mapping\n    }\n\n    /// Creates a .dot output for visualizing the module graph.\n    #[must_use]\n    pub fn as_dot(\u0026self) -\u003e String {\n        let mut output = String::from(\"digraph D {{\\n\");\n\n        for def in \u0026self.nodes {\n            if def.degree \u003e 0 {\n                output.push_str(\u0026format!(\"    \\\"{}\\\" [shape=box]\\n\", def.module.as_str()));\n            }\n        }\n\n        output.push('\\n');\n\n        for (src, edges) in self.edges.iter().enumerate() {\n            let from_node = self.nodes[src].module.as_str();\n            for TopoEdge { src, dst, cost } in edges {\n                let to_node = self.nodes[src.1].module.as_str();\n                let label = if *cost == 0.0 {\n                    String::new()\n                } else {\n                    format!(\"label=\\\"{cost}\\\"\")\n                };\n\n                output.push_str(\u0026format!(\n                    \"    \\\"{}\\\" - \\\"{}\\\" [ headlabel=\\\"{}\\\" {} taillabel=\\\"{}\\\" ]\\n\",\n                    from_node,\n                    to_node,\n                    dst.0.name(),\n                    label,\n                    src.0.name(),\n                ));\n            }\n        }\n\n        output.push_str(\"\\n}}\");\n        output\n    }\n\n    ///\n    /// Writes the dot output to a *.dot file\n    /// and converts this file into a svg.\n    ///\n    /// # Note\n    ///\n    /// Be aware that this command relies on the 'dot' command line\n    /// programm to generate the svg.\n    ///\n    /// # Errors\n    ///\n    /// This operation will return an IO Error if\n    /// either the file cannot be created or the operations\n    /// using the dot engine wont work.\n    ///\n    pub fn write_to_svg(\u0026self, path: \u0026str) -\u003e std::io::Result\u003c()\u003e {\n        use std::fs::File;\n        use std::io::Write;\n        use std::process::Command;\n        let dot_output = self.as_dot();\n        let mut file = File::create(format!(\"{path}.dot\"))?;\n        write!(file, \"{dot_output}\")?;\n\n        let svg_output = Command::new(\"dot\")\n            .arg(\"-Tsvg\")\n            .arg(format!(\"{path}.dot\"))\n            .output()?;\n\n        let mut file = File::create(format!(\"{path}.svg\"))?;\n        write!(file, \"{}\", String::from_utf8_lossy(\u0026svg_output.stdout))?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":178},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":820},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":603},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":427},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":152},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":337},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":559},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":559},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":555},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":133,"coverable":142},{"path":["/","Users","mk","Developer","rust","des","des","src","prelude.rs"],"content":"//!\n//! Convenience re-export of common members.\n//!\n\n//\n// # Generic core exports\n//\n\npub use crate::runtime::Builder;\npub use crate::runtime::Runtime;\npub use crate::runtime::RuntimeResult;\n\npub use crate::time::Duration;\npub use crate::time::SimTime;\n\npub use crate::runtime::Application;\npub use crate::runtime::Event;\npub use crate::runtime::EventLifecycle;\npub use crate::runtime::EventSet;\n\npub use crate::runtime::random;\npub use crate::runtime::sample;\n\n//\n// # feature = \"net\"\n//\n\ncfg_net! {\n    pub use crate::net::message::CustomSizeBody;\n    pub use crate::net::message::Message;\n    pub use crate::net::message::MessageBody;\n    pub use crate::net::message::MessageId;\n    pub use crate::net::message::MessageKind;\n    pub use crate::net::message::MessageHeader;\n\n    pub use crate::net::message::{send, send_in, send_at, schedule_in, schedule_at};\n\n    pub use crate::net::Sim;\n    pub use crate::net::ScopedSim;\n    pub use crate::net::Globals;\n\n    pub use crate::net::channel::Channel;\n    pub use crate::net::channel::ChannelMetrics;\n    pub use crate::net::channel::ChannelRef;\n    pub use crate::net::channel::ChannelDropBehaviour;\n\n    pub use crate::net::gate::Gate;\n    pub use crate::net::gate::GateRef;\n\n    pub use crate::net::module::Module;\n    pub use crate::net::module::ModuleId;\n    pub use crate::net::module::ModuleRef;\n    pub use crate::net::module::ModuleReferencingError;\n\n    pub use crate::net::module::{\n        current, shutdow_and_restart_at, shutdow_and_restart_in, shutdown\n    };\n    pub use crate::net::{par, par_for};\n\n    pub use crate::net::ObjectPath;\n    pub use crate::net::ParMap;\n\n    pub use crate::net::TopoEdge;\n    pub use crate::net::TopoNode;\n    pub use crate::net::Topology;\n\n    pub use crate::net::processing::ProcessingElement;\n\n    cfg_ndl! {\n        pub use crate::ndl::Registry;\n        pub use crate::ndl::RegistryCreatable;\n    }\n\n    cfg_async! {\n        pub use crate::net::module::AsyncModule;\n    }\n\n    pub use std::net::IpAddr;\n    pub use std::net::Ipv4Addr;\n    pub use std::net::Ipv6Addr;\n    pub use std::net::SocketAddr;\n    pub use std::net::SocketAddrV4;\n    pub use std::net::SocketAddrV6;\n\n    //\n    // Export the derives if net\n    //\n\n    pub use des_macros::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","bench.rs"],"content":"use std::{\n    io::Write,\n    path::PathBuf,\n    sync::Arc,\n    time::{Duration, Instant, SystemTime},\n};\n\nuse sysinfo::{CpuExt, SystemExt};\n\nuse super::{FT_ASYNC, FT_CQUEUE, FT_INTERNAL_METRICS, FT_NET};\n\n/// A run profiler\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Profiler {\n    /// The target executable.\n    pub target: PathBuf,\n    exec: String,\n\n    /// Whether the target is in release mode or not.\n    pub target_is_release: bool,\n    /// The hardware enviroment of the execution.\n    pub env: ProfilerEnv,\n\n    /// The time point where the simulation started.\n    pub simulation_start: SystemTime,\n\n    time_start: Instant,\n    /// The duration of the simulation.\n    pub duration: Duration,\n\n    /// The number of events that where executed.\n    pub event_count: usize,\n    /// The active features.\n    pub features: Vec\u003cString\u003e,\n}\n\nimpl Profiler {\n    /// Returns the ident str for the profiler\n    #[allow(unused)]\n    pub(super) fn ident(\u0026self) -\u003e String {\n        format!(\n            \"{}--{}-{}-{}\",\n            self.exec, self.env.arch, self.env.os_family, self.env.os\n        )\n    }\n\n    /// Starts the profile.\n    pub(super) fn start(\u0026mut self) {\n        self.time_start = Instant::now();\n    }\n\n    /// Finishes the profile.\n    pub(super) fn finish(\u0026mut self, event_count: usize) {\n        self.event_count = event_count;\n        let now = Instant::now();\n        self.duration = now - self.time_start;\n    }\n}\n\n#[cfg(debug_assertions)]\nfn is_release() -\u003e bool {\n    false\n}\n\n#[cfg(not(debug_assertions))]\nfn is_release() -\u003e bool {\n    true\n}\n\nimpl Default for Profiler {\n    fn default() -\u003e Self {\n        let target = std::env::current_exe().unwrap_or_default();\n        let target_is_release = is_release();\n\n        let mut exec = target\n            .file_name()\n            .expect(\"Failed to find binary\")\n            .to_string_lossy()\n            .to_string();\n        if target_is_release {\n            exec.push_str(\"-release\");\n        }\n\n        let mut features = Vec::with_capacity(5);\n        if FT_CQUEUE {\n            features.push(\"cqueue\".into());\n        }\n        if FT_NET {\n            features.push(\"net\".into());\n        }\n        if FT_ASYNC {\n            features.push(\"async\".into());\n        }\n        if FT_INTERNAL_METRICS {\n            features.push(\"metrics\".into());\n        }\n\n        Self {\n            target,\n            exec,\n            target_is_release,\n\n            env: ProfilerEnv::default(),\n\n            simulation_start: SystemTime::now(),\n            time_start: Instant::now(),\n            duration: Duration::ZERO,\n\n            event_count: 0,\n            features,\n        }\n    }\n}\n\n/// A description of the runtime enviroment.\n#[derive(Debug, Clone)]\npub struct ProfilerEnv {\n    /// The target arch.\n    pub arch: String,\n    /// The target os.\n    pub os: String,\n    /// The target os family.\n    pub os_family: String,\n\n    #[allow(unused)]\n    system: Arc\u003csysinfo::System\u003e,\n}\n\nimpl ProfilerEnv {\n    #[allow(unused)]\n    fn write_to(\u0026self, f: \u0026mut impl Write) -\u003e std::io::Result\u003c()\u003e {\n        writeln!(\n            f,\n            \"\\t{} / {}\",\n            self.system\n                .host_name()\n                .unwrap_or_else(|| \"Unknown-System\".into()),\n            self.system\n                .long_os_version()\n                .unwrap_or_else(|| self.os.clone())\n        )?;\n        writeln!(f, \"\\t{}-{}-{}\", self.arch, self.os_family, self.os)?;\n        if let Some(cpu) = self.system.cpus().first() {\n            writeln!(\n                f,\n                \"\\t{} ({} / {}) @ {}MHz\",\n                cpu.name(),\n                cpu.brand(),\n                cpu.vendor_id(),\n                cpu.frequency()\n            )?;\n        }\n        writeln!(\n            f,\n            \"\\tmem: {} total {} swap\",\n            self.system.total_memory(),\n            self.system.total_swap()\n        )?;\n\n        Ok(())\n    }\n}\n\nimpl PartialEq for ProfilerEnv {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.arch == other.arch \u0026\u0026 self.os == other.os \u0026\u0026 self.os_family == other.os_family\n    }\n}\n\nimpl Eq for ProfilerEnv {}\n\nimpl Default for ProfilerEnv {\n    fn default() -\u003e Self {\n        let mut system = sysinfo::System::new();\n        system.refresh_cpu();\n        system.refresh_memory();\n\n        Self {\n            arch: std::env::consts::ARCH.to_string(),\n            os: std::env::consts::OS.to_string(),\n            os_family: std::env::consts::FAMILY.to_string(),\n\n            system: Arc::new(system),\n        }\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":171},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":171},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":171},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":171},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":350},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":350},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":350},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":175},"fn_name":null}],"covered":32,"coverable":61},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","builder.rs"],"content":"use std::{\n    fmt::Debug,\n    sync::{Mutex, TryLockError},\n};\n\n#[cfg(feature = \"cqueue\")]\nuse std::time::Duration;\n\nuse rand::{\n    rngs::{OsRng, StdRng},\n    RngCore, SeedableRng,\n};\n\nuse crate::prelude::SimTime;\n\nuse super::{Application, FutureEventSet, Profiler, Runtime, RuntimeLimit, RNG};\n\n/// A lock the ensures only one runtime exits at a time.\nstatic SIMULATION_LOCK: Mutex\u003c()\u003e = Mutex::new(());\n\n/// A builder for a runtime instance.\n#[must_use]\npub struct Builder {\n    pub(super) quiet: bool,\n    pub(super) rng: Box\u003cdyn RngCore\u003e,\n    pub(super) limit: RuntimeLimit,\n    pub(super) start_time: SimTime,\n\n    #[cfg(feature = \"cqueue\")]\n    pub(super) cqueue_num_buckets: usize,\n    #[cfg(feature = \"cqueue\")]\n    pub(super) cqueue_bucket_timespan: Duration,\n}\n\nimpl Builder {\n    /// Creates a new unconfigured builder.\n    ///\n    /// # Panics\n    ///\n    /// Panics if no RNG can be build.\n    pub fn new() -\u003e Builder {\n        Builder {\n            quiet: false,\n            rng: Box::new(StdRng::from_rng(OsRng).expect(\"Failed to create RNG\")),\n            limit: RuntimeLimit::None,\n\n            start_time: SimTime::MIN,\n\n            #[cfg(feature = \"cqueue\")]\n            cqueue_num_buckets: 1028,\n\n            #[cfg(feature = \"cqueue\")]\n            cqueue_bucket_timespan: Duration::from_secs_f64(0.0025),\n        }\n    }\n\n    /// Creates a `Builder` with a static seeded RNG.\n    pub fn seeded(seed: u64) -\u003e Builder {\n        Builder {\n            quiet: false,\n            rng: Box::new(StdRng::seed_from_u64(seed)),\n            limit: RuntimeLimit::None,\n\n            start_time: SimTime::MIN,\n\n            #[cfg(feature = \"cqueue\")]\n            cqueue_num_buckets: 1028,\n\n            #[cfg(feature = \"cqueue\")]\n            cqueue_bucket_timespan: Duration::from_secs_f64(0.0025),\n        }\n    }\n\n    ///\n    /// Sets the cqueue options if this runtime uses a cqueue.\n    /// NOP otherwise.\n    ///\n    #[cfg(feature = \"cqueue\")]\n    pub fn cqueue_options(mut self, n: usize, t: Duration) -\u003e Self {\n        self.cqueue_num_buckets = n;\n        self.cqueue_bucket_timespan = t;\n\n        self\n    }\n\n    ///\n    /// Suppressed runtime messages from the simulation framework.\n    ///\n    pub fn quiet(mut self) -\u003e Self {\n        self.quiet = true;\n        self\n    }\n\n    ///\n    /// Changes the maximum iteration number of a runtime.\n    ///\n    pub fn start_time(mut self, time: SimTime) -\u003e Self {\n        self.start_time = time;\n        self\n    }\n\n    ///\n    /// Changes the maximum iteration number of a runtime.\n    ///\n    pub fn max_itr(mut self, max_itr: usize) -\u003e Self {\n        self.limit.add(RuntimeLimit::EventCount(max_itr));\n        self\n    }\n\n    ///\n    /// Changes the maximum time of the runtime (default: inf).\n    ///\n    pub fn max_time(mut self, max_time: SimTime) -\u003e Self {\n        self.limit.add(RuntimeLimit::SimTime(max_time));\n        self\n    }\n\n    ///\n    /// Sets a custom limit to the end of the runtime, overwriting\n    /// all `max_itr` and `max_time` options.\n    ///\n    pub fn limit(mut self, limit: RuntimeLimit) -\u003e Self {\n        self.limit.add(limit);\n        self\n    }\n\n    ///\n    /// Builds a new [`Runtime`] instance, using an application as core,\n    /// and accepting events of type [`Event\u003cA\u003e`](crate::runtime::Event).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// // Assumme Application is implemented for App.\n    /// #[derive(Debug)]\n    /// struct App(usize,  String);\n    /// # impl Application for App {\n    /// #   type EventSet = Events;\n    /// #   type Lifecycle = ();\n    /// # }\n    /// # enum Events {}\n    /// # impl EventSet\u003cApp\u003e for Events {\n    /// #   fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {}\n    /// # }\n    ///\n    /// let app = App(42, String::from(\"Hello there!\"));\n    /// let rt = Builder::new().build(app);\n    /// ```\n    pub fn build\u003cA: Application\u003e(self, app: A) -\u003e Runtime\u003cA\u003e {\n        let permit = {\n            let lock = SIMULATION_LOCK.try_lock();\n            match lock {\n                Ok(permit) =\u003e permit,\n                Err(err) =\u003e {\n                    match err {\n                        TryLockError::WouldBlock =\u003e {\n                            eprintln!(\"des::warning ** another runtime allready exists ... waiting for simlock\");\n                            let lock = SIMULATION_LOCK.lock();\n                            match lock {\n                                Ok(lock) =\u003e lock,\n                                Err(p) =\u003e {\n                                    eprintln!(\"des::error ** another runtime poisoned the simlock ... cleaning up\");\n                                    Runtime::\u003cA\u003e::poison_cleanup();\n                                    p.into_inner()\n                                }\n                            }\n                        }\n                        TryLockError::Poisoned(p) =\u003e {\n                            eprintln!(\"des::error ** another runtime poisoned the simlock ... cleaning up\");\n                            Runtime::\u003cA\u003e::poison_cleanup();\n                            p.into_inner()\n                        }\n                    }\n                }\n            }\n        };\n\n        // Log prep\n        // StandardLogger::setup().expect(\"Failed to create logger\");\n        #[cfg(feature = \"cqueue\")]\n        if std::mem::size_of::\u003cA::EventSet\u003e() \u003e 128 {\n            eprintln!(\"des::warning ** creating runtime with event-set bigger that 128 bytes * this may lead to performance losses\");\n        }\n\n        let future_event_set = FutureEventSet::new_with(\u0026self);\n\n        // Set SimTime\n        SimTime::set_now(self.start_time);\n\n        // Set RNG\n        *unsafe { \u0026mut *RNG.get() } = Some(self.rng);\n\n        Runtime {\n            future_event_set,\n\n            event_id: 0,\n            itr: 0,\n            permit,\n\n            limit: self.limit,\n\n            quiet: self.quiet,\n            profiler: Profiler::default(),\n\n            app,\n        }\n    }\n}\n\nimpl Default for Builder {\n    fn default() -\u003e Self {\n        Builder::new()\n    }\n}\n\nimpl Debug for Builder {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"Builder\").finish()\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":170},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":170},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":170},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":38,"coverable":58},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","event","event_set.rs"],"content":"cfg_not_cqueue! {\n    mod default_impl {\n        use crate::{runtime::{Application, EventNode}, time::SimTime};\n        use std::collections::{BinaryHeap, VecDeque};\n        use crate::runtime::Builder;\n\n\n\n        pub(crate) struct FutureEventSet\u003cA\u003e\n        where\n            A: Application,\n        {\n            heap: BinaryHeap\u003cEventNode\u003cA\u003e\u003e,\n            zero_queue: VecDeque\u003cEventNode\u003cA\u003e\u003e,\n\n            last_event_simtime: SimTime,\n        }\n\n        impl\u003cA\u003e FutureEventSet\u003cA\u003e\n        where\n            A: Application,\n        {\n            #[allow(clippy::unused_self)]\n            pub(crate) fn descriptor(\u0026self) -\u003e String {\n                \"FutureEventSet::BinaryHeap()\".to_string()\n            }\n\n            pub(crate) fn len(\u0026self) -\u003e usize {\n                self.len_zero() + self.len_nonzero()\n            }\n\n            pub(crate) fn is_empty(\u0026self) -\u003e bool {\n                self.heap.is_empty() \u0026\u0026 self.zero_queue.is_empty()\n            }\n\n            pub(crate) fn len_zero(\u0026self) -\u003e usize {\n                self.zero_queue.len()\n            }\n\n            pub(crate) fn len_nonzero(\u0026self) -\u003e usize {\n                self.heap.len()\n            }\n\n            pub(crate) fn new_with(options: \u0026Builder) -\u003e Self {\n                Self {\n                    heap: BinaryHeap::with_capacity(64),\n                    zero_queue: VecDeque::with_capacity(32),\n\n                    last_event_simtime: options.start_time,\n                }\n            }\n\n            //\n            // clippy::let_and_return occures on not(feature = \"metrics\")\n            // but would produce invalid code with feature \"metrics\"\n            //\n            #[allow(clippy::let_and_return)]\n            #[allow(clippy::needless_pass_by_value)]\n            #[allow(clippy::cast_precision_loss)]\n            pub(crate) fn fetch_next(\n                \u0026mut self,\n            ) -\u003e (A::EventSet, SimTime) {\n\n                let event = if let Some(event) = self.zero_queue.pop_front() {\n                    self.last_event_simtime = event.time;\n                    event\n                } else {\n                    let event = self.heap.pop().expect(\"unreachable: fetch_next shall only be called with the guarantee that an event exists\");\n                    self.last_event_simtime = event.time;\n                    event\n                };\n\n                (event.event, event.time)\n            }\n\n            #[allow(clippy::needless_pass_by_value)]\n            pub(crate) fn add(\n                \u0026mut self,\n                time: SimTime,\n                event: impl Into\u003cA::EventSet\u003e,\n            ) {\n                assert!(\n                    time \u003e= self.last_event_simtime,\n                    \"Sorry we cannot timetravel yet\"\n                );\n\n                let node = EventNode {\n                    id: 0,\n                    event: event.into(),\n                    time,\n\n                    _phantom: std::marker::PhantomData,\n                };\n\n                if self.last_event_simtime == time {\n                    self.zero_queue.push_back(node);\n                } else {\n                    self.heap.push(node);\n                }\n            }\n        }\n    }\n\n    pub(crate) use default_impl::*;\n}\n\ncfg_cqueue! {\n    mod cqueue_impl {\n        use crate::{runtime::{Application, Builder}, time::SimTime};\n        use des_cqueue::CQueue;\n\n        pub(crate) struct FutureEventSet\u003cA\u003e\n        where\n            A: Application,\n        {\n            inner: CQueue\u003cA::EventSet\u003e,\n        }\n\n        impl\u003cA\u003e FutureEventSet\u003cA\u003e\n        where\n            A: Application,\n        {\n            #[allow(clippy::unused_self)]\n            pub(crate) fn descriptor(\u0026self) -\u003e String {\n                format!(\"FutureEventSet::CQueue::{}\", self.inner.descriptor())\n            }\n\n            pub(crate) fn len(\u0026self) -\u003e usize {\n                self.inner.len()\n            }\n\n            pub(crate) fn is_empty(\u0026self) -\u003e bool {\n                self.inner.is_empty()\n            }\n\n            pub(crate) fn new_with(options: \u0026Builder) -\u003e Self {\n                Self {\n                    inner: CQueue::new(options.cqueue_num_buckets, options.cqueue_bucket_timespan),\n                }\n            }\n\n            #[allow(clippy::needless_pass_by_value)]\n            pub(crate) fn fetch_next(\n                \u0026mut self,\n            ) -\u003e (A::EventSet, SimTime) {\n\n                let (event, time) = self.inner.fetch_next();\n                (event, SimTime::from_duration(time))\n            }\n\n            #[allow(clippy::needless_pass_by_value)]\n            pub(crate) fn add(\n                \u0026mut self,\n                time: SimTime,\n                event: impl Into\u003cA::EventSet\u003e,\n            ) {\n                self.inner.add(*time, event.into());\n            }\n        }\n    }\n\n    pub(crate) use self::cqueue_impl::*;\n\n}\n","traces":[{"line":124,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":236402},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":236402},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":118007},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":118007},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":118007},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":118007},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":118007},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","event","mod.rs"],"content":"use crate::time::SimTime;\n\nmod event_set;\npub(crate) use event_set::*;\n\npub(crate) trait EventSink\u003cE\u003e {\n    fn add(\u0026mut self, event: E, time: SimTime);\n}\n\nimpl\u003cA: Application\u003e EventSink\u003cA::EventSet\u003e for Runtime\u003cA\u003e {\n    fn add(\u0026mut self, event: A::EventSet, time: SimTime) {\n        self.add_event(event, time);\n    }\n}\n\nimpl\u003cE\u003e EventSink\u003cE\u003e for Vec\u003c(E, SimTime)\u003e {\n    fn add(\u0026mut self, event: E, time: SimTime) {\n        self.push((event, time));\n    }\n}\n\nmod types;\npub use types::*;\n\nuse super::Runtime;\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2390},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":2390},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":4109},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":4109},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","event","types.rs"],"content":"use std::cmp;\nuse std::fmt::{Debug, Display};\nuse std::marker::PhantomData;\n\nuse crate::runtime::Runtime;\nuse crate::time::SimTime;\n\n///\n/// A trait that defines an runtime application\n/// that depends on a event set to be processed by the\n/// runtime and a lifecylce managment.\n///\npub trait Application: Sized {\n    ///\n    /// The set of events used in the simulation.\n    ///\n    type EventSet: EventSet\u003cSelf\u003e;\n    ///\n    /// A global type, defining the behavior at sim start / sim end\n    ///\n    type Lifecycle: EventLifecycle\u003cSelf\u003e;\n}\n\n///\n/// A type that can be used as a wrapper around all events\n/// handled by an application A.\n///\n/// Note that ther is a cyclic dependecy between the event set\n/// and the application.\n/// This is due to the fact that Events allways defined those two parameters\n/// to be related (since specific events of the event set require runtime params),\n/// but this type information is willingly elided, to fit into the rust generics system.\n///\npub trait EventSet\u003cA\u003e\nwhere\n    A: Application,\n{\n    ///\n    /// A function to handle an upcoming event represented as a instance\n    /// of the event set.\n    ///\n    /// Since events sets are usually macro-generated this is just a match statement that calls\n    /// the handle function on the given variant, as defined by the trait [Event].\n    ///\n    fn handle(self, runtime: \u0026mut Runtime\u003cA\u003e);\n}\n\n///\n/// A type that can handle an event, specific to the given aplication,\n/// and associated event set.\n///\n/// Note that events in an event set dont need to implement this trait,\n/// unless the event set is derived using the [`event_set`](crate::event_set)\n/// macros. Nonetheless is it advised to use this trait to better isolate different events\n/// and their associated data.\n///\npub trait Event\u003cApp\u003e\nwhere\n    App: Application,\n{\n    ///\n    /// A function to handle an upcoming event represented as a specific\n    /// instance of a event type.\n    ///\n    /// There is an implicit type bound that the Apps event set must contain\n    /// the Self type as a variant. This is usually guaranteed by macro-generting event sets,\n    /// but could lead to unexpected behaviour if not done properly in custom\n    /// event set implementations.\n    ///\n    fn handle(self, runtime: \u0026mut Runtime\u003cApp\u003e);\n}\n\n///\n/// A type that defines the lifecycle behaviour of an application A.\n///\npub trait EventLifecycle\u003cA = Self\u003e {\n    ///\n    /// A function that is called only once at the start of the simulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # struct Worker;\n    /// # impl Worker { fn initalize(\u0026mut self) {}}\n    /// # enum MyEventSet { EventA, EventB }\n    /// # impl EventSet\u003cMyApp\u003e for MyEventSet {\n    /// #   fn handle(self, rt: \u0026mut Runtime\u003cMyApp\u003e) {}\n    /// # }\n    /// struct MyApp { workers: Vec\u003cWorker\u003e };\n    /// impl Application for MyApp {\n    ///     type EventSet = MyEventSet;\n    ///     type Lifecycle = Self;\n    /// }\n    /// impl EventLifecycle for MyApp {\n    ///     fn at_sim_start(runtime: \u0026mut Runtime\u003cSelf\u003e) {\n    ///         runtime.app.workers.iter_mut().for_each(|w| w.initalize());\n    ///     }\n    /// }\n    /// ```\n    ///\n    #[allow(unused_variables)]\n    fn at_sim_start(runtime: \u0026mut Runtime\u003cA\u003e)\n    where\n        A: Application,\n    {\n    }\n\n    ///\n    /// A function that is called once the simulation reachted its limit.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # struct Worker;\n    /// # impl Worker { fn finish(\u0026mut self) {}}\n    /// # enum MyEventSet { EventA, EventB }\n    /// # impl EventSet\u003cMyApp\u003e for MyEventSet {\n    /// #   fn handle(self, rt: \u0026mut Runtime\u003cMyApp\u003e) {}\n    /// # }\n    /// struct MyApp { workers: Vec\u003cWorker\u003e };\n    /// impl Application for MyApp {\n    ///     type EventSet = MyEventSet;\n    ///     type Lifecycle = Self;\n    /// }\n    /// impl EventLifecycle for MyApp {\n    ///     fn at_sim_end(rt: \u0026mut Runtime\u003cSelf\u003e) {\n    ///         rt.app.workers.iter_mut().for_each(|w| w.finish());\n    ///     }\n    /// }\n    /// ```\n    ///\n    #[allow(unused_variables)]\n    fn at_sim_end(runtime: \u0026mut Runtime\u003cA\u003e)\n    where\n        A: Application,\n    {\n    }\n}\n\nimpl\u003cA\u003e EventLifecycle\u003cA\u003e for () {}\n\n///\n/// A runtime unqiue identifier for a event.\n///\npub(crate) type EventId = usize;\n\n///\n/// A bin-heap node of a event from the applicaitons event set.\n///\n/// # Allocation\n///\n/// This node does not contain nested heap allocations by default,\n/// only if the generic event itself requires heap allocations.\n/// Nonetheless this node will be stored on the heap as it is\n/// only used inside a [`std::collections::BinaryHeap`].\n///\npub(crate) struct EventNode\u003cA\u003e\nwhere\n    A: Application,\n{\n    /// The deadline timestamp for the event.\n    pub(crate) time: SimTime,\n    /// A runtime-specific unique identifier.\n    pub(crate) id: EventId,\n    /// The actual event.\n    pub(crate) event: A::EventSet,\n\n    /// A marker to preserve the type information concerning the application\n    /// not only the Event set.\n    pub(crate) _phantom: PhantomData\u003cA\u003e,\n}\n\nimpl\u003cA\u003e cmp::PartialEq for EventNode\u003cA\u003e\nwhere\n    A: Application,\n{\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.id == other.id\n    }\n}\n\nimpl\u003cA\u003e cmp::Eq for EventNode\u003cA\u003e where A: Application {}\n\nimpl\u003cA\u003e cmp::PartialOrd for EventNode\u003cA\u003e\nwhere\n    A: Application,\n{\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003ccmp::Ordering\u003e {\n        Some(self.cmp(other))\n    }\n\n    fn lt(\u0026self, other: \u0026Self) -\u003e bool {\n        other.time \u003c self.time\n    }\n\n    fn le(\u0026self, other: \u0026Self) -\u003e bool {\n        other.time \u003c= self.time\n    }\n\n    fn gt(\u0026self, other: \u0026Self) -\u003e bool {\n        other.time \u003e self.time\n    }\n\n    fn ge(\u0026self, other: \u0026Self) -\u003e bool {\n        other.time \u003e= self.time\n    }\n}\n\nimpl\u003cA\u003e cmp::Ord for EventNode\u003cA\u003e\nwhere\n    A: Application,\n{\n    fn cmp(\u0026self, other: \u0026Self) -\u003e cmp::Ordering {\n        // Inverted call should act as reverse\n        other.time.cmp(\u0026self.time)\n    }\n}\n\nimpl\u003cA\u003e Debug for EventNode\u003cA\u003e\nwhere\n    A: Application,\n    A::EventSet: Debug,\n{\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"EventNode {{ id: {} time: {} event: {:?} }}\",\n            self.id, self.time, self.event\n        )\n    }\n}\n\nimpl\u003cA\u003e Display for EventNode\u003cA\u003e\nwhere\n    A: Application,\n    A::EventSet: Display,\n{\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"EventNode {{ id: {} time: {} event: {} }}\",\n            self.id, self.time, self.event\n        )\n    }\n}\n","traces":[{"line":103,"address":[],"length":0,"stats":{"Line":172},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":172},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":24},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","limit.rs"],"content":"use crate::time::SimTime;\nuse std::{fmt::Display, mem};\n\n///\n/// A composed limit that terminates the event execution of\n/// a runtime.\n///\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum RuntimeLimit {\n    /// A unbounded runtime. A runtime with this limit will\n    /// only finish if the all events are handled and no new\n    /// events have been created.\n    None,\n\n    /// A bound based on the number of executed events.\n    /// A runtime with this limit will terminated prematurly after the\n    /// given bound is exceeded, but will finish normally if the bound-th event\n    /// is the last one.\n    EventCount(usize),\n\n    /// A bound based on the simulation time.\n    /// A runtime with this bound will terminate after no events\n    /// scheduled before the given simulation time are left.\n    SimTime(SimTime),\n\n    /// This bound combines two other bounds with a logical AND.\n    /// This will only terminated the simulation if both given\n    /// limits are fulfilled.\n    CombinedAnd(Box\u003cRuntimeLimit\u003e, Box\u003cRuntimeLimit\u003e),\n\n    /// This bound combines two other bounds with a logical OR.\n    /// This will terminated the simulation if one of given\n    /// limits is fulfilled.\n    CombinedOr(Box\u003cRuntimeLimit\u003e, Box\u003cRuntimeLimit\u003e),\n}\n\nimpl RuntimeLimit {\n    pub(crate) fn applies(\u0026self, itr_count: usize, time: SimTime) -\u003e bool {\n        match self {\n            Self::None =\u003e false,\n\n            Self::EventCount(e) =\u003e itr_count \u003e *e,\n            Self::SimTime(t) =\u003e time \u003e *t,\n\n            Self::CombinedAnd(lhs, rhs) =\u003e {\n                lhs.applies(itr_count, time) \u0026\u0026 rhs.applies(itr_count, time)\n            }\n            Self::CombinedOr(lhs, rhs) =\u003e {\n                lhs.applies(itr_count, time) || rhs.applies(itr_count, time)\n            }\n        }\n    }\n\n    pub(crate) fn add(\u0026mut self, limit: RuntimeLimit) {\n        if matches!(self, Self::None) {\n            *self = limit;\n        } else {\n            let mut other = Self::None;\n            mem::swap(\u0026mut other, self);\n            *self = Self::CombinedOr(Box::new(other), Box::new(limit));\n        }\n    }\n}\n\nimpl Display for RuntimeLimit {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::None =\u003e write!(f, \"None\"),\n\n            Self::EventCount(e) =\u003e write!(f, \"MaxEventCount({e})\"),\n            Self::SimTime(t) =\u003e write!(f, \"MaxSimTime({t})\"),\n\n            Self::CombinedAnd(lhs, rhs) =\u003e write!(f, \"{lhs} and {rhs}\"),\n            Self::CombinedOr(lhs, rhs) =\u003e write!(f, \"{lhs} or {rhs}\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn raw_limits() {\n        let limit = RuntimeLimit::None;\n        assert_eq!(limit.to_string(), \"None\");\n        assert!(!limit.applies(123, 100.0.into()));\n        assert!(!limit.applies(0, 0.0.into()));\n        assert!(!limit.applies(usize::MAX, SimTime::MAX));\n\n        let limit = RuntimeLimit::EventCount(100);\n        assert_eq!(limit.to_string(), \"MaxEventCount(100)\");\n        assert!(!limit.applies(23, 100.0.into()));\n        assert!(limit.applies(101, 0.0.into()));\n        assert!(limit.applies(101, SimTime::MAX));\n        assert!(limit.applies(230, 23.0.into()));\n\n        let limit = RuntimeLimit::SimTime(100.0.into());\n        assert_eq!(limit.to_string(), \"MaxSimTime(100s)\");\n        assert!(!limit.applies(0, 10.0.into()));\n        assert!(!limit.applies(0, 100.0.into()));\n        assert!(limit.applies(0, 100.000001.into()));\n        assert!(limit.applies(0, SimTime::MAX));\n    }\n\n    #[test]\n    fn combined_limits() {\n        use RuntimeLimit::*;\n\n        let limit = CombinedAnd(Box::new(EventCount(100)), Box::new(SimTime(100.0.into())));\n        assert_eq!(limit.to_string(), \"MaxEventCount(100) and MaxSimTime(100s)\");\n        assert!(!limit.applies(200, 10.0.into()));\n        assert!(!limit.applies(0, 200.0.into()));\n        assert!(limit.applies(101, 100.000001.into()));\n\n        let limit = CombinedOr(Box::new(EventCount(100)), Box::new(SimTime(100.0.into())));\n        assert_eq!(limit.to_string(), \"MaxEventCount(100) or MaxSimTime(100s)\");\n        assert!(!limit.applies(20, 10.0.into()));\n        assert!(limit.applies(0, 200.0.into()));\n        assert!(limit.applies(101, 10.0.into()));\n\n        let mut other = RuntimeLimit::EventCount(100);\n        other.add(SimTime(100.0.into()));\n        assert_eq!(limit, other);\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":118032},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":118032},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":110794},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":154},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":7078},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":184},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":184},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":22,"coverable":22},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","metrics","mod.rs"],"content":"//! Future impl for runtime metrics\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","runtime","mod.rs"],"content":"//!\n//! Central primitives for running a discrete event simulation.\n//!\n\nuse crate::{\n    macros::support::SyncWrap,\n    time::{Duration, SimTime},\n};\nuse rand::{distributions::Standard, prelude::Distribution, Rng, RngCore};\nuse std::{\n    any::type_name,\n    cell::UnsafeCell,\n    fmt::{Debug, Display},\n    sync::MutexGuard,\n};\n\nmod event;\npub use self::event::*;\n\nmod limit;\npub use self::limit::*;\n\nmod bench;\npub use bench::*;\n\nmod builder;\npub use builder::*;\n\nmod metrics;\n\npub(crate) const FT_NET: bool = cfg!(feature = \"net\");\npub(crate) const FT_NDL: bool = cfg!(feature = \"ndl\");\npub(crate) const FT_CQUEUE: bool = cfg!(feature = \"cqueue\");\npub(crate) const FT_INTERNAL_METRICS: bool = cfg!(feature = \"metrics\");\npub(crate) const FT_ASYNC: bool = cfg!(feature = \"async\");\n\npub(crate) const SYM_CHECKMARK: char = '\\u{2713}';\npub(crate) const SYM_CROSSMARK: char = '\\u{02df}';\n\npub(crate) static RNG: SyncWrap\u003cUnsafeCell\u003cOption\u003cBox\u003cdyn RngCore\u003e\u003e\u003e\u003e =\n    SyncWrap::new(UnsafeCell::new(None));\n\n///\n/// Returns a reference to a given rng.\n///\n/// # Panics\n///\n/// This function will panic if the RNG has not been initalized.\n/// This will be done once the `Runtime` was created.\n///\n#[must_use]\npub fn rng() -\u003e \u0026'static mut dyn RngCore {\n    unsafe { \u0026mut *RNG.get() }\n        .as_mut()\n        .expect(\"RNG not yet initalized\")\n}\n\n///\n/// Generates a random instance of type T with a Standard distribution.\n///\n#[must_use]\npub fn random\u003cT\u003e() -\u003e T\nwhere\n    Standard: Distribution\u003cT\u003e,\n{\n    rng().gen::\u003cT\u003e()\n}\n\n///\n/// Generates a random instance of type T with a distribution\n/// of type D.\n///\npub fn sample\u003cT, D\u003e(distr: D) -\u003e T\nwhere\n    D: Distribution\u003cT\u003e,\n{\n    rng().sample::\u003cT, D\u003e(distr)\n}\n\n///\n/// The central managment point for a generic\n/// instance of a discrete event based simulation.\n///\n/// # Generic usage\n///\n/// If you want to create a generic simulation you are requied to provide a 'app'\n/// parameter with an associated event set yourself. To do this follow this steps:\n///\n/// - Create an 'App' struct that implements the trait [`Application`].\n/// This struct will hold the systems state and define the event set used in the simulation.\n/// - Create your events that handle the logic of you simulation. They must implement [`Event`] with the generic\n/// parameter A, where A is your 'App' struct.\n/// - To bind those two together create a enum that implements [`EventSet`] that holds all your events.\n/// This can be done via a macro. The use this event set as the associated event set in 'App'.\n///\n/// # Usage with module system\n///\n/// If you want to use the module system for network-like simulations\n/// than you must create a [`Sim\u003cA\u003e`] as app parameter for the core [`Runtime`].\n/// This network runtime comes preconfigured with an event set and all managment\n/// event nessecary for the simulation. All you have to do is to pass the app into [`Builder::build`]\n/// to create a runnable instance and the run it.\n///\n/// [`Event`]: crate::runtime::Event\n/// [`EventSet`]: crate::runtime::EventSet\npub struct Runtime\u003cApp\u003e\nwhere\n    App: Application,\n{\n    /// The contained runtime application, defining globals and the used event set.\n    pub app: App,\n\n    // Rt limits\n    limit: RuntimeLimit,\n\n    event_id: EventId,\n    itr: usize,\n\n    // Misc\n    quiet: bool,\n    profiler: Profiler,\n\n    #[allow(dead_code)]\n    permit: MutexGuard\u003c'static, ()\u003e,\n\n    future_event_set: FutureEventSet\u003cApp\u003e,\n}\n\nimpl\u003cA\u003e Runtime\u003cA\u003e\nwhere\n    A: Application,\n{\n    // ///\n    // /// Returns the current number of events on enqueud.\n    // ///\n    // pub(crate) fn num_non_zero_events_queued(\u0026self) -\u003e usize {\n    //     self.future_event_set.len_nonzero()\n    // }\n\n    // ///\n    // /// Returns the current number of events on enqueud.\n    // ///\n    // pub(crate) fn num_zero_events_queued(\u0026self) -\u003e usize {\n    //     self.future_event_set.len_zero()\n    // }\n\n    ///\n    /// Returns the number of events that were dispatched on this [`Runtime`] instance.\n    ///\n    #[inline]\n    pub fn num_events_dispatched(\u0026self) -\u003e usize {\n        self.event_id\n    }\n\n    ///\n    /// Returns the number of events that were recieved \u0026 handled on this [`Runtime`] instance.\n    ///\n    pub fn num_events_received(\u0026self) -\u003e usize {\n        self.itr\n    }\n\n    ///\n    /// Returns the current simulation time.\n    ///\n    #[allow(clippy::unused_self)]\n    pub fn sim_time(\u0026self) -\u003e SimTime {\n        SimTime::now()\n    }\n\n    // ///\n    // /// Returns the random number generator by mutable refernce\n    // ///\n    // pub(crate) fn rng(\u0026mut self) -\u003e *mut StdRng {\n    //     self::rng()\n    // }\n\n    ///\n    /// Returns the rng.\n    ///\n    #[allow(clippy::unused_self)]\n    pub fn random\u003cT\u003e(\u0026mut self) -\u003e T\n    where\n        Standard: Distribution\u003cT\u003e,\n    {\n        self::random()\n    }\n\n    ///\n    /// Returns the rng.\n    ///\n    #[allow(clippy::unused_self)]\n    pub fn rng_sample\u003cT, D\u003e(\u0026mut self, distr: D) -\u003e T\n    where\n        D: Distribution\u003cT\u003e,\n    {\n        self::sample(distr)\n    }\n}\n\nimpl\u003cA\u003e Runtime\u003cA\u003e\nwhere\n    A: Application,\n{\n    ///\n    /// Creates a new [`Runtime`] Instance using an application as core,\n    /// and accepting events of type [`Event\u003cA\u003e`](crate::runtime::Event).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// // Assumme Application is implemented for App.\n    /// #[derive(Debug)]\n    /// struct App(usize,  String);\n    /// # impl Application for App {\n    /// #   type EventSet = Events;\n    /// #   type Lifecycle = ();\n    /// # }\n    /// # enum Events {}\n    /// # impl EventSet\u003cApp\u003e for Events {\n    /// #   fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {}\n    /// # }\n    ///\n    /// let app = App(42, String::from(\"Hello there!\"));\n    /// let rt = Builder::new().build(app);\n    /// ```\n    ///\n    // #[must_use]\n    // pub fn new(app: A) -\u003e Self {\n    //     Self::new_with(app, RuntimeOptions::default())\n    // }\n\n    ///\n    /// Creates a new [`Runtime`] Instance using an application as core,\n    /// and accepting events of type [`Event\u003cA\u003e`](crate::runtime::Event), using a custom set of\n    /// [`RuntimeOptions`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// // Assumme Application is implemented for App.\n    /// #[derive(Debug)]\n    /// struct App(usize,  String);\n    /// # impl Application for App {\n    /// #   type EventSet = Events;\n    /// #   type Lifecycle = ();\n    /// # }\n    /// # enum Events {}\n    /// # impl EventSet\u003cApp\u003e for Events {\n    /// #   fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {}\n    /// # }\n    ///\n    /// let app = App(42, String::from(\"Hello there!\"));\n    /// let rt = Builder::seeded(42).max_itr(69).build(app);\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// Panics if no RNG can be created from the OS-RNG.\n    ///\n    // #[must_use]\n    // pub fn new_with(app: A, mut options: RuntimeOptions) -\u003e Self {\n    //     todo!()\n    // }\n\n    fn poison_cleanup() {\n        // NOP\n    }\n\n    /// Runs the application until it terminates or a breaking condition\n    /// is reached.\n    ///\n    /// ### Examples\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// struct MyApp();\n    /// impl Application for MyApp {\n    ///     type EventSet = MyEventSet;\n    ///     type Lifecycle = Self;\n    /// }\n    /// impl EventLifecycle for MyApp {\n    ///     fn at_sim_start(rt: \u0026mut Runtime\u003cSelf\u003e) {\n    ///         rt.add_event(MyEventSet::EventA, SimTime::from(1.0));\n    ///         rt.add_event(MyEventSet::EventB, SimTime::from(2.0));\n    ///         rt.add_event(MyEventSet::EventA, SimTime::from(3.0));\n    ///     }\n    /// }\n    ///\n    /// #[derive(Debug)]\n    /// enum MyEventSet {\n    ///     EventA,\n    ///     EventB\n    /// }\n    /// impl EventSet\u003cMyApp\u003e for MyEventSet {\n    ///     fn handle(self, rt: \u0026mut Runtime\u003cMyApp\u003e) {\n    ///         dbg!(self, SimTime::now());\n    ///     }\n    /// }\n    ///\n    ///\n    /// let runtime = Builder::new().build(MyApp());\n    /// let result = runtime.run();\n    ///\n    /// match result {\n    ///     RuntimeResult::Finished { time, profiler, .. } =\u003e {\n    ///         assert_eq!(time, SimTime::from(3.0));\n    ///         assert_eq!(profiler.event_count, 3);\n    ///     },\n    ///     _ =\u003e panic!(\"They can't do that! Shoot them or something!\")\n    /// }\n    ///\n    /// ```\n    #[must_use]\n    pub fn run(mut self) -\u003e RuntimeResult\u003cA\u003e {\n        // (0) Start sim-start\n        self.start();\n\n        // (1) Event main loop\n        if !self.future_event_set.is_empty() {\n            while self.next() {}\n        }\n\n        // (2) Finish sim-end\n        self.finish()\n    }\n\n    fn start(\u0026mut self) {\n        macro_rules! symbol {\n            ($i:ident) =\u003e {\n                if $i {\n                    SYM_CHECKMARK\n                } else {\n                    SYM_CROSSMARK\n                }\n            };\n        }\n\n        // (0) Publish sim-start message\n        println!(\"\\u{23A1}\");\n        println!(\"\\u{23A2} Simulation starting\");\n        println!(\n            \"\\u{23A2}  net [{}] metrics [{}] cqueue [{}] ndl[{}] async[{}]\",\n            symbol!(FT_NET),\n            symbol!(FT_INTERNAL_METRICS),\n            symbol!(FT_CQUEUE),\n            symbol!(FT_NDL),\n            symbol!(FT_ASYNC),\n        );\n        println!(\n            \"\\u{23A2}  Executor := {}\",\n            self.future_event_set.descriptor()\n        );\n        println!(\"\\u{23A2}  Event limit := {}\", self.limit);\n        println!(\"\\u{23A3}\");\n\n        // (1) Start profiler\n        self.profiler.start();\n\n        // (2) sim-starting on application object\n        A::Lifecycle::at_sim_start(self);\n    }\n\n    /// Processes the next event in the future event list by calling its handler.\n    /// Returns `true` if there is another event in queue, false if not.\n    ///\n    /// This function requires the caller to guarantee that at least one\n    /// event exists in the future event set.\n    #[allow(clippy::should_implement_trait)]\n    fn next(\u0026mut self) -\u003e bool {\n        debug_assert!(!self.future_event_set.is_empty());\n\n        let (event, time) = self.future_event_set.fetch_next();\n\n        self.itr += 1;\n\n        if self.limit.applies(self.itr, time) {\n            self.future_event_set.add(time, event);\n            return false;\n        }\n\n        // Let this be the only position where SimTime is changed\n        SimTime::set_now(time);\n\n        // {\n        //     #[cfg(feature = \"tracing\")]\n        //     let span = tracing::span!(tracing::Level::TRACE, \"event\", id = self.itr);\n        //     #[cfg(feature = \"tracing\")]\n        //     let _g = span.enter();\n\n        event.handle(self);\n        // }\n\n        !self.future_event_set.is_empty()\n    }\n\n    /// Decontructs the runtime and returns the application and the final `sim_time`.\n    ///\n    /// This funtions should only be used when running the simulation with manual calls\n    /// to [`next`](Runtime::next).\n    #[allow(unused_mut)]\n    #[must_use]\n    fn finish(mut self) -\u003e RuntimeResult\u003cA\u003e {\n        // Call the fin-handler on the allocated application\n        A::Lifecycle::at_sim_end(\u0026mut self);\n        self.profiler.finish(self.itr);\n\n        if self.future_event_set.is_empty() \u0026\u0026 self.itr == 0 {\n            if !self.quiet {\n                println!(\"\\u{23A1}\");\n                println!(\"\\u{23A2} Empty simulation\");\n                println!(\"\\u{23A2}  Ended at event #0 after 0s\");\n                println!(\"\\u{23A3}\");\n            }\n\n            return RuntimeResult::EmptySimulation { app: self.app };\n        }\n\n        if self.future_event_set.is_empty() {\n            let time = self.sim_time();\n\n            if !self.quiet {\n                println!(\"\\u{23A1}\");\n                println!(\"\\u{23A2} Simulation ended\");\n                println!(\"\\u{23A2}  Ended at event #{} after {}\", self.itr, time);\n                println!(\"\\u{23A3}\");\n            }\n\n            RuntimeResult::Finished {\n                app: self.app,\n                profiler: self.profiler,\n                time,\n            }\n        } else {\n            let time = self.sim_time();\n\n            if !self.quiet {\n                println!(\"\\u{23A1}\");\n                println!(\"\\u{23A2} Simulation ended prematurly\");\n                println!(\n                    \"\\u{23A2}  Ended at event #{} with {} active events after {}\",\n                    self.itr,\n                    self.future_event_set.len(),\n                    time\n                );\n                println!(\"\\u{23A3}\");\n            }\n\n            RuntimeResult::PrematureAbort {\n                profiler: self.profiler,\n                active_events: self.future_event_set.len(),\n                app: self.app,\n                time,\n            }\n        }\n    }\n\n    ///\n    /// Adds and event to the future event heap, that will be handled in 'duration'\n    /// time units.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// # struct MyApp();\n    /// # impl Application for MyApp {\n    /// #     type EventSet = MyEventSet;\n    /// #     type Lifecycle = ();\n    /// # }\n    /// #\n    /// # enum MyEventSet {\n    /// #     EventA,\n    /// #     EventB\n    /// # }\n    /// # impl EventSet\u003cMyApp\u003e for MyEventSet {\n    /// #     fn handle(self, rt: \u0026mut Runtime\u003cMyApp\u003e) {}\n    /// # }\n    /// #\n    /// fn main() {\n    ///     let mut runtime = Builder::seeded(1)\n    ///         .start_time(10.0.into())\n    ///         .build(MyApp());\n    ///     runtime.add_event_in(MyEventSet::EventA, Duration::new(12, 0));\n    ///\n    ///     match runtime.run() {\n    ///         RuntimeResult::Finished { time, profiler, .. } =\u003e {\n    ///             assert_eq!(time, SimTime::from(22.0));\n    ///             assert_eq!(profiler.event_count, 1);\n    ///         },\n    ///         _ =\u003e panic!(\"They can't do that! Shoot them or something!\")\n    ///     }\n    /// }\n    /// ```\n    ///\n    pub fn add_event_in(\u0026mut self, event: impl Into\u003cA::EventSet\u003e, duration: impl Into\u003cDuration\u003e) {\n        self.add_event(event, self.sim_time() + duration.into());\n    }\n\n    ///\n    /// Adds and event to the furtue event heap that will be handled at the given time.\n    /// Note that this time must be in the future i.e. greated that `sim_time`, or this\n    /// function will panic.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use des::prelude::*;\n    ///\n    /// # struct MyApp();\n    /// # impl Application for MyApp {\n    /// #     type EventSet = MyEventSet;\n    /// #     type Lifecycle = ();\n    /// # }\n    /// #\n    /// # enum MyEventSet {\n    /// #     EventA,\n    /// #     EventB\n    /// # }\n    /// # impl EventSet\u003cMyApp\u003e for MyEventSet {\n    /// #     fn handle(self, rt: \u0026mut Runtime\u003cMyApp\u003e) {}\n    /// # }\n    /// #\n    /// fn main() {\n    ///     let mut runtime = Builder::seeded(1)\n    ///         .start_time(10.0.into())\n    ///         .build(MyApp());\n    ///     runtime.add_event(MyEventSet::EventA, SimTime::from(12.0));\n    ///\n    ///     match runtime.run() {\n    ///         RuntimeResult::Finished { time, profiler, .. } =\u003e {\n    ///             assert_eq!(time, SimTime::from(12.0)); // 12 not 10+12 = 22\n    ///             assert_eq!(profiler.event_count, 1);\n    ///         },\n    ///         _ =\u003e panic!(\"They can't do that! Shoot them or something!\")\n    ///     }\n    /// }\n    /// ```\n    ///\n    pub fn add_event(\u0026mut self, event: impl Into\u003cA::EventSet\u003e, time: SimTime) {\n        self.future_event_set.add(time, event);\n    }\n}\n\n///\n/// The result of an full execution of a runtime object.\n///\n#[derive(Debug, Clone, Eq, PartialEq)]\npub enum RuntimeResult\u003cA\u003e {\n    /// The simulation has finished with an event count of `1`.\n    /// This ususally inidcates that some parameter was invalid,\n    /// or the user forgot to insert a startup event. However a\n    /// at_sim_start event has been called.\n    EmptySimulation {\n        /// The application provided upon runtime creation, only changed through\n        /// the `at_sim_start` method of modules.\n        app: A,\n    },\n    /// The simulation has fully depleted its event pool with an event count\n    /// greater than `1`. The function `at_sim_end` has been called.\n    Finished {\n        /// The application after the simulation was executed.\n        app: A,\n        /// The time of the final event in the simulation.\n        time: SimTime,\n        /// The runtime profile of the simulation\n        profiler: Profiler,\n    },\n    /// The simulation has not fully deleted its event pool. but a `RuntimeLimit`\n    /// has been reached.\n    PrematureAbort {\n        /// The application in the intermediary state of premature abort,\n        /// but `at_sim_end` has been called.\n        app: A,\n        /// The time of the last event valid withing the limits of the runtime.\n        time: SimTime,\n        /// The size of the current event pool.\n        active_events: usize,\n        /// The runtime profile of the simulation\n        profiler: Profiler,\n    },\n}\n\nimpl\u003cA\u003e RuntimeResult\u003cA\u003e {\n    /// Gets the contained application from the runtime result.\n    ///\n    /// An application is contained in each variant of a runtime result.\n    pub fn into_app(self) -\u003e A {\n        match self {\n            Self::EmptySimulation { app }\n            | Self::Finished { app, .. }\n            | Self::PrematureAbort { app, .. } =\u003e app,\n        }\n    }\n\n    ///\n    /// Returns the contained [`PrematureAbort`](Self::PrematureAbort) variant\n    /// consuming the `self`value.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if self contains another variant that [`PrematureAbort`](Self::PrematureAbort).\n    ///\n    pub fn unwrap_premature_abort(self) -\u003e (A, SimTime, Profiler, usize) {\n        match self {\n            Self::PrematureAbort { app, time,profiler, active_events} =\u003e (app, time, profiler, active_events),\n            _ =\u003e panic!(\"called `RuntimeResult::unwrap_premature_abort` on a value that is not `PrematureAbort`\")\n        }\n    }\n\n    ///\n    /// Returns the contained [`Finished`](Self::Finished) variant consuming the `self` value.\n    ///\n    /// # Panics\n    ///\n    /// This function panics should the `self` value contain another variant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # use des::runtime::Profiler;\n    /// # #[derive(Debug, PartialEq, Eq)]\n    /// # struct MyApp;\n    /// # fn main() {\n    /// let p = Profiler::default();\n    /// let result = RuntimeResult::Finished { app: MyApp, time: 1.0.into(), profiler: p.clone() };\n    /// assert_eq!(result.unwrap(), (MyApp, SimTime::from(1.0), p));\n    /// # }\n    /// ```\n    ///\n    /// ```should_panic\n    /// # use des::prelude::*;\n    /// # #[derive(Debug, PartialEq, Eq)]\n    /// # struct MyApp;\n    /// # fn main() {\n    /// let result = RuntimeResult::EmptySimulation { app: MyApp };\n    /// result.unwrap();\n    /// # }\n    /// ```\n    pub fn unwrap(self) -\u003e (A, SimTime, Profiler) {\n        match self {\n            Self::Finished {\n                app,\n                time,\n                profiler,\n            } =\u003e (app, time, profiler),\n            _ =\u003e panic!(\"called `RuntimeResult::unwrap` on value that is not 'Finished'\"),\n        }\n    }\n\n    ///\n    /// Returns the contained [`Finished`](Self::Finished) variant or\n    /// the provided default.\n    ///\n    /// The argument `default` is eagerly evaulated, for lazy evaluation use\n    /// [`unwrap_or_else`](Self::unwrap_or_else).\n    ///\n    pub fn unwrap_or(self, default: (A, SimTime, Profiler)) -\u003e (A, SimTime, Profiler) {\n        match self {\n            Self::Finished {\n                app,\n                time,\n                profiler,\n            } =\u003e (app, time, profiler),\n            _ =\u003e default,\n        }\n    }\n\n    ///\n    /// Returns the contained [`Finished`](Self::Finished) variant or lazily\n    /// computes a fallback value from the given closure.\n    ///\n    pub fn unwrap_or_else\u003cF\u003e(self, f: F) -\u003e (A, SimTime, Profiler)\n    where\n        F: FnOnce() -\u003e (A, SimTime, Profiler),\n    {\n        match self {\n            Self::Finished {\n                app,\n                time,\n                profiler,\n            } =\u003e (app, time, profiler),\n            _ =\u003e f(),\n        }\n    }\n\n    ///\n    /// Maps the `app` property that is contained in all variants to a new\n    /// value of type T, using the given closure.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use des::prelude::*;\n    /// # #[derive(Debug, PartialEq, Eq)]\n    /// struct InnerResult { value: usize }\n    /// # #[derive(Debug, PartialEq, Eq)]\n    /// struct OuterResult { inner: InnerResult }\n    ///\n    /// # fn main() {\n    /// let result = RuntimeResult::EmptySimulation {\n    ///     app: OuterResult { inner: InnerResult { value: 42 } }\n    /// };\n    /// let result = result.map_app(|outer| outer.inner);\n    /// assert_eq!(result, RuntimeResult::EmptySimulation { app: InnerResult { value: 42 } });\n    /// # }\n    /// ```\n    ///\n    pub fn map_app\u003cF, T\u003e(self, f: F) -\u003e RuntimeResult\u003cT\u003e\n    where\n        F: FnOnce(A) -\u003e T,\n    {\n        match self {\n            Self::EmptySimulation { app } =\u003e RuntimeResult::EmptySimulation { app: f(app) },\n            Self::Finished {\n                app,\n                time,\n                profiler,\n            } =\u003e RuntimeResult::Finished {\n                app: f(app),\n                time,\n                profiler,\n            },\n            Self::PrematureAbort {\n                app,\n                time,\n                profiler,\n                active_events,\n            } =\u003e RuntimeResult::PrematureAbort {\n                app: f(app),\n                time,\n                profiler,\n                active_events,\n            },\n        }\n    }\n}\n\ncfg_net! {\n    use crate::net::{gate::{GateRef, Connection},  HandleMessageEvent, message::Message, MessageExitingConnection, module::ModuleRef, NetEvents, Sim};\n\n    impl\u003cA\u003e Runtime\u003cSim\u003cA\u003e\u003e where\n        A: EventLifecycle\u003cSim\u003cA\u003e\u003e,{\n        ///\n        /// Adds a message event into a [`Runtime\u003cNetworkApplication\u003cA\u003e\u003e`] onto a gate.\n        ///\n        pub fn add_message_onto(\n            \u0026mut self,\n            gate: GateRef,\n            message: impl Into\u003cMessage\u003e,\n            time: SimTime,\n        ) {\n            let event = MessageExitingConnection {\n                con: Connection::new(gate),\n                msg: message.into(),\n            };\n\n            self.add_event(NetEvents::MessageExitingConnection(event), time);\n        }\n\n        ///\n        /// Adds a message event into a [`Runtime\u003cNetworkApplication\u003cA\u003e\u003e`] onto a module.\n        ///\n        pub fn handle_message_on(\n            \u0026mut self,\n            module: impl Into\u003cModuleRef\u003e,\n            message: impl Into\u003cMessage\u003e,\n            time: SimTime,\n        ) {\n            let event = HandleMessageEvent {\n                module: module.into(),\n                message: message.into(),\n            };\n\n            self.add_event(NetEvents::HandleMessageEvent(event), time);\n        }\n    }\n}\n\nimpl\u003cA\u003e Debug for Runtime\u003cA\u003e\nwhere\n    A: Application,\n{\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"Runtime\u003c{}\u003e {{ sim_time: {} (itr {} / {}) dispached: {} enqueued: {} }}\",\n            type_name::\u003cA\u003e(),\n            self.sim_time(),\n            self.num_events_received(),\n            self.limit,\n            self.num_events_dispatched(),\n            self.future_event_set.len()\n        )\n    }\n}\n\nimpl\u003cA\u003e Display for Runtime\u003cA\u003e\nwhere\n    A: Application,\n{\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"Runtime\u003c{}\u003e {{ sim_time: {} (itr {} / {}) dispached: {} enqueued: {} }}\",\n            type_name::\u003cA\u003e(),\n            self.sim_time(),\n            self.num_events_received(),\n            self.limit,\n            self.num_events_dispatched(),\n            self.future_event_set.len()\n        )\n    }\n}\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":422349},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":422349},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":420270},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":420270},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":420118},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":420118},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":235960},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":236010},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":118003},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":118003},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":118003},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":342},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":121},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":118005},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":97,"coverable":170},{"path":["/","Users","mk","Developer","rust","des","des","src","sync","atomic.rs"],"content":"//! A wrapper around atomics.\n//!\n//! While still cheap, atomic operations are more expensive than primitive integer\n//! operations. This difference matters, since some lock use atomics to share state.\n//! In single-threaded contexts this is not nessecary. Accordingly there are\n//! wrappers around a not-really atomic implementation of Atomics for single-thread use.\n//!\n//! Not that this implemation results in 2-3 % performance increase since\n//! atomic based locks are used in every event.\n\nuse std::{cell::UnsafeCell, sync::atomic::Ordering};\n\ncfg_not_multi_threaded! {\n    pub(crate) struct AtomicUsize {\n        v: UnsafeCell\u003cusize\u003e,\n    }\n\n    impl AtomicUsize {\n        pub(crate) const fn new(v: usize) -\u003e Self {\n            Self {\n                v: UnsafeCell::new(v),\n            }\n        }\n\n        #[allow(clippy::mut_from_ref)]\n        fn get_v(\u0026self) -\u003e \u0026mut usize {\n            unsafe { \u0026mut *self.v.get() }\n        }\n\n        pub(crate) fn get_mut(\u0026mut self) -\u003e \u0026mut usize {\n            self.get_v()\n        }\n\n        pub(crate) fn into_inner(self) -\u003e usize {\n            *self.get_v()\n        }\n\n        pub(crate) fn load(\u0026self, _order: Ordering) -\u003e usize {\n            *self.get_v()\n        }\n\n        pub(crate) fn store(\u0026self, val: usize, _order: Ordering) {\n            *self.get_v() = val;\n        }\n\n        pub(crate) fn swap(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v = val;\n            ret\n        }\n\n        pub(crate) fn compare_exchange(\n            \u0026self,\n            cur: usize,\n            new: usize,\n            suc: Ordering,\n            fail: Ordering,\n        ) -\u003e Result\u003cusize, usize\u003e {\n            let v = self.get_v();\n            if *v != cur {\n                return Err(*v);\n            }\n            Ok(self.swap(new, suc))\n        }\n\n        pub(crate) fn fetch_add(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v = v.wrapping_add(val);\n            ret\n        }\n\n        pub(crate) fn fetch_sub(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v = v.wrapping_sub(val);\n            ret\n        }\n\n        pub(crate) fn fetch_and(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v \u0026= val;\n            ret\n        }\n\n        pub(crate) fn fetch_nand(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v = !(*v \u0026 val);\n            ret\n        }\n\n        pub(crate) fn fetch_or(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v |= val;\n            ret\n        }\n\n        pub(crate) fn fetch_xor(\u0026self, val: usize, _order: Ordering) -\u003e usize {\n            let v = self.get_v();\n            let ret = *v;\n            *v ^= val;\n            ret\n        }\n    }\n\n    unsafe impl Send for AtomicUsize {}\n    unsafe impl Sync for AtomicUsize {}\n}\n\ncfg_multi_threaded! {\n    pub(crate) use std::sync::atomic::AtomicUsize;\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":36984},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":36984},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":356},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":356},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":59},{"path":["/","Users","mk","Developer","rust","des","des","src","sync","mod.rs"],"content":"#![allow(unused)]\n//! Synchronisation primitives for internal use\n//!\n//! The primitives defined here provide either specialised capabilities\n//! or a more efficient implementation if the feature multi-threaded is not\n//! set. As an example, the `RwLock` that is implemented here uses a `RefCell` inspired\n//! implementation in single-threaded contexts, which is significantly more performant.\n\nmod swaplock;\npub(crate) use self::swaplock::*;\n\nmod atomic;\npub(crate) use self::atomic::*;\n\nmod rwlock;\npub(crate) use self::rwlock::*;\n\nmod mutex;\npub(crate) use self::mutex::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","src","sync","mutex.rs"],"content":"cfg_not_multi_threaded! {\n    use std::{\n        cell::UnsafeCell,\n        sync::atomic::{AtomicBool, Ordering},\n        ops::{Deref, DerefMut},\n    };\n\n    #[derive(Debug)]\n    pub(crate) struct Mutex\u003cT\u003e {\n        value: UnsafeCell\u003cT\u003e,\n        locked: AtomicBool,\n    }\n\n    impl\u003cT\u003e Mutex\u003cT\u003e {\n        pub(crate) const fn new(value: T) -\u003e Self {\n            Self {\n                value: UnsafeCell::new(value),\n                locked: AtomicBool::new(false),\n            }\n        }\n\n        pub(crate) fn into_inner(self) -\u003e T {\n            self.value.into_inner()\n        }\n\n        pub(crate) fn is_locked(\u0026self) -\u003e bool {\n            self.locked.load(Ordering::SeqCst)\n        }\n\n\n        pub(crate) fn lock(\u0026self) -\u003e MutexGuard\u003c'_, T\u003e {\n            MutexGuard::new(self)\n        }\n    }\n\n    unsafe impl\u003cT: Send\u003e Send for Mutex\u003cT\u003e {}\n    unsafe impl\u003cT: Send\u003e Sync for Mutex\u003cT\u003e {}\n\n    pub(crate) struct MutexGuard\u003c'a, T\u003e {\n        inner: \u0026'a Mutex\u003cT\u003e,\n    }\n\n    impl\u003c'a, T\u003e MutexGuard\u003c'a, T\u003e {\n        fn new(inner: \u0026'a Mutex\u003cT\u003e) -\u003e Self {\n            let lock_failed = inner.locked.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed).is_err();\n            assert!(!lock_failed, \"Could not lock mutex on single thread\");\n            Self { inner }\n        }\n    }\n\n    impl\u003cT\u003e Deref for MutexGuard\u003c'_, T\u003e{\n        type Target = T;\n        fn deref(\u0026self) -\u003e \u0026T {\n            // SAFTEY lock gurantees exclusive access.\n            unsafe { \u0026*self.inner.value.get() }\n        }\n    }\n\n    impl\u003cT\u003e DerefMut for MutexGuard\u003c'_, T\u003e{\n        fn deref_mut(\u0026mut self) -\u003e \u0026mut T {\n            // SAFTEY lock gurantees exclusive access.\n            unsafe { \u0026mut *self.inner.value.get() }\n        }\n    }\n\n    impl\u003cT\u003e Drop for MutexGuard\u003c'_, T\u003e {\n        fn drop(\u0026mut self) {\n            self.inner.locked.store(false, Ordering::Release);\n        }\n    }\n}\n\ncfg_multi_threaded! {\n    pub(crate) use ::spin::mutex::*;\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":15785},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":15785},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":7807},"fn_name":null}],"covered":16,"coverable":20},{"path":["/","Users","mk","Developer","rust","des","des","src","sync","rwlock.rs"],"content":"//! Implements are classic non-poisonable Read-Write-Lock with an\n//! API inspired by `spin::RwLock`.\n//!\n//! In single-threaded contexts this will be implemented using a `RefCell`\n//! like structure (with appropiate API).\n//! In multi-threaded contexts, `spin::RwLock` is used.\n\ncfg_not_multi_threaded! {\n    use std::{\n        cell::{Cell, UnsafeCell},\n        marker::PhantomData,\n        ops::{Deref, DerefMut},\n        ptr::NonNull,\n    };\n\n    type BorrowFlag = isize;\n    const UNUSED: BorrowFlag = 0;\n\n    #[inline]\n    fn is_writing(x: BorrowFlag) -\u003e bool {\n        x \u003c UNUSED\n    }\n\n    #[inline]\n    fn is_reading(x: BorrowFlag) -\u003e bool {\n        x \u003e UNUSED\n    }\n\n    #[derive(Debug)]\n    pub(crate) struct RwLock\u003cT\u003e {\n        flag: Cell\u003cBorrowFlag\u003e,\n        value: UnsafeCell\u003cT\u003e,\n    }\n\n    impl\u003cT\u003e RwLock\u003cT\u003e {\n        pub(crate) const fn new(value: T) -\u003e Self {\n            Self {\n                flag: Cell::new(0),\n                value: UnsafeCell::new(value),\n            }\n        }\n\n        pub(crate) fn into_inner(self) -\u003e T {\n            self.value.into_inner()\n        }\n\n        pub(crate) fn read(\u0026self) -\u003e RwLockReadGuard\u003c'_, T\u003e {\n            self.try_read()\n                .expect(\"Failed to get read lock on single thread\")\n        }\n\n        pub(crate) fn try_read(\u0026self) -\u003e Option\u003cRwLockReadGuard\u003c'_, T\u003e\u003e {\n            let permit = ReadBorrow::new(\u0026self.flag)?;\n            let value = unsafe { NonNull::new_unchecked(self.value.get()) };\n            Some(RwLockReadGuard { permit, value })\n        }\n\n        pub(crate) fn write(\u0026self) -\u003e RwLockWriteGuard\u003c'_, T\u003e {\n            self.try_write()\n                .expect(\"Failed to get read lock on single thread\")\n        }\n\n        pub(crate) fn try_write(\u0026self) -\u003e Option\u003cRwLockWriteGuard\u003c'_, T\u003e\u003e {\n            let permit = WriteBorrow::new(\u0026self.flag)?;\n            let value = unsafe { NonNull::new_unchecked(self.value.get()) };\n            Some(RwLockWriteGuard {\n                permit,\n                value,\n                marker: PhantomData,\n            })\n        }\n    }\n\n    unsafe impl\u003cT: Send\u003e Send for RwLock\u003cT\u003e {}\n    unsafe impl\u003cT: Send + Sync\u003e Sync for RwLock\u003cT\u003e {}\n\n    pub(crate) struct RwLockReadGuard\u003c'a, T\u003e {\n        permit: ReadBorrow\u003c'a\u003e,\n        value: NonNull\u003cT\u003e,\n    }\n\n    impl\u003cT\u003e Deref for RwLockReadGuard\u003c'_, T\u003e {\n        type Target = T;\n        fn deref(\u0026self) -\u003e \u0026Self::Target {\n            unsafe { self.value.as_ref() }\n        }\n    }\n\n    impl\u003c'a, T\u003e RwLockReadGuard\u003c'a, T\u003e {\n        pub(crate) fn leak(self) -\u003e \u0026'a T {\n            std::mem::forget(self.permit);\n            unsafe { self.value.as_ref() }\n        }\n    }\n\n    unsafe impl\u003cT: Send\u003e Send for RwLockReadGuard\u003c'_, T\u003e {}\n    unsafe impl\u003cT: Send + Sync\u003e Sync for RwLockReadGuard\u003c'_, T\u003e {}\n\n    struct ReadBorrow\u003c'b\u003e {\n        cell: \u0026'b Cell\u003cBorrowFlag\u003e,\n    }\n\n    impl\u003c'b\u003e ReadBorrow\u003c'b\u003e {\n        fn new(cell: \u0026'b Cell\u003cBorrowFlag\u003e) -\u003e Option\u003cSelf\u003e {\n            let b = cell.get().wrapping_add(1);\n            if is_reading(b) {\n                cell.set(b);\n                Some(Self { cell })\n            } else {\n               None\n            }\n        }\n    }\n\n    impl Drop for ReadBorrow\u003c'_\u003e {\n        fn drop(\u0026mut self) {\n            let b = self.cell.get();\n            self.cell.set(b - 1);\n        }\n    }\n\n    impl Clone for ReadBorrow\u003c'_\u003e {\n        fn clone(\u0026self) -\u003e Self {\n            let b = self.cell.get();\n            self.cell.set(b + 1);\n            Self { cell: self.cell }\n        }\n    }\n\n    pub(crate) struct RwLockWriteGuard\u003c'a, T\u003e {\n        permit: WriteBorrow\u003c'a\u003e,\n        value: NonNull\u003cT\u003e,\n\n        marker: PhantomData\u003c\u0026'a mut T\u003e,\n    }\n\n    impl\u003cT\u003e Deref for RwLockWriteGuard\u003c'_, T\u003e {\n        type Target = T;\n        fn deref(\u0026self) -\u003e \u0026T {\n            // SAFETY: the value is accessible as long as we hold our borrow.\n            unsafe { self.value.as_ref() }\n        }\n    }\n\n    impl\u003cT\u003e DerefMut for RwLockWriteGuard\u003c'_, T\u003e {\n        fn deref_mut(\u0026mut self) -\u003e \u0026mut T {\n            // SAFETY: the value is accessible as long as we hold our borrow.\n            unsafe { self.value.as_mut() }\n        }\n    }\n\n    unsafe impl\u003cT: Send + Sync\u003e Send for RwLockWriteGuard\u003c'_, T\u003e {}\n    unsafe impl\u003cT: Send + Sync\u003e Sync for RwLockWriteGuard\u003c'_, T\u003e {}\n\n    struct WriteBorrow\u003c'b\u003e {\n        cell: \u0026'b Cell\u003cBorrowFlag\u003e,\n    }\n\n    impl\u003c'b\u003e WriteBorrow\u003c'b\u003e {\n        fn new(cell: \u0026'b Cell\u003cBorrowFlag\u003e) -\u003e Option\u003cSelf\u003e {\n            // NOTE: Unlike BorrowRefMut::clone, new is called to create the initial\n            // mutable reference, and so there must currently be no existing\n            // references. Thus, while clone increments the mutable refcount, here\n            // we explicitly only allow going from UNUSED to UNUSED - 1.\n            match cell.get() {\n                UNUSED =\u003e {\n                    cell.set(UNUSED - 1);\n                    Some(Self { cell })\n                }\n                _ =\u003e None,\n            }\n        }\n    }\n\n    impl Drop for WriteBorrow\u003c'_\u003e {\n        fn drop(\u0026mut self) {\n            let b = self.cell.get();\n            self.cell.set(b + 1);\n        }\n    }\n}\n\ncfg_multi_threaded! {\n    pub(crate) use spin::rwlock::*;\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":275984},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":236380},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":137992},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":118187},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":118187},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":118190},"fn_name":null}],"covered":35,"coverable":50},{"path":["/","Users","mk","Developer","rust","des","des","src","sync","swaplock.rs"],"content":"//! Implements a lock, that only provides write access using the swap\n//! method.\n//!\n//! This ensures that writes will not leak any \u0026mut T accordingly W-W conflicts cannot appear.\n//!\n//! # Contract\n//!\n//! All swap operations must be coordianted from a single thread.\n//! -\u003e simulation core runs on only one thread.\n//!\n//! All read handles must be closed when a swap is performed.\n//! -\u003e Swaps happen inbetween events, while read handles are only handed out in\n//! the event processing itself. Additionaly read handles are not leaked to the user\n//! so we can ensure all are closed at event end.\n\nuse std::sync::atomic::Ordering::SeqCst;\nuse std::{cell::UnsafeCell, marker::PhantomData, ops::Deref, rc::Rc};\n\nuse super::AtomicUsize;\n\n/// A lock that can only be accessed mutably by swapping the contents.\npub(crate) struct SwapLock\u003cT\u003e {\n    inner: UnsafeCell\u003cT\u003e,\n    read_count: AtomicUsize,\n}\n\nimpl\u003cT\u003e SwapLock\u003cT\u003e {\n    pub(crate) const fn new(inner: T) -\u003e Self {\n        Self {\n            inner: UnsafeCell::new(inner),\n            read_count: AtomicUsize::new(0),\n        }\n    }\n\n    pub(crate) unsafe fn reset(\u0026self, inner: T) {\n        *self.inner.get() = inner;\n        self.read_count.store(0, SeqCst);\n    }\n\n    pub(crate) fn swap(\u0026self, other: \u0026mut T) {\n        // SAFTEY REASONS\n        assert!(\n            self.read_count.load(SeqCst) == 0,\n            \"SwapLock cannot swap, since {} read handles are still alive\",\n            self.read_count.load(SeqCst)\n        );\n\n        let inner = unsafe { \u0026mut *self.inner.get() };\n        std::mem::swap(inner, other);\n    }\n\n    pub(crate) fn read(\u0026self) -\u003e SwapLockReadGuard\u003c'_, T\u003e {\n        SwapLockReadGuard::new(self)\n    }\n}\n\nunsafe impl\u003cT: Send\u003e Send for SwapLock\u003cT\u003e {}\nunsafe impl\u003cT: Sync\u003e Sync for SwapLock\u003cT\u003e {}\n\npub(crate) struct SwapLockReadGuard\u003c'a, T\u003e {\n    lock: \u0026'a SwapLock\u003cT\u003e,\n    _phantom: PhantomData\u003cRc\u003cT\u003e\u003e,\n}\n\nimpl\u003c'a, T\u003e SwapLockReadGuard\u003c'a, T\u003e {\n    fn new(lock: \u0026'a SwapLock\u003cT\u003e) -\u003e Self {\n        let ptr: *const SwapLock\u003cT\u003e = lock;\n        lock.read_count.fetch_add(1, SeqCst);\n        Self {\n            lock,\n            _phantom: PhantomData,\n        }\n    }\n\n    pub(crate) fn as_real_inner(\u0026self) -\u003e \u0026T {\n        unsafe { \u0026(*self.lock.inner.get()) }\n    }\n}\n\nimpl\u003c'a, T\u003e Deref for SwapLockReadGuard\u003c'a, T\u003e {\n    type Target = T;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        unsafe {\n            \u0026(*self.lock.inner.get())\n        }\n    }\n}\n\nimpl\u003c'a, T\u003e Drop for SwapLockReadGuard\u003c'a, T\u003e {\n    fn drop(\u0026mut self) {\n        let ptr: *const SwapLock\u003cT\u003e = self.lock;\n        self.lock.read_count.fetch_sub(1, SeqCst);\n    }\n}\n\nunsafe impl\u003cT: Sync\u003e Sync for SwapLockReadGuard\u003c'_, T\u003e {}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":356},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":356},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":356},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":9362},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":7268},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":7268},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":6365},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":13633},"fn_name":null}],"covered":20,"coverable":24},{"path":["/","Users","mk","Developer","rust","des","des","src","time","driver.rs"],"content":"use super::SimTime;\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::sync::{Arc, Weak};\nuse std::task::Waker;\n\nthread_local! {\n    static TIME_CTX: RefCell\u003cOption\u003cDriver\u003e\u003e = const { RefCell::new(None)}\n}\n\n#[derive(Debug)]\npub(crate) struct Driver {\n    pub(crate) next_wakeup: SimTime,\n    pub(super) queue: Arc\u003cTimerQueue\u003e,\n}\n\n#[derive(Debug)]\npub(super) struct TimerQueue {\n    cur: RefCell\u003cSimTime\u003e,\n    pending: RefCell\u003cVecDeque\u003cArc\u003cTimerSlot\u003e\u003e\u003e,\n}\n\n#[derive(Debug)]\npub(crate) struct TimerSlot {\n    time: SimTime,\n    entrys: RefCell\u003cVec\u003cTimerSlotEntry\u003e\u003e,\n    queue: Arc\u003cTimerQueue\u003e,\n}\n\n#[derive(Debug)]\npub(super) struct TimerSlotEntry {\n    pub(super) waker: Waker,\n    pub(super) id: usize,\n}\n\n#[derive(Debug)]\npub(super) struct TimerSlotEntryHandle {\n    id: usize,\n    resolved: bool,\n    handle: Weak\u003cTimerSlot\u003e,\n}\n\nimpl Drop for TimerSlotEntryHandle {\n    fn drop(\u0026mut self) {\n        if !self.resolved {\n            let Some(handle) = self.handle.upgrade() else {\n                Driver::with_current(|driver| println!(\"[{}] {:?}\", SimTime::now(), driver.queue));\n                return;\n            };\n            let _ = handle.remove(self.id);\n        }\n    }\n}\n\nimpl Driver {\n    pub(crate) fn new() -\u003e Self {\n        Self {\n            next_wakeup: SimTime::MAX,\n            queue: Arc::new(TimerQueue::new()),\n        }\n    }\n\n    pub(crate) fn set(self) -\u003e Option\u003cDriver\u003e {\n        TIME_CTX.with(|ctx| ctx.borrow_mut().replace(self))\n    }\n\n    pub(crate) fn unset() -\u003e Option\u003cDriver\u003e {\n        TIME_CTX.with(|ctx| ctx.borrow_mut().take())\n    }\n\n    pub(crate) fn next(\u0026self) -\u003e Option\u003cSimTime\u003e {\n        self.queue.next()\n    }\n\n    pub(crate) fn bump(\u0026self) -\u003e Vec\u003cTimerSlot\u003e {\n        self.queue.bump()\n    }\n\n    pub(super) fn with_current\u003cR\u003e(f: impl FnOnce(\u0026mut Driver) -\u003e R) -\u003e R {\n        TIME_CTX.with(|ctx| {\n            f(ctx\n                .borrow_mut()\n                .as_mut()\n                .expect(\"no IO time driver provided\"))\n        })\n    }\n}\n\nimpl TimerQueue {\n    fn new() -\u003e Self {\n        Self {\n            cur: RefCell::new(SimTime::ZERO),\n            pending: RefCell::new(VecDeque::new()),\n        }\n    }\n\n    pub(super) fn add(\n        self: \u0026Arc\u003cTimerQueue\u003e,\n        entry: TimerSlotEntry,\n        time: SimTime,\n    ) -\u003e TimerSlotEntryHandle {\n        let mut pending = self.pending.borrow_mut();\n        let id = entry.id;\n\n        match pending.binary_search_by(|slot| slot.time.cmp(\u0026time)) {\n            Ok(found) =\u003e {\n                pending[found].add(entry);\n                TimerSlotEntryHandle {\n                    id,\n                    handle: Arc::downgrade(\u0026pending[found]),\n                    resolved: false,\n                }\n            }\n            Err(insert_at) =\u003e {\n                let slot = TimerSlot::new(time, self.clone());\n                slot.add(entry);\n\n                pending.insert(insert_at, Arc::new(slot));\n                TimerSlotEntryHandle {\n                    id,\n                    handle: Arc::downgrade(\u0026pending[insert_at]),\n                    resolved: false,\n                }\n            }\n        }\n    }\n\n    pub(super) fn next(\u0026self) -\u003e Option\u003cSimTime\u003e {\n        self.pending\n            .borrow()\n            .front()\n            .filter(|slot| !slot.entrys.borrow().is_empty())\n            .map(|s| s.time)\n    }\n\n    pub(crate) fn bump(\u0026self) -\u003e Vec\u003cTimerSlot\u003e {\n        let cur = SimTime::now();\n        *self.cur.borrow_mut() = cur;\n        if self\n            .pending\n            .borrow()\n            .front()\n            .map_or(false, |slot| slot.time \u003c= cur)\n        {\n            let mut buffer = Vec::new();\n            let mut pending = self.pending.borrow_mut();\n            while pending\n                .front()\n                .map(|slot| slot.time \u003c= cur)\n                .unwrap_or(false)\n            {\n                let Ok(slot) = Arc::try_unwrap(pending.pop_front().expect(\"unreachable\")) else {\n                    continue;\n                };\n                buffer.push(slot)\n            }\n            buffer\n        } else {\n            Vec::new()\n        }\n    }\n}\n\nimpl TimerSlot {\n    fn new(time: SimTime, queue: Arc\u003cTimerQueue\u003e) -\u003e Self {\n        Self {\n            time,\n            queue,\n            entrys: RefCell::new(Vec::with_capacity(2)),\n        }\n    }\n\n    fn add(\u0026self, entry: TimerSlotEntry) {\n        println!(\"\u003e\u003e adding to timer slot {}\", self.time);\n        self.entrys.borrow_mut().push(entry);\n    }\n\n    fn remove(\u0026self, id: usize) -\u003e Option\u003cTimerSlotEntry\u003e {\n        println!(\"\u003e\u003e removing from timer slot {}\", self.time);\n        let mut entries = self.entrys.borrow_mut();\n        for i in 0..entries.len() {\n            if entries[i].id == id {\n                return Some(entries.remove(i));\n            }\n        }\n\n        None\n    }\n\n    pub(crate) fn wake_all(self) {\n        self.entrys\n            .into_inner()\n            .into_iter()\n            .for_each(|entry| entry.waker.wake());\n    }\n}\n\nimpl TimerSlotEntryHandle {\n    pub(super) fn resolve(\u0026mut self) {\n        self.resolved = true;\n    }\n\n    pub(super) fn reset(self, new_deadline: SimTime) -\u003e Option\u003cTimerSlotEntryHandle\u003e {\n        let handle = self.handle.upgrade()?;\n        let entry = handle.remove(self.id)?;\n        Some(handle.queue.add(entry, new_deadline))\n    }\n}\n\nunsafe impl Send for TimerSlotEntry {}\nunsafe impl Send for TimerSlotEntryHandle {}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":14124},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":4699},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":14097},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":484},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":494},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4476},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":9238},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":9219},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":4708},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":9697},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":474},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":474},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":721},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":474},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":4471},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":703},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":69,"coverable":80},{"path":["/","Users","mk","Developer","rust","des","des","src","time","duration.rs"],"content":"/// A Duration type to represent a span of time.\npub use std::time::Duration;\n\nuse super::SimTime;\nuse std::ops::{Add, AddAssign};\n\nimpl Add\u003cDuration\u003e for SimTime {\n    type Output = SimTime;\n\n    fn add(self, rhs: Duration) -\u003e Self::Output {\n        self.checked_add(rhs)\n            .expect(\"Overflow when adding Duration to SimTime\")\n    }\n}\n\nimpl AddAssign\u003cDuration\u003e for SimTime {\n    fn add_assign(\u0026mut self, rhs: Duration) {\n        self.0.add_assign(rhs);\n    }\n}\n\n// f64\n\nimpl Add\u003cf64\u003e for SimTime {\n    type Output = SimTime;\n\n    fn add(self, rhs: f64) -\u003e Self::Output {\n        self.checked_add(Duration::from_secs_f64(rhs))\n            .expect(\"Overflow when adding Duration to SimTime\")\n    }\n}\n\nimpl AddAssign\u003cf64\u003e for SimTime {\n    fn add_assign(\u0026mut self, rhs: f64) {\n        self.0.add_assign(Duration::from_secs_f64(rhs));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn addition() {\n        let mut time = SimTime::from(14.2);\n        let duration = 3.4;\n\n        assert_eq!(time + duration, SimTime::from(17.6));\n        time += duration;\n        assert_eq!(time, SimTime::from(17.6));\n\n        let mut time = SimTime::from(14.2);\n        let duration = Duration::from_secs_f64(3.4);\n\n        assert_eq!(time + duration, SimTime::from(17.6));\n        time += duration;\n        assert_eq!(time, SimTime::from(17.6));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":5635},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":5635},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":100129},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":100129},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","Users","mk","Developer","rust","des","des","src","time","error.rs"],"content":"//! Time error types.\nuse std::fmt;\n\n/// Errors returned by `Timeout`.\n///\n/// This error is returned when a timeout expires before the function was able\n/// to finish.\n#[derive(Debug, PartialEq, Eq)]\npub struct Elapsed(());\n\n// ===== impl Elapsed =====\n\nimpl Elapsed {\n    pub(crate) fn new() -\u003e Self {\n        Elapsed(())\n    }\n}\n\nimpl fmt::Display for Elapsed {\n    fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        \"deadline has elapsed\".fmt(fmt)\n    }\n}\n\nimpl std::error::Error for Elapsed {}\n\nimpl From\u003cElapsed\u003e for std::io::Error {\n    fn from(_err: Elapsed) -\u003e std::io::Error {\n        std::io::ErrorKind::TimedOut.into()\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":6},{"path":["/","Users","mk","Developer","rust","des","des","src","time","interval.rs"],"content":"use super::{sleep_until, SimTime, Sleep};\nuse std::convert::TryInto;\nuse std::future::{poll_fn, Future};\nuse std::pin::Pin;\nuse std::task::{ready, Context, Poll};\nuse std::time::Duration;\n\n/// Creates new [`Interval`] that yields with interval of `period`. The first\n/// tick completes immediately. The default [`MissedTickBehavior`] is\n/// [`Burst`](MissedTickBehavior::Burst), but this can be configured\n/// by calling [`set_missed_tick_behavior`](Interval::set_missed_tick_behavior).\n///\n/// An interval will tick indefinitely. At any time, the [`Interval`] value can\n/// be dropped. This cancels the interval.\n///\n/// This function is equivalent to\n/// [`interval_at(Instant::now(), period)`](interval_at).\n///\n/// # Panics\n///\n/// This function panics if `period` is zero.\n///\n/// A simple example using `interval` to execute a task every two seconds.\n///\n/// The difference between `interval` and [`sleep`] is that an [`Interval`]\n/// measures the time since the last tick, which means that [`.tick().await`]\n/// may wait for a shorter time than the duration specified for the interval\n/// if some time has passed between calls to [`.tick().await`].\n///\n/// If the tick in the example below was replaced with [`sleep`], the task\n/// would only be executed once every three seconds, and not every two\n/// seconds.\n///\n/// [`sleep`]: crate::time::sleep()\n/// [`.tick().await`]: Interval::tick\n#[track_caller]\npub fn interval(period: Duration) -\u003e Interval {\n    assert!(period \u003e Duration::new(0, 0), \"`period` must be non-zero.\");\n    internal_interval_at(SimTime::now(), period)\n}\n\n/// Creates new [`Interval`] that yields with interval of `period` with the\n/// first tick completing at `start`. The default [`MissedTickBehavior`] is\n/// [`Burst`](MissedTickBehavior::Burst), but this can be configured\n/// by calling [`set_missed_tick_behavior`](Interval::set_missed_tick_behavior).\n///\n/// An interval will tick indefinitely. At any time, the [`Interval`] value can\n/// be dropped. This cancels the interval.\n///\n/// # Panics\n///\n/// This function panics if `period` is zero.\n///\n#[track_caller]\npub fn interval_at(start: SimTime, period: Duration) -\u003e Interval {\n    assert!(period \u003e Duration::new(0, 0), \"`period` must be non-zero.\");\n    internal_interval_at(start, period)\n}\n\n#[cfg_attr(not(all(tokio_unstable, feature = \"tracing\")), allow(unused_variables))]\nfn internal_interval_at(start: SimTime, period: Duration) -\u003e Interval {\n    let delay = Box::pin(sleep_until(start));\n\n    Interval {\n        delay,\n        period,\n        missed_tick_behavior: MissedTickBehavior::default(),\n    }\n}\n\n/// Defines the behavior of an [`Interval`] when it misses a tick.\n///\n/// Generally, a tick is missed if too much time is spent without calling\n/// [`Interval::tick()`].\n///\n/// By default, when a tick is missed, [`Interval`] fires ticks as quickly as it\n/// can until it is \"caught up\" in time to where it should be.\n/// `MissedTickBehavior` can be used to specify a different behavior for\n/// [`Interval`] to exhibit. Each variant represents a different strategy.\n///\n/// Note that because the executor cannot guarantee exact precision with timers,\n/// these strategies will only apply when the delay is greater than 5\n/// milliseconds.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum MissedTickBehavior {\n    /// Ticks as fast as possible until caught up.\n    ///\n    /// When this strategy is used, [`Interval`] schedules ticks \"normally\" (the\n    /// same as it would have if the ticks hadn't been delayed), which results\n    /// in it firing ticks as fast as possible until it is caught up in time to\n    /// where it should be. Unlike [`Delay`] and [`Skip`], the ticks yielded\n    /// when `Burst` is used (the [`SimTime`](crate::time::SimTime)s that [`tick`](Interval::tick)\n    /// yields) aren't different than they would have been if a tick had not\n    /// been missed. Like [`Skip`], and unlike [`Delay`], the ticks may be\n    /// shortened.\n    ///\n    /// This looks something like this:\n    /// ```text\n    /// Expected ticks: |     1     |     2     |     3     |     4     |     5     |     6     |\n    /// Actual ticks:   | work -----|          delay          | work | work | work -| work -----|\n    /// ```\n    ///\n    /// This is the default behavior when [`Interval`] is created with\n    /// [`interval`] and [`interval_at`].\n    ///\n    /// [`Delay`]: MissedTickBehavior::Delay\n    /// [`Skip`]: MissedTickBehavior::Skip\n    Burst,\n\n    /// Tick at multiples of `period` from when [`tick`] was called, rather than\n    /// from `start`.\n    ///\n    /// When this strategy is used and [`Interval`] has missed a tick, instead\n    /// of scheduling ticks to fire at multiples of `period` from `start` (the\n    /// time when the first tick was fired), it schedules all future ticks to\n    /// happen at a regular `period` from the point when [`tick`] was called.\n    /// Unlike [`Burst`] and [`Skip`], ticks are not shortened, and they aren't\n    /// guaranteed to happen at a multiple of `period` from `start` any longer.\n    ///\n    /// This looks something like this:\n    /// ```text\n    /// Expected ticks: |     1     |     2     |     3     |     4     |     5     |     6     |\n    /// Actual ticks:   | work -----|          delay          | work -----| work -----| work -----|\n    /// ```\n    ///\n    /// [`Burst`]: MissedTickBehavior::Burst\n    /// [`Skip`]: MissedTickBehavior::Skip\n    /// [`tick`]: Interval::tick\n    Delay,\n\n    /// Skips missed ticks and tick on the next multiple of `period` from\n    /// `start`.\n    ///\n    /// When this strategy is used, [`Interval`] schedules the next tick to fire\n    /// at the next-closest tick that is a multiple of `period` away from\n    /// `start` (the point where [`Interval`] first ticked). Like [`Burst`], all\n    /// ticks remain multiples of `period` away from `start`, but unlike\n    /// [`Burst`], the ticks may not be *one* multiple of `period` away from the\n    /// last tick. Like [`Delay`], the ticks are no longer the same as they\n    /// would have been if ticks had not been missed, but unlike [`Delay`], and\n    /// like [`Burst`], the ticks may be shortened to be less than one `period`\n    /// away from each other.\n    ///\n    /// This looks something like this:\n    /// ```text\n    /// Expected ticks: |     1     |     2     |     3     |     4     |     5     |     6     |\n    /// Actual ticks:   | work -----|          delay          | work ---| work -----| work -----|\n    /// ```\n    ///\n    /// [`Burst`]: MissedTickBehavior::Burst\n    /// [`Delay`]: MissedTickBehavior::Delay\n    Skip,\n}\n\nimpl MissedTickBehavior {\n    /// If a tick is missed, this method is called to determine when the next tick should happen.\n    fn next_timeout(self, timeout: SimTime, now: SimTime, period: Duration) -\u003e SimTime {\n        match self {\n            Self::Burst =\u003e timeout + period,\n            Self::Delay =\u003e now + period,\n            Self::Skip =\u003e {\n                now + period\n                    - Duration::from_nanos(\n                        ((now - timeout).as_nanos() % period.as_nanos())\n                            .try_into()\n                            // This operation is practically guaranteed not to\n                            // fail, as in order for it to fail, `period` would\n                            // have to be longer than `now - timeout`, and both\n                            // would have to be longer than 584 years.\n                            //\n                            // If it did fail, there's not a good way to pass\n                            // the error along to the user, so we just panic.\n                            .expect(\n                                \"too much time has elapsed since the interval was supposed to tick\",\n                            ),\n                    )\n            }\n        }\n    }\n}\n\nimpl Default for MissedTickBehavior {\n    /// Returns [`MissedTickBehavior::Burst`].\n    ///\n    /// For most usecases, the [`Burst`] strategy is what is desired.\n    /// Additionally, to preserve backwards compatibility, the [`Burst`]\n    /// strategy must be the default. For these reasons,\n    /// [`MissedTickBehavior::Burst`] is the default for [`MissedTickBehavior`].\n    /// See [`Burst`] for more details.\n    ///\n    /// [`Burst`]: MissedTickBehavior::Burst\n    fn default() -\u003e Self {\n        Self::Burst\n    }\n}\n\n/// Interval returned by [`interval`] and [`interval_at`].\n///\n/// This type allows you to wait on a sequence of instants with a certain\n/// duration between each instant. Unlike calling [`sleep`] in a loop, this lets\n/// you count the time spent between the calls to [`sleep`] as well.\n///\n/// An `Interval` can be turned into a `Stream` with [`IntervalStream`].\n///\n/// [`IntervalStream`]: https://docs.rs/tokio-stream/latest/tokio_stream/wrappers/struct.IntervalStream.html\n/// [`sleep`]: crate::time::sleep()\n#[derive(Debug)]\n#[must_use = \"futures do nothing unless you `.await` or poll them\"]\npub struct Interval {\n    /// Future that completes the next time the `Interval` yields a value.\n    delay: Pin\u003cBox\u003cSleep\u003e\u003e,\n\n    /// The duration between values yielded by `Interval`.\n    period: Duration,\n\n    /// The strategy `Interval` should use when a tick is missed.\n    missed_tick_behavior: MissedTickBehavior,\n}\n\nimpl Interval {\n    /// Completes when the next instant in the interval has been reached.\n    ///\n    /// # Cancel safety\n    ///\n    /// This method is cancellation safe. If `tick` is used as the branch in a `tokio::select!` and\n    /// another branch completes first, then no tick has been consumed.\n    pub async fn tick(\u0026mut self) -\u003e SimTime {\n        let instant = poll_fn(|cx| self.poll_tick(cx));\n        instant.await\n    }\n\n    /// Polls for the next instant in the interval to be reached.\n    ///\n    /// This method can return the following values:\n    ///\n    ///  * `Poll::Pending` if the next instant has not yet been reached.\n    ///  * `Poll::Ready(instant)` if the next instant has been reached.\n    ///\n    /// When this method returns `Poll::Pending`, the current task is scheduled\n    /// to receive a wakeup when the instant has elapsed. Note that on multiple\n    /// calls to `poll_tick`, only the [`Waker`](std::task::Waker) from the\n    /// [`Context`] passed to the most recent call is scheduled to receive a\n    /// wakeup.\n    pub fn poll_tick(\u0026mut self, cx: \u0026mut Context\u003c'_\u003e) -\u003e Poll\u003cSimTime\u003e {\n        // Wait for the delay to be done\n        ready!(Pin::new(\u0026mut self.delay).poll(cx));\n\n        // Get the time when we were scheduled to tick\n        let timeout = self.delay.deadline();\n\n        let now = SimTime::now();\n\n        // If a tick was not missed, and thus we are being called before the\n        // next tick is due, just schedule the next tick normally, one `period`\n        // after `timeout`\n        //\n        // However, if a tick took excessively long and we are now behind,\n        // schedule the next tick according to how the user specified with\n        // `MissedTickBehavior`\n        let next = if now \u003e timeout + Duration::from_millis(5) {\n            self.missed_tick_behavior\n                .next_timeout(timeout, now, self.period)\n        } else {\n            timeout + self.period\n        };\n\n        self.delay.as_mut().reset(next);\n\n        // Return the time when we were scheduled to tick\n        Poll::Ready(timeout)\n    }\n\n    /// Resets the interval to complete one period after the current time.\n    ///\n    /// This method ignores [`MissedTickBehavior`] strategy.\n    pub fn reset(\u0026mut self) {\n        self.delay.as_mut().reset(SimTime::now() + self.period);\n    }\n\n    /// Returns the [`MissedTickBehavior`] strategy currently being used.\n    #[must_use]\n    pub fn missed_tick_behavior(\u0026self) -\u003e MissedTickBehavior {\n        self.missed_tick_behavior\n    }\n\n    /// Sets the [`MissedTickBehavior`] strategy that should be used.\n    pub fn set_missed_tick_behavior(\u0026mut self, behavior: MissedTickBehavior) {\n        self.missed_tick_behavior = behavior;\n    }\n\n    /// Returns the period of the interval.\n    #[must_use]\n    pub fn period(\u0026self) -\u003e Duration {\n        self.period\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":471},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":343},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":35,"coverable":40},{"path":["/","Users","mk","Developer","rust","des","des","src","time","mod.rs"],"content":"//!\n//! Temporal quantification in a simulation context.\n//!\n//! Note that the implementation of [`SimTime`] depends on the features that\n//! are active. If features \"async\" is active, tokio provides an implementation\n//! for [`SimTime`] based on its internal feature \"sim\". If not a drop-in replacement\n//! is provided by des.\n//!\n//! # Examples\n//!\n//! A [`Duration`] describes a span of time, either in the context of\n//! real [`SystemTime`](std::time::SystemTime) or provided [`SimTime`].\n//! There are mutiple ways to create a new [`Duration`].\n//!\n//! ```rust\n//! # use des::time::*;\n//! let five_seconds = Duration::from_secs(5);\n//! assert_eq!(five_seconds, Duration::from_millis(5_000));\n//! assert_eq!(five_seconds, Duration::from_micros(5_000_000));\n//! assert_eq!(five_seconds, Duration::from_nanos(5_000_000_000));\n//!\n//! let ten_seconds = Duration::from_secs(10);\n//! let seven_nanos = Duration::from_nanos(7);\n//! let total = ten_seconds + seven_nanos;\n//! assert_eq!(total, Duration::new(10, 7));\n//! ```\n\nmod duration;\npub use duration::*;\n\nuse crate::sync::RwLock;\nuse std::f64::EPSILON;\nuse std::fmt::{Debug, Display};\nuse std::ops::{Deref, Div, Sub, SubAssign};\n\ncfg_async! {\n    pub mod error;\n\n    mod driver;\n    pub(crate) use driver::*;\n\n    mod sleep;\n    pub use sleep::*;\n\n    mod timeout;\n    pub use timeout::*;\n\n    mod interval;\n    pub use interval::*;\n}\n\nstatic SIMTIME: RwLock\u003cSimTime\u003e = RwLock::new(SimTime::ZERO);\n\n///\n/// A specific point of time in the simulation.\n///\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct SimTime(Duration);\n\nimpl SimTime {\n    /// Returns an instant corresponding to \"now\" in the simulation context.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use des::prelude::SimTime;\n    ///\n    /// let now = SimTime::now();\n    /// ```\n    #[must_use]\n    pub fn now() -\u003e Self {\n        *SIMTIME.read()\n    }\n\n    ///\n    /// Sets the sim time\n    ///\n    pub(crate) fn set_now(time: SimTime) {\n        *SIMTIME.write() = time;\n    }\n\n    ///\n    /// Constructs an instance of `SimTime` from a give duration since `SimTime::ZERO`.\n    ///\n    #[must_use]\n    pub const fn from_duration(duration: Duration) -\u003e Self {\n        Self(duration)\n    }\n\n    ///\n    /// Makes an equallity check with an error margin.\n    ///\n    #[must_use]\n    pub fn eq_approx(\u0026self, other: SimTime, error: Duration) -\u003e bool {\n        let dur = self.duration_diff(other);\n        dur \u003c error\n    }\n\n    /// Retursn the amount of time elapsed from the earlier of the two values\n    /// to the higher.\n    #[must_use]\n    pub fn duration_diff(\u0026self, other: SimTime) -\u003e Duration {\n        if *self \u003e other {\n            self.duration_since(other)\n        } else {\n            other.duration_since(*self)\n        }\n    }\n\n    /// Returns the amount of time elapsed from another instant to this one,\n    /// or zero duration if that instant is later than this one.\n    ///\n    /// # Panics\n    ///\n    /// This function  panics of the checked operation fails.\n    #[must_use]\n    pub fn duration_since(\u0026self, earlier: SimTime) -\u003e Duration {\n        self.checked_duration_since(earlier)\n            .expect(\"duration subtraction invalid\")\n    }\n\n    /// Returns the amount of time elapsed from another instant to this one,\n    /// or None if that instant is later than this one.\n    #[must_use]\n    pub fn checked_duration_since(\u0026self, earlier: SimTime) -\u003e Option\u003cDuration\u003e {\n        self.0.checked_sub(earlier.0)\n    }\n\n    /// Returns the amount of time elapsed from another instant to this one,\n    /// or zero duration if that instant is later than this one.\n    #[must_use]\n    pub fn saturating_duration_since(\u0026self, earlier: SimTime) -\u003e Duration {\n        self.checked_duration_since(earlier).unwrap_or_default()\n    }\n\n    /// Returns the amount of time elapsed since this instant was created.\n    #[must_use]\n    pub fn elapsed(\u0026self) -\u003e Duration {\n        Self::now() - *self\n    }\n\n    /// Returns `Some(t)` where `t` is the time `self + duration` if `t` can be represented as\n    /// `Instant` (which means it's inside the bounds of the underlying data structure), `None`\n    /// otherwise.\n    #[must_use]\n    pub fn checked_add(\u0026self, duration: Duration) -\u003e Option\u003cSimTime\u003e {\n        self.0.checked_add(duration).map(SimTime)\n    }\n\n    /// Returns `Some(t)` where `t` is the time `self - duration` if `t` can be represented as\n    /// `Instant` (which means it's inside the bounds of the underlying data structure), `None`\n    /// otherwise.\n    #[must_use]\n    pub fn checked_sub(\u0026self, duration: Duration) -\u003e Option\u003cSimTime\u003e {\n        self.0.checked_sub(duration).map(SimTime)\n    }\n}\n\n// # Custom Additions\nimpl SimTime {\n    /// The smallest instance of a [`SimTime`].\n    pub const ZERO: SimTime = SimTime(Duration::ZERO);\n    /// The smallest valid instance of a [`SimTime`].\n    pub const MIN: SimTime = SimTime(Duration::ZERO);\n    /// The greatest instance of a [`SimTime`].\n    pub const MAX: SimTime = SimTime(Duration::MAX);\n}\n\n// CMP\n\nimpl PartialEq\u003cf64\u003e for SimTime {\n    fn eq(\u0026self, other: \u0026f64) -\u003e bool {\n        let diff = (self.0.as_secs_f64() - *other).abs();\n        diff \u003c EPSILON\n    }\n}\n\n// OPS\n\nimpl Sub\u003cDuration\u003e for SimTime {\n    type Output = SimTime;\n\n    fn sub(self, rhs: Duration) -\u003e Self::Output {\n        self.checked_sub(rhs)\n            .expect(\"Overflow when substracting Duration from SimTime\")\n    }\n}\n\nimpl SubAssign\u003cDuration\u003e for SimTime {\n    fn sub_assign(\u0026mut self, rhs: Duration) {\n        *self = *self - rhs;\n    }\n}\n\nimpl Sub\u003cSimTime\u003e for SimTime {\n    type Output = Duration;\n\n    fn sub(self, rhs: SimTime) -\u003e Self::Output {\n        self.duration_since(rhs)\n    }\n}\n\nimpl Div\u003cSimTime\u003e for SimTime {\n    type Output = f64;\n\n    fn div(self, rhs: SimTime) -\u003e Self::Output {\n        self.0.as_secs_f64() / rhs.0.as_secs_f64()\n    }\n}\n\nimpl Div\u003cf64\u003e for SimTime {\n    type Output = SimTime;\n\n    fn div(self, rhs: f64) -\u003e Self::Output {\n        Self::from(self.0.as_secs_f64() / rhs)\n    }\n}\n\n// DEREF\n\nimpl Deref for SimTime {\n    type Target = Duration;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\n// FMT\n\nimpl Debug for SimTime {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        Debug::fmt(\u0026self.0, f)\n    }\n}\n\nimpl Display for SimTime {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        Debug::fmt(\u0026self.0, f)\n    }\n}\n\n// FROM\n\nimpl From\u003cSimTime\u003e for f64 {\n    fn from(this: SimTime) -\u003e Self {\n        this.0.as_secs_f64()\n    }\n}\n\nimpl From\u003cf64\u003e for SimTime {\n    fn from(value: f64) -\u003e Self {\n        SimTime(Duration::from_secs_f64(value))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ops() {\n        assert_eq!(\n            f64::from(SimTime::from_duration(Duration::from_millis(300))),\n            0.3\n        );\n\n        assert_eq!(SimTime::from(60.0) / 3.0, SimTime::from(20.0));\n        assert_eq!(SimTime::from(60.0) / SimTime::from(3.0), 20.0);\n\n        assert_eq!(\n            SimTime::from(30.0) - SimTime::from(10.0),\n            Duration::from_secs(20)\n        );\n        assert_eq!(SimTime::from(30.0) - Duration::from_secs(10), 20.0);\n        let mut time = SimTime::from(30.0);\n        time -= Duration::from_secs(10);\n        assert_eq!(time, 20.0);\n    }\n}\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":137980},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":137980},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":118178},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":118178},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":118050},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":118050},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":5770},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":5770},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":118191},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":118191},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":555},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":555},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":72},"fn_name":null}],"covered":39,"coverable":48},{"path":["/","Users","mk","Developer","rust","des","des","src","time","sleep.rs"],"content":"use super::{\n    driver::{Driver, TimerSlotEntry, TimerSlotEntryHandle},\n    SimTime,\n};\nuse pin_project_lite::pin_project;\nuse std::{\n    cmp::Ordering, future::Future, pin::Pin, sync::atomic::AtomicUsize, task::Poll, time::Duration,\n};\n\n/// Waits until `duration` has elapsed.\n///\n/// Equivalent to `sleep_until(Instant::now() + duration)`. An asynchronous\n/// analog to `std::thread::sleep`.\n///\n/// No work is performed while awaiting on the sleep future to complete. `Sleep`\n/// operates at millisecond granularity and should not be used for tasks that\n/// require high-resolution timers. The implementation is platform specific,\n/// and some platforms (specifically Windows) will provide timers with a\n/// larger resolution than 1 ms.\n///\n/// To run something regularly on a schedule, see [`interval`].\n///\n/// The maximum duration for a sleep is 68719476734 milliseconds (approximately 2.2 years).\n///\n/// # Cancellation\n///\n/// Canceling a sleep instance is done by dropping the returned future. No additional\n/// cleanup work is required.\n///\n/// # Panics\n///\n/// This function panics whenever a timer is created outside of a\n/// Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,\n/// since the function is executed outside of the runtime.\n/// Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.\n/// And this is because wrapping the function on an async makes it lazy,\n/// and so gets executed inside the runtime successfully without\n/// panicking.\n///\n/// [`Sleep`]: struct@crate::time::Sleep\n/// [`interval`]: crate::time::interval()\n/// [`Builder::enable_time`]: crate::runtime::Builder::enable_time\n/// [`Builder::enable_all`]: crate::runtime::Builder::enable_all\npub fn sleep(duration: Duration) -\u003e Sleep {\n    match SimTime::now().checked_add(duration) {\n        Some(deadline) =\u003e Sleep::new(deadline),\n        None =\u003e Sleep::far_future(),\n    }\n}\n\n/// Waits until `deadline` is reached.\n///\n/// No work is performed while awaiting on the sleep future to complete. `Sleep`\n/// operates at millisecond granularity and should not be used for tasks that\n/// require high-resolution timers.\n///\n/// To run something regularly on a schedule, see [`interval`].\n///\n/// # Cancellation\n///\n/// Canceling a sleep instance is done by dropping the returned future. No additional\n/// cleanup work is required.\n///\n/// # Panics\n///\n/// This function panics whenever a timer is created outside of a\n/// Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,\n/// since the function is executed outside of the runtime.\n/// Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.\n/// And this is because wrapping the function on an async makes it lazy,\n/// and so gets executed inside the runtime successfully without\n/// panicking.\n///\n/// [`Sleep`]: struct@crate::time::Sleep\n/// [`interval`]: crate::time::interval()\n/// [`Builder::enable_time`]: crate::runtime::Builder::enable_time\n/// [`Builder::enable_all`]: crate::runtime::Builder::enable_all\npub fn sleep_until(deadline: SimTime) -\u003e Sleep {\n    Sleep::new(deadline)\n}\n\npin_project! {\n    /// Future returned by [`sleep`](sleep) and [`sleep_until`](sleep_until).\n    ///\n    /// This type does not implement the `Unpin` trait, which means that if you\n    /// use it with [`select!`] or by calling `poll`, you have to pin it first.\n    /// If you use it with `.await`, this does not apply.\n    ///\n    #[project(!Unpin)]\n    #[must_use  = \"futures do nothing unless you `.await` or poll them\"]\n    #[derive(Debug)]\n    pub struct Sleep {\n        deadline: SimTime,\n        id: usize,\n\n        #[pin]\n        handle: Option\u003cTimerSlotEntryHandle\u003e\n    }\n}\n\nstatic SLEEP_ID: AtomicUsize = AtomicUsize::new(0);\n\nimpl Sleep {\n    pub(super) fn new(deadline: SimTime) -\u003e Sleep {\n        let next = SLEEP_ID.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n        Sleep {\n            deadline,\n            id: next,\n            handle: None,\n        }\n    }\n\n    pub(super) fn far_future() -\u003e Sleep {\n        Self::new(SimTime::MAX)\n    }\n\n    /// Returns the instant at which the future will complete.\n    #[must_use]\n    pub fn deadline(\u0026self) -\u003e SimTime {\n        self.deadline\n    }\n\n    /// Returns `true` if `Sleep` has elapsed.\n    ///\n    /// A `Sleep` instance is elapsed when the requested duration has elapsed.\n    #[must_use]\n    pub fn is_elapsed(\u0026self) -\u003e bool {\n        self.deadline \u003c= SimTime::now()\n    }\n\n    /// Resets the `Sleep` instance to a new deadline.\n    ///\n    /// Calling this function allows changing the instant at which the `Sleep`\n    /// future completes without having to create new associated state.\n    ///\n    /// This function can be called both before and after the future has\n    /// completed.\n    ///\n    /// To call this method, you will usually combine the call with\n    /// [`Pin::as_mut`], which lets you call the method without consuming the\n    /// `Sleep` itself.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// use des::time::{Duration, Instant};\n    ///\n    /// # #[tokio::main(flavor = \"current_thread\")]\n    /// # async fn main() {\n    /// let sleep = des::time::sleep(Duration::from_millis(10));\n    /// tokio::pin!(sleep);\n    ///\n    /// sleep.as_mut().reset(Instant::now() + Duration::from_millis(20));\n    /// # }\n    /// ```\n    ///\n    /// See also the top-level examples.\n    ///\n    /// [`Pin::as_mut`]: fn@std::pin::Pin::as_mut\n    pub fn reset(self: Pin\u003c\u0026mut Self\u003e, deadline: SimTime) {\n        self.reset_inner(deadline);\n    }\n\n    fn reset_inner(self: Pin\u003c\u0026mut Self\u003e, deadline: SimTime) {\n        let mut me = self.project();\n        if let Some(handle) = me.handle.take() {\n            // Reogranize timer calls.\n            handle.reset(deadline);\n        }\n        *me.deadline = deadline;\n    }\n}\n\nimpl Future for Sleep {\n    type Output = ();\n    fn poll(\n        self: Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cSelf::Output\u003e {\n        // A poll might come from one of three sources\n        // a) inital poll\n        // b) poll at scheduled deadline\n        // c) spurious wakeup i.e. tokio::select\n\n        let scheduled = self.handle.is_some();\n\n        // Project initaly\n\n        let mut me = self.project();\n        match (*me.deadline).cmp(\u0026SimTime::now()) {\n            Ordering::Greater =\u003e {\n                if !scheduled {\n                    let handle = Driver::with_current(|ctx| {\n                        ctx.queue.add(\n                            TimerSlotEntry {\n                                id: *me.id,\n                                waker: cx.waker().clone(),\n                            },\n                            *me.deadline,\n                        )\n                    });\n                    *me.handle = Some(handle);\n                }\n                Poll::Pending\n            }\n            _ =\u003e {\n                if let Some(mut handle) = me.handle.take() {\n                    handle.resolve();\n                }\n                Poll::Ready(())\n            }\n        }\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":481},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":481},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":481},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":481},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":485},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":484},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":243},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":696},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":238},"fn_name":null}],"covered":35,"coverable":35},{"path":["/","Users","mk","Developer","rust","des","des","src","time","timeout.rs"],"content":"//! Allows a future to execute for a maximum amount of time.\n//!\n//! See [`Timeout`] documentation for more details.\n//!\n//! [`Timeout`]: struct@Timeout\n\nuse crate::time::{error::Elapsed, sleep_until, Sleep};\nuse pin_project_lite::pin_project;\nuse std::future::Future;\nuse std::pin::Pin;\nuse std::task::{self, Poll};\nuse std::time::Duration;\n\nuse super::SimTime;\n\n/// Requires a `Future` to complete before the specified duration has elapsed.\n///\n/// If the future completes before the duration has elapsed, then the completed\n/// value is returned. Otherwise, an error is returned and the future is\n/// canceled.\n///\n/// # Cancelation\n///\n/// Cancelling a timeout is done by dropping the future. No additional cleanup\n/// or other work is required.\n///\n/// The original future may be obtained by calling [`Timeout::into_inner`]. This\n/// consumes the `Timeout`.\n///\n/// # Examples\n///\n/// Create a new `Timeout` set to expire in 10 milliseconds.\n///\n/// ```rust\n/// use des::time::timeout;\n/// use tokio::sync::oneshot;\n///\n/// use std::time::Duration;\n///\n/// # async fn dox() {\n/// let (tx, rx) = oneshot::channel();\n/// # tx.send(()).unwrap();\n///\n/// // Wrap the future with a `Timeout` set to expire in 10 milliseconds.\n/// if let Err(_) = timeout(Duration::from_millis(10), rx).await {\n///     println!(\"did not receive value within 10 ms\");\n/// }\n/// # }\n/// ```\n///\n/// # Panics\n///\n/// This function panics whenever a timer is created outside of a\n/// Tokio runtime. That is why `rt.block_on(sleep(...))` will panic,\n/// since the function is executed outside of the runtime.\n/// Whereas `rt.block_on(async {sleep(...).await})` doesn't panic.\n/// And this is because wrapping the function on an async makes it lazy,\n/// and so gets executed inside the runtime successfully without\n/// panicking.\n#[track_caller]\npub fn timeout\u003cT\u003e(duration: Duration, future: T) -\u003e Timeout\u003cT\u003e\nwhere\n    T: Future,\n{\n    let deadline = SimTime::now().checked_add(duration);\n    let delay = match deadline {\n        Some(deadline) =\u003e Sleep::new(deadline),\n        None =\u003e Sleep::far_future(),\n    };\n    Timeout::new_with_delay(future, delay)\n}\n\n/// Requires a `Future` to complete before the specified instant in time.\n///\n/// If the future completes before the instant is reached, then the completed\n/// value is returned. Otherwise, an error is returned.\n///\n/// # Cancelation\n///\n/// Cancelling a timeout is done by dropping the future. No additional cleanup\n/// or other work is required.\n///\n/// The original future may be obtained by calling [`Timeout::into_inner`]. This\n/// consumes the `Timeout`.\n///\n/// # Examples\n///\n/// Create a new `Timeout` set to expire in 10 milliseconds.\n///\n/// ```rust\n/// use des::time::{SimTime, timeout_at};\n/// use tokio::sync::oneshot;\n///\n/// use std::time::Duration;\n///\n/// # async fn dox() {\n/// let (tx, rx) = oneshot::channel();\n/// # tx.send(()).unwrap();\n///\n/// // Wrap the future with a `Timeout` set to expire 10 milliseconds into the\n/// // future.\n/// if let Err(_) = timeout_at(SimTime::now() + Duration::from_millis(10), rx).await {\n///     println!(\"did not receive value within 10 ms\");\n/// }\n/// # }\n/// ```\npub fn timeout_at\u003cT\u003e(deadline: SimTime, future: T) -\u003e Timeout\u003cT\u003e\nwhere\n    T: Future,\n{\n    let delay = sleep_until(deadline);\n\n    Timeout {\n        value: future,\n        delay,\n    }\n}\n\npin_project! {\n    /// Future returned by [`timeout`](timeout) and [`timeout_at`](timeout_at).\n    #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n    pub struct Timeout\u003cT\u003e {\n        #[pin]\n        value: T,\n        #[pin]\n        delay: Sleep,\n    }\n}\n\nimpl\u003cT\u003e Timeout\u003cT\u003e {\n    pub(crate) fn new_with_delay(value: T, delay: Sleep) -\u003e Timeout\u003cT\u003e {\n        Timeout { value, delay }\n    }\n\n    /// Gets a reference to the underlying value in this timeout.\n    pub fn get_ref(\u0026self) -\u003e \u0026T {\n        \u0026self.value\n    }\n\n    /// Gets a mutable reference to the underlying value in this timeout.\n    pub fn get_mut(\u0026mut self) -\u003e \u0026mut T {\n        \u0026mut self.value\n    }\n\n    /// Consumes this timeout, returning the underlying value.\n    pub fn into_inner(self) -\u003e T {\n        self.value\n    }\n}\n\nimpl\u003cT\u003e Future for Timeout\u003cT\u003e\nwhere\n    T: Future,\n{\n    type Output = Result\u003cT::Output, Elapsed\u003e;\n\n    fn poll(self: Pin\u003c\u0026mut Self\u003e, cx: \u0026mut task::Context\u003c'_\u003e) -\u003e Poll\u003cSelf::Output\u003e {\n        let me = self.project();\n\n        // First, try polling the future\n        if let Poll::Ready(v) = me.value.poll(cx) {\n            return Poll::Ready(Ok(v));\n        }\n\n        let delay = me.delay;\n\n        let poll_delay = || -\u003e Poll\u003cSelf::Output\u003e {\n            match delay.poll(cx) {\n                Poll::Ready(()) =\u003e Poll::Ready(Err(Elapsed::new())),\n                Poll::Pending =\u003e Poll::Pending,\n            }\n        };\n\n        poll_delay()\n    }\n}\n","traces":[{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":21,"coverable":25},{"path":["/","Users","mk","Developer","rust","des","des","src","tracing.rs"],"content":"//! Alternative tracing impl\n\nuse std::sync::{\n    atomic::{AtomicU64, Ordering},\n    mpsc::{self, Receiver, Sender},\n};\n\nuse crate::{\n    prelude::{ObjectPath, SimTime},\n    sync::{Mutex, RwLock},\n};\nuse fxhash::{FxBuildHasher, FxHashMap};\nuse nu_ansi_term::{Color, Style};\nuse tracing::{Level, Subscriber};\nuse tracing_subscriber::{\n    filter::Directive,\n    fmt::{format::Writer, FormatEvent, FormatFields, FormattedFields},\n    registry::LookupSpan,\n    util::SubscriberInitExt,\n    EnvFilter,\n};\n\n/// A token describing a logger scope.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct ScopeToken(u64);\n\nstatic SCOPE_CURRENT_TOKEN: AtomicU64 = AtomicU64::new(u64::MAX);\nstatic SCOPE_TOKEN_NEXT: AtomicU64 = AtomicU64::new(0);\nstatic SCOPES: std::sync::Mutex\u003cOption\u003cSender\u003c(ScopeToken, ObjectPath)\u003e\u003e\u003e =\n    std::sync::Mutex::new(None);\n\n/// Creates a new scope attached to the tracing subscriber.\n///\n/// This function is intended for internal use, but remains\n/// public, since it may be usefull in rare scenarios\n#[doc(hidden)]\npub fn new_scope(obj_path: ObjectPath) -\u003e ScopeToken {\n    let token = ScopeToken(SCOPE_TOKEN_NEXT.fetch_add(1, Ordering::SeqCst));\n    let lock = SCOPES.lock().unwrap();\n    if let Some(scopes) = \u0026*lock {\n        scopes.send((token, obj_path)).expect(\"Failed to send\");\n    } else {\n        // WARNING MAYBE\n    }\n    token\n}\n\n/// Indicates that the begin of a scope, that was allread registerd.\n///\n/// This function is intended for internal use, but remains\n/// public, since it may be usefull in rare scenarios\n#[doc(hidden)]\npub fn enter_scope(token: ScopeToken) {\n    SCOPE_CURRENT_TOKEN.store(token.0, Ordering::SeqCst);\n}\n\n/// Indicates that no scope is currently active.\n///\n/// This function is intended for internal use, but remains\n/// public, since it may be usefull in rare scenarios\n#[doc(hidden)]\npub fn leave_scope() {\n    SCOPE_CURRENT_TOKEN.store(u64::MAX, Ordering::SeqCst);\n}\n\n/// The log level that will be used if `RUST_LOG` is not defined.\npub const FALLBACK_LOG_LEVEL: Level = Level::TRACE;\n\n/// Create a new tracing subscriber with a sim formatter.\n///\n/// # Panics\n///\n/// Panics when subscriber initilization fails.\npub fn init() {\n    let subscriber = tracing_subscriber::fmt();\n    let subscriber = subscriber.event_format(format());\n    let subscriber = subscriber.with_env_filter(\n        EnvFilter::builder()\n            .with_default_directive(Directive::from(FALLBACK_LOG_LEVEL))\n            .from_env_lossy(),\n    );\n    subscriber.finish().init();\n}\n\n/// An instance of a simulation formatter.\n#[must_use]\npub fn format() -\u003e SimFormat {\n    SimFormat::init()\n}\n\n/// A formatter that includes simulation specific information into the tracing messages.\n#[derive(Debug)]\npub struct SimFormat {\n    scopes: RwLock\u003cFxHashMap\u003cu64, Scope\u003e\u003e,\n    rx: Mutex\u003cReceiver\u003c(ScopeToken, ObjectPath)\u003e\u003e,\n}\n\nunsafe impl Sync for SimFormat {}\n\n#[derive(Debug)]\nstruct Scope {\n    path: ObjectPath,\n}\n\nimpl SimFormat {\n    fn init() -\u003e SimFormat {\n        let (tx, rx) = mpsc::channel();\n        SCOPES.lock().unwrap().replace(tx);\n        SimFormat {\n            scopes: RwLock::new(FxHashMap::with_hasher(FxBuildHasher::default())),\n            rx: Mutex::new(rx),\n        }\n    }\n\n    fn fetch_scopes(\u0026self) {\n        let rx = self.rx.lock();\n        let mut scopes = self.scopes.write();\n        while let Ok((new_token, new_scope)) = rx.try_recv() {\n            scopes.insert(new_token.0, Scope { path: new_scope });\n        }\n    }\n}\n\nmacro_rules! maybe_ansi {\n    ($style:ident, $ansi:ident, $writer:ident: $($t:tt)*) =\u003e {\n        MaybeAnsi(format!($($t)*), $style, $ansi).write(\u0026mut $writer)\n    };\n}\n\nimpl\u003cS, N\u003e FormatEvent\u003cS, N\u003e for SimFormat\nwhere\n    S: Subscriber + for\u003c'a\u003e LookupSpan\u003c'a\u003e,\n    N: for\u003c'a\u003e FormatFields\u003c'a\u003e + 'static,\n{\n    fn format_event(\n        \u0026self,\n        ctx: \u0026tracing_subscriber::fmt::FmtContext\u003c'_, S, N\u003e,\n        mut writer: tracing_subscriber::fmt::format::Writer\u003c'_\u003e,\n        event: \u0026tracing::Event\u003c'_\u003e,\n    ) -\u003e std::fmt::Result {\n        let meta = event.metadata();\n        let ansi = writer.has_ansi_escapes();\n\n        let dimmed = Style::new().dimmed();\n        let bold = Style::new().bold();\n\n        maybe_ansi!(dimmed, ansi, writer: \"[ {:?} ] \", SimTime::now())?;\n\n        let style = match *meta.level() {\n            Level::TRACE =\u003e Style::new().fg(Color::Cyan),\n            Level::DEBUG =\u003e Style::new().fg(Color::Purple),\n            Level::INFO =\u003e Style::new().fg(Color::Green),\n            Level::WARN =\u003e Style::new().fg(Color::Yellow),\n            Level::ERROR =\u003e Style::new().fg(Color::Red),\n        };\n\n        self.fetch_scopes();\n        let scope_id = SCOPE_CURRENT_TOKEN.load(Ordering::SeqCst);\n        let scopes = self.scopes.read();\n\n        if let Some(scope) = scopes.get(\u0026scope_id) {\n            if !ansi {\n                write!(writer, \"{} \", meta.level().as_str())?;\n            }\n            maybe_ansi!(style, ansi, writer: \"{} \", scope.path)?;\n        } else {\n            maybe_ansi!(style, ansi, writer: \"{} \", meta.level().as_str())?;\n        }\n\n        if let Some(scope) = ctx.event_scope() {\n            let mut seen = false;\n            for span in scope.from_root() {\n                maybe_ansi!(bold, ansi, writer: \"{}\", span.metadata().name())?;\n                seen = true;\n                let ext = span.extensions();\n                if let Some(fields) = \u0026ext.get::\u003cFormattedFields\u003cN\u003e\u003e() {\n                    if !fields.is_empty() {\n                        maybe_ansi!(bold, ansi, writer: \"{{\")?;\n                        write!(writer, \"{fields}\")?;\n                        maybe_ansi!(bold, ansi, writer: \"}}\")?;\n                    }\n                }\n                maybe_ansi!(dimmed, ansi, writer: \":\")?;\n            }\n\n            if seen {\n                writer.write_char(' ')?;\n            }\n        }\n\n        maybe_ansi!(dimmed, ansi, writer: \"{}: \", meta.target())?;\n\n        ctx.format_fields(writer.by_ref(), event)?;\n        writeln!(writer)\n    }\n}\n\nstruct MaybeAnsi(String, Style, bool);\n\nimpl MaybeAnsi {\n    fn write(self, writer: \u0026mut Writer\u003c'_\u003e) -\u003e std::fmt::Result {\n        if self.2 {\n            write!(writer, \"{}\", self.1.prefix())?;\n            write!(writer, \"{}\", self.0)?;\n            write!(writer, \"{}\", self.1.suffix())\n        } else {\n            write!(writer, \"{}\", self.0)\n        }\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":253},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":16928},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":16928},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4809},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4809},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":45},"fn_name":null}],"covered":64,"coverable":72},{"path":["/","Users","mk","Developer","rust","des","des","tests","_require_full.rs"],"content":"#![cfg(not(feature = \"full\"))]\ncompile_error!(\"des main tests required cfg(feature = full)\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","tests","async.rs"],"content":"#![cfg(feature = \"async\")]\n#![allow(unused_variables)]\n\nuse des::{\n    net::AsyncFn,\n    prelude::*,\n    time::{self, sleep, timeout, timeout_at, MissedTickBehavior},\n};\nuse std::sync::{\n    atomic::{AtomicBool, AtomicUsize, Ordering},\n    Arc,\n};\nuse tokio::{\n    sync::{\n        mpsc::{self, channel, Sender},\n        Semaphore,\n    },\n    task::JoinHandle,\n};\n\nuse serial_test::serial;\n\n// # Test case\n// The module behaves like a sync module, not creating any more\n// futures than the async call itself.\n\n#[derive(Default)]\nstruct QuasaiSyncModule {\n    counter: usize,\n}\n\nimpl AsyncModule for QuasaiSyncModule {\n    async fn handle_message(\u0026mut self, msg: Message) {\n        println!(\"[{}] Received msg: {}\", current().name(), msg.header().id);\n        self.counter += msg.header().id as usize;\n    }\n}\n\n#[test]\n#[serial]\nfn quasai_sync_non_blocking() {\n    let mut rt = Sim::new(());\n    rt.node(\"root\", QuasaiSyncModule::default());\n    rt.node(\"other\", QuasaiSyncModule::default());\n\n    let gate_a = rt.gate(\"root\", \"a\");\n    let gate_b = rt.gate(\"other\", \"b\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n\n    rt.add_message_onto(gate_a.clone(), Message::new().id(1).build(), SimTime::ZERO);\n    rt.add_message_onto(gate_a, Message::new().id(2).build(), SimTime::ZERO);\n\n    rt.add_message_onto(gate_b.clone(), Message::new().id(1).build(), SimTime::ZERO);\n    rt.add_message_onto(gate_b.clone(), Message::new().id(2).build(), SimTime::ZERO);\n    rt.add_message_onto(gate_b, Message::new().id(3).build(), SimTime::ZERO);\n\n    let result = rt.run();\n    match result {\n        RuntimeResult::Finished {\n            app,\n            time,\n            profiler,\n        } =\u003e {\n            assert_eq!(time, SimTime::ZERO);\n            assert_eq!(profiler.event_count, 10);\n        }\n        _ =\u003e panic!(\"Expected runtime to finish\"),\n    }\n}\n\n// # Test case\n// A module has 3 permantent tasks that each forward\n// the message, the final one incrementing a module bound\n// tracker\n// The tasks shutdown with a shutdown message\n\n#[derive(Default)]\nstruct MutipleTasksModule {\n    handles: Vec\u003cJoinHandle\u003c()\u003e\u003e,\n    sender: Option\u003cSender\u003cMessage\u003e\u003e,\n    result: Arc\u003cAtomicUsize\u003e,\n}\n\nimpl AsyncModule for MutipleTasksModule {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        let (txa, mut rxa) = channel::\u003cMessage\u003e(8);\n        let (txb, mut rxb) = channel(8);\n        let (txc, mut rxc) = channel(8);\n\n        let result = self.result.clone();\n\n        let ta = tokio::spawn(async move {\n            while let Some(v) = rxa.recv().await {\n                let k = v.header().kind;\n                txb.send(v).await.unwrap();\n\n                if k == 42 {\n                    rxa.close();\n                    txb.closed().await;\n                }\n            }\n        });\n\n        let tb = tokio::spawn(async move {\n            while let Some(v) = rxb.recv().await {\n                let k = v.header().kind;\n                txc.send(v).await.unwrap();\n\n                if k == 42 {\n                    rxb.close();\n                    txc.closed().await;\n                }\n            }\n        });\n\n        let tc = tokio::spawn(async move {\n            while let Some(v) = rxc.recv().await {\n                let k = v.header().kind;\n                result.fetch_add(v.header().id as usize, std::sync::atomic::Ordering::SeqCst);\n\n                if k == 42 {\n                    rxc.close();\n                }\n            }\n        });\n\n        self.sender = Some(txa);\n        self.handles.push(ta);\n        self.handles.push(tb);\n        self.handles.push(tc);\n    }\n\n    async fn at_sim_end(\u0026mut self) {\n        self.sender\n            .take()\n            .unwrap()\n            .send(Message::new().kind(42).build())\n            .await\n            .unwrap();\n\n        for join in self.handles.drain(..) {\n            join.await.unwrap()\n        }\n\n        self.result\n            .fetch_add(100, std::sync::atomic::Ordering::SeqCst);\n    }\n\n    async fn handle_message(\u0026mut self, msg: Message) {\n        self.sender.as_ref().unwrap().send(msg).await.unwrap()\n    }\n}\n\n#[test]\n#[serial]\nfn mutiple_active_tasks() {\n    let mut rt = Sim::new(());\n    rt.node(\"root\", MutipleTasksModule::default());\n\n    let gate_a = rt.gate(\"root\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n\n    rt.add_message_onto(gate_a.clone(), Message::new().id(1).build(), SimTime::ZERO);\n    rt.add_message_onto(gate_a, Message::new().id(2).build(), SimTime::ZERO);\n\n    let result = rt.run();\n    match result {\n        RuntimeResult::Finished {\n            app,\n            time,\n            profiler,\n        } =\u003e {\n            assert_eq!(time, SimTime::ZERO);\n\n            //  2 * (Gate + HandleMessage)\n            assert_eq!(profiler.event_count, 4);\n\n            // let m1 = app\n            //     .module(|m| m.module_core().name() == \"RootModule\")\n            //     .unwrap()\n            //     .self_as::\u003cMutipleTasksModule\u003e()\n            //     .unwrap();\n\n            // assert_eq!(m1.result.load(std::sync::atomic::Ordering::SeqCst), 100 + 3);\n        }\n        _ =\u003e panic!(\"Expected runtime to finish\"),\n    }\n}\n\n// # Test case\n// A module sleeps upon receiving a message,\n// This sleeps do NOT interfere with recv()\n\n#[derive(Default)]\nstruct TimeSleepModule {\n    counter: usize,\n}\n\nimpl AsyncModule for TimeSleepModule {\n    async fn handle_message(\u0026mut self, msg: Message) {\n        tracing::debug!(\"recv msg: {}\", msg.str());\n        let wait_time = msg.header().kind as u64;\n        tracing::info!(\n            \"\u003c{}\u003e [{}] Waiting for timer\",\n            current().name(),\n            SimTime::now()\n        );\n        sleep(Duration::from_secs(wait_time)).await;\n        tracing::info!(\n            \"\u003c{}\u003e [{}] Done waiting for id: {}\",\n            current().name(),\n            SimTime::now(),\n            msg.header().id\n        );\n        self.counter += msg.header().id as usize\n    }\n}\n\n#[test]\n#[serial]\nfn one_module_timers() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", TimeSleepModule::default());\n\n    let gate_a = rt.gate(\"root\", \"a\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n\n    rt.add_message_onto(\n        gate_a.clone(),\n        Message::new().id(1).kind(1).build(),\n        SimTime::ZERO,\n    );\n    rt.add_message_onto(\n        gate_a,\n        Message::new().id(2).kind(2).build(),\n        SimTime::from_duration(Duration::new(2, 0)),\n    );\n\n    let result = rt.run();\n    match result {\n        RuntimeResult::Finished {\n            app,\n            time,\n            profiler,\n        } =\u003e {\n            assert_eq!(time, 4.0);\n            assert_eq!(profiler.event_count, 6);\n        }\n        _ =\u003e panic!(\"Expected runtime to finish\"),\n    }\n}\n\n// # Test case\n// The module sleeps on message receival\n// The sleeps should delay the next recv.\n\n#[test]\n#[serial]\nfn one_module_delayed_recv() {\n    let mut rt = Sim::new(());\n    rt.node(\"root\", TimeSleepModule::default());\n\n    let gate_a = rt.gate(\"root\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n\n    rt.add_message_onto(\n        gate_a.clone(),\n        Message::new().id(1).kind(2).build(),\n        SimTime::ZERO,\n    );\n    rt.add_message_onto(\n        gate_a,\n        Message::new().id(2).kind(2).build(),\n        SimTime::from_duration(Duration::new(2, 0)),\n    );\n\n    let result = rt.run();\n    match result {\n        RuntimeResult::Finished {\n            app,\n            time,\n            profiler,\n        } =\u003e {\n            assert_eq!(time, 4.0);\n\n            // 1) Gate #1 (0s)\n            // 2) HandleMessage #1 (0s)\n            // 3) Gate #2 (2s)\n            // 4) HandleMessage #2 (2s) (will finish sleep but wakeup was added later)\n            // 5) Wakeup aka NOP (2s)\n            // 6) Wakeup - sleep reloved - send in '5 (4s)\n            assert_eq!(profiler.event_count, 6);\n\n            // let m1 = app\n            //     .module(|m| m.module_core().name() == \"RootModule\")\n            //     .unwrap()\n            //     .self_as::\u003cTimeSleepModule\u003e()\n            //     .unwrap();\n\n            // assert_eq!(m1.counter, 3);\n        }\n        _ =\u003e panic!(\"Expected runtime to finish\"),\n    }\n}\n\n// # Test case\n// Mutiple Modules delay themself with sleeps\n\n#[test]\n#[serial]\nfn mutiple_module_delayed_recv() {\n    let mut rt = Sim::new(());\n    rt.node(\"a\", TimeSleepModule::default());\n    rt.node(\"b\", TimeSleepModule::default());\n\n    let gate_a = rt.gate(\"a\", \"in\");\n    let gate_b = rt.gate(\"b\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n\n    // # Module 1\n    //  |0  |1  |2  |3  |4  |5  |6\n    //       \u003cID=1_\u003e\n    //          ....\u003cID=2_\u003e\n    rt.add_message_onto(\n        gate_a.clone(),\n        Message::new().id(1).kind(2).build(),\n        SimTime::from_duration(Duration::new(1, 0)),\n    );\n    rt.add_message_onto(\n        gate_a,\n        Message::new().id(2).kind(2).build(),\n        SimTime::from_duration(Duration::new(2, 0)),\n    );\n\n    // # Module 1\n    //  |0  |1  |2  |3  |4  |5  |6\n    //      \u003cID\u003e\n    //          \u003cID=20\u003e\n    rt.add_message_onto(\n        gate_b.clone(),\n        Message::new().id(10).kind(1).build(),\n        SimTime::from_duration(Duration::new(1, 0)),\n    );\n    rt.add_message_onto(\n        gate_b,\n        Message::new().id(20).kind(2).build(),\n        SimTime::from_duration(Duration::new(2, 0)),\n    );\n\n    let result = rt.run();\n    match result {\n        RuntimeResult::Finished {\n            app,\n            time,\n            profiler,\n        } =\u003e {\n            assert_eq!(time, 5.0);\n\n            assert_eq!(profiler.event_count, 12);\n\n            // let m1 = app\n            //     .module(|m| m.module_core().name() == \"RootModule\")\n            //     .unwrap()\n            //     .self_as::\u003cTimeSleepModule\u003e()\n            //     .unwrap();\n\n            // assert_eq!(m1.counter, 3);\n\n            // let m2 = app\n            //     .module(|m| m.module_core().name() == \"OtherRootModule\")\n            //     .unwrap()\n            //     .self_as::\u003cTimeSleepModule\u003e()\n            //     .unwrap();\n\n            // assert_eq!(m2.counter, 30);\n        }\n        _ =\u003e panic!(\"Expected runtime to finish\"),\n    }\n}\n\nstruct SemaphoreModule {\n    semaphore: Arc\u003cSemaphore\u003e,\n    handle: Option\u003cJoinHandle\u003c()\u003e\u003e,\n    result: Arc\u003cAtomicBool\u003e,\n}\n\nimpl Default for SemaphoreModule {\n    fn default() -\u003e Self {\n        Self {\n            semaphore: Arc::new(Semaphore::new(0)),\n            handle: None,\n            result: Arc::new(AtomicBool::new(false)),\n        }\n    }\n}\n\nimpl AsyncModule for SemaphoreModule {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        let sem = self.semaphore.clone();\n        let res = self.result.clone();\n        self.handle = Some(tokio::spawn(async move {\n            let premit = sem.acquire_many(5).await.unwrap();\n            println!(\"[{}] Aquired semaphore\", SimTime::now());\n            res.fetch_or(true, std::sync::atomic::Ordering::SeqCst);\n            drop(premit)\n        }));\n    }\n\n    async fn handle_message(\u0026mut self, msg: Message) {\n        self.semaphore.add_permits(msg.header().kind as usize);\n    }\n}\n\n#[test]\n#[serial]\nfn semaphore_in_waiting_task() {\n    let mut rt = Sim::new(());\n    rt.node(\"a\", SemaphoreModule::default());\n    rt.node(\"b\", SemaphoreModule::default());\n\n    let gate_a = rt.gate(\"a\", \"in\");\n    let gate_b = rt.gate(\"b\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n\n    rt.add_message_onto(\n        gate_a.clone(),\n        Message::new().id(1).kind(2).build(),\n        SimTime::from_duration(Duration::new(1, 0)),\n    );\n    rt.add_message_onto(\n        gate_a,\n        Message::new().id(2).kind(3).build(),\n        SimTime::from_duration(Duration::new(2, 0)),\n    );\n\n    rt.add_message_onto(\n        gate_b.clone(),\n        Message::new().id(10).kind(2).build(),\n        SimTime::from_duration(Duration::new(1, 0)),\n    );\n    rt.add_message_onto(\n        gate_b.clone(),\n        Message::new().id(20).kind(2).build(),\n        SimTime::from_duration(Duration::new(2, 0)),\n    );\n    rt.add_message_onto(\n        gate_b,\n        Message::new().id(20).kind(1).build(),\n        SimTime::from_duration(Duration::new(3, 0)),\n    );\n\n    let result = rt.run();\n    match result {\n        RuntimeResult::Finished {\n            app,\n            time,\n            profiler,\n        } =\u003e {\n            assert_eq!(time, 3.0);\n            assert_eq!(profiler.event_count, 10);\n        }\n        _ =\u003e panic!(\"Expected runtime to finish\"),\n    }\n}\n\n#[test]\n#[serial]\nfn async_time_sleep_far_future() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|rx| async move {\n            assert_eq!(SimTime::now(), 0.0);\n            time::sleep_until(10.0.into()).await;\n            assert_eq!(SimTime::now(), 10.0);\n            let sleep = time::sleep(Duration::MAX);\n            assert_eq!(sleep.deadline(), SimTime::MAX);\n            assert!(!sleep.is_elapsed());\n\n            sleep.await;\n            panic!(\"should never be reached\");\n        }),\n    );\n\n    let result = Builder::seeded(123).build(sim).run();\n    assert_eq!(result.unwrap().1, 10.0);\n}\n\n#[test]\n#[serial]\nfn async_time_sleep_select() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|rx| async move {\n            tokio::select! {\n                _ = time::sleep(Duration::from_secs(10)) =\u003e unreachable!(),\n                _ = time::sleep(Duration::from_secs(5)) =\u003e println!(\"resolved\"),\n            }\n        })\n        .require_join(),\n    );\n\n    let result = Builder::seeded(123).build(sim).run().unwrap();\n    assert_eq!(result.1, 5.0);\n    assert_eq!(result.2.event_count, 1); // Just async wakeup for 5s, 10s will never be scheduled\n}\n\n#[test]\n#[serial]\nfn async_time_sleep_reset() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|rx| async move {\n            let sleep = time::sleep(Duration::from_secs(5));\n            tokio::pin!(sleep);\n\n            sleep.as_mut().reset(10.0.into());\n            sleep.await\n        })\n        .require_join(),\n    );\n\n    let result = Builder::seeded(123).build(sim).run().unwrap();\n    assert_eq!(result.1, 10.0);\n    assert_eq!(result.2.event_count, 1); // Just async wakeup for 10s, 5s was not yet scheduled\n}\n\n#[test]\n#[serial]\nfn async_time_timeout() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|rx| async move {\n            let result: Result\u003ci32, time::error::Elapsed\u003e =\n                timeout(Duration::from_secs(10), std::future::pending()).await;\n            assert!(result.is_err());\n\n            let (tx, mut rx) = mpsc::channel(1);\n\n            let handle = tokio::spawn(async move {\n                time::sleep(Duration::from_secs(5)).await;\n                tx.send(42).await.unwrap();\n            });\n\n            let result: Result\u003cOption\u003ci32\u003e, time::error::Elapsed\u003e =\n                timeout_at(20.0.into(), rx.recv()).await;\n            assert_eq!(result, Ok(Some(42)));\n\n            handle.await.unwrap();\n        })\n        .require_join(),\n    );\n\n    let result = Builder::seeded(123).build(sim).run().unwrap();\n    assert_eq!(result.1, 15.0);\n    // why 15s?\n    // wakeup 20s will never be scheduled, since\n    // -\u003e wakeup 15s from tokio::task is allready scheduled\n    // -\u003e upon completion of 15s timeout 20s is allready removed\n}\n\n#[test]\n#[serial]\nfn async_time_timeout_far_future() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|rx| async move {\n            // add a sleep to get a nonempty sim\n            time::sleep(Duration::from_secs(42)).await;\n\n            let mut timeout = timeout(Duration::MAX, std::future::pending());\n            let _: \u0026std::future::Pending\u003ci32\u003e = timeout.get_ref();\n            let _: \u0026mut std::future::Pending\u003ci32\u003e = timeout.get_mut();\n\n            let result: Result\u003ci32, time::error::Elapsed\u003e = timeout.await;\n            panic!(\"will never be reached\")\n        }),\n    );\n\n    let result = Builder::seeded(123).build(sim).run().unwrap();\n    assert_eq!(result.1, 42.0);\n}\n\n#[test]\n#[serial]\nfn async_time_interval() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|rx| async move {\n            // (0) No missed ticks\n            let counter = Arc::new(AtomicUsize::new(0));\n\n            let c = counter.clone();\n            tokio::spawn(async move {\n                let mut interval = time::interval(Duration::from_secs(1));\n                assert_eq!(interval.period(), Duration::from_secs(1));\n                assert_eq!(\n                    interval.missed_tick_behavior(),\n                    MissedTickBehavior::default()\n                );\n\n                loop {\n                    interval.tick().await;\n                    c.fetch_add(1, Ordering::SeqCst);\n                }\n            });\n\n            time::sleep(Duration::from_secs_f64(7.5)).await;\n            assert_eq!(counter.load(Ordering::SeqCst), 1 + 7);\n        }),\n    );\n\n    let _ = Builder::seeded(123).max_time(100.0.into()).build(sim).run();\n}\n\n#[test]\n#[serial]\nfn async_time_interval_missed_tick_behaviour() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"burst\",\n        AsyncFn::new(|rx| async move {\n            // (0) No missed ticks\n            let mut interval = time::interval(Duration::from_secs(1));\n            interval.set_missed_tick_behavior(MissedTickBehavior::Burst);\n\n            time::sleep(Duration::from_secs_f64(4.5)).await;\n\n            for _ in 0..6 {\n                // expected ticks at 0, 1, 2, 3, 4, 5\n                // got at 4.5, ..., 4.5, 5\n                interval.tick().await;\n            }\n            assert_eq!(SimTime::now(), 5.0);\n        }),\n    );\n\n    sim.node(\n        \"delay\",\n        AsyncFn::new(|rx| async move {\n            // (0) No missed ticks\n            let mut interval = time::interval(Duration::from_secs(1));\n            interval.set_missed_tick_behavior(MissedTickBehavior::Delay);\n            let mut last = SimTime::now();\n\n            time::sleep(Duration::from_secs_f64(4.5)).await;\n\n            for i in 0..6 {\n                // expected ticks at 0, 1, 2, 3, 4, 5\n                // got at 4.5, ..., 4.5, 5\n                interval.tick().await;\n                if i != 0 {\n                    assert_eq!(SimTime::now(), last + 1.0);\n                }\n                last = SimTime::now();\n            }\n\n            assert_eq!(SimTime::now(), 4.5 + 5.0);\n        }),\n    );\n\n    sim.node(\n        \"skip\",\n        AsyncFn::new(|rx| async move {\n            // (0) No missed ticks\n            let mut interval = time::interval_at(0.0.into(), Duration::from_secs(1));\n            interval.set_missed_tick_behavior(MissedTickBehavior::Skip);\n\n            time::sleep(Duration::from_secs_f64(4.5)).await;\n\n            for i in 0..6 {\n                // expected ticks at 0, 1, 2, 3, 4, 5\n                // got at 4.5, ..., 4.5, 5\n                interval.tick().await;\n                if i != 0 {\n                    assert_eq!(SimTime::now().subsec_millis(), 0);\n                }\n            }\n\n            assert_eq!(SimTime::from(5.0).elapsed(), Duration::from_secs(4));\n            assert_eq!(SimTime::now(), 9.0);\n        }),\n    );\n\n    let _ = Builder::seeded(123).max_time(100.0.into()).build(sim).run();\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":61,"coverable":67},{"path":["/","Users","mk","Developer","rust","des","des","tests","basic-runtime.rs"],"content":"use des::{prelude::*, runtime::RuntimeLimit};\nuse rand::{distributions::Standard, prelude::SliceRandom, Rng};\nuse serial_test::serial;\n\n/// The Event ste\n#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\nenum MyEventSet {\n    RegisterToRtWithTime(RegisterToRtWithTime),\n    B(B),\n    RepeatWithDelay(RepeatWithDelay),\n}\n\nimpl EventSet\u003cApp\u003e for MyEventSet {\n    fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {\n        match self {\n            Self::RegisterToRtWithTime(a) =\u003e a.handle(rt),\n            Self::B(b) =\u003e b.handle(rt),\n            Self::RepeatWithDelay(rwd) =\u003e rwd.handle(rt),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\nstruct RegisterToRtWithTime {\n    id: usize,\n}\n\nimpl RegisterToRtWithTime {\n    fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {\n        rt.app\n            .event_list\n            .push((SimTime::now(), MyEventSet::RegisterToRtWithTime(self)))\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\nstruct B {\n    id: usize,\n}\n\nimpl B {\n    fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {\n        rt.app\n            .event_list\n            .push((SimTime::now(), MyEventSet::B(self)))\n    }\n}\n\n/// The application\nstruct App {\n    event_list: Vec\u003c(SimTime, MyEventSet)\u003e,\n}\n\nimpl Application for App {\n    type EventSet = MyEventSet;\n    type Lifecycle = ();\n}\n\n#[test]\n#[serial]\nfn zero_event_runtime() {\n    let rt = Builder::seeded(123).build(App {\n        event_list: Vec::new(),\n    });\n\n    let res = rt.run();\n    assert!(matches!(res, RuntimeResult::EmptySimulation { .. }))\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\nstruct RepeatWithDelay {\n    delay: Duration,\n    repeat: usize,\n    repeat_limit: usize,\n}\nimpl RepeatWithDelay {\n    fn handle(mut self, rt: \u0026mut Runtime\u003cApp\u003e) {\n        if self.repeat \u003c= self.repeat_limit {\n            let delay = self.delay;\n            self.repeat += 1;\n            rt.add_event_in(MyEventSet::RepeatWithDelay(self), delay)\n        }\n    }\n}\n\n#[test]\n#[serial]\nfn one_event_runtime() {\n    let mut rt = Builder::new().build(App {\n        event_list: Vec::new(),\n    });\n    rt.add_event(\n        MyEventSet::RepeatWithDelay(RepeatWithDelay {\n            delay: Duration::new(1, 0),\n            repeat: 0,\n            repeat_limit: 15,\n        }),\n        SimTime::ZERO,\n    );\n\n    // repeat i = i secs\n    // limit (\u003c=) is at 15s thus time limit 16s\n    // this means 17 events\n\n    let res = rt.run();\n    match res {\n        RuntimeResult::Finished { time, profiler, .. } =\u003e {\n            assert_eq!(time, SimTime::from_duration(Duration::new(16, 0)));\n            assert_eq!(profiler.event_count, 17);\n        }\n        _ =\u003e panic!(\"Runtime should have finished\"),\n    }\n}\n\n#[test]\n#[serial]\nfn ensure_event_order() {\n    use rand::{rngs::StdRng, SeedableRng};\n\n    let mut id = 0;\n    let mut events = Vec::with_capacity(128);\n    let mut time = SimTime::ZERO;\n\n    let mut rng = StdRng::seed_from_u64(123);\n\n    for _i in 0..128 {\n        time += rng.sample::\u003cf64, Standard\u003e(Standard);\n        id += 1;\n\n        events.push((\n            MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime { id }),\n            time,\n        ));\n    }\n\n    events.shuffle(\u0026mut rng);\n\n    let mut rt: Runtime\u003cApp\u003e = Builder::seeded(123).build(App {\n        event_list: Vec::with_capacity(128),\n    });\n\n    for (event, time) in events {\n        rt.add_event(event, time);\n    }\n\n    match rt.run() {\n        RuntimeResult::Finished {\n            app,\n            time: rt_fin_time,\n            profiler,\n        } =\u003e {\n            assert_eq!(rt_fin_time, time);\n            assert_eq!(profiler.event_count, 128);\n\n            let mut last_id = 0;\n            for (_, event) in app.event_list {\n                match event {\n                    MyEventSet::RegisterToRtWithTime(a) =\u003e {\n                        assert_eq!(last_id + 1, a.id);\n                        last_id += 1;\n                    }\n                    _ =\u003e panic!(\"Unexpected event\"),\n                }\n            }\n        }\n        _ =\u003e panic!(\"Expected runtime to finish after fininte non-replicating event set\"),\n    }\n}\n\n#[test]\n#[cfg(not(feature = \"cqueue\"))]\n#[serial]\nfn ensure_event_order_same_time() {\n    StandardLogger::active(false);\n\n    let one = SimTime::from_duration(Duration::new(1, 0));\n    let two = SimTime::from_duration(Duration::new(2, 0));\n\n    let events = vec![\n        (\n            MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime { id: 1 }),\n            SimTime::ZERO,\n        ),\n        (\n            MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime { id: 2 }),\n            one,\n        ),\n        (\n            MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime { id: 3 }),\n            one,\n        ),\n        (\n            MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime { id: 4 }),\n            one,\n        ),\n        (\n            MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime { id: 5 }),\n            two,\n        ),\n    ];\n\n    let mut rt: Runtime\u003cApp\u003e = Builder::seeded(123).build(App {\n        event_list: Vec::with_capacity(32),\n    });\n\n    for (event, time) in events {\n        rt.add_event(event, time);\n    }\n\n    match rt.run() {\n        RuntimeResult::Finished {\n            app,\n            time: rt_fin_time,\n            event_count,\n        } =\u003e {\n            assert_eq!(rt_fin_time, two);\n            assert_eq!(event_count, 5);\n\n            let mut last_id = 0;\n            for (_, event) in app.event_list {\n                match event {\n                    MyEventSet::RegisterToRtWithTime(a) =\u003e {\n                        assert_eq!(last_id + 1, a.id);\n                        last_id += 1;\n                    }\n                    _ =\u003e panic!(\"Unexpected event\"),\n                }\n            }\n        }\n        _ =\u003e panic!(\"Expected runtime to finish after fininte non-replicating event set\"),\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct EventBox {\n    time: SimTime,\n    events: Vec\u003cMyEventSet\u003e,\n}\n\nconst N: usize = 100_000;\n\n#[test]\n#[serial]\nfn full_test_n_100_000() {\n    let mut rt: Runtime\u003cApp\u003e = Builder::seeded(123).build(App {\n        event_list: Vec::with_capacity(N),\n    });\n\n    let mut events = Vec::with_capacity(N);\n\n    // create a event set\n    let mut t = SimTime::ZERO;\n    for _ in 0..N {\n        let num_box_elements = rt.random::\u003cusize\u003e() % 100;\n        let num_box_elements = if num_box_elements \u003c 5 {\n            num_box_elements + 1\n        } else {\n            1\n        };\n\n        let mut boxed = EventBox {\n            events: Vec::new(),\n            time: t,\n        };\n        for _ in 0..num_box_elements {\n            boxed.events.push(random_event(\u0026mut rt))\n        }\n\n        events.push(boxed);\n\n        t += (rt.random::\u003cf64\u003e()).min(0.001);\n    }\n\n    let mut dispatched = events.clone();\n    dispatched.shuffle(\u0026mut rand::thread_rng());\n\n    let mut c = 0;\n    for eventbox in dispatched {\n        let EventBox { time, events } = eventbox;\n        for event in events {\n            rt.add_event(event, time);\n            c += 1;\n        }\n    }\n\n    println!(\"c := {}\", c);\n\n    let (App { event_list }, _, _) = rt.run().unwrap();\n    let mut boxed_list = Vec::with_capacity(N);\n\n    let mut current_box = EventBox {\n        time: SimTime::ZERO,\n        events: Vec::new(),\n    };\n    for (time, event) in event_list {\n        if time == current_box.time {\n            current_box.events.push(event);\n        } else {\n            boxed_list.push(current_box);\n            current_box = EventBox {\n                time,\n                events: vec![event],\n            };\n        }\n    }\n\n    if !current_box.events.is_empty() {\n        boxed_list.push(current_box);\n    }\n\n    assert_eq!(events.len(), boxed_list.len());\n\n    for (lhs, rhs) in events.into_iter().zip(boxed_list) {\n        // assert eq\n        assert_eq!(lhs.time, rhs.time);\n        assert_eq!(lhs.events.len(), rhs.events.len());\n\n        for l in lhs.events {\n            assert!(rhs.events.iter().any(|r| l == *r))\n        }\n    }\n}\n\nfn random_event(rt: \u0026mut Runtime\u003cApp\u003e) -\u003e MyEventSet {\n    if rt.random::\u003cbool\u003e() {\n        MyEventSet::RegisterToRtWithTime(RegisterToRtWithTime {\n            id: rt.random::\u003cusize\u003e(),\n        })\n    } else {\n        MyEventSet::B(B { id: rt.random() })\n    }\n}\n\nstruct DeferredApplication {\n    started: bool,\n    ended: bool,\n}\nimpl EventLifecycle for DeferredApplication {\n    fn at_sim_start(rt: \u0026mut Runtime\u003cSelf\u003e) {\n        rt.app.started = true;\n    }\n    fn at_sim_end(rt: \u0026mut Runtime\u003cSelf\u003e) {\n        rt.app.ended = true;\n    }\n}\nimpl Application for DeferredApplication {\n    type Lifecycle = Self;\n    type EventSet = DeferredES;\n}\n\nstruct DeferredES;\nimpl EventSet\u003cDeferredApplication\u003e for DeferredES {\n    fn handle(self, _rt: \u0026mut Runtime\u003cDeferredApplication\u003e) {}\n}\n\n#[test]\n#[serial]\nfn deferred_sim_start() {\n    let app = DeferredApplication {\n        started: false,\n        ended: false,\n    };\n    let rt = Builder::seeded(123).build(app);\n\n    assert_eq!(rt.app.started, false);\n    assert_eq!(rt.app.ended, false);\n\n    let app = match rt.run() {\n        RuntimeResult::EmptySimulation { app } =\u003e app,\n        _ =\u003e panic!(\"Which events?\"),\n    };\n\n    assert_eq!(app.started, true);\n    assert_eq!(app.ended, true);\n}\n\nstruct CustomStartApp;\nimpl Application for CustomStartApp {\n    type EventSet = CustomStartEvent;\n    type Lifecycle = Self;\n}\n\nstruct CustomStartEvent;\nimpl EventSet\u003cCustomStartApp\u003e for CustomStartEvent {\n    fn handle(self, _: \u0026mut Runtime\u003cCustomStartApp\u003e) {}\n}\n\nimpl EventLifecycle for CustomStartApp {\n    fn at_sim_start(_: \u0026mut Runtime\u003cSelf\u003e) {\n        assert_eq!(SimTime::now(), 42.0);\n    }\n}\n\n#[test]\n#[serial]\nfn custom_start_time() {\n    let _ = Builder::new()\n        .quiet()\n        .start_time(42.0.into())\n        .limit(RuntimeLimit::EventCount(10))\n        .build(CustomStartApp)\n        .run();\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":110204},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":110204},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":55014},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":55173},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":55014},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":55014},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":55014},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":55014},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":55173},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":55173},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":55173},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":55173},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":110059},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":110059},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":54886},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":54886},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":55173},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":29,"coverable":31},{"path":["/","Users","mk","Developer","rust","des","des","tests","builder-async.rs"],"content":"#![cfg(feature = \"async\")]\n\nuse std::{\n    io,\n    sync::{\n        atomic::{AtomicBool, AtomicU16, AtomicUsize, Ordering},\n        Arc,\n    },\n};\n\nuse des::{net::AsyncFn, prelude::*, time::sleep};\nuse serial_test::serial;\n\n#[test]\n#[serial]\nfn builder_async_fn_quasai_sync() {\n    let done = Arc::new(AtomicBool::new(false));\n    let d2 = done.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(move |_| {\n            let d2 = d2.clone();\n            async move {\n                d2.store(true, Ordering::SeqCst);\n            }\n        }),\n    );\n\n    assert_eq!(done.load(Ordering::SeqCst), false);\n    let _ = Builder::seeded(123).build(sim).run();\n    assert_eq!(done.load(Ordering::SeqCst), true);\n}\n\n#[test]\n#[serial]\nfn builder_async_fn_sleep() {\n    let time = Arc::new(AtomicU16::new(0));\n    let t2 = time.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(move |_| {\n            let t2 = t2.clone();\n            async move {\n                sleep(Duration::from_secs(10)).await;\n                t2.store(SimTime::now().as_secs() as u16, Ordering::SeqCst);\n            }\n        }),\n    );\n\n    assert_eq!(time.load(Ordering::SeqCst), 0);\n    let _ = Builder::seeded(123).build(sim).run();\n    assert_eq!(time.load(Ordering::SeqCst), 10);\n}\n\n#[test]\n#[serial]\nfn builder_async_fn_message_recv() {\n    let counter = Arc::new(AtomicU16::new(0));\n    let c2 = counter.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(move |mut rx| {\n            let c2 = c2.clone();\n            async move {\n                while let Some(msg) = rx.recv().await {\n                    c2.fetch_add(msg.header().id, Ordering::SeqCst);\n                }\n            }\n        }),\n    );\n    let gate = sim.gate(\"alice\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate.clone(), Message::new().id(1).build(), 1.0.into());\n    rt.add_message_onto(gate.clone(), Message::new().id(2).build(), 2.0.into());\n    rt.add_message_onto(gate.clone(), Message::new().id(3).build(), 3.0.into());\n\n    let _ = rt.run();\n    assert_eq!(counter.load(Ordering::SeqCst), 6);\n}\n\n#[test]\n#[serial]\nfn builder_async_fn_channeled() {\n    let counter = Arc::new(AtomicU16::new(0));\n    let c2 = counter.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"tx\",\n        AsyncFn::new(|_| async move {\n            for i in 0..16 {\n                sleep(Duration::from_secs(i)).await;\n                send(Message::new().id(i as u16).build(), \"port\");\n            }\n        }),\n    );\n    sim.node(\n        \"rx\",\n        AsyncFn::new(move |mut rx| {\n            let c2 = c2.clone();\n            async move {\n                while let Some(msg) = rx.recv().await {\n                    c2.fetch_add(msg.header().id, Ordering::SeqCst);\n                }\n            }\n        }),\n    );\n\n    let txg = sim.gate(\"tx\", \"port\");\n    let rxg = sim.gate(\"rx\", \"port\");\n\n    txg.connect(\n        rxg,\n        Some(Channel::new(ChannelMetrics {\n            bitrate: 10000,\n            latency: Duration::from_millis(20),\n            jitter: Duration::ZERO,\n            drop_behaviour: ChannelDropBehaviour::Queue(None),\n        })),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n    assert_eq!(counter.load(Ordering::SeqCst), (0..16).sum());\n}\n\n#[test]\n#[serial]\nfn builder_async_failable() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::failable(|_| async move {\n            if false {\n                return Err(io::Error::new(io::ErrorKind::Other, \"other\"));\n            }\n\n            Ok(())\n        }),\n    );\n    let _ = Builder::new().build(sim).run();\n}\n\n#[test]\n#[serial]\n#[should_panic]\nfn builder_async_failable_with_fail() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::failable(|_| async move {\n            if true {\n                return Err(io::Error::new(io::ErrorKind::Other, \"other\"));\n            }\n\n            Ok(())\n        }),\n    );\n    let _ = Builder::new().build(sim).run();\n}\n\n#[test]\n#[serial]\nfn builder_async_no_join() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|_| async move { std::future::pending().await }),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\n#[should_panic = \"at_sim_end() could not complete, since it is stuck at some await point\"]\nfn builder_async_require_join() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::io(|_| async move { std::future::pending().await }).require_join(),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\nfn builder_async_restart() {\n    static COUNTER: AtomicUsize = AtomicUsize::new(0);\n\n    let mut sim = Sim::new(());\n    let software = AsyncFn::io(|_| async move {\n        COUNTER.fetch_add(1, Ordering::SeqCst);\n\n        des::time::sleep(Duration::from_secs(10)).await;\n        shutdow_and_restart_in(Duration::from_secs(5));\n        std::future::pending().await\n    });\n    assert_eq!(format!(\"{software:?}\"), \"AsyncFn\");\n\n    sim.node(\"alice\", software);\n\n    let _ = Builder::seeded(123).max_time(25.0.into()).build(sim).run();\n\n    // once at 0, 15, next would be 30\n    assert_eq!(COUNTER.load(Ordering::SeqCst), 2);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","tests","builder.rs"],"content":"#![cfg(feature = \"net\")]\n\nuse des::{\n    net::{FailabilityPolicy, HandlerFn, ModuleBlock, ModuleFn},\n    prelude::*,\n};\nuse serial_test::serial;\nuse spin::Mutex;\nuse std::{\n    hint::black_box,\n    io,\n    sync::{\n        atomic::{AtomicU16, Ordering},\n        Arc,\n    },\n};\n\n#[test]\n#[serial]\nfn builder_builds_hierachie() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"parent\",\n        ModuleFn::new(\n            || {\n                assert!(current().parent().is_err());\n                assert!(current().child(\"child\").is_ok());\n            },\n            |_, _| {},\n        ),\n    );\n    sim.node(\n        \"parent.child\",\n        ModuleFn::new(\n            || {\n                assert!(current().parent().is_ok());\n                assert!(current().child(\"grandchild\").is_ok());\n            },\n            |_, _| {},\n        ),\n    );\n    sim.node(\n        \"parent.child.grandchild\",\n        ModuleFn::new(\n            || {\n                assert!(current().parent().is_ok());\n                assert!(current().child(\"some\").is_err());\n            },\n            |_, _| {},\n        ),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\n#[should_panic = \"cannot create node 'alice', node allready exists\"]\nfn builder_panic_node_duplicate() {\n    let mut sim = Sim::new(());\n    sim.node(\"alice\", HandlerFn::new(|_| {}));\n    sim.node(\"bob\", HandlerFn::new(|_| {}));\n    sim.node(\"alice\", HandlerFn::new(|_| {}));\n}\n\n#[test]\n#[serial]\n#[should_panic = \"cannot create node 'bob.bombardil', since parent node 'bob' is required, but does not exist\"]\nfn builder_panic_missing_parent() {\n    let mut sim = Sim::new(());\n    sim.node(\"alice\", HandlerFn::new(|_| {}));\n    sim.node(\"alice.alicent\", HandlerFn::new(|_| {}));\n    sim.node(\"bob.bombardil\", HandlerFn::new(|_| {}));\n}\n\n#[test]\n#[serial]\n#[should_panic = \"cannot create gate 'bob.port', because node 'bob' does not exist\"]\nfn builder_panic_gate_missing_node() {\n    let mut sim = Sim::new(());\n    sim.node(\"alice\", HandlerFn::new(|_| {}));\n    let _ = sim.gate(\"alice\", \"port\");\n\n    let _ = sim.gate(\"bob\", \"port\");\n}\n\n#[test]\n#[serial]\nfn builder_gate_cluster() {\n    struct Alice;\n    impl Module for Alice {\n        fn at_sim_start(\u0026mut self, _: usize) {\n            for i in 0..4 {\n                assert!(current().gate(\"cluster\", i).is_some());\n            }\n        }\n    }\n\n    let mut sim = Sim::new(());\n    sim.node(\"alice\", Alice);\n    let _ = sim.gates(\"alice\", \"cluster\", 4);\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\nfn builder_module_block() {\n    struct Def;\n    struct Block;\n    impl Module for Def {}\n    impl ModuleBlock for Block {\n        fn build\u003cA\u003e(self, mut sim: ScopedSim\u003c'_, A\u003e) {\n            sim.root(Def);\n            let _ = sim.gate(\"\", \u0026format!(\"port-{}\", sim.scope()));\n\n            sim.node(\"sub\", Def);\n            let _ = sim.gates(\"sub\", \"cluster\", 123);\n\n            let _ = sim.inner();\n        }\n    }\n\n    let mut sim = Sim::new(());\n    sim.node(\"alice\", Block);\n    assert!(sim.get(\u0026\"alice.sub\".into()).is_some());\n}\n\n#[test]\n#[serial]\nfn builder_handler_fn() {\n    let counter = Arc::new(AtomicU16::new(0));\n    let c2 = counter.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        HandlerFn::new(move |msg| {\n            c2.fetch_add(msg.header().id, Ordering::SeqCst);\n        }),\n    );\n    let gate = sim.gate(\"alice\", \"port\");\n    let other = sim.gate(\"alice\", \"port\");\n    assert!(Arc::ptr_eq(\u0026gate, \u0026other));\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate.clone(), Message::new().id(1).build(), 1.0.into());\n    rt.add_message_onto(gate.clone(), Message::new().id(2).build(), 2.0.into());\n    rt.add_message_onto(gate.clone(), Message::new().id(3).build(), 3.0.into());\n\n    let _ = rt.run();\n    assert_eq!(counter.load(Ordering::SeqCst), 6);\n}\n\n#[test]\n#[serial]\nfn builder_handler_fn_with_err() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        HandlerFn::failable(\n            |_| {\n                if black_box(false) {\n                    return Err(io::Error::new(io::ErrorKind::Other, \"other\"));\n                }\n\n                Ok(())\n            },\n            FailabilityPolicy::Panic,\n        ),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\n#[should_panic = \"node 'alice' failed to process message, handler fn failed with: other\"]\nfn builder_handler_fn_failure_panic() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        HandlerFn::failable(\n            |_| {\n                if black_box(true) {\n                    return Err(io::Error::new(io::ErrorKind::Other, \"other\"));\n                }\n\n                Ok(())\n            },\n            FailabilityPolicy::Panic,\n        ),\n    );\n    let gate = sim.gate(\"alice\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate, Message::new().build(), 1.0.into());\n\n    let _ = rt.run();\n}\n\n#[test]\n#[serial]\nfn builder_handler_fn_failure_no_panic() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        HandlerFn::failable(\n            |_| {\n                if black_box(true) {\n                    return Err(io::Error::new(io::ErrorKind::Other, \"other\"));\n                }\n\n                Ok(())\n            },\n            FailabilityPolicy::Continue,\n        ),\n    );\n    let gate = sim.gate(\"alice\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate, Message::new().build(), 1.0.into());\n\n    let _ = rt.run();\n}\n\n#[test]\n#[serial]\nfn builder_module_fn() {\n    let records = Arc::new(Mutex::new(Vec::new()));\n    let r2 = records.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        ModuleFn::new(\n            || 0,\n            move |state, _| {\n                *state += 1;\n                if *state \u003e 8 {\n                    r2.lock().push(*state);\n                }\n            },\n        ),\n    );\n    let gate = sim.gate(\"alice\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    for i in 0..10 {\n        rt.add_message_onto(\n            gate.clone(),\n            Message::new().id(i).build(),\n            (i as f64).into(),\n        );\n    }\n\n    let _ = rt.run();\n    assert_eq!(*records.lock(), [9, 10]);\n}\n\n#[test]\n#[serial]\nfn builder_module_fn_restart_at_failure() {\n    let starts = Arc::new(AtomicU16::new(0));\n    let s2 = starts.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        ModuleFn::failable(\n            move || {\n                s2.fetch_add(1, Ordering::SeqCst);\n                0\n            },\n            |_, msg| {\n                if msg.header().id == 1 {\n                    Err(io::Error::new(io::ErrorKind::Other, \"other\"))\n                } else {\n                    Ok(())\n                }\n            },\n            FailabilityPolicy::Restart,\n        ),\n    );\n    let gate = sim.gate(\"alice\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate.clone(), Message::new().id(1).build(), 1.0.into());\n    rt.add_message_onto(gate.clone(), Message::new().id(1).build(), 2.0.into());\n    rt.add_message_onto(gate.clone(), Message::new().id(2).build(), 3.0.into());\n\n    let _ = rt.run();\n    assert_eq!(starts.load(Ordering::SeqCst), 3);\n}\n\n#[test]\n#[serial]\nfn builder_module_fn_gen_in_module_scope() {\n    let stage = Arc::new(AtomicU16::new(0));\n    let s2 = stage.clone();\n\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        ModuleFn::new(\n            move || {\n                s2.store(1, Ordering::SeqCst);\n                assert_eq!(current().path().as_str(), \"alice\");\n\n                123\n            },\n            |_, _| {},\n        ),\n    );\n\n    assert_eq!(stage.load(Ordering::SeqCst), 0);\n    let _ = Builder::seeded(123).build(sim).run();\n    assert_eq!(stage.load(Ordering::SeqCst), 1);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","tests","channels.rs"],"content":"#![cfg(feature = \"net\")]\nuse std::sync::{\n    atomic::{AtomicUsize, Ordering},\n    Arc,\n};\n\nuse des::{\n    net::channel::{ChannelDropBehaviour, ChannelProbe},\n    prelude::*,\n};\nuse rand::{rngs::StdRng, SeedableRng};\nuse serial_test::serial;\n\n#[derive(Default)]\nstruct DropChanModule {\n    send: usize,\n    received: usize,\n}\n\nimpl Module for DropChanModule {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        send(Message::new().content([0u8; 512]).build(), \"out\");\n        send(Message::new().content([1u8; 512]).build(), \"out\");\n\n        self.send += 2;\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        self.received += 1;\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_ne!(self.send, self.received)\n    }\n}\n\n#[test]\n#[serial]\nfn channel_dropping_message() {\n    let mut rt = Sim::new(());\n    rt.node(\"root\", DropChanModule::default());\n\n    let g_in = rt.gate(\"root\", \"in\");\n    let g_out = rt.gate(\"root\", \"out\");\n\n    let channel = Channel::new(ChannelMetrics {\n        bitrate: 1000,\n        latency: Duration::from_millis(100),\n        jitter: Duration::ZERO,\n        drop_behaviour: ChannelDropBehaviour::default(),\n    });\n    g_in.connect(g_out, Some(channel));\n\n    let rt = Builder::seeded(123).build(rt);\n    let _ = rt.run();\n}\n\n#[derive(Debug, Default)]\nstruct BufferChanModule {\n    send: usize,\n    received: usize,\n}\n\nimpl Module for BufferChanModule {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        send(Message::new().content([0u8; 512]).build(), \"out\");\n        send(Message::new().content([1u8; 512]).build(), \"out\");\n        send(Message::new().content([1u8; 512]).build(), \"out\");\n\n        self.send += 3;\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        self.received += 1;\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.send, 3);\n        assert_eq!(self.received, 2);\n    }\n}\n\n#[test]\n#[serial]\nfn channel_buffering_message() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", BufferChanModule::default());\n\n    let g_in = rt.gate(\"root\", \"in\");\n    let g_out = rt.gate(\"root\", \"out\");\n\n    let channel = Channel::new(ChannelMetrics {\n        bitrate: 1000,\n        latency: Duration::from_millis(100),\n        jitter: Duration::ZERO,\n        drop_behaviour: ChannelDropBehaviour::Queue(Some(600)),\n    });\n    g_in.connect(g_out, Some(channel));\n\n    let rt = Builder::seeded(123).build(rt);\n    let _ = rt.run();\n}\n\nstruct SendMessageModule;\nimpl Module for SendMessageModule {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        schedule_in(Message::new().kind(10).build(), Duration::from_secs(1));\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        if msg.header().kind == 10 {\n            send(Message::new().content(\"Hello world\").build(), \"out\");\n            let gate = current().gate(\"out\", 0).unwrap();\n            let ch = gate.channel().unwrap();\n            assert!(ch.is_busy());\n        }\n    }\n}\n\n#[test]\n#[serial]\nfn channel_instant_busy() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", SendMessageModule);\n\n    let g_in = rt.gate(\"root\", \"in\");\n    let g_out = rt.gate(\"root\", \"out\");\n\n    let channel = Channel::new(ChannelMetrics::new(\n        1000,\n        Duration::from_millis(100),\n        Duration::ZERO,\n        ChannelDropBehaviour::default(),\n    ));\n\n    g_in.connect(g_out, Some(channel));\n\n    let rt = Builder::seeded(123).build(rt);\n    let _ = rt.run();\n}\n\n#[derive(Default)]\nstruct ChannelProbing(Arc\u003cAtomicUsize\u003e);\nimpl Module for ChannelProbing {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        let chan = current().gate(\"port\", 0).unwrap().channel().unwrap();\n\n        chan.attach_probe(Probe(self.0.clone()));\n        assert_eq!(chan.metrics().bitrate, 1234);\n\n        let msg = Message::new().build();\n        let busy_time = chan.calculate_busy(\u0026msg);\n        let tft = SimTime::now() + busy_time;\n        dbg!(busy_time);\n        assert_eq!(\n            tft + Duration::from_millis(100),\n            SimTime::from_duration(chan.calculate_duration(\u0026msg, \u0026mut StdRng::seed_from_u64(123)))\n        );\n\n        assert_eq!(chan.transmission_finish_time(), SimTime::MIN);\n        assert_eq!(format!(\"{chan:?}\"), format!(\"Channel {{ metrics: ChannelMetrics {{ bitrate: 1234, latency: 100ms, jitter: 0ns, drop_behaviour: Drop }}, state: Idle }}\"));\n\n        send(msg, \"port\");\n\n        assert_eq!(chan.transmission_finish_time(), tft);\n        assert_eq!(format!(\"{chan:?}\"), format!(\"Channel {{ metrics: ChannelMetrics {{ bitrate: 1234, latency: 100ms, jitter: 0ns, drop_behaviour: Drop }}, state: Busy {{ until: {tft}, bytes: 0, packets: 0 }} }}\"));\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.0.load(Ordering::SeqCst), 1);\n    }\n}\n\nstruct Probe(Arc\u003cAtomicUsize\u003e);\nimpl ChannelProbe for Probe {\n    fn on_message_transmit(\u0026mut self, _: \u0026ChannelMetrics, _: \u0026Message) {\n        self.0.fetch_add(1, Ordering::SeqCst);\n    }\n}\n\n#[test]\n#[serial]\nfn channel_probes() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut rt = Sim::new(());\n    rt.node(\"alice\", ChannelProbing::default());\n    rt.node(\"bob\", ChannelProbing::default());\n\n    let alice_port = rt.gate(\"alice\", \"port\");\n    let bob_port = rt.gate(\"bob\", \"port\");\n\n    let chan = Channel::new(ChannelMetrics {\n        bitrate: 1234,\n        latency: Duration::from_millis(100),\n        jitter: Duration::ZERO,\n        drop_behaviour: ChannelDropBehaviour::default(),\n    });\n\n    alice_port.connect(bob_port, Some(chan));\n\n    let rt = Builder::seeded(123).build(rt);\n    let _ = rt.run();\n}\n\nstruct LatencyOnly(usize);\n\nimpl Module for LatencyOnly {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        for _ in 0..10 {\n            send(Message::new().build(), \"out\");\n        }\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        self.0 += 1;\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.0, 10);\n    }\n}\n\n#[test]\n#[serial]\nfn latency_only_channel() {\n    let mut sim = Sim::new(());\n    sim.node(\"alice\", LatencyOnly(0));\n    let gout = sim.gate(\"alice\", \"out\");\n    let gin = sim.gate(\"alice\", \"in\");\n    gout.connect(\n        gin,\n        Some(Channel::new(ChannelMetrics::new(\n            0,\n            Duration::from_secs(1),\n            Duration::ZERO,\n            ChannelDropBehaviour::Drop,\n        ))),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":53,"coverable":53},{"path":["/","Users","mk","Developer","rust","des","des","tests","common","mock.rs"],"content":"#![allow(unused)]\n\nuse spin::Mutex;\nuse std::{io, sync::Arc};\nuse tracing_subscriber::fmt::MakeWriter;\n\n#[derive(Debug, Clone)]\npub struct MakeMockWriter {\n    lines: Arc\u003cMutex\u003cString\u003e\u003e,\n}\n\n#[derive(Debug, Clone)]\npub struct MockWriter {\n    lines: Arc\u003cMutex\u003cString\u003e\u003e,\n}\n\nimpl io::Write for MockWriter {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e io::Result\u003cusize\u003e {\n        let mut lines = self.lines.lock();\n        lines.push_str(\u0026String::from_utf8_lossy(buf));\n        Ok(buf.len())\n    }\n\n    fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        Ok(())\n    }\n}\n\nimpl MakeMockWriter {\n    pub fn new() -\u003e Self {\n        MakeMockWriter {\n            lines: Arc::new(Mutex::new(String::new())),\n        }\n    }\n\n    pub fn content(\u0026self) -\u003e String {\n        self.lines.lock().clone()\n    }\n}\n\nimpl\u003c'a\u003e MakeWriter\u003c'a\u003e for MakeMockWriter {\n    type Writer = MockWriter;\n    fn make_writer(\u0026'a self) -\u003e Self::Writer {\n        MockWriter {\n            lines: self.lines.clone(),\n        }\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":12},"fn_name":null}],"covered":10,"coverable":12},{"path":["/","Users","mk","Developer","rust","des","des","tests","load-order.rs"],"content":"#![cfg(feature = \"net\")]\n\nuse des::net::ModuleFn;\nuse des::prelude::*;\nuse std::sync::{atomic::AtomicU16, Arc};\n\n#[test]\nfn load_order() {\n    let state = Arc::new(AtomicU16::new(0));\n    let mut sim = Sim::new(());\n\n    macro_rules! stage {\n        ($i:ident == $l:literal) =\u003e {{\n            let old = $i.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n            assert_eq!(old, $l);\n        }};\n    }\n\n    let s2 = state.clone();\n    sim.node(\"alice\", ModuleFn::new(move || stage!(s2 == 0), |_, _| {}));\n    let s2 = state.clone();\n    sim.node(\n        \"alice.submodule\",\n        ModuleFn::new(move || stage!(s2 == 1), |_, _| {}),\n    );\n    let s2 = state.clone();\n    sim.node(\n        \"alice.bob\",\n        ModuleFn::new(move || stage!(s2 == 3), |_, _| {}),\n    );\n    let s2 = state.clone();\n    sim.node(\n        \"alice.submodule.sub\",\n        ModuleFn::new(move || stage!(s2 == 2), |_, _| {}),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","tests","message-body.rs"],"content":"use des::prelude::*;\n\nmacro_rules! test_primive {\n    ($ident:ident, $t:ty, $e:expr, $s:expr) =\u003e {\n        #[test]\n        fn $ident() {\n            let value: $t = $e;\n            assert_eq!(value.byte_len(), $s)\n        }\n    };\n}\ntest_primive!(test_void, (), (), 0);\n\ntest_primive!(test_u8, u8, 0, 1);\ntest_primive!(test_u16, u16, 0, 2);\ntest_primive!(test_u32, u32, 0, 4);\ntest_primive!(test_u64, u64, 0, 8);\ntest_primive!(test_u128, u128, 0, 16);\n\ntest_primive!(test_i8, i8, 0, 1);\ntest_primive!(test_i16, i16, 0, 2);\ntest_primive!(test_i32, i32, 0, 4);\ntest_primive!(test_i64, i64, 0, 8);\ntest_primive!(test_i128, i128, 0, 16);\n\ntest_primive!(test_f32, f32, 0.0, 4);\ntest_primive!(test_f64, f64, 0.0, 8);\n\ntest_primive!(test_bool, bool, true, 1);\ntest_primive!(test_char, char, 'a', 4);\n\n#[test]\nfn test_string() {\n    assert_eq!(String::new().byte_len(), 0);\n    assert_eq!(\"Hello World\".to_string().byte_len(), 11);\n    assert_eq!(\"Hello World\".to_string().byte_len(), 15);\n}\n\n#[test]\n#[allow(unused_allocation)]\nfn test_box() {\n    assert_eq!(Box::new(0u8).byte_len(), 1);\n    assert_eq!(Box::new(0i128).byte_len(), 16);\n    assert_eq!(Box::new(String::from(\"Hello World\")).byte_len(), 11);\n    assert_eq!(Box::new(()).byte_len(), 0);\n}\n\n#[test]\nfn test_option() {\n    assert_eq!(Some(0u8).byte_len(), 1);\n    let v: Option\u003cu8\u003e = None;\n    assert_eq!(v.byte_len(), 0);\n\n    assert_eq!(Some(\"Hello World\".to_string()).byte_len(), 11);\n    let v: Option\u003cString\u003e = None;\n    assert_eq!(v.byte_len(), 0);\n}\n\n#[test]\nfn test_result() {\n    type R = Result\u003cString, u8\u003e;\n    let v: R = Ok(\"Hello World\".to_string());\n    assert_eq!(v.byte_len(), 11);\n\n    let v: R = Ok(String::new());\n    assert_eq!(v.byte_len(), 0);\n\n    let v: R = Err(0);\n    assert_eq!(v.byte_len(), 1);\n\n    let v: R = Err(16);\n    assert_eq!(v.byte_len(), 1);\n}\n\n#[test]\nfn test_collections() {\n    let v = vec![1u8, 2, 3];\n    assert_eq!(v.byte_len(), 3);\n\n    let v = vec![String::new(), format!(\"Hello World\"), format!(\"ABC\")];\n    assert_eq!(v.byte_len(), 11 + 3);\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":15},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","Users","mk","Developer","rust","des","des","tests","meta.rs"],"content":"use des::prelude::*;\nuse serial_test::serial;\n\nstruct Parent;\n\nimpl Module for Parent {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        current().set_meta(32u64);\n        schedule_in(Message::new().build(), Duration::from_secs(1));\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        assert_eq!(current().meta::\u003cu64\u003e(), Some(32));\n        assert_eq!(current().meta::\u003cbool\u003e(), None);\n\n        assert_eq!(\n            current().child(\"a\").unwrap().meta::\u003cString\u003e(),\n            Some(\"a\".to_string())\n        );\n        assert_eq!(\n            current().child(\"b\").unwrap().meta::\u003cString\u003e(),\n            Some(\"b\".to_string())\n        );\n    }\n}\n\nstruct Child;\n\nimpl Module for Child {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        current().set_meta(current().name());\n        schedule_in(Message::new().build(), Duration::from_secs(1));\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        assert_eq!(current().parent().unwrap().meta::\u003cu64\u003e(), Some(32));\n    }\n}\n\n#[test]\n#[serial]\nfn read_meta_through_tree() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut rt = Sim::new(());\n\n    rt.node(\"root\", Parent);\n    rt.node(\"root.a\", Child);\n    rt.node(\"root.b\", Child);\n\n    let rt = Builder::seeded(123).build(rt);\n\n    let res = rt.run();\n    let _res = res.unwrap();\n}\n\nstruct Overrider;\nimpl Module for Overrider {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        current().set_meta(32u64);\n        schedule_in(Message::new().build(), Duration::from_secs(1));\n        current().set_meta(64u64);\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        assert_eq!(current().meta::\u003cu64\u003e(), Some(64));\n    }\n}\n\n#[test]\n#[serial]\nfn meta_override_previous_value() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", Overrider);\n\n    let rt = Builder::seeded(123).build(rt);\n\n    let res = rt.run();\n    let _res = res.unwrap();\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":23,"coverable":23},{"path":["/","Users","mk","Developer","rust","des","des","tests","ndl.rs"],"content":"#![cfg(feature = \"ndl\")]\n\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\nuse des::{prelude::*, registry};\nuse des_ndl::error::RootResult;\n\n#[path = \"common/mock.rs\"]\nmod mock;\n\nmod common {\n    use des::{net::module::current, prelude::*};\n\n    #[derive(Default)]\n    pub struct Main;\n    impl Module for Main {}\n\n    #[derive(Default)]\n    pub struct Node {\n        dst: usize,\n        rem: usize,\n        delay: Duration,\n        rcv: usize,\n    }\n    impl Module for Node {\n        fn at_sim_start(\u0026mut self, _stage: usize) {\n            self.dst = par(\"dst\")\n                .as_option()\n                .map(|s| s.parse::\u003cusize\u003e().unwrap())\n                .unwrap_or(0);\n            self.rem = par(\"c\")\n                .as_option()\n                .map(|s| s.parse::\u003cusize\u003e().unwrap())\n                .unwrap_or(0);\n            self.delay = Duration::from_secs_f64(\n                par(\"delay\")\n                    .as_option()\n                    .map(|s| s.parse::\u003cf64\u003e().unwrap())\n                    .unwrap_or(1.0),\n            );\n\n            tracing::info!(\n                \"sim_start(dst := {}, c := {}, delay := {})\",\n                self.dst,\n                self.rem,\n                self.delay.as_secs_f64()\n            );\n            if self.rem \u003e 0 {\n                schedule_in(Message::new().kind(1).build(), self.delay)\n            }\n        }\n\n        fn handle_message(\u0026mut self, msg: Message) {\n            match msg.header().kind {\n                1 =\u003e {\n                    self.rem -= 1;\n                    send(Message::new().kind(2).id(self.dst as u16).build(), \"out\");\n\n                    if self.rem \u003e 0 {\n                        schedule_in(Message::new().kind(1).build(), self.delay)\n                    }\n                }\n                2 =\u003e {\n                    if current().name().starts_with(\"node\") {\n                        assert_eq!(format!(\"node[{}]\", msg.header().id), current().name());\n                        self.rcv += 1;\n                    }\n                    if current().name().starts_with(\"ring\") {\n                        if format!(\"ring[{}]\", msg.header().id) == current().name() {\n                            self.rcv += 1;\n                        } else {\n                            send(msg, \"out\")\n                        }\n                    }\n                }\n                _ =\u003e unreachable!(),\n            }\n        }\n\n        fn at_sim_end(\u0026mut self) {\n            if let Some(v) = par(\"expected\")\n                .as_option()\n                .map(|v| v.parse::\u003cusize\u003e().unwrap())\n            {\n                assert_eq!(v, self.rcv, \"failed at module: {}\", current().path());\n            }\n        }\n    }\n\n    #[derive(Default)]\n    pub struct Debugger;\n    impl Module for Debugger {}\n\n    #[derive(Default)]\n    pub struct Router;\n    impl Module for Router {\n        fn handle_message(\u0026mut self, msg: Message) {\n            let g = current().gate(\"out\", msg.header().id as usize).unwrap();\n            send(msg, g);\n        }\n    }\n}\nuse common::*;\nuse serial_test::serial;\n\n#[test]\n#[serial]\nfn small_network() -\u003e RootResult\u003c()\u003e {\n    // Logger::new().set_logger();\n\n    let mut app = Sim::ndl(\n        \"tests/ndl/small_network/main.ndl\",\n        registry![Main, Node, Router, Debugger],\n    )?;\n    app.include_par_file(\"tests/ndl/small_network/main.par\")\n        .unwrap();\n\n    let r = Builder::seeded(123)\n        .max_time(1000.0.into())\n        .build(app)\n        .run()\n        .unwrap();\n\n    assert_eq!(r.1.as_secs(), 200);\n    Ok(())\n}\n\n#[test]\n#[serial]\nfn ring_topology() -\u003e RootResult\u003c()\u003e {\n    // Logger::new().set_logger();\n\n    let mut app = Sim::ndl(\n        \"tests/ndl/ring_topo/main.ndl\",\n        registry![Main, Node, Router, Debugger],\n    )?;\n    app.include_par_file(\"tests/ndl/ring_topo/main.par\")\n        .unwrap();\n\n    let r = Builder::seeded(123)\n        .max_time(1000.0.into())\n        .build(app)\n        .run()\n        .unwrap();\n\n    assert_eq!(r.1.as_secs(), 200);\n    Ok(())\n}\n\nstruct Single;\n\nimpl RegistryCreatable for Single {\n    fn create(path: \u0026ObjectPath, _: \u0026str) -\u003e Self {\n        println!(\"{path}\");\n        assert!(par(\"addr\").is_some());\n        Self\n    }\n}\n\nimpl Module for Single {}\n\n#[test]\n#[serial]\nfn build_with_preexisting_sim() -\u003e RootResult\u003c()\u003e {\n    let mut sim = Sim::new(());\n    sim.include_par(\"alice.addr = 1.1.1.1\\n\");\n    sim.build_ndl(\"tests/ndl/single.ndl\", registry![Single, else _])?;\n\n    let _ = Builder::seeded(123).build(sim).run();\n    Ok(())\n}\n\n#[test]\n#[serial]\nfn non_std_gate_connections() -\u003e RootResult\u003c()\u003e {\n    let sim = Sim::ndl(\n        \"tests/ndl/local-con.ndl\",\n        Registry::new().with_default_fallback(),\n    )?;\n    let _ = Builder::seeded(123).build(sim).run();\n    Ok(())\n}\n\n#[test]\n#[serial]\nfn registry_missing_symbol() {\n    let sim: Result\u003cSim\u003c()\u003e, des_ndl::error::RootError\u003e = Sim::ndl(\n        \"tests/ndl/ab-deep.ndl\",\n        Registry::new().symbol(\"Main\", |_| Debugger),\n    );\n    let errors = sim.unwrap_err().errors;\n    assert_eq!(errors.len(), 3);\n    assert_eq!(\n        errors.get(0).unwrap().internal.to_string(),\n        \"symbol 'A' at 'a' could not be resolved by the registry\",\n    );\n    assert_eq!(\n        errors.get(1).unwrap().internal.to_string(),\n        \"symbol 'B' at 'a.b' could not be resolved by the registry\",\n    );\n    assert_eq!(\n        errors.get(2).unwrap().internal.to_string(),\n        \"symbol 'B' at 'b' could not be resolved by the registry\",\n    );\n}\n\n#[test]\n#[serial]\nfn registry_fmt() {\n    assert_eq!(\n        format!(\"{:?}\", Registry::new().symbol(\"A\", |_| Debugger)),\n        \"Registry\"\n    );\n}\n\n#[test]\n#[serial]\nfn registry_custom_resolver() -\u003e RootResult\u003c()\u003e {\n    static COUNTER: AtomicUsize = AtomicUsize::new(0);\n\n    let registry = Registry::default()\n        .symbol(\"A\", |_| Debugger)\n        .symbol(\"Main\", |_| Debugger)\n        .custom(|_, symbol| {\n            if symbol == \"B\" {\n                COUNTER.fetch_add(1, Ordering::SeqCst);\n                Some(Debugger)\n            } else {\n                None\n            }\n        });\n\n    let sim = Sim::ndl(\"tests/ndl/ab.ndl\", registry)?;\n    let _ = Builder::seeded(123).build(sim).run();\n\n    assert_eq!(COUNTER.load(Ordering::SeqCst), 1);\n\n    Ok(())\n}\n\nstruct Sender;\nimpl Module for Sender {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        send(Message::new().build(), \"port\")\n    }\n}\n\n#[test]\n#[serial]\nfn registry_default_fallback_does_not_pani() -\u003e RootResult\u003c()\u003e {\n    let registry = Registry::default()\n        .symbol(\"A\", |_| Sender)\n        .with_default_fallback();\n\n    let sim = Sim::ndl(\"tests/ndl/ab.ndl\", registry)?;\n    let _ = Builder::seeded(123).build(sim).run();\n\n    Ok(())\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2500},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2500},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":950},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":950},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":950},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":941},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1550},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":450},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":450},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1550},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1600},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":500},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":600},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":450},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":450},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":450},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":42,"coverable":46},{"path":["/","Users","mk","Developer","rust","des","des","tests","net.rs"],"content":"use des::prelude::*;\n\n#[derive(Default)]\nstruct Receiver {\n    counter: usize,\n}\n\nimpl Module for Receiver {\n    fn handle_message(\u0026mut self, _msg: Message) {\n        self.counter += 1;\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.counter, 10);\n    }\n}\n\n#[derive(Default)]\nstruct Sender;\n\nimpl Module for Sender {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        for i in 0..10 {\n            send_in(\n                Message::new().id(i as u16).build(),\n                (\"port\", 0),\n                Duration::from_secs(i),\n            );\n        }\n    }\n}\n\n#[test]\nfn connectivity() {\n    let mut app = Sim::new(());\n\n    app.node(\"rx\", Receiver::default());\n    app.node(\"tx\", Sender::default());\n\n    let rx = app.gate(\"rx\", \"port\");\n    let tx = app.gate(\"tx\", \"port\");\n\n    rx.connect(\n        tx,\n        Some(Channel::new(ChannelMetrics {\n            bitrate: 10000,\n            latency: Duration::from_millis(100),\n            jitter: Duration::ZERO,\n            drop_behaviour: ChannelDropBehaviour::Queue(None),\n        })),\n    );\n\n    let app = Builder::seeded(123).build(app);\n    let _ = app.run().unwrap();\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":10},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","Users","mk","Developer","rust","des","des","tests","par.rs"],"content":"#![cfg(feature = \"net\")]\n\nuse std::io;\n\nuse des::net::{par_export, ModuleFn, Par};\nuse des::prelude::*;\nuse serial_test::serial;\n\nfn par_for_r(module: \u0026str, key: \u0026str) -\u003e Par {\n    par_for(key, module)\n}\n\nconst EXAMPLE_TYPES: \u0026str = \"\n    netA.*.text = \\\"My name\\\"\n    netA.s0.usize = 123\n    netA.s1.usize = 420\n    netA.s1.isize = -120\n\";\n\nconst EXAMPLE_NETWORK: \u0026str = \"\n    netA.*.dnsServer = 1.1.1.1\n    netA.s0.ip = 0.0.0.1\n    netA.s1.ip = 0.0.0.1\n    netA.s1.ipv6 = fe80\n\";\n\n#[test]\n#[serial]\nfn non_parse_read() {\n    let rt = Sim::new(());\n    let par = \u0026rt.globals().parameters;\n\n    par.build(EXAMPLE_NETWORK);\n\n    assert!(par_for_r(\"netB.s1\", \"dnsServer\").is_none());\n\n    // Case \"netA.s0\"\n    assert_eq!(\n        par_for_r(\"netA.s0\", \"dnsServer\").as_option(),\n        Some(\"1.1.1.1\".to_string())\n    );\n    assert_eq!(\n        par_for_r(\"netA.s0\", \"ip\").as_option(),\n        Some(\"0.0.0.1\".to_string())\n    );\n    assert_eq!(par_for_r(\"netA.s0\", \"ipv6\").as_option(), None);\n\n    // Case \"netA.s1\"\n    assert_eq!(\n        par_for_r(\"netA.s1\", \"dnsServer\").as_option(),\n        Some(\"1.1.1.1\".to_string())\n    );\n    assert_eq!(\n        par_for_r(\"netA.s1\", \"ip\").as_option(),\n        Some(\"0.0.0.1\".to_string())\n    );\n    assert_eq!(\n        par_for_r(\"netA.s1\", \"ipv6\").as_option(),\n        Some(\"fe80\".to_string())\n    );\n\n    // Case \"netA.other\"\n    assert_eq!(\n        par_for_r(\"netA.other\", \"dnsServer\").as_option(),\n        Some(\"1.1.1.1\".to_string())\n    );\n    assert_eq!(par_for_r(\"netA.other\", \"ip\").as_option(), None);\n    assert_eq!(par_for_r(\"netA.other\", \"ipv6\").as_option(), None);\n}\n\n#[test]\n#[serial]\nfn parse_integers() {\n    let rt = Sim::new(());\n    let par = \u0026rt.globals().parameters;\n\n    par.build(EXAMPLE_TYPES);\n\n    // Case \"netA.s0\"\n    assert_eq!(\n        *par_for_r(\"netA.s0\", \"text\").unwrap(),\n        \"\\\"My name\\\"\".to_string()\n    );\n    assert_eq!(\n        par_for_r(\"netA.s0\", \"usize\")\n            .unwrap()\n            .parse::\u003cusize\u003e()\n            .unwrap(),\n        123\n    );\n    assert_eq!(par_for_r(\"netA.s0\", \"isize\").as_option(), None);\n\n    // Case \"netA.s1\"\n    assert_eq!(\n        *par_for_r(\"netA.s1\", \"text\").unwrap(),\n        \"\\\"My name\\\"\".to_string()\n    );\n    assert_eq!(\n        par_for_r(\"netA.s1\", \"usize\")\n            .unwrap()\n            .parse::\u003cusize\u003e()\n            .unwrap(),\n        420\n    );\n    assert_eq!(\n        par_for_r(\"netA.s1\", \"isize\")\n            .unwrap()\n            .parse::\u003cisize\u003e()\n            .unwrap(),\n        -120\n    );\n\n    // Case \"netA.other\"\n    assert_eq!(\n        par_for_r(\"netA.other\", \"text\").as_option(),\n        Some(\"\\\"My name\\\"\".to_string())\n    );\n    assert_eq!(par_for_r(\"netA.other\", \"usize\").as_option(), None);\n    assert_eq!(par_for_r(\"netA.other\", \"isize\").as_option(), None);\n}\n\n#[test]\n#[serial]\nfn parse_strings() {\n    let rt = Sim::new(());\n    let par = \u0026rt.globals().parameters;\n    par.build(EXAMPLE_TYPES);\n\n    let handle = par_for_r(\"netA.other\", \"text\").unwrap();\n\n    assert_eq!(\u0026*handle, \"\\\"My name\\\"\");\n    assert_eq!(handle.into_inner(), \"My name\".to_string());\n}\n\n#[test]\n#[serial]\nfn par_remove() {\n    let mut sim = Sim::new(());\n    sim.globals().parameters.build(\"counter = 123\");\n    sim.node(\n        \"\",\n        ModuleFn::new(\n            || {\n                assert!(par(\"counter\").is_some());\n                let _ = par(\"counter\").unset();\n                assert!(par(\"counter\").is_none());\n            },\n            |_, _| {},\n        ),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\n#[should_panic = \"failed to unwrap addr\"]\nfn par_panic() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"\",\n        ModuleFn::new(\n            || {\n                let _ = par(\"addr\").expect(\"failed to unwrap addr\");\n            },\n            |_, _| {},\n        ),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n\n#[test]\n#[serial]\nfn par_export_test() -\u003e io::Result\u003c()\u003e {\n    let rt = Sim::new(());\n    rt.globals().parameters.build(EXAMPLE_NETWORK);\n\n    let mut str = Vec::new();\n    par_export(\u0026mut str)?;\n\n    let str = String::from_utf8_lossy(\u0026str);\n    assert_eq!(str, \"netA.*.dnsServer = 1.1.1.1\\nnetA.s0.ip = 0.0.0.1\\nnetA.s1.ipv6 = fe80\\nnetA.s1.ip = 0.0.0.1\\n\");\n\n    Ok(())\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":20},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","Users","mk","Developer","rust","des","des","tests","processing.rs"],"content":"#![cfg(feature = \"net\")]\nuse des::net::processing::*;\nuse des::prelude::*;\nuse serial_test::serial;\nuse std::sync::atomic::Ordering::SeqCst;\nuse std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\nuse std::sync::Arc;\n\nmod lcommon {\n    use des::net::processing::*;\n    use des::prelude::*;\n\n    pub struct ConsumeAllIncoming;\n    impl ProcessingElement for ConsumeAllIncoming {\n        fn incoming(\u0026mut self, _msg: Message) -\u003e Option\u003cMessage\u003e {\n            None\n        }\n    }\n\n    pub struct IncrementIncomingId;\n    impl ProcessingElement for IncrementIncomingId {\n        fn incoming(\u0026mut self, mut msg: Message) -\u003e Option\u003cMessage\u003e {\n            msg.header_mut().id += 1;\n            Some(msg)\n        }\n    }\n\n    pub struct PanicOnIncoming;\n    impl ProcessingElement for PanicOnIncoming {\n        fn incoming(\u0026mut self, _msg: Message) -\u003e Option\u003cMessage\u003e {\n            panic!(\"common::PanicOnIncoming\")\n        }\n    }\n}\n\n#[derive(Default)]\nstruct PluginCreation {\n    sum: usize,\n}\nimpl Module for PluginCreation {\n    fn stack(\u0026self) -\u003e impl ProcessingElement + 'static {\n        lcommon::IncrementIncomingId\n    }\n\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        for i in 0..100 {\n            schedule_at(\n                Message::new().id(i).build(),\n                SimTime::now() + Duration::from_secs(i as u64),\n            )\n        }\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        assert_eq!(SimTime::now().as_secs() + 1, msg.header().id as u64);\n        self.sum += msg.header().id as usize;\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.sum, (0..100).sum::\u003cusize\u003e() + 100);\n    }\n}\n\n#[test]\n#[serial]\nfn plugin_raw_creation() {\n    // Logger::new().set_logger();\n\n    let mut app = Sim::new(());\n    app.node(\"root\", PluginCreation::default());\n\n    let rt = Builder::seeded(123).build(app);\n    let result = rt.run().unwrap();\n\n    assert_eq!(result.1, SimTime::from_duration(Duration::from_secs(99)));\n    assert_eq!(result.2.event_count, 100);\n}\n\nstruct ActivitySensor {\n    pub expected: usize,\n    pub shared: Arc\u003cAtomicUsize\u003e,\n}\nimpl ProcessingElement for ActivitySensor {\n    fn event_start(\u0026mut self) {\n        let real = self.shared.fetch_add(1, SeqCst);\n        assert_eq!(real, self.expected);\n    }\n\n    fn event_end(\u0026mut self) {\n        let real = self.shared.fetch_sub(1, SeqCst);\n        assert_eq!(real - 1, self.expected);\n    }\n}\n\n#[derive(Default)]\nstruct PluginPriorityDefer {\n    arc: Arc\u003cAtomicUsize\u003e,\n}\nimpl Module for PluginPriorityDefer {\n    fn stack(\u0026self) -\u003e impl IntoProcessingElements {\n        (\n            ActivitySensor {\n                shared: self.arc.clone(),\n                expected: 0,\n            },\n            ActivitySensor {\n                shared: self.arc.clone(),\n                expected: 1,\n            },\n            ActivitySensor {\n                shared: self.arc.clone(),\n                expected: 2,\n            },\n        )\n    }\n\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        for i in 0..100 {\n            schedule_in(Message::new().build(), Duration::from_secs(i));\n        }\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {}\n}\n\n#[test]\n#[serial]\nfn plugin_priority_defer() {\n    // Logger::new().set_logger();\n\n    let mut app = Sim::new(());\n    app.node(\"root\", PluginPriorityDefer::default());\n\n    let rt = Builder::seeded(123).build(app);\n    let result = rt.run();\n\n    let RuntimeResult::Finished { time, profiler, .. } = result else {\n        panic!(\"Unexpected runtime result\")\n    };\n\n    assert_eq!(time, 99.0);\n    assert_eq!(profiler.event_count, 100);\n}\n\nstruct IncrementArcPlugin {\n    arc: Arc\u003cAtomicUsize\u003e,\n}\nimpl ProcessingElement for IncrementArcPlugin {\n    fn incoming(\u0026mut self, msg: Message) -\u003e Option\u003cMessage\u003e {\n        self.arc.fetch_add(1, SeqCst);\n        Some(msg)\n    }\n}\n\nimpl Drop for IncrementArcPlugin {\n    fn drop(\u0026mut self) {\n        assert_eq!(self.arc.load(SeqCst), 20)\n    }\n}\n\n#[derive(Default)]\nstruct PluginAtShutdown {\n    arc: Arc\u003cAtomicUsize\u003e,\n}\nimpl Module for PluginAtShutdown {\n    fn stack(\u0026self) -\u003e impl IntoProcessingElements {\n        IncrementArcPlugin {\n            arc: self.arc.clone(),\n        }\n    }\n\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        if SimTime::now().as_secs() == 0 {\n            // Schedule events at all time points 1..=20\n            for i in 1..=20 {\n                schedule_at(\n                    Message::new().build(),\n                    SimTime::from_duration(Duration::from_secs(i)),\n                )\n            }\n        }\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        if SimTime::now().as_secs() == 10 {\n            // will be back online at second 11\n            shutdow_and_restart_in(Duration::from_millis(500));\n        }\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.arc.load(SeqCst), 20);\n    }\n}\n\n#[test]\n#[serial]\nfn plugin_shutdown_non_persistent_data() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Trace)\n    //     .set_logger();\n\n    let mut app = Sim::new(());\n    app.node(\"root\", PluginAtShutdown::default());\n\n    let rt = Builder::seeded(123).build(app);\n\n    let res = rt.run();\n    let _res = res.unwrap();\n}\n\n#[test]\n#[serial]\nfn module_as_processing_element() {\n    static DONE: AtomicBool = AtomicBool::new(false);\n\n    struct A;\n    struct B;\n    impl Module for A {\n        fn handle_message(\u0026mut self, _: Message) {\n            DONE.store(true, Ordering::SeqCst);\n        }\n    }\n    impl Module for B {\n        fn stack(\u0026self) -\u003e impl IntoProcessingElements {\n            A\n        }\n\n        fn handle_message(\u0026mut self, _: Message) {\n            panic!(\"should never be called\");\n        }\n    }\n\n    let mut sim = Sim::new(());\n    sim.node(\"a\", B);\n    let gate = sim.gate(\"a\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate, Message::new().build(), 1.0.into());\n\n    let _ = rt.run();\n    assert!(DONE.load(Ordering::SeqCst));\n}\n\n#[test]\n#[serial]\nfn custom_default_pe() {\n    static DONE: AtomicBool = AtomicBool::new(false);\n\n    struct EatAllAndSayDone;\n    impl ProcessingElement for EatAllAndSayDone {\n        fn incoming(\u0026mut self, _: Message) -\u003e Option\u003cMessage\u003e {\n            DONE.store(true, Ordering::SeqCst);\n            None\n        }\n    }\n\n    fn custom() -\u003e Vec\u003cProcessorElement\u003e {\n        vec![ProcessorElement::new(EatAllAndSayDone)]\n    }\n\n    set_default_processing_elements(custom);\n\n    struct A;\n    impl Module for A {}\n\n    let mut sim = Sim::new(());\n    sim.node(\"a\", A);\n    let gate = sim.gate(\"a\", \"port\");\n\n    let mut rt = Builder::seeded(123).build(sim);\n    rt.add_message_onto(gate, Message::new().build(), 1.0.into());\n\n    let _ = rt.run();\n    assert!(DONE.load(Ordering::SeqCst));\n\n    fn reset() -\u003e Vec\u003cProcessorElement\u003e {\n        Vec::new()\n    }\n\n    set_default_processing_elements(reset)\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":201},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":301},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":51,"coverable":55},{"path":["/","Users","mk","Developer","rust","des","des","tests","select.rs"],"content":"#![cfg(feature = \"macros\")]\nuse des::prelude::*;\nuse std::sync::atomic::AtomicUsize;\n\nstruct Main;\n\nstatic A: AtomicUsize = AtomicUsize::new(0);\nstatic B: AtomicUsize = AtomicUsize::new(0);\n\nimpl AsyncModule for Main {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        tokio::select! {\n            // Note that this test may change its result, if another call to the RNG\n            // is added before the simulation reaches this point.\n            // Thus this test may change, however, it should only change if RNG access changes\n            _ = std::future::ready(()) =\u003e {\n                A.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n            },\n            _ = std::future::ready(()) =\u003e {\n                B.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n            },\n        }\n    }\n}\n\n#[test]\nfn deterministic_branching() {\n    // Since the invalid behaviour is indetermistic.,\n    // check multiple iterations\n    for _ in 0..100 {\n        let mut rt = Sim::new(());\n        rt.node(\"root\", Main);\n\n        let rt = Builder::seeded(123).build(rt);\n        let v = rt.run();\n        assert!(matches!(v, RuntimeResult::EmptySimulation { .. }));\n    }\n\n    let a = A.load(std::sync::atomic::Ordering::SeqCst);\n    let b = B.load(std::sync::atomic::Ordering::SeqCst);\n\n    assert!((a == 100 \u0026\u0026 b == 0) || (a == 0 \u0026\u0026 b == 100));\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":200},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":100},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","Users","mk","Developer","rust","des","des","tests","shutdown.rs"],"content":"#![cfg(feature = \"async\")]\n\nuse des::{net::ModuleFn, prelude::*, time::sleep};\nuse serial_test::serial;\nuse std::sync::{\n    atomic::{AtomicUsize, Ordering},\n    Arc,\n};\n\nstruct DropTest {\n    heap: Vec\u003cusize\u003e,\n    dropper: \u0026'static AtomicUsize,\n}\n\nimpl DropTest {\n    fn new(dropper: \u0026'static AtomicUsize) -\u003e Self {\n        Self {\n            heap: vec![0],\n            dropper,\n        }\n    }\n\n    fn step(\u0026mut self) -\u003e usize {\n        let v = self.heap[self.heap.len() - 1];\n        self.heap.push(v + 1);\n        v + 1\n    }\n}\n\nimpl Drop for DropTest {\n    fn drop(\u0026mut self) {\n        println!(\"DROPPED\");\n        self.dropper.fetch_add(1, Ordering::SeqCst);\n    }\n}\n\nstruct StatelessModule;\n\nimpl AsyncModule for StatelessModule {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        tokio::spawn(async {\n            let mut drop_test = DropTest::new(\u0026DROPPED_STATELESS_SHUTDOWN);\n            loop {\n                sleep(Duration::from_secs(1)).await;\n                drop_test.step();\n            }\n        });\n    }\n\n    async fn handle_message(\u0026mut self, _msg: Message) {\n        shutdown();\n    }\n}\n\nstatic DROPPED_STATELESS_SHUTDOWN: AtomicUsize = AtomicUsize::new(0);\n\n#[test]\n#[serial]\nfn stateless_module_shudown() {\n    println!(\"0\");\n\n    DROPPED_STATELESS_SHUTDOWN.store(0, Ordering::SeqCst);\n    println!(\"1\");\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", StatelessModule);\n    let gate = rt.gate(\"root\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n    rt.add_message_onto(\n        gate,\n        Message::new().build(),\n        SimTime::from_duration(Duration::from_secs(10)),\n    );\n\n    let _ = rt.run().unwrap();\n    assert_eq!(DROPPED_STATELESS_SHUTDOWN.load(Ordering::SeqCst), 1)\n}\n\nstruct StatelessModuleRestart;\n\nimpl AsyncModule for StatelessModuleRestart {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        tokio::spawn(async {\n            let mut drop_test = DropTest::new(\u0026DROPPED_STATLESS_RESTART);\n            loop {\n                sleep(Duration::from_secs(1)).await;\n                drop_test.step();\n            }\n        });\n    }\n\n    async fn handle_message(\u0026mut self, msg: Message) {\n        match msg.header().id {\n            9 =\u003e shutdow_and_restart_at(SimTime::now() + Duration::from_secs(10)),\n            10 =\u003e shutdown(),\n            _ =\u003e unreachable!(),\n        }\n    }\n}\n\nstatic DROPPED_STATLESS_RESTART: AtomicUsize = AtomicUsize::new(0);\n\n#[test]\n#[serial]\nfn stateless_module_restart() {\n    DROPPED_STATLESS_RESTART.store(0, Ordering::SeqCst);\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", StatelessModuleRestart);\n    let gate = rt.gate(\"root\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n    rt.add_message_onto(\n        gate.clone(),\n        Message::new().id(9).build(),\n        SimTime::from_duration(Duration::from_secs(10)),\n    );\n    rt.add_message_onto(\n        gate,\n        Message::new().id(10).build(),\n        SimTime::from_duration(Duration::from_secs(30)),\n    );\n\n    let _ = rt.run().unwrap();\n    assert_eq!(DROPPED_STATLESS_RESTART.load(Ordering::SeqCst), 2)\n}\n\n#[derive(Default)]\nstruct StatefullModule {\n    state: usize,\n}\n\nimpl AsyncModule for StatefullModule {\n    fn reset(\u0026mut self) {\n        assert_eq!(self.state, 10);\n        self.state = 5;\n    }\n\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        self.state = 10;\n        tokio::spawn(async {\n            let mut drop_test = DropTest::new(\u0026DROPPED_STATFULL_RESTART);\n            loop {\n                sleep(Duration::from_secs(1)).await;\n                drop_test.step();\n            }\n        });\n    }\n\n    async fn handle_message(\u0026mut self, msg: Message) {\n        match msg.header().id {\n            9 =\u003e shutdow_and_restart_at(SimTime::now() + Duration::from_secs(10)),\n            10 =\u003e shutdown(),\n            _ =\u003e unreachable!(),\n        }\n    }\n\n    async fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.state, 5)\n    }\n}\n\nstatic DROPPED_STATFULL_RESTART: AtomicUsize = AtomicUsize::new(0);\n\n#[test]\n#[serial]\nfn statefull_module_restart() {\n    DROPPED_STATFULL_RESTART.store(0, Ordering::SeqCst);\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", StatefullModule::default());\n    let gate = rt.gate(\"root\", \"in\");\n\n    let mut rt = Builder::seeded(123).build(rt);\n    rt.add_message_onto(\n        gate.clone(),\n        Message::new().id(9).build(),\n        SimTime::from_duration(Duration::from_secs(10)),\n    );\n    rt.add_message_onto(\n        gate,\n        Message::new().id(10).build(),\n        SimTime::from_duration(Duration::from_secs(30)),\n    );\n\n    let _ = rt.run().unwrap();\n    assert_eq!(DROPPED_STATFULL_RESTART.load(Ordering::SeqCst), 2);\n}\n\nstruct ShutdownViaHandleModule;\n\nimpl AsyncModule for ShutdownViaHandleModule {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        tokio::spawn(async move {\n            let mut drop_test = DropTest::new(\u0026DROPPED_SHUTDOWN_VIA_HANDLE);\n            loop {\n                sleep(Duration::from_secs(1)).await;\n                if drop_test.step() \u003e 10 {\n                    shutdown()\n                }\n            }\n        });\n    }\n}\n\nstatic DROPPED_SHUTDOWN_VIA_HANDLE: AtomicUsize = AtomicUsize::new(0);\n\n#[test]\n#[serial]\nfn shutdown_via_async_handle() {\n    DROPPED_SHUTDOWN_VIA_HANDLE.store(0, Ordering::SeqCst);\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", ShutdownViaHandleModule);\n\n    let rt = Builder::seeded(123).build(rt);\n\n    let _ = rt.run().unwrap();\n    assert_eq!(DROPPED_SHUTDOWN_VIA_HANDLE.load(Ordering::SeqCst), 1)\n}\n\nstruct RestartViaHandleModule;\n\nimpl AsyncModule for RestartViaHandleModule {\n    async fn at_sim_start(\u0026mut self, _: usize) {\n        tokio::spawn(async move {\n            let mut drop_test = DropTest::new(\u0026DROPPED_RESTART_VIA_HANDLE);\n            loop {\n                sleep(Duration::from_secs(1)).await;\n                let v = drop_test.step();\n\n                if v == 10 {\n                    if SimTime::now() \u003c SimTime::from_duration(Duration::from_secs(20)) {\n                        shutdow_and_restart_at(SimTime::from_duration(Duration::from_secs(30)));\n                    } else {\n                        shutdown();\n                    }\n                }\n            }\n        });\n    }\n}\n\nstatic DROPPED_RESTART_VIA_HANDLE: AtomicUsize = AtomicUsize::new(0);\n\n#[test]\n#[serial]\nfn restart_via_async_handle() {\n    DROPPED_RESTART_VIA_HANDLE.store(0, Ordering::SeqCst);\n\n    let mut rt = Sim::new(());\n    rt.node(\"root\", RestartViaHandleModule);\n\n    let rt = Builder::seeded(123).build(rt);\n\n    let _ = rt.run().unwrap();\n    assert_eq!(DROPPED_RESTART_VIA_HANDLE.load(Ordering::SeqCst), 2)\n}\n\n#[derive(Clone)]\nstruct CountDropsMessage {\n    counter: Arc\u003cAtomicUsize\u003e,\n}\nimpl MessageBody for CountDropsMessage {\n    fn byte_len(\u0026self) -\u003e usize {\n        1\n    }\n}\nimpl Drop for CountDropsMessage {\n    fn drop(\u0026mut self) {\n        self.counter.fetch_add(1, Ordering::SeqCst);\n    }\n}\n\n#[derive(Default)]\nstruct WillIgnoreInncomingInDowntime {\n    received: Arc\u003cAtomicUsize\u003e,\n    drops: Arc\u003cAtomicUsize\u003e,\n}\n\nimpl Module for WillIgnoreInncomingInDowntime {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        if SimTime::now().as_secs() == 0 {\n            // schedule events for seconds 1..=10\n            for i in 1..=10 {\n                schedule_in(\n                    Message::new()\n                        .content(CountDropsMessage {\n                            counter: self.drops.clone(),\n                        })\n                        .build(),\n                    Duration::from_secs(i),\n                );\n            }\n        }\n    }\n\n    fn handle_message(\u0026mut self, mut msg: Message) {\n        self.received.fetch_add(1, Ordering::SeqCst);\n        if SimTime::now().as_secs() == 6 {\n            shutdow_and_restart_in(Duration::from_secs_f64(2.5));\n            // will miss incoming messages '7 and '8\n        }\n\n        // Forget the message, aka assign an temp counter\n        msg.content_mut::\u003cCountDropsMessage\u003e().counter = Arc::new(AtomicUsize::new(0));\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.received.load(Ordering::SeqCst), 8);\n        assert_eq!(self.drops.load(Ordering::SeqCst), 2);\n    }\n}\n\n#[test]\n#[serial]\nfn shutdown_will_ignore_incoming() {\n    let mut rt = Sim::new(());\n    rt.node(\"root\", WillIgnoreInncomingInDowntime::default());\n\n    let rt = Builder::seeded(123).build(rt);\n\n    let _ = rt.run().unwrap();\n}\n\n#[derive(Default)]\nstruct EndNode {\n    sent: usize,\n    recv: usize,\n    drops: Arc\u003cAtomicUsize\u003e,\n}\n\nimpl Module for EndNode {\n    fn at_sim_start(\u0026mut self, _: usize) {\n        schedule_in(Message::new().kind(1).build(), Duration::from_secs(1));\n    }\n\n    fn handle_message(\u0026mut self, mut msg: Message) {\n        match msg.header().kind {\n            1 =\u003e {\n                if SimTime::now().as_secs() \u003e 10 {\n                    return;\n                }\n\n                self.sent += 1;\n                send(\n                    Message::new()\n                        .kind(2)\n                        .content(CountDropsMessage {\n                            counter: self.drops.clone(),\n                        })\n                        .build(),\n                    \"port\",\n                );\n                schedule_in(Message::new().kind(1).build(), Duration::from_secs(1));\n            }\n            2 =\u003e {\n                self.recv += 1;\n\n                // forget the message drop counter;\n                msg.content_mut::\u003cCountDropsMessage\u003e().counter = Arc::new(AtomicUsize::new(0));\n            }\n            _ =\u003e unreachable!(),\n        }\n    }\n\n    fn at_sim_end(\u0026mut self) {\n        assert_eq!(self.sent, 10);\n        assert_eq!(self.recv, 7);\n\n        assert_eq!(self.drops.load(Ordering::SeqCst), 3);\n    }\n}\n\nstruct Transit;\n\nimpl Module for Transit {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        if SimTime::now() == SimTime::ZERO {\n            schedule_in(Message::new().build(), Duration::from_secs_f64(5.5));\n        }\n    }\n\n    fn handle_message(\u0026mut self, _msg: Message) {\n        // happens at 5.5 so '6 '7 '8 will be lost\n        shutdow_and_restart_in(Duration::from_secs(3));\n    }\n}\n\n#[test]\n#[serial]\nfn shutdown_will_drop_transiting() {\n    // Logger::new().set_logger();\n    let mut app = Sim::new(());\n    app.node(\"ping\", EndNode::default());\n    app.node(\"pong\", EndNode::default());\n    app.node(\"transit\", Transit);\n\n    let ping = app.gate(\"ping\", \"port\");\n    let pong = app.gate(\"pong\", \"port\");\n    let con = app.gate(\"transit\", \"connector\");\n\n    ping.connect(con.clone(), None);\n    con.connect(pong, None);\n\n    let rt = Builder::seeded(123).max_itr(500).build(app);\n    let _ = rt.run().unwrap();\n}\n\n#[test]\n#[serial]\nfn shutdown_will_drop_transiting_delayed_channels() {\n    // Logger::new().set_logger();\n    let mut app = Sim::new(());\n\n    app.node(\"ping\", EndNode::default());\n    app.node(\"pong\", EndNode::default());\n    app.node(\"transit\", Transit);\n\n    let ping = app.gate(\"ping\", \"port\");\n    let pong = app.gate(\"pong\", \"port\");\n    let con = app.gate(\"transit\", \"connector\");\n\n    ping.connect(\n        con.clone(),\n        Some(Channel::new(ChannelMetrics {\n            bitrate: 100_000,\n            latency: Duration::from_secs_f64(0.004),\n            jitter: Duration::ZERO,\n            drop_behaviour: ChannelDropBehaviour::default(),\n        })),\n    );\n    con.connect(\n        pong,\n        Some(Channel::new(ChannelMetrics {\n            bitrate: 100_000,\n            latency: Duration::from_secs_f64(0.004),\n            jitter: Duration::ZERO,\n            drop_behaviour: ChannelDropBehaviour::default(),\n        })),\n    );\n\n    let rt = Builder::seeded(123).max_itr(500).build(app);\n    let _ = rt.run().unwrap();\n}\n\n#[test]\n#[serial]\nfn shutdown_prevents_accessing_parents() {\n    let mut sim = Sim::new(());\n    sim.node(\"a\", ModuleFn::new(\n        || schedule_in(Message::new().build(), Duration::from_secs(10)),\n        |_, _| {\n            let err = current().child(\"b\").unwrap_err();\n            assert_eq!(err, ModuleReferencingError::CurrentlyInactive(\"The child module 'b' of 'a' is currently shut down, thus cannot be accessed\".to_string()));\n        }\n    ));\n    sim.node(\n        \"a.b\",\n        ModuleFn::new(\n            || schedule_in(Message::new().build(), Duration::from_secs(5)),\n            |_, _| {\n                shutdown();\n            },\n        ),\n    );\n    sim.node(\n        \"a.b.c\",\n        ModuleFn::new(\n            || schedule_in(Message::new().build(), Duration::from_secs(10)),\n            |_, _| {\n                let err = current().parent().unwrap_err();\n                assert_eq!(err, ModuleReferencingError::CurrentlyInactive(\"The parent module of 'a.b.c' is currently shut down, thus cannot be accessed\".to_string()));\n            },\n        ),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":100,"coverable":100},{"path":["/","Users","mk","Developer","rust","des","des","tests","topology.rs"],"content":"#![cfg(feature = \"ndl\")]\nuse des::prelude::*;\n\n#[test]\nfn main() {\n    let app = Sim::ndl(\n        \"tests/ndl/small_network/main.ndl\",\n        Registry::new().with_default_fallback(),\n    )\n    .map_err(|e| println!(\"{e}\"))\n    .unwrap();\n    let rt = Builder::new().build(app);\n    let app = rt.run().into_app();\n    let mut topo = app.globals().topology.lock().unwrap().clone();\n\n    let dj = topo.dijkstra(\"node[1]\".into());\n    assert_eq!(dj.get(\u0026\"node[1]\".into()), None);\n\n    topo.filter_nodes(|n| n.module.name() != \"node[2]\");\n    topo.map_costs(|edge| edge.cost * 2.0);\n    topo.filter_edges(|_| true);\n    assert_eq!(topo.edges(), 9);\n\n    // 4 nodes, router, debugger, main\n    assert_eq!(topo.nodes().len(), 7);\n    assert_eq!(topo.nodes().into_iter().filter(|n| n.alive).count(), 6);\n\n    let i = topo\n        .nodes()\n        .into_iter()\n        .position(|n| n.module.name() == \"router\")\n        .unwrap();\n\n    let j = topo\n        .nodes()\n        .into_iter()\n        .position(|n| n.module.name() == \"debugger\")\n        .unwrap();\n\n    assert!(topo\n        .edges_for(i)\n        .iter()\n        .any(|edge| edge.dst.1 == j \u0026\u0026 edge.src.0.name() == \"debug\"));\n\n    let _ = topo.write_to_svg(\"tests/topology\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","tests","tracing-init.rs"],"content":"#[test]\nfn init() {\n    des::tracing::init();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des","tests","tracing.rs"],"content":"use des::{net::{Sim, AsyncFn}, runtime::Builder, tracing::format};\nuse tracing::{level_filters::LevelFilter, subscriber::with_default, Instrument, span, Level};\n\n#[path =\"common/mock.rs\"]\nmod mock;\n\n#[test]\n#[serial_test::serial]\nfn test_mock_output() {\n    let writer = mock::MakeMockWriter::new();\n    let subscriber = tracing_subscriber::fmt()\n        .with_ansi(false)\n        .with_max_level(LevelFilter::TRACE)\n        .event_format(format())\n        .with_writer(writer.clone())\n        .finish();\n\n    with_default(subscriber, || {\n        let sim = Sim::new(());\n        let _ = Builder::seeded(123).build(sim).run();\n\n        tracing::info!(GENERAL = \"Kenobi\", \"Hello there\");\n        assert_eq!(\n            writer.content(),\n            \"[ 0ns ] INFO tracing: Hello there GENERAL=\\\"Kenobi\\\"\\n\"\n        );\n    })\n}\n\n#[test]\n#[serial_test::serial]\nfn scope_regognition() {\n    let writer = mock::MakeMockWriter::new();\n    let subscriber = tracing_subscriber::fmt()\n        .with_ansi(false)\n        .with_max_level(LevelFilter::TRACE)\n        .event_format(format())\n        .with_writer(writer.clone())\n        .finish();\n\n    with_default(subscriber, || {\n        let mut sim = Sim::new(());\n        sim.node(\"a\", AsyncFn::new(|_| async {\n            tracing::info!(\"node(a) says(1) at(0s)\");\n            tracing::error!(\"node(a) says(2) at(0s)\");\n\n        }));\n        sim.node(\"a.b\", AsyncFn::new(|_| async {\n            tracing::trace!(\"node(b) says(1) at(0s)\");\n        }));\n\n        let _ = Builder::seeded(123).build(sim).run();\n        assert_eq!(\n            writer.content(), \n            \"[ 0ns ] INFO a tracing: node(a) says(1) at(0s)\\n[ 0ns ] ERROR a tracing: node(a) says(2) at(0s)\\n[ 0ns ] TRACE a.b tracing: node(b) says(1) at(0s)\\n\"\n        );\n    });\n}\n\n#[test]\n#[serial_test::serial]\nfn time_regognition() {\n    let writer = mock::MakeMockWriter::new();\n    let subscriber = tracing_subscriber::fmt()\n        .with_ansi(false)\n        .with_max_level(LevelFilter::TRACE)\n        .event_format(format())\n        .with_writer(writer.clone())\n        .finish();\n\n    with_default(subscriber, || {\n        let mut sim = Sim::new(());\n        sim.node(\"a\", AsyncFn::new(|_| async {\n            tracing::info!(\"node(a) says(1) at(0s)\");\n            des::time::sleep(std::time::Duration::from_secs(5)).await;\n            tracing::error!(\"node(a) says(2) at(5s)\");\n\n        }));\n        sim.node(\"a.b\", AsyncFn::new(|_| async {\n            tracing::trace!(\"node(b) says(1) at(0s)\");\n        }));\n\n        let _ = Builder::seeded(123).build(sim).run();\n        assert_eq!(\n            writer.content(), \n            \"[ 0ns ] INFO a tracing: node(a) says(1) at(0s)\\n[ 0ns ] TRACE a.b tracing: node(b) says(1) at(0s)\\n[ 5s ] ERROR a tracing: node(a) says(2) at(5s)\\n\"\n        );\n    });\n}\n\n#[test]\n#[serial_test::serial]\nfn span_regognition() {\n    let writer = mock::MakeMockWriter::new();\n    let subscriber = tracing_subscriber::fmt()\n        .with_ansi(false)\n        .with_max_level(LevelFilter::TRACE)\n        .event_format(format())\n        .with_writer(writer.clone())\n        .finish();\n\n    with_default(subscriber, || {\n        let mut sim = Sim::new(());\n        sim.node(\"a\", AsyncFn::new(|_| async {\n            tracing::info!(\"node(a) says(1) at(0s)\");\n        }.instrument(span!(Level::DEBUG, \"my-span\", key=123))));\n        sim.node(\"a.b\", AsyncFn::new(|_| async {\n            tracing::trace!(\"node(b) says(1) at(0s)\");\n        }));\n\n        let _ = Builder::seeded(123).build(sim).run();\n        assert_eq!(\n            writer.content(), \n            \"[ 0ns ] INFO a my-span{key=123}: tracing: node(a) says(1) at(0s)\\n[ 0ns ] TRACE a.b tracing: node(b) says(1) at(0s)\\n\"\n        );\n    });\n}\n\n#[test]\n#[serial_test::serial]\nfn multi_span_regognition() {\n    #[tracing::instrument]\n    async fn say_hello() {\n        tracing::info!(\"hello\")\n    }\n    \n    let writer = mock::MakeMockWriter::new();\n    let subscriber = tracing_subscriber::fmt()\n        .with_ansi(false)\n        .with_max_level(LevelFilter::TRACE)\n        .event_format(format())\n        .with_writer(writer.clone())\n        .finish();\n\n    with_default(subscriber, || {\n        let mut sim = Sim::new(());\n        sim.node(\"a\", AsyncFn::new(|_| async {\n            say_hello().await;\n        }.instrument(span!(Level::DEBUG, \"my-span\", key=123))));\n        sim.node(\"a.b\", AsyncFn::new(|_| async {\n            tracing::trace!(\"node(b) says(1) at(0s)\");\n        }.instrument(span!(Level::DEBUG, \"other-span\"))));\n\n        let _ = Builder::seeded(123).build(sim).run();\n        assert_eq!(\n            writer.content(), \n            \"[ 0ns ] INFO a my-span{key=123}:say_hello: tracing: hello\\n[ 0ns ] TRACE a.b other-span: tracing: node(b) says(1) at(0s)\\n\"\n        );\n    });\n}\n\n#[test]\n#[serial_test::serial]\nfn with_ansi() {\n    #[tracing::instrument]\n    async fn say_hello() {\n        tracing::info!(\"hello\")\n    }\n    \n    let writer = mock::MakeMockWriter::new();\n    let subscriber = tracing_subscriber::fmt()\n        .with_ansi(true)\n        .with_max_level(LevelFilter::TRACE)\n        .event_format(format())\n        .with_writer(writer.clone())\n        .finish();\n\n    with_default(subscriber, || {\n        let mut sim = Sim::new(());\n        sim.node(\"a\", AsyncFn::new(|_| async {\n            tracing::info!(\"Hello World!\")\n        }));\n       \n\n        let _ = Builder::seeded(123).build(sim).run();\n        assert_eq!(\n            writer.content(), \n            \"\\u{1b}[2m[ 0ns ] \\u{1b}[0m\\u{1b}[32ma \\u{1b}[0m\\u{1b}[2mtracing: \\u{1b}[0mHello World!\\n\"\n        );\n    });\n}\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","bin","cqueue-perf-irregular.rs"],"content":"use std::time::{Duration, Instant};\n\nuse des_cqueue::CQueue;\nuse rand::{distributions::Uniform, rngs::SmallRng, Rng, SeedableRng};\n\nfn main() {\n    let args = std::env::args().collect::\u003cVec\u003c_\u003e\u003e();\n    let n = args\n        .iter()\n        .find(|s| s.starts_with(\"--cfg-cqueue-n=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(1024);\n\n    let t = Duration::from_secs_f64(\n        args.iter()\n            .find(|s| s.starts_with(\"--cfg-cqueue-t=\"))\n            .map(|s| s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1].parse::\u003cf64\u003e().unwrap())\n            .unwrap_or(0.005),\n    );\n\n    let num = args\n        .iter()\n        .find(|s| s.starts_with(\"num=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(400);\n\n    let e_delay = args\n        .iter()\n        .find(|s| s.starts_with(\"delay=\"))\n        .map(|s| s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1].parse::\u003cf64\u003e().unwrap())\n        .unwrap_or(1.0);\n\n    let sample = args\n        .iter()\n        .find(|s| s.starts_with(\"sample=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(0x12345678);\n\n    let mut cqueue = CQueue::new(n, t);\n\n    // SETUP\n\n    let mut rng = SmallRng::seed_from_u64(sample as u64);\n\n    let mut delay = Duration::ZERO;\n    for e in 0..num {\n        cqueue.add(delay, e);\n        let rng = rng.sample(Uniform::new(0.0, 1.0));\n        let offset = rng * 4.0 * e_delay;\n        delay += Duration::from_secs_f64(offset);\n    }\n\n    // RUN\n    let e_delay = Duration::from_secs_f64(e_delay);\n\n    let rng_table: Vec\u003cusize\u003e =\n        std::iter::repeat_with(|| rng.sample(Uniform::new(usize::MIN, usize::MAX)))\n            .take(num)\n            .collect();\n\n    let t0 = Instant::now();\n    let mut time = Duration::ZERO;\n    let mut c = 0;\n    let mut pending_event = Vec::new();\n\n    while c \u003c 100_000_000 {\n        let (e, t) = cqueue.fetch_next();\n        time = t;\n\n        pending_event.push(e);\n        while !pending_event.is_empty() {\n            let rng_sample = rng_table[e] % num;\n            if rng_sample \u003c pending_event.len() {\n                cqueue.add(time + e_delay, pending_event.pop().unwrap());\n            } else {\n                break;\n            }\n        }\n\n        // cqueue.add(time + e_delay, e);\n        c += 1;\n    }\n\n    let _ = time;\n\n    println!(\"{}\", Instant::now().duration_since(t0).as_secs_f64());\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":55},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","bin","cqueue-perf.rs"],"content":"use std::time::{Duration, Instant};\n\nuse des_cqueue::CQueue;\nuse rand::{distributions::Uniform, rngs::SmallRng, Rng, SeedableRng};\n\nfn main() {\n    let args = std::env::args().collect::\u003cVec\u003c_\u003e\u003e();\n    let n = args\n        .iter()\n        .find(|s| s.starts_with(\"--cfg-cqueue-n=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(1024);\n\n    let t = Duration::from_secs_f64(\n        args.iter()\n            .find(|s| s.starts_with(\"--cfg-cqueue-t=\"))\n            .map(|s| s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1].parse::\u003cf64\u003e().unwrap())\n            .unwrap_or(0.005),\n    );\n\n    let num = args\n        .iter()\n        .find(|s| s.starts_with(\"num=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(400);\n\n    let e_delay = args\n        .iter()\n        .find(|s| s.starts_with(\"delay=\"))\n        .map(|s| s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1].parse::\u003cf64\u003e().unwrap())\n        .unwrap_or(1.0);\n\n    // let e_size = args\n    //     .iter()\n    //     .find(|s| s.starts_with(\"size=\"))\n    //     .map(|s| {\n    //         s.split(\"=\").collect::\u003cVec\u003c_\u003e\u003e()[1]\n    //             .parse::\u003cusize\u003e()\n    //             .unwrap()\n    //     })\n    //     .unwrap_or(4);\n\n    let sample = args\n        .iter()\n        .find(|s| s.starts_with(\"sample=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(0x12345678);\n\n    let mut cqueue = CQueue::new(n, t);\n\n    // SETUP\n\n    let mut rng = SmallRng::seed_from_u64(sample as u64);\n\n    let mut delay = Duration::ZERO;\n    for e in 0..num {\n        cqueue.add(delay, e);\n        let rng = rng.sample(Uniform::new(0.0, 1.0));\n        let offset = rng * 4.0 * e_delay;\n        delay += Duration::from_secs_f64(offset);\n    }\n\n    // RUN\n    let e_delay = Duration::from_secs_f64(e_delay);\n\n    let t0 = Instant::now();\n    let mut time = Duration::ZERO;\n    let mut c = 0;\n    while c \u003c 100_000_000 {\n        let (e, t) = cqueue.fetch_next();\n        time = t;\n        cqueue.add(time + e_delay, e);\n        c += 1;\n    }\n\n    let _ = time;\n\n    println!(\"{}\", Instant::now().duration_since(t0).as_secs_f64());\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":46},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","lib.rs"],"content":"#![warn(clippy::pedantic)]\n\n// mod nightly;\n// pub use nightly::*;\n\npub mod stable;\npub use stable::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","nightly","alloc.rs"],"content":"use std::{\n    alloc::{self, AllocError, Allocator, Layout},\n    fmt::Debug,\n    mem::{align_of, size_of},\n    ptr::NonNull,\n};\n\nstruct ListNode {\n    size: usize,\n    next: Option\u003c\u0026'static mut ListNode\u003e,\n}\n\nimpl ListNode {\n    const fn new(size: usize) -\u003e Self {\n        ListNode { size, next: None }\n    }\n\n    fn start_addr(\u0026self) -\u003e usize {\n        self as *const Self as usize\n    }\n\n    fn end_addr(\u0026self) -\u003e usize {\n        self.start_addr() + self.size\n    }\n}\n\npub struct CQueueLLAllocatorInner {\n    head: ListNode,\n    pages: Vec\u003c*mut u8\u003e,\n    page_size: usize,\n    allocated_mem: usize,\n}\n\nimpl CQueueLLAllocatorInner {\n    /// Creates an empty LinkedListAllocator.\n    pub fn new() -\u003e Self {\n        Self::with_page_size(page_size::get())\n    }\n\n    pub fn with_page_size(page_size: usize) -\u003e Self {\n        let mut this = Self {\n            head: ListNode::new(0),\n            pages: Vec::new(),\n            page_size,\n            allocated_mem: 0,\n        };\n\n        unsafe {\n            this.add_page();\n        }\n\n        this\n    }\n\n    pub(super) fn metrics(\u0026self) -\u003e (usize, usize) {\n        (self.allocated_mem, self.page_size * self.page_size)\n    }\n\n    #[cfg(test)]\n    pub(crate) fn info(\u0026self) {}\n\n    unsafe fn add_page(\u0026mut self) {\n        let block = alloc::alloc_zeroed(\n            Layout::from_size_align(self.page_size, self.page_size).expect(\"page layout invalid\"),\n        );\n        self.pages.push(block);\n        self.add_free_region(block as usize, self.page_size)\n    }\n\n    pub fn handle(\u0026self) -\u003e CQueueLLAllocator {\n        CQueueLLAllocator {\n            inner: self as *const CQueueLLAllocatorInner as *mut CQueueLLAllocatorInner,\n        }\n    }\n\n    #[cfg(test)]\n    pub(crate) fn dbg_alloc_total(\u0026self) -\u003e usize {\n        self.allocated_mem\n    }\n\n    #[cfg(test)]\n    pub(crate) fn dbg_is_empty(\u0026self) -\u003e bool {\n        self.allocated_mem == 0\n    }\n\n    #[cfg(test)]\n    pub(crate) fn dbg_pages(\u0026self) -\u003e usize {\n        self.pages.len()\n    }\n\n    /// Adds the given memory region to the front of the list.\n    unsafe fn add_free_region(\u0026mut self, addr: usize, size: usize) {\n        // ensure that the freed region is capable of holding ListNode\n        assert_eq!(align_up(addr, align_of::\u003cListNode\u003e()), addr);\n        assert!(size \u003e= size_of::\u003cListNode\u003e());\n\n        // create a new list node and append it at the start of the list\n        let mut node = ListNode::new(size);\n        node.next = self.head.next.take();\n        let node_ptr = addr as *mut ListNode;\n        node_ptr.write(node);\n        self.head.next = Some(\u0026mut *node_ptr)\n    }\n\n    /// Looks for a free region with the given size and alignment and removes\n    /// it from the list.\n    ///\n    /// Returns a tuple of the list node and the start address of the allocation.\n    fn find_region(\u0026mut self, size: usize, align: usize) -\u003e Option\u003c(\u0026'static mut ListNode, usize)\u003e {\n        // reference to current list node, updated for each iteration\n        let mut current = \u0026mut self.head;\n        // look for a large enough memory region in linked list\n        while let Some(ref mut region) = current.next {\n            if let Ok(alloc_start) = Self::alloc_from_region(region, size, align) {\n                // region suitable for allocation -\u003e remove node from list\n                let next = region.next.take();\n                let ret = Some((current.next.take().unwrap(), alloc_start));\n                current.next = next;\n                return ret;\n            } else {\n                // region not suitable -\u003e continue with next region\n                current = current.next.as_mut().unwrap();\n            }\n        }\n\n        // no suitable region found\n        // create new region\n        unsafe {\n            self.add_page();\n            self.find_region(size, align)\n        }\n    }\n\n    /// Try to use the given region for an allocation with given size and\n    /// alignment.\n    ///\n    /// Returns the allocation start address on success.\n    fn alloc_from_region(region: \u0026ListNode, size: usize, align: usize) -\u003e Result\u003cusize, ()\u003e {\n        let alloc_start = align_up(region.start_addr(), align);\n        let alloc_end = alloc_start.checked_add(size).ok_or(())?;\n\n        if alloc_end \u003e region.end_addr() {\n            // region too small\n            return Err(());\n        }\n\n        let excess_size = region.end_addr() - alloc_end;\n        if excess_size \u003e 0 \u0026\u0026 excess_size \u003c size_of::\u003cListNode\u003e() {\n            // rest of region too small to hold a ListNode (required because the\n            // allocation splits the region in a used and a free part)\n            return Err(());\n        }\n\n        // region suitable for allocation\n        Ok(alloc_start)\n    }\n\n    fn size_align(layout: Layout) -\u003e (usize, usize) {\n        let layout = layout\n            .align_to(align_of::\u003cListNode\u003e())\n            .expect(\"adjusting alignment failed\")\n            .pad_to_align();\n        let size = layout.size().max(size_of::\u003cListNode\u003e());\n        (size, layout.align())\n    }\n}\n\nimpl Debug for CQueueLLAllocatorInner {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"CQueueLLAllocatorInner\")\n            .field(\"allocated_memory\", \u0026self.allocated_mem)\n            .field(\"pages\", \u0026self.pages.len())\n            .finish()\n    }\n}\n\nimpl Drop for CQueueLLAllocatorInner {\n    fn drop(\u0026mut self) {\n        let layout = Layout::from_size_align(self.page_size, self.page_size)\n            .expect(\"failed to generate page layout\");\n        for page in self.pages.iter() {\n            unsafe { alloc::dealloc(*page, layout) }\n        }\n    }\n}\n\n// impl Allocator for LinkedListAllocator {}\n\nfn align_up(addr: usize, align: usize) -\u003e usize {\n    (addr + align - 1) \u0026 !(align - 1)\n}\n\n#[derive(Clone, Copy, PartialEq, Eq, Hash)]\npub struct CQueueLLAllocator {\n    inner: *mut CQueueLLAllocatorInner,\n}\n\nunsafe impl Allocator for CQueueLLAllocator {\n    fn allocate(\u0026self, layout: std::alloc::Layout) -\u003e Result\u003cNonNull\u003c[u8]\u003e, AllocError\u003e {\n        let (size, align) = CQueueLLAllocatorInner::size_align(layout);\n        let allocator = unsafe { \u0026mut *self.inner };\n\n        if size \u003e allocator.page_size {\n            return Err(AllocError);\n        }\n\n        if let Some((region, alloc_start)) = allocator.find_region(size, align) {\n            unsafe {\n                let alloc_end = alloc_start.checked_add(size).expect(\"overflow\");\n                let excess_size = region.end_addr() - alloc_end;\n                if excess_size \u003e 0 {\n                    if excess_size \u003c size {\n                        // println!(\"alloc: dropping {} bytes of memory\", excess_size);\n                        // alloc_end = alloc_end.checked_add(size).expect(\"overflow\");\n                    } else {\n                        allocator.add_free_region(alloc_end, excess_size);\n                    }\n                }\n                // println!(\n                //     \"alloc: Layout {{ size: {}, align: {} }} as Layout {{ size: {}, ptr: {} }}\",\n                //     layout.size(),\n                //     layout.align(),\n                //     size,\n                //     alloc_start\n                // );\n                allocator.allocated_mem += size;\n                Ok(NonNull::slice_from_raw_parts(\n                    NonNull::new_unchecked(alloc_start as *mut u8),\n                    size,\n                ))\n            }\n        } else {\n            Err(AllocError)\n        }\n    }\n\n    unsafe fn deallocate(\u0026self, ptr: NonNull\u003cu8\u003e, layout: Layout) {\n        let (size, _) = CQueueLLAllocatorInner::size_align(layout);\n        let allocator = unsafe { \u0026mut *self.inner };\n        allocator.allocated_mem -= size;\n        allocator.add_free_region(ptr.as_ptr() as usize, size)\n    }\n}\n\nimpl Debug for CQueueLLAllocator {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"CQueueLLAllocator\")\n            .field(\"ptr\", \u0026self.inner)\n            .finish()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","nightly","linked_list.rs"],"content":"use super::{alloc::CQueueLLAllocator, EventHandle};\nuse std::{fmt::Debug, hash::Hash, marker::PhantomData, time::Duration};\n\npub(crate) struct DualLinkedList\u003cE\u003e {\n    alloc: CQueueLLAllocator,\n    head: Box\u003cEventNode\u003cE\u003e, CQueueLLAllocator\u003e,\n    tail: Box\u003cEventNode\u003cE\u003e, CQueueLLAllocator\u003e,\n    len: usize,\n}\n\n#[derive(Clone)]\npub struct EventNode\u003cE\u003e {\n    pub(super) value: Option\u003cE\u003e,\n    pub(super) time: Duration,\n\n    pub(super) id: usize,\n\n    pub(super) prev: *mut EventNode\u003cE\u003e,\n    pub(super) next: *mut EventNode\u003cE\u003e,\n}\n\n// IMPL: DLL\n\nimpl\u003cT\u003e DualLinkedList\u003cT\u003e {\n    pub(super) fn new(alloc: CQueueLLAllocator) -\u003e Self {\n        let mut head = EventNode::empty(Duration::ZERO, alloc);\n        let mut tail = EventNode::empty(Duration::MAX, alloc);\n\n        let head_ptr: *mut EventNode\u003cT\u003e = \u0026mut *head;\n        let tail_ptr: *mut EventNode\u003cT\u003e = \u0026mut *tail;\n\n        head.next = tail_ptr;\n        tail.prev = head_ptr;\n\n        Self {\n            alloc,\n            head,\n            tail,\n            len: 0,\n        }\n    }\n\n    pub(super) fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    pub(super) fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    pub(super) fn cancel(\u0026mut self, handle: EventHandle\u003cT\u003e) -\u003e bool {\n        let mut cur = self.head.next;\n        unsafe {\n            while !(*cur).next.is_null() {\n                if (*cur).id == handle.id {\n                    // remove\n                    let cur = Box::from_raw_in(cur, self.alloc);\n                    (*cur.prev).next = cur.next;\n                    (*cur.next).prev = cur.prev;\n                    self.len -= 1;\n\n                    drop(cur);\n                    return true;\n                }\n                cur = (*cur).next;\n            }\n        }\n        false\n    }\n\n    pub(super) fn front_time(\u0026self) -\u003e Duration {\n        // SAFTEY:\n        // Value is guranteed to be valid since head-\u003enext is allways valid\n        let front = unsafe { \u0026mut *self.head.next };\n        if front.next.is_null() {\n            Duration::MAX\n        } else {\n            // SAFTEY:\n            // front is valid, and neither head nor tail so itt must contain a value\n            front.time\n        }\n    }\n\n    /// Inserts a new element into the queue, returing a Handle to\n    /// cancel the event at will\n    pub(super) fn add(\u0026mut self, event: T, time: Duration, event_id: usize) {\n        let mut node = EventNode::new(event, time, event_id, self.alloc);\n        self.len += 1;\n        let node_ptr: *mut EventNode\u003cT\u003e = \u0026mut *node;\n\n        // From back insert\n        let mut cur: *mut EventNode\u003cT\u003e = \u0026mut *self.tail;\n        loop {\n            // SAFTEY:\n            // There a two cases\n            // 1) cur is head -\u003e since head has Duration::MIN the loop will\n            //    break thus cur is a valid ptr.\n            // 2) cur is not head (maybe tail) -\u003e all such elements are guranteed to have\n            //    valid prev ptrs.\n            // Thus cur will be valid, non-null at the end of the loop.\n            // This loop will terminated if there are no circles in the DLL\n            unsafe {\n                if (*cur).time \u003e node.time {\n                    cur = (*cur).prev;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // SAFTEY: cur is valid after the end of the loop (see aboth)\n        let prev = cur;\n        let next = unsafe { (*cur).next };\n\n        node.prev = prev;\n        node.next = next;\n\n        // SAFTEY:\n        // If the ptr is non-null it is valid,\n        // since nodes are only dropped once they were removed from the DLL.\n        // At removal, they remove ptrs to themselfs from other nodes.\n        if !prev.is_null() {\n            unsafe { (*prev).next = node_ptr }\n        }\n\n        // SAFTEY: see prev\n        if !next.is_null() {\n            unsafe { (*next).prev = node_ptr }\n        }\n\n        // Forget the node to leak the memory.\n        std::mem::forget(node);\n    }\n\n    /// Removes the element with the earliest time from the queue.\n    pub(super) fn pop_min(\u0026mut self) -\u003e Option\u003c(T, Duration)\u003e {\n        let node = unsafe { Box::from_raw_in(self.head.next, self.alloc) };\n        if node.next.is_null() {\n            // The node that would have been returned is the tail.\n            // Thus forgett this Box, since the tail is allready owned by self.\n            std::mem::forget(node);\n            None\n        } else {\n            self.len -= 1;\n\n            // The node is not the tail (or the head),\n            // Thus the node has valid ptrs to prev and next.\n            // 1) This head.next will point to a valid node (may be tail)\n            // 2) node.next will be a valid node\n            // 3) node.next.prev will point ot a valid node (head)\n            self.head.next = node.next;\n            unsafe {\n                (*node.next).prev = \u0026mut *self.head;\n            }\n\n            // All references are removed from the DLL thus the node\n            // is only owned by this instance.\n            // Droping the node via into_inner is valid since the only remaining\n            // ref (the NodeHandle) will be invalidated by this operation,\n            // if nessecary\n            let v = node.into_inner();\n            Some(v)\n        }\n    }\n\n    pub(super) fn iter(\u0026self) -\u003e Iter\u003c'_, T\u003e {\n        self.into_iter()\n    }\n\n    #[allow(unused)]\n    pub(super) fn iter_mut(\u0026mut self) -\u003e IterMut\u003c'_, T\u003e {\n        self.into_iter()\n    }\n}\n\nimpl\u003cT\u003e Debug for DualLinkedList\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let head_ptr: *const EventNode\u003cT\u003e = \u0026*self.head;\n        let tail_ptr: *const EventNode\u003cT\u003e = \u0026*self.tail;\n\n        f.debug_struct(\"DLL\")\n            .field(\"head\", \u0026head_ptr)\n            .field(\"tail\", \u0026tail_ptr)\n            .finish()\n    }\n}\n\nimpl\u003cT\u003e Drop for DualLinkedList\u003cT\u003e {\n    fn drop(\u0026mut self) {\n        while self.pop_min().is_some() {}\n    }\n}\n\n// EQ\n\nimpl\u003cT: PartialEq\u003e PartialEq for DualLinkedList\u003cT\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        let mut lhs = self.iter();\n        let mut rhs = other.iter();\n\n        loop {\n            let l = lhs.next();\n            let r = rhs.next();\n            if let Some(l) = l {\n                if let Some(r) = r {\n                    if l.0 != r.0 {\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            } else if r.is_some() {\n                return false;\n            } else {\n                break;\n            }\n        }\n\n        true\n    }\n}\n\nimpl\u003cT: Eq\u003e Eq for DualLinkedList\u003cT\u003e {}\n\n// HASH\n\nimpl\u003cT: Hash\u003e Hash for DualLinkedList\u003cT\u003e {\n    fn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.iter().for_each(|v| v.hash(state))\n    }\n}\n\n// FROM\n\n// IMPL: DLL Into Iter\n\npub struct Iter\u003c'a, T\u003e {\n    marker: PhantomData\u003c\u0026'a DualLinkedList\u003cT\u003e\u003e,\n    cur: *mut EventNode\u003cT\u003e,\n    alloc: CQueueLLAllocator,\n}\n\nimpl\u003c'a, T\u003e Iterator for Iter\u003c'a, T\u003e {\n    type Item = (\u0026'a T, \u0026'a Duration);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        // SAFTEY:\n        // Will point to a valid node since:\n        // IA) head-\u003enext is a valid node\n        // IS) each time the next node is check to be non-null (thus valid)\n        let cur = unsafe { Box::from_raw_in(self.cur, self.alloc) };\n        let result: Option\u003c(*const T, *const Duration)\u003e = {\n            if cur.next.is_null() {\n                // is tail\n                None\n            } else {\n                self.cur = cur.next;\n                // SAFTEY:\n                // cur is allways valid + now non-tail\n                Some((unsafe { cur.value.as_ref().unwrap_unchecked() }, \u0026cur.time))\n            }\n        };\n        std::mem::forget(cur);\n        result.map(|(v, t)| unsafe { (\u0026*v, \u0026*t) })\n    }\n}\n\nimpl\u003c'a, T\u003e IntoIterator for \u0026'a DualLinkedList\u003cT\u003e {\n    type Item = (\u0026'a T, \u0026'a Duration);\n    type IntoIter = Iter\u003c'a, T\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        Iter {\n            marker: PhantomData,\n            cur: self.head.next,\n            alloc: self.alloc,\n        }\n    }\n}\n\npub struct IterMut\u003c'a, T\u003e {\n    marker: PhantomData\u003c\u0026'a mut DualLinkedList\u003cT\u003e\u003e,\n    cur: *mut EventNode\u003cT\u003e,\n    alloc: CQueueLLAllocator,\n}\n\nimpl\u003c'a, T\u003e Iterator for IterMut\u003c'a, T\u003e {\n    type Item = (\u0026'a mut T, \u0026'a Duration);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        // SAFTEY:\n        // Will point to a valid node since:\n        // IA) head-\u003enext is a valid node\n        // IS) each time the next node is check to be non-null (thus valid)\n        let mut cur = unsafe { Box::from_raw_in(self.cur, self.alloc) };\n        let result: Option\u003c(*mut T, *const Duration)\u003e = {\n            if cur.next.is_null() {\n                // is tail\n                None\n            } else {\n                self.cur = cur.next;\n                // SAFTEY:\n                // cur is allways valid + now non-tail\n                Some((unsafe { cur.value.as_mut().unwrap_unchecked() }, \u0026cur.time))\n            }\n        };\n        std::mem::forget(cur);\n        result.map(|(v, t)| unsafe { (\u0026mut *v, \u0026*t) })\n    }\n}\n\nimpl\u003c'a, T\u003e IntoIterator for \u0026'a mut DualLinkedList\u003cT\u003e {\n    type Item = (\u0026'a mut T, \u0026'a Duration);\n    type IntoIter = IterMut\u003c'a, T\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        IterMut {\n            marker: PhantomData,\n            cur: self.head.next,\n            alloc: self.alloc,\n        }\n    }\n}\n\npub struct IntoIter\u003cT\u003e {\n    dll: DualLinkedList\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Iterator for IntoIter\u003cT\u003e {\n    type Item = (T, Duration);\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.dll.pop_min()\n    }\n}\n\nimpl\u003cT\u003e IntoIterator for DualLinkedList\u003cT\u003e {\n    type Item = (T, Duration);\n    type IntoIter = IntoIter\u003cT\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        IntoIter { dll: self }\n    }\n}\n\n// IMPL: Node\n\nimpl\u003cT\u003e EventNode\u003cT\u003e {\n    pub(super) fn empty(\n        time: Duration,\n        alloc: CQueueLLAllocator,\n    ) -\u003e Box\u003cEventNode\u003cT\u003e, CQueueLLAllocator\u003e {\n        Box::new_in(\n            Self {\n                value: None,\n                id: 0,\n                time,\n                prev: std::ptr::null_mut(),\n                next: std::ptr::null_mut(),\n            },\n            alloc,\n        )\n    }\n\n    pub(super) fn new(\n        value: T,\n        time: Duration,\n        id: usize,\n        alloc: CQueueLLAllocator,\n    ) -\u003e Box\u003cEventNode\u003cT\u003e, CQueueLLAllocator\u003e {\n        Box::new_in(\n            Self {\n                value: Some(value),\n                time,\n                id,\n                prev: std::ptr::null_mut(),\n                next: std::ptr::null_mut(),\n            },\n            alloc,\n        )\n    }\n\n    #[allow(clippy::boxed_local)]\n    fn into_inner(mut self: Box\u003cSelf, CQueueLLAllocator\u003e) -\u003e (T, Duration) {\n        // SAFTEY:\n        // This function may only be applied to nodes that are\n        // neither head nor tail. Such notes allways contain a value\n        (unsafe { self.value.take().unwrap_unchecked() }, self.time)\n    }\n}\n\nimpl\u003cE\u003e Debug for EventNode\u003cE\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"EventNode\")\n            .field(\"prev\", \u0026self.prev)\n            .field(\"next\", \u0026self.next)\n            .field(\"time\", \u0026self.time)\n            .field(\"value\", \u0026self.value.is_some())\n            .finish()\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":134},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","nightly","mod.rs"],"content":"use std::{collections::VecDeque, marker::PhantomData, ops::Rem, time::Duration};\n\n// mod _alloc;\nmod alloc;\nmod linked_list;\n\npub(crate) use alloc::*;\nuse linked_list::DualLinkedList;\n\n/// A calender queue.\n///\n/// This type acts as a sorter for entries of type E\n/// that occure at a given point in time, represented by the\n/// Duration type. This means that the fetch_next\n/// method will allways return the entry with the smallest timestamp.\n/// In general, this can be compared to a BinaryHeap where the entries\n/// are a tupel (E, Duration) sorted by the Duration.\n///\n/// Note however that this datatype is optimized for use in a discrete\n/// event simulation. Thus is supports O(1) inserts and removals, as\n/// well as O(1) fetch_next. Note that this is a amorised analysis\n/// assuming that the parameters are optimal for the given distribution\n/// of event arrival times. Additionaly the CQueue does not allow for\n/// the insertion of entries with a timestamp smaller that entries\n/// that was last fetched (or Duration::ZERO initally).\n///\n#[derive(Debug)]\npub struct CQueue\u003cE\u003e {\n    #[allow(unused)]\n    pub(crate) alloc: Box\u003cCQueueLLAllocatorInner\u003e,\n\n    // Parameters\n    pub(crate) n: usize,\n    pub(crate) t: Duration,\n    pub(crate) t_nanos: u128,\n\n    // Buckets\n    pub(crate) zero_event_bucket: VecDeque\u003c(E, Duration, usize)\u003e,\n    pub(crate) buckets: Vec\u003cDualLinkedList\u003cE\u003e\u003e,\n\n    pub(crate) head: usize,\n\n    pub(crate) t_current: Duration,\n    pub(crate) t0: Duration,\n    pub(crate) t1: Duration,\n    pub(crate) t_all: u128,\n\n    // Misc\n    pub(crate) event_id: usize,\n    pub(crate) len: usize,\n}\n\n/// A handle that identifies a event.\n#[derive(Debug, PartialEq, Eq, Hash)]\npub struct EventHandle\u003cE\u003e {\n    _phantom: PhantomData\u003cE\u003e,\n    id: usize,\n    time: Duration,\n}\n\nimpl\u003cE\u003e CQueue\u003cE\u003e {\n    /// Returns a String describing the datatype and its parameters.\n    pub fn descriptor(\u0026self) -\u003e String {\n        format!(\"CTimeVDeque({}, {:?})\", self.n, self.t)\n    }\n\n    /// Returns the number of elements in the queue.\n    pub fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    /// Returns the number of element in the subset that is\n    /// manage by the zero-event-time optimization.\n    pub fn len_zero(\u0026self) -\u003e usize {\n        self.zero_event_bucket.len()\n    }\n\n    /// Returns the number of elements in the subset that is\n    /// not managed by the zero-event-time optimization.\n    pub fn len_nonzero(\u0026self) -\u003e usize {\n        self.len() - self.len_zero()\n    }\n\n    /// Indicates whether the queue is empty.\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    pub fn metrics(\u0026self) -\u003e (usize, usize) {\n        let (alloc, total) = self.alloc.metrics();\n        let additional = std::mem::size_of::\u003cSelf\u003e();\n        let additional = additional + std::mem::size_of::\u003c(E, Duration, usize)\u003e() * self.len_zero();\n        (alloc + additional, total + additional)\n    }\n\n    /// Returns the timestamp of the last emitted event.\n    /// This acts as a lower bound to the insertion of new events.\n    pub fn time(\u0026self) -\u003e Duration {\n        self.t_current\n    }\n\n    /// Creates a new parameteriszed CQueue.\n    pub fn new(n: usize, t: Duration) -\u003e Self {\n        // essentialy t*n\n        let t_all = t.as_nanos() * n as u128;\n\n        let alloc = Box::new(CQueueLLAllocatorInner::new());\n\n        Self {\n            n,\n            t_nanos: t.as_nanos(),\n            t,\n\n            zero_event_bucket: VecDeque::with_capacity(64),\n            buckets: std::iter::repeat_with(|| DualLinkedList::new(alloc.handle()))\n                .take(n)\n                .collect(),\n            head: 0,\n            t_current: Duration::ZERO,\n\n            t0: Duration::ZERO,\n            t1: t,\n\n            t_all,\n\n            alloc,\n            event_id: 0,\n            len: 0,\n        }\n    }\n\n    ///\n    /// Adds an event to the calenderqueue.\n    ///\n    /// Returns an event handle to cancel the event at will.\n    ///\n    /// # Panics\n    ///\n    /// This funtion panics if the timestamp violates the lower\n    /// bound, defined by the timestamp of the last emitted event.\n    ///\n    pub fn add(\u0026mut self, time: Duration, event: E) -\u003e EventHandle\u003cE\u003e {\n        assert!(\n            time \u003e= self.t_current,\n            \"Cannot add past event to calender queue\"\n        );\n\n        self.len += 1;\n        if time == self.t_current {\n            let id = self.event_id;\n            self.zero_event_bucket.push_back((event, time, id));\n            self.event_id = id.wrapping_add(1);\n\n            EventHandle {\n                _phantom: PhantomData,\n                id,\n                time,\n            }\n        } else {\n            // delta time ?\n\n            let time_mod = time.as_nanos().rem(self.t_all);\n\n            let index = time_mod / self.t_nanos;\n            let index: usize = index as usize;\n            let index = index % self.n;\n\n            // find insert pos\n\n            let id = self.event_id;\n            self.buckets[index].add(event, time, id);\n            self.event_id = id.wrapping_add(1);\n            EventHandle {\n                _phantom: PhantomData,\n                id,\n                time,\n            }\n        }\n    }\n\n    pub fn cancel(\u0026mut self, handle: EventHandle\u003cE\u003e) {\n        if handle.time \u003e= self.t_current {\n            if handle.time == self.t_current {\n                if let Some(i) = self\n                    .zero_event_bucket\n                    .iter()\n                    .position(|v| v.2 == handle.id)\n                {\n                    self.zero_event_bucket.remove(i);\n                    self.len -= 1;\n                }\n            } else {\n                let time_mod = handle.time.as_nanos().rem(self.t_all);\n\n                let index = time_mod / self.t_nanos;\n                let index: usize = index as usize;\n                let index = index % self.n;\n\n                if self.buckets[index].cancel(handle) {\n                    self.len -= 1;\n                }\n            }\n        }\n    }\n\n    ///\n    /// Fetches the smalles event from the calender queue.\n    ///\n    /// # Panics\n    ///\n    /// This function assummes that the queue is not empty.\n    /// If it is this function panics.\n    ///\n    pub fn fetch_next(\u0026mut self) -\u003e (E, Duration) {\n        assert!(!self.is_empty(), \"Cannot fetch from empty queue\");\n\n        if let Some((event, time, _)) = self.zero_event_bucket.pop_front() {\n            self.len -= 1;\n            return (event, time);\n        }\n\n        loop {\n            // Move until full bucket is found.\n            while self.buckets[self.head].is_empty() {\n                self.head = (self.head + 1) % self.n;\n                self.t0 += self.t;\n                self.t1 += self.t;\n            }\n\n            // Bucket with \u003e 0 elements found\n\n            let min = self.buckets[self.head].front_time();\n            if min \u003e self.t1 {\n                self.head = (self.head + 1) % self.n;\n                self.t0 += self.t;\n                self.t1 += self.t;\n                continue;\n            }\n\n            self.t_current = min;\n\n            // SAFTEY:\n            // Bucket is non-empty, thus pop-min returns a valid value.\n            self.len -= 1;\n            return unsafe { self.buckets[self.head].pop_min().unwrap_unchecked() };\n        }\n    }\n}\n\nimpl\u003cE\u003e Default for CQueue\u003cE\u003e {\n    fn default() -\u003e Self {\n        Self::new(1024, Duration::from_millis(5))\n    }\n}\n\nimpl\u003cE\u003e Drop for CQueue\u003cE\u003e {\n    fn drop(\u0026mut self) {\n        // Manually drop the DLL so that the alloc can be dropped last\n        for dll in self.buckets.drain(..) {\n            drop(dll)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":76},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","nightly","tests.rs"],"content":"use super::*;\nuse rand::distributions::Uniform;\nuse rand::rngs::SmallRng;\nuse rand::seq::SliceRandom;\nuse rand::*;\nuse std::alloc::{Allocator, Layout};\nuse std::mem::size_of;\nuse std::time::Duration;\n\n#[test]\nfn alloc_single_page_one_alloc_one_allocator() {\n    // Layout will allways be big enoght for a Free Node\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu32 = Box::new_in(42u32, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu32);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu64 = Box::new_in(42u64, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu64);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu128 = Box::new_in(42u128, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu128);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    // Now layout will grow\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let barray = Box::new_in([42u8; 55], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 56); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let barray = Box::new_in([42u8; 128], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 128); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n}\n\n#[test]\nfn alloc_single_page_one_alloc_shared_allocator() {\n    // Layout will allways be big enoght for a Free Node\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu32 = Box::new_in(42u32, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu32);\n    assert!(alloc.dbg_is_empty());\n\n    let bu64 = Box::new_in(42u64, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu64);\n    assert!(alloc.dbg_is_empty());\n\n    let bu128 = Box::new_in(42u128, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu128);\n    assert!(alloc.dbg_is_empty());\n\n    // Now layout will grow\n\n    let barray = Box::new_in([42u8; 55], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 56); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n\n    let barray = Box::new_in([42u8; 128], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 128); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n}\n\n#[test]\nfn alloc_single_page_alloc_exceeds_page_size() {\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    assert!(alloc\n        .handle()\n        .allocate(Layout::new::\u003c[u8; 8000]\u003e())\n        .is_err())\n    // let _ = Box::new_in([42u8; 8000], alloc.handle());\n}\n\n#[test]\nfn alloc_single_page_list_alloc() {\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let mut boxes = Vec::new();\n    for i in 0..10 {\n        boxes.push(Box::new_in([i as u8; 400], alloc.handle()))\n    }\n\n    // 4000 byte\n    assert_eq!(alloc.dbg_alloc_total(), 4000);\n    for i in 0..10 {\n        assert_eq!(boxes[i][0], i as u8);\n    }\n\n    // Drop the last 2000 byte\n    for _ in 0..5 {\n        boxes.pop();\n    }\n\n    assert_eq!(alloc.dbg_alloc_total(), 2000);\n\n    drop(boxes);\n\n    assert!(alloc.dbg_is_empty());\n}\n\n#[test]\nfn alloc_multiple_pages_same_size_allocation() {\n    #[allow(dead_code)]\n    struct A {\n        bytes: [u8; 32],\n        int: u128,\n        s: String,\n    }\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let mut boxes = Vec::new();\n    for _ in 0..100 {\n        boxes.push(Box::new_in(\n            A {\n                bytes: [0; 32],\n                int: 42,\n                s: String::from(\"Hallow str\"),\n            },\n            alloc.handle(),\n        ));\n    }\n\n    assert!(\n        alloc.dbg_alloc_total() \u003e= size_of::\u003cA\u003e() * 100,\n        \"alloc: {} expected: {} * 100\",\n        alloc.dbg_alloc_total(),\n        size_of::\u003cA\u003e()\n    )\n}\n\n#[test]\nfn alloc_multiple_pages_skip_to_small_elements() {\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let b1 = Box::new_in([0u8; 2500], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 2504); // align\n    assert_eq!(alloc.dbg_pages(), 1);\n\n    // remaining bytes of page 1 were skipped\n    // since elements are asssumed to be 2500 bytes big\n\n    let b2 = Box::new_in([0u8; 128], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 2504 + 128); // align\n    assert_eq!(alloc.dbg_pages(), 2);\n\n    drop(b1);\n    drop(b2);\n\n    assert_eq!(alloc.dbg_alloc_total(), 0);\n    assert_eq!(alloc.dbg_pages(), 2);\n\n    drop(alloc);\n}\n\n#[test]\nfn alloc_16_byteboxes() {\n    struct Word {\n        _opaque: [u8; 16],\n    }\n\n    impl Word {\n        fn new() -\u003e Self {\n            Self { _opaque: [42; 16] }\n        }\n    }\n\n    assert_eq!(std::mem::size_of::\u003cWord\u003e(), 16);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let mut list = Vec::new();\n    for _ in 1..10 {\n        let b = Box::new_in(Word::new(), alloc.handle());\n        list.push(b)\n    }\n    alloc.info();\n\n    list.remove(2);\n\n    alloc.info();\n\n    drop(list);\n\n    alloc.info();\n\n    for _ in 1..10 {\n        let b = Box::new_in(Word::new(), alloc.handle());\n        std::mem::forget(b);\n    }\n\n    alloc.info();\n}\n\n// #[test]\n// fn clinked_list() {\n//     let mut ls = CacheOptimizedLinkedList::with_capacity(4);\n//     ls.add(1, Duration::from_secs(1), 1);\n//     println!(\"{:?}\", ls);\n//     ls.add(2, Duration::from_secs(2), 2);\n//     println!(\"{:?}\", ls);\n//     ls.add(3, Duration::from_secs(3), 3);\n//     println!(\"{:?}\", ls);\n\n//     while let Some((event, time, _)) = ls.pop_min() {\n//         println!(\"popped {} at {:?}\", event, time);\n//         println!(\"{:?}\", ls)\n//     }\n\n//     ls.add(4, Duration::from_secs(4), 4);\n//     println!(\"{:?}\", ls);\n// }\n\n// #[test]\n// fn linked_list_ordered_in_ordered_out() {\n//     let events = [\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (5, Duration::from_secs_f64(5.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ];\n\n//     let dll = DLL::from_iter(events.clone());\n//     let event = dll.into_iter().collect::\u003cVec\u003c_\u003e\u003e();\n\n//     assert_eq!(\u0026events[..], \u0026event);\n// }\n\n// #[test]\n// fn linked_list_unordered_in_ordered_out() {\n//     let mut events = [\n//         (5, Duration::from_secs_f64(5.0)),\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//     ];\n\n//     let dll = CacheOptimizedLinkedList::from_iter(events.clone());\n//     let event = dll.into_iter().collect::\u003cVec\u003c_\u003e\u003e();\n\n//     events.sort();\n\n//     assert_eq!(\u0026events[..], \u0026event);\n// }\n\n// #[test]\n// fn linked_list_ordered_collision_in_retain() {\n//     let events = [\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (3, Duration::from_secs_f64(4.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (5, Duration::from_secs_f64(5.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ];\n\n//     let dll = CacheOptimizedLinkedList::from_iter(events.clone());\n//     let event = dll.into_iter().collect::\u003cVec\u003c_\u003e\u003e();\n\n//     assert_eq!(\u0026events[..], \u0026event);\n// }\n\n// #[test]\n// fn linked_list_unordered_collision_in_retain() {\n//     let mut events = [\n//         (5, Duration::from_secs_f64(5.0)),\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//         (4, Duration::from_secs_f64(1.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//     ];\n\n//     let dll = CacheOptimizedLinkedList::from_iter(events.clone());\n//     let event = dll.into_iter().collect::\u003cVec\u003c_\u003e\u003e();\n\n//     events.sort_by(|l, r| l.1.cmp(\u0026r.1));\n\n//     assert_eq!(\u0026events[..], \u0026event);\n// }\n\n// #[test]\n// fn linked_list_iter_and_iter_mut() {\n//     let events = [\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (5, Duration::from_secs_f64(5.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ];\n\n//     let mut dll = CacheOptimizedLinkedList::from_iter(events.clone());\n\n//     let mut c = 1;\n//     for item in dll.iter() {\n//         assert_eq!(*item.0, c);\n//         assert_eq!(item.1.as_secs(), c);\n//         c += 1;\n//     }\n\n//     for item in dll.iter_mut() {\n//         *item.0 += 1;\n//     }\n\n//     let mut c = 1;\n//     for item in dll.iter() {\n//         assert_eq!(*item.0, c + 1);\n//         assert_eq!(item.1.as_secs(), c);\n//         c += 1;\n//     }\n// }\n\n// #[test]\n// fn linked_list_ordered_in_eq() {\n//     let events = [\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (5, Duration::from_secs_f64(5.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ];\n\n//     let dll = CacheOptimizedLinkedList::from(events);\n//     let dll2 = CacheOptimizedLinkedList::from(events);\n\n//     assert_eq!(dll, dll2)\n// }\n\n// #[test]\n// fn linked_list_unordered_in_eq() {\n//     let dll = CacheOptimizedLinkedList::from([\n//         (4, Duration::from_secs_f64(4.0)),\n//         (5, Duration::from_secs_f64(5.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//         (1, Duration::from_secs_f64(1.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//     ]);\n\n//     let dll2 = CacheOptimizedLinkedList::from([\n//         (5, Duration::from_secs_f64(5.0)),\n//         (1, Duration::from_secs_f64(1.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ]);\n\n//     assert_eq!(dll, dll2)\n// }\n\n// #[test]\n// fn linked_list_same_time_in_order() {\n//     let dll = CacheOptimizedLinkedList::from([\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(3.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(3.0)),\n//         (5, Duration::from_secs_f64(3.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ]);\n//     let mut c = 1;\n//     for item in dll {\n//         assert_eq!(item.0, c);\n//         c += 1;\n//     }\n//     assert_eq!(c, 7);\n\n//     let dll = CacheOptimizedLinkedList::from([\n//         // (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(3.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(3.0)),\n//         (5, Duration::from_secs_f64(3.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ]);\n//     let mut c = 2;\n//     for item in dll {\n//         assert_eq!(item.0, c);\n//         c += 1;\n//     }\n//     assert_eq!(c, 7);\n\n//     let dll = CacheOptimizedLinkedList::from([\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(3.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(3.0)),\n//         (5, Duration::from_secs_f64(3.0)),\n//         // (6, Duration::from_secs_f64(6.0)),\n//     ]);\n//     let mut c = 1;\n//     for item in dll {\n//         assert_eq!(item.0, c);\n//         c += 1;\n//     }\n//     assert_eq!(c, 6);\n// }\n\n// #[test]\n// fn linked_list_remove_min() {\n//     let mut CacheOptimizedLinkedList = CacheOptimizedLinkedList::from([\n//         // (1, Duration::from_secs_f64(1.0)),\n//         // (2, Duration::from_secs_f64(2.0)),\n//         // (3, Duration::from_secs_f64(3.0)),\n//         (4, Duration::from_secs_f64(4.0)),\n//         (5, Duration::from_secs_f64(5.0)),\n//         (6, Duration::from_secs_f64(6.0)),\n//     ]);\n\n//     let e1 = CacheOptimizedLinkedList.add(1, Duration::from_secs_f64(1.0));\n//     let e2 = CacheOptimizedLinkedList.add(2, Duration::from_secs_f64(2.0));\n//     let e3 = CacheOptimizedLinkedList.add(3, Duration::from_secs_f64(3.0));\n\n//     assert_eq!(CacheOptimizedLinkedList.len(), 6);\n//     e1.cancel();\n//     assert_eq!(CacheOptimizedLinkedList.len(), 5);\n//     e3.cancel();\n//     assert_eq!(CacheOptimizedLinkedList.len(), 4);\n//     e2.cancel();\n//     assert_eq!(CacheOptimizedLinkedList.len(), 3);\n\n//     assert_eq!(\n//         CacheOptimizedLinkedList.into_iter().collect::\u003cVec\u003c_\u003e\u003e(),\n//         vec![\n//             (4, Duration::from_secs_f64(4.0)),\n//             (5, Duration::from_secs_f64(5.0)),\n//             (6, Duration::from_secs_f64(6.0)),\n//         ]\n//     )\n// }\n\n// #[test]\n// fn linked_list_remove_back() {\n//     let mut CacheOptimizedLinkedList = CacheOptimizedLinkedList::from([\n//         (1, Duration::from_secs_f64(1.0)),\n//         (2, Duration::from_secs_f64(2.0)),\n//         (3, Duration::from_secs_f64(3.0)),\n//         // (4, Duration::from_secs_f64(4.0)),\n//         // (5, Duration::from_secs_f64(5.0)),\n//         // (6, Duration::from_secs_f64(6.0)),\n//     ]);\n\n//     let e1 = CacheOptimizedLinkedList.add(4, Duration::from_secs_f64(4.0));\n//     let e2 = CacheOptimizedLinkedList.add(5, Duration::from_secs_f64(5.0));\n//     let e3 = CacheOptimizedLinkedList.add(6, Duration::from_secs_f64(6.0));\n\n//     assert_eq!(CacheOptimizedLinkedList.len(), 6);\n//     e3.cancel();\n//     assert_eq!(CacheOptimizedLinkedList.len(), 5);\n//     e1.cancel();\n//     assert_eq!(CacheOptimizedLinkedList.len(), 4);\n//     e2.cancel();\n//     assert_eq!(CacheOptimizedLinkedList.len(), 3);\n\n//     assert_eq!(\n//         CacheOptimizedLinkedList.into_iter().collect::\u003cVec\u003c_\u003e\u003e(),\n//         vec![\n//             (1, Duration::from_secs_f64(1.0)),\n//             (2, Duration::from_secs_f64(2.0)),\n//             (3, Duration::from_secs_f64(3.0)),\n//         ]\n//     )\n// }\n\n#[test]\nfn cqueue_simple_event_order_nonoverlapping() {\n    let mut cqueue = CQueue::new(100, Duration::from_secs(1));\n    let events = (0..=100).map(|e| (e, Duration::from_secs(e)));\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    assert_eq!(cqueue.len(), 101);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        println!(\"Itr: {}\", c);\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_simple_event_order_wrap_around() {\n    // This test is identicall to 'cqueue_simple_event_order_nonoverlapping'\n    // but with other config options for the cqueue.\n    let mut cqueue = CQueue::new(20, Duration::from_secs(1));\n    let events = (0..=100).map(|e| (e, Duration::from_secs(e)));\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_simple_event_out_of_order_nonoverlapping() {\n    let mut cqueue = CQueue::new(100, Duration::from_secs(1));\n    let mut events = (0..=100)\n        .map(|e| (e, Duration::from_secs(e)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    let mut rng = SmallRng::seed_from_u64(123);\n    events.shuffle(\u0026mut rng);\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    assert_eq!(cqueue.len(), 101);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        println!(\"Itr: {}\", c);\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_simple_event_out_of_order_wrap_around() {\n    // This test is identicall to 'cqueue_simple_event_order_nonoverlapping'\n    // but with other config options for the cqueue.\n    let mut cqueue = CQueue::new(20, Duration::from_secs(1));\n    let mut events = (0..=100)\n        .map(|e| (e, Duration::from_secs(e)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    let mut rng = SmallRng::seed_from_u64(123);\n    events.shuffle(\u0026mut rng);\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_zero_bucket_in_out() {\n    let mut cqueue = CQueue::new(10, Duration::new(1, 0));\n    for i in 0..10 {\n        cqueue.add(Duration::ZERO, i);\n    }\n    assert_eq!(cqueue.len_zero(), 10);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 2 - without forwarding to the current event\n\n    for i in 0..10 {\n        cqueue.add(Duration::new(9, 0), i);\n    }\n    assert_eq!(cqueue.len_zero(), 0);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 3: allready forwared\n\n    for i in 0..10 {\n        cqueue.add(Duration::new(9, 0), i);\n    }\n    assert_eq!(cqueue.len_zero(), 10);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n}\n\n#[test]\nfn cqueue_zero_bucket_cancel() {\n    let mut cqueue = CQueue::new(10, Duration::new(1, 0));\n    let mut handles = (0..10)\n        .map(|i| cqueue.add(Duration::ZERO, i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len_zero(), 10);\n\n    // remove element 6\n    cqueue.cancel(handles.remove(6));\n    assert_eq!(cqueue.len(), 9);\n    assert_eq!(cqueue.len_zero(), 9);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        if c == 6 {\n            c += 1;\n            continue;\n        }\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 2 - without forwarding to the current event\n\n    let mut handles = (0..10)\n        .map(|i| cqueue.add(Duration::new(9, 0), i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len_zero(), 0);\n\n    cqueue.cancel(handles.remove(3));\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        if c == 3 {\n            c += 1;\n            continue;\n        }\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 3: allready forwared\n\n    let mut handles = (0..10)\n        .map(|i| cqueue.add(Duration::new(9, 0), i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len_zero(), 10);\n\n    cqueue.cancel(handles.remove(0));\n\n    let mut c = 1;\n    while !cqueue.is_empty() {\n        // if c == 0 { ... }\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n}\n\n#[test]\nfn cqueue_out_of_order_with_overlaps() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut delay = Duration::new(1, 0);\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut events = (0..200)\n        .map(|v| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.1, 1.0)));\n            (v, delay)\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    events.shuffle(\u0026mut rng);\n    let _ = events\n        .into_iter()\n        .map(|(event, time)| cqueue.add(time, event))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut last_time = Duration::ZERO;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 200 - c);\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e last_time);\n\n        last_time = t;\n        c += 1;\n    }\n    assert_eq!(c, 200);\n}\n\n#[test]\nfn cqueue_out_of_order_with_cancel() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut delay = Duration::new(1, 0);\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut events = (0..200)\n        .map(|v| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.1, 1.0)));\n            (v, delay, rng.sample(Uniform::new(1, 10)) == 8)\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    events.shuffle(\u0026mut rng);\n    let handles = events\n        .into_iter()\n        .map(|(event, time, cancel)| (cqueue.add(time, event), cancel, event))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let canceled = handles\n        .into_iter()\n        .filter_map(|(h, flg, event)| {\n            if flg {\n                cqueue.cancel(h);\n                Some(event)\n            } else {\n                None\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut last_time = Duration::ZERO;\n    while !cqueue.is_empty() {\n        if canceled.contains(\u0026c) {\n            c += 1;\n            continue;\n        }\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e last_time);\n\n        last_time = t;\n        c += 1;\n    }\n    // The 200th event was canceld thus the loop broke, event though one\n    // iteration was still due (to be simpliar to previous test cases)\n    assert_eq!(c, 199);\n}\n\n#[test]\nfn cqueue_out_of_order_boxes_overlapping() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut delay = Duration::new(1, 0);\n    let mut s = 0;\n    let mut event_boxes = (0..100)\n        .map(|_| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.0, 1.0)));\n            let n = rng.sample(Uniform::new(1, 4));\n            let old_s = s;\n            s += n;\n            (delay, old_s, n)\n        })\n        // .map(|(t, from, n)| (from..(from + n)).map(|i| (i, t)))\n        // .flatten()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    event_boxes.shuffle(\u0026mut rng);\n    let _ = event_boxes\n        .into_iter()\n        .map(|(t, from, n)| (from..(from + n)).map(move |i| (i, t)))\n        .flatten()\n        .map(|(e, t)| cqueue.add(t, e))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut lt = Duration::ZERO;\n    while !cqueue.is_empty() {\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e= lt);\n        c += 1;\n        lt = t;\n    }\n}\n\n#[test]\nfn cqueue_out_of_order_boxes_with_cancel() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut delay = Duration::new(1, 0);\n    let mut s = 0;\n    let mut event_boxes = (0..100)\n        .map(|_| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.0, 1.0)));\n            let n = rng.sample(Uniform::new(1, 4));\n            let old_s = s;\n            s += n;\n            (delay, old_s, n)\n        })\n        // .map(|(t, from, n)| (from..(from + n)).map(|i| (i, t)))\n        // .flatten()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    event_boxes.shuffle(\u0026mut rng);\n    let handles = event_boxes\n        .into_iter()\n        .map(|(t, from, n)| (from..(from + n)).map(move |i| (i, t)))\n        .flatten()\n        .map(|(e, t)| (cqueue.add(t, e), e, rng.sample(Uniform::new(1, 10)) == 2))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    // Cancel events\n    let cancelled = handles\n        .into_iter()\n        .filter_map(|(h, e, flg)| {\n            if flg {\n                cqueue.cancel(h);\n                Some(e)\n            } else {\n                None\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut lt = Duration::ZERO;\n    while !cqueue.is_empty() {\n        if cancelled.contains(\u0026c) {\n            c += 1;\n            continue;\n        }\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e= lt);\n        c += 1;\n        lt = t;\n    }\n}\n\n#[test]\nfn cqueue_cancel_validity() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut handles = (0..10)\n        .map(|i| Some(cqueue.add(Duration::from_secs(i), i)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len(), 10);\n\n    // Succesful cancel 0, 9\n    cqueue.cancel(handles[0].take().unwrap());\n    cqueue.cancel(handles[9].take().unwrap());\n\n    assert_eq!(cqueue.len(), 8);\n\n    // Cur [1,2,3,4,5,6,7,8]\n    for i in 1..4 {\n        let event = cqueue.fetch_next();\n        assert_eq!(event.0, i);\n    }\n    assert_eq!(cqueue.len(), 5);\n\n    // Cur [4,5,6,7,8]\n    cqueue.cancel(handles[2].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    cqueue.cancel(handles[3].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    // Suc again\n    cqueue.cancel(handles[8].take().unwrap());\n    assert_eq!(cqueue.len(), 4);\n\n    // Cur [4,5,6,7]\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let _ = cqueue.fetch_next();\n        c += 1;\n    }\n\n    assert_eq!(c, 4)\n}\n\n#[test]\nfn cqueue_cancel_validity_2() {\n    let mut cqueue = CQueue::new(10, Duration::new(3, 0));\n    let mut handles = (0..10)\n        .map(|i| Some(cqueue.add(Duration::from_secs(i), i)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len(), 10);\n\n    // Succesful cancel 0, 9\n    cqueue.cancel(handles[0].take().unwrap());\n    cqueue.cancel(handles[9].take().unwrap());\n\n    assert_eq!(cqueue.len(), 8);\n\n    // Cur [1,2,3,4,5,6,7,8]\n    for i in 1..4 {\n        let event = cqueue.fetch_next();\n        assert_eq!(event.0, i);\n    }\n    assert_eq!(cqueue.len(), 5);\n\n    // Cur [4,5,6,7,8]\n    cqueue.cancel(handles[2].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    cqueue.cancel(handles[3].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    // Suc again\n    cqueue.cancel(handles[8].take().unwrap());\n    assert_eq!(cqueue.len(), 4);\n\n    // Cur [4,5,6,7]\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let _ = cqueue.fetch_next();\n        c += 1;\n    }\n\n    assert_eq!(c, 4)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","stable","alloc.rs"],"content":"use std::{\n    alloc::{self, Layout},\n    fmt::Debug,\n    mem::{align_of, size_of},\n    ptr::NonNull,\n};\n\nstruct ListNode {\n    size: usize,\n    next: Option\u003c\u0026'static mut ListNode\u003e,\n}\n\nimpl ListNode {\n    fn new(size: usize) -\u003e Self {\n        ListNode { size, next: None }\n    }\n\n    fn start_addr(\u0026self) -\u003e usize {\n        self as *const Self as usize\n    }\n\n    fn end_addr(\u0026self) -\u003e usize {\n        self.start_addr() + self.size\n    }\n}\n\npub struct CQueueLLAllocatorInner {\n    head: ListNode,\n    pages: Vec\u003c*mut u8\u003e,\n    page_size: usize,\n    allocated_mem: usize,\n}\n\nimpl CQueueLLAllocatorInner {\n    /// Creates an empty `LinkedListAllocator`.\n    pub fn new() -\u003e Self {\n        Self::with_page_size(page_size::get())\n    }\n\n    pub fn with_page_size(page_size: usize) -\u003e Self {\n        let mut this = Self {\n            head: ListNode::new(0),\n            pages: Vec::new(),\n            page_size,\n            allocated_mem: 0,\n        };\n\n        unsafe {\n            this.add_page();\n        }\n\n        this\n    }\n\n    pub(super) fn metrics(\u0026self) -\u003e (usize, usize) {\n        (self.allocated_mem, self.page_size * self.page_size)\n    }\n\n    #[cfg(test)]\n    pub(crate) fn info(\u0026self) {}\n\n    unsafe fn add_page(\u0026mut self) {\n        let block = alloc::alloc_zeroed(\n            Layout::from_size_align(self.page_size, self.page_size).expect(\"page layout invalid\"),\n        );\n        self.pages.push(block);\n        self.add_free_region(block as usize, self.page_size);\n    }\n\n    pub fn handle(\u0026self) -\u003e CQueueLLAllocator {\n        CQueueLLAllocator {\n            inner: (self as *const CQueueLLAllocatorInner).cast_mut(),\n        }\n    }\n\n    #[cfg(test)]\n    pub(crate) fn dbg_alloc_total(\u0026self) -\u003e usize {\n        self.allocated_mem\n    }\n\n    #[cfg(test)]\n    pub(crate) fn dbg_is_empty(\u0026self) -\u003e bool {\n        self.allocated_mem == 0\n    }\n\n    #[cfg(test)]\n    pub(crate) fn dbg_pages(\u0026self) -\u003e usize {\n        self.pages.len()\n    }\n\n    /// Adds the given memory region to the front of the list.\n    unsafe fn add_free_region(\u0026mut self, addr: usize, size: usize) {\n        // ensure that the freed region is capable of holding ListNode\n        assert_eq!(align_up(addr, align_of::\u003cListNode\u003e()), addr);\n        assert!(size \u003e= size_of::\u003cListNode\u003e());\n\n        // create a new list node and append it at the start of the list\n        let mut node = ListNode::new(size);\n        node.next = self.head.next.take();\n        let node_ptr = addr as *mut ListNode;\n        node_ptr.write(node);\n        self.head.next = Some(\u0026mut *node_ptr);\n    }\n\n    /// Looks for a free region with the given size and alignment and removes\n    /// it from the list.\n    ///\n    /// Returns a tuple of the list node and the start address of the allocation.\n    fn find_region(\u0026mut self, size: usize, align: usize) -\u003e Option\u003c(\u0026'static mut ListNode, usize)\u003e {\n        // reference to current list node, updated for each iteration\n        let mut current = \u0026mut self.head;\n        // look for a large enough memory region in linked list\n        while let Some(ref mut region) = current.next {\n            if let Ok(alloc_start) = Self::alloc_from_region(region, size, align) {\n                // region suitable for allocation -\u003e remove node from list\n                let next = region.next.take();\n                let ret = Some((current.next.take().unwrap(), alloc_start));\n                current.next = next;\n                return ret;\n            }\n            // region not suitable -\u003e continue with next region\n            current = current.next.as_mut().unwrap();\n        }\n\n        // no suitable region found\n        // create new region\n        unsafe {\n            self.add_page();\n            self.find_region(size, align)\n        }\n    }\n\n    /// Try to use the given region for an allocation with given size and\n    /// alignment.\n    ///\n    /// Returns the allocation start address on success.\n    fn alloc_from_region(region: \u0026ListNode, size: usize, align: usize) -\u003e Result\u003cusize, ()\u003e {\n        let alloc_start = align_up(region.start_addr(), align);\n        let alloc_end = alloc_start.checked_add(size).ok_or(())?;\n\n        if alloc_end \u003e region.end_addr() {\n            // region too small\n            return Err(());\n        }\n\n        let excess_size = region.end_addr() - alloc_end;\n        if excess_size \u003e 0 \u0026\u0026 excess_size \u003c size_of::\u003cListNode\u003e() {\n            // rest of region too small to hold a ListNode (required because the\n            // allocation splits the region in a used and a free part)\n            return Err(());\n        }\n\n        // region suitable for allocation\n        Ok(alloc_start)\n    }\n\n    fn size_align(layout: Layout) -\u003e (usize, usize) {\n        let layout = layout\n            .align_to(align_of::\u003cListNode\u003e())\n            .expect(\"adjusting alignment failed\")\n            .pad_to_align();\n        let size = layout.size().max(size_of::\u003cListNode\u003e());\n        (size, layout.align())\n    }\n}\n\n#[allow(clippy::missing_fields_in_debug)]\nimpl Debug for CQueueLLAllocatorInner {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"CQueueLLAllocatorInner\")\n            .field(\"allocated_memory\", \u0026self.allocated_mem)\n            .field(\"pages\", \u0026self.pages.len())\n            .finish()\n    }\n}\n\nimpl Drop for CQueueLLAllocatorInner {\n    fn drop(\u0026mut self) {\n        let layout = Layout::from_size_align(self.page_size, self.page_size)\n            .expect(\"failed to generate page layout\");\n        for page in \u0026self.pages {\n            unsafe { alloc::dealloc(*page, layout) }\n        }\n    }\n}\n\n// impl Allocator for LinkedListAllocator {}\n\nfn align_up(addr: usize, align: usize) -\u003e usize {\n    (addr + align - 1) \u0026 !(align - 1)\n}\n\n#[derive(Clone, Copy, PartialEq, Eq, Hash)]\npub struct CQueueLLAllocator {\n    inner: *mut CQueueLLAllocatorInner,\n}\n\nimpl CQueueLLAllocator {\n    pub fn allocate(\u0026self, layout: std::alloc::Layout) -\u003e Result\u003c*mut u8, ()\u003e {\n        let (size, align) = CQueueLLAllocatorInner::size_align(layout);\n        let allocator = unsafe { \u0026mut *self.inner };\n\n        if size \u003e allocator.page_size {\n            return Err(());\n        }\n\n        if let Some((region, alloc_start)) = allocator.find_region(size, align) {\n            unsafe {\n                let alloc_end = alloc_start.checked_add(size).expect(\"overflow\");\n                let excess_size = region.end_addr() - alloc_end;\n                if excess_size \u003e 0 {\n                    if excess_size \u003c size {\n                        // println!(\"alloc: dropping {} bytes of memory\", excess_size);\n                        // alloc_end = alloc_end.checked_add(size).expect(\"overflow\");\n                    } else {\n                        allocator.add_free_region(alloc_end, excess_size);\n                    }\n                }\n                // println!(\n                //     \"alloc: Layout {{ size: {}, align: {} }} as Layout {{ size: {}, ptr: {} }}\",\n                //     layout.size(),\n                //     layout.align(),\n                //     size,\n                //     alloc_start\n                // );\n                allocator.allocated_mem += size;\n                Ok(alloc_start as *mut u8)\n            }\n        } else {\n            Err(())\n        }\n    }\n\n    pub unsafe fn deallocate(\u0026self, ptr: NonNull\u003cu8\u003e, layout: Layout) {\n        let (size, _) = CQueueLLAllocatorInner::size_align(layout);\n        let allocator = unsafe { \u0026mut *self.inner };\n        allocator.allocated_mem -= size;\n        allocator.add_free_region(ptr.as_ptr() as usize, size);\n    }\n}\n\nimpl Debug for CQueueLLAllocator {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"CQueueLLAllocator\")\n            .field(\"ptr\", \u0026self.inner)\n            .finish()\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":950867},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1911620},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1911620},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1433714},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1433714},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3100},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3100},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3100},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3100},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":180471},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":180471},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":950669},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":480806},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":480806},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":958714},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":2902},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2902},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":477906},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":477906},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":955812},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":950481},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":955800},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":955800},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":955800},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":955800},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":955800},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":6398},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":3100},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1428575},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1428575},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":477905},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":477905},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":477905},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":477905},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":475480},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":469674},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":77,"coverable":88},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","stable","boxed.rs"],"content":"use std::{\n    alloc::Layout,\n    ops::{Deref, DerefMut},\n    ptr::{self, NonNull},\n};\n\nuse super::alloc::CQueueLLAllocator;\n\npub struct LocalBox\u003cE\u003e {\n    ptr: *mut E,\n    alloc: CQueueLLAllocator,\n}\n\nimpl\u003cE\u003e LocalBox\u003cE\u003e {\n    pub fn new_in(value: E, alloc: CQueueLLAllocator) -\u003e LocalBox\u003cE\u003e {\n        let bytes = alloc.allocate(Layout::new::\u003cE\u003e()).unwrap();\n        let ptr = bytes.cast::\u003cE\u003e();\n        unsafe {\n            ptr::write_volatile(ptr, value);\n        }\n        LocalBox { ptr, alloc }\n    }\n\n    pub unsafe fn from_raw_in(ptr: *mut E, alloc: CQueueLLAllocator) -\u003e LocalBox\u003cE\u003e {\n        LocalBox { ptr, alloc }\n    }\n}\n\nimpl\u003cE\u003e Deref for LocalBox\u003cE\u003e {\n    type Target = E;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        unsafe { \u0026*self.ptr }\n    }\n}\n\nimpl\u003cE\u003e DerefMut for LocalBox\u003cE\u003e {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        unsafe { \u0026mut *self.ptr }\n    }\n}\n\nimpl\u003cE\u003e Drop for LocalBox\u003cE\u003e {\n    fn drop(\u0026mut self) {\n        unsafe {\n            ptr::drop_in_place(self.ptr);\n\n            let ptr = NonNull::new(self.ptr.cast::\u003cu8\u003e()).unwrap();\n            self.alloc.deallocate(ptr, Layout::new::\u003cE\u003e());\n        }\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":477904},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":297434},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":4152659},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4152659},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1658044},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1658044},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":477895},"fn_name":null}],"covered":13,"coverable":13},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","stable","linked_list.rs"],"content":"use super::{alloc::CQueueLLAllocator, boxed::LocalBox, EventHandle};\nuse std::{fmt::Debug, hash::Hash, marker::PhantomData, time::Duration};\n\npub(crate) struct DualLinkedList\u003cE\u003e {\n    alloc: CQueueLLAllocator,\n    head: LocalBox\u003cEventNode\u003cE\u003e\u003e,\n    tail: LocalBox\u003cEventNode\u003cE\u003e\u003e,\n    len: usize,\n}\n\n#[derive(Clone)]\npub struct EventNode\u003cE\u003e {\n    pub(super) value: Option\u003cE\u003e,\n    pub(super) time: Duration,\n\n    pub(super) id: usize,\n\n    pub(super) prev: *mut EventNode\u003cE\u003e,\n    pub(super) next: *mut EventNode\u003cE\u003e,\n}\n\n// IMPL: DLL\n\nimpl\u003cT\u003e DualLinkedList\u003cT\u003e {\n    pub(super) fn new(alloc: CQueueLLAllocator) -\u003e Self {\n        let mut head = EventNode::empty(Duration::ZERO, alloc);\n        let mut tail = EventNode::empty(Duration::MAX, alloc);\n\n        let head_ptr: *mut EventNode\u003cT\u003e = \u0026mut *head;\n        let tail_ptr: *mut EventNode\u003cT\u003e = \u0026mut *tail;\n\n        head.next = tail_ptr;\n        tail.prev = head_ptr;\n\n        Self {\n            alloc,\n            head,\n            tail,\n            len: 0,\n        }\n    }\n\n    pub(super) fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    pub(super) fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    pub(super) fn cancel(\u0026mut self, handle: \u0026EventHandle\u003cT\u003e) -\u003e bool {\n        let mut cur = self.head.next;\n        unsafe {\n            while !(*cur).next.is_null() {\n                if (*cur).id == handle.id {\n                    // remove\n                    let mut cur = LocalBox::from_raw_in(cur, self.alloc);\n                    (*cur.prev).next = cur.next;\n                    (*cur.next).prev = cur.prev;\n                    self.len -= 1;\n\n                    drop(cur);\n                    return true;\n                }\n                cur = (*cur).next;\n            }\n        }\n        false\n    }\n\n    pub(super) fn front_time(\u0026self) -\u003e Duration {\n        // SAFTEY:\n        // Value is guranteed to be valid since head-\u003enext is allways valid\n        let ptr = self.head.next;\n        let front = unsafe { \u0026mut *ptr };\n        if front.next.is_null() {\n            Duration::MAX\n        } else {\n            // SAFTEY:\n            // front is valid, and neither head nor tail so itt must contain a value\n            front.time\n        }\n    }\n\n    /// Inserts a new element into the queue, returing a Handle to\n    /// cancel the event at will\n    pub(super) fn add(\u0026mut self, event: T, time: Duration, event_id: usize) {\n        let mut node = EventNode::new(event, time, event_id, self.alloc);\n        self.len += 1;\n        let node_ptr: *mut EventNode\u003cT\u003e = \u0026mut *node;\n\n        // From back insert\n        let mut cur: *mut EventNode\u003cT\u003e = \u0026mut *self.tail;\n        loop {\n            // SAFTEY:\n            // There a two cases\n            // 1) cur is head -\u003e since head has Duration::MIN the loop will\n            //    break thus cur is a valid ptr.\n            // 2) cur is not head (maybe tail) -\u003e all such elements are guranteed to have\n            //    valid prev ptrs.\n            // Thus cur will be valid, non-null at the end of the loop.\n            // This loop will terminated if there are no circles in the DLL\n            unsafe {\n                if (*cur).time \u003e node.time {\n                    cur = (*cur).prev;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // SAFTEY: cur is valid after the end of the loop (see aboth)\n        let prev = cur;\n        let next = unsafe { (*cur).next };\n\n        node.prev = prev;\n        node.next = next;\n\n        // SAFTEY:\n        // If the ptr is non-null it is valid,\n        // since nodes are only dropped once they were removed from the DLL.\n        // At removal, they remove ptrs to themselfs from other nodes.\n        if !prev.is_null() {\n            unsafe { (*prev).next = node_ptr }\n        }\n\n        // SAFTEY: see prev\n        if !next.is_null() {\n            unsafe { (*next).prev = node_ptr }\n        }\n\n        // Forget the node to leak the memory.\n        std::mem::forget(node);\n    }\n\n    /// Removes the element with the earliest time from the queue.\n    pub(super) fn pop_min(\u0026mut self) -\u003e Option\u003c(T, Duration)\u003e {\n        let mut node = unsafe { LocalBox::from_raw_in(self.head.next, self.alloc) };\n        if node.next.is_null() {\n            // The node that would have been returned is the tail.\n            // Thus forgett this Box, since the tail is allready owned by self.\n            std::mem::forget(node);\n            None\n        } else {\n            self.len -= 1;\n\n            // The node is not the tail (or the head),\n            // Thus the node has valid ptrs to prev and next.\n            // 1) This head.next will point to a valid node (may be tail)\n            // 2) node.next will be a valid node\n            // 3) node.next.prev will point ot a valid node (head)\n            self.head.next = node.next;\n            unsafe {\n                (*node.next).prev = \u0026mut *self.head;\n            }\n\n            // All references are removed from the DLL thus the node\n            // is only owned by this instance.\n            // Droping the node via into_inner is valid since the only remaining\n            // ref (the NodeHandle) will be invalidated by this operation,\n            // if nessecary\n            Some(EventNode::into_inner(node))\n        }\n    }\n\n    pub(super) fn iter(\u0026self) -\u003e Iter\u003c'_, T\u003e {\n        self.into_iter()\n    }\n\n    #[allow(unused)]\n    pub(super) fn iter_mut(\u0026mut self) -\u003e IterMut\u003c'_, T\u003e {\n        self.into_iter()\n    }\n}\n\nimpl\u003cT\u003e Debug for DualLinkedList\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let head_ptr: *const EventNode\u003cT\u003e = \u0026*self.head;\n        let tail_ptr: *const EventNode\u003cT\u003e = \u0026*self.tail;\n\n        f.debug_struct(\"DLL\")\n            .field(\"head\", \u0026head_ptr)\n            .field(\"tail\", \u0026tail_ptr)\n            .finish()\n    }\n}\n\nimpl\u003cT\u003e Drop for DualLinkedList\u003cT\u003e {\n    fn drop(\u0026mut self) {\n        while self.pop_min().is_some() {}\n    }\n}\n\n// EQ\n\nimpl\u003cT: PartialEq\u003e PartialEq for DualLinkedList\u003cT\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        let mut lhs = self.iter();\n        let mut rhs = other.iter();\n\n        loop {\n            let l = lhs.next();\n            let r = rhs.next();\n            if let Some(l) = l {\n                if let Some(r) = r {\n                    if l.0 != r.0 {\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            } else if r.is_some() {\n                return false;\n            } else {\n                break;\n            }\n        }\n\n        true\n    }\n}\n\nimpl\u003cT: Eq\u003e Eq for DualLinkedList\u003cT\u003e {}\n\n// HASH\n\nimpl\u003cT: Hash\u003e Hash for DualLinkedList\u003cT\u003e {\n    fn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.iter().for_each(|v| v.hash(state));\n    }\n}\n\n// IMPL: DLL Into Iter\n\npub struct Iter\u003c'a, T\u003e {\n    marker: PhantomData\u003c\u0026'a DualLinkedList\u003cT\u003e\u003e,\n    cur: *mut EventNode\u003cT\u003e,\n    alloc: CQueueLLAllocator,\n}\n\nimpl\u003c'a, T\u003e Iterator for Iter\u003c'a, T\u003e {\n    type Item = (\u0026'a T, \u0026'a Duration);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        // SAFTEY:\n        // Will point to a valid node since:\n        // IA) head-\u003enext is a valid node\n        // IS) each time the next node is check to be non-null (thus valid)\n        let cur = unsafe { LocalBox::from_raw_in(self.cur, self.alloc) };\n        let result: Option\u003c(*const T, *const Duration)\u003e = {\n            if cur.next.is_null() {\n                // is tail\n                None\n            } else {\n                self.cur = cur.next;\n                // SAFTEY:\n                // cur is allways valid + now non-tail\n                Some((unsafe { cur.value.as_ref().unwrap_unchecked() }, \u0026cur.time))\n            }\n        };\n        std::mem::forget(cur);\n        result.map(|(v, t)| unsafe { (\u0026*v, \u0026*t) })\n    }\n}\n\nimpl\u003c'a, T\u003e IntoIterator for \u0026'a DualLinkedList\u003cT\u003e {\n    type Item = (\u0026'a T, \u0026'a Duration);\n    type IntoIter = Iter\u003c'a, T\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        Iter {\n            marker: PhantomData,\n            cur: self.head.next,\n            alloc: self.alloc,\n        }\n    }\n}\n\npub struct IterMut\u003c'a, T\u003e {\n    marker: PhantomData\u003c\u0026'a mut DualLinkedList\u003cT\u003e\u003e,\n    cur: *mut EventNode\u003cT\u003e,\n    alloc: CQueueLLAllocator,\n}\n\nimpl\u003c'a, T\u003e Iterator for IterMut\u003c'a, T\u003e {\n    type Item = (\u0026'a mut T, \u0026'a Duration);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        // SAFTEY:\n        // Will point to a valid node since:\n        // IA) head-\u003enext is a valid node\n        // IS) each time the next node is check to be non-null (thus valid)\n        let mut cur = unsafe { LocalBox::from_raw_in(self.cur, self.alloc) };\n        let result: Option\u003c(*mut T, *const Duration)\u003e = {\n            if cur.next.is_null() {\n                // is tail\n                None\n            } else {\n                self.cur = cur.next;\n                // SAFTEY:\n                // cur is allways valid + now non-tail\n                Some((unsafe { cur.value.as_mut().unwrap_unchecked() }, \u0026cur.time))\n            }\n        };\n        std::mem::forget(cur);\n        result.map(|(v, t)| unsafe { (\u0026mut *v, \u0026*t) })\n    }\n}\n\nimpl\u003c'a, T\u003e IntoIterator for \u0026'a mut DualLinkedList\u003cT\u003e {\n    type Item = (\u0026'a mut T, \u0026'a Duration);\n    type IntoIter = IterMut\u003c'a, T\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        IterMut {\n            marker: PhantomData,\n            cur: self.head.next,\n            alloc: self.alloc,\n        }\n    }\n}\n\npub struct IntoIter\u003cT\u003e {\n    dll: DualLinkedList\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Iterator for IntoIter\u003cT\u003e {\n    type Item = (T, Duration);\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.dll.pop_min()\n    }\n}\n\nimpl\u003cT\u003e IntoIterator for DualLinkedList\u003cT\u003e {\n    type Item = (T, Duration);\n    type IntoIter = IntoIter\u003cT\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        IntoIter { dll: self }\n    }\n}\n\n// IMPL: Node\n\nimpl\u003cT\u003e EventNode\u003cT\u003e {\n    pub(super) fn empty(time: Duration, alloc: CQueueLLAllocator) -\u003e LocalBox\u003cEventNode\u003cT\u003e\u003e {\n        LocalBox::new_in(\n            Self {\n                value: None,\n                id: 0,\n                time,\n                prev: std::ptr::null_mut(),\n                next: std::ptr::null_mut(),\n            },\n            alloc,\n        )\n    }\n\n    pub(super) fn new(\n        value: T,\n        time: Duration,\n        id: usize,\n        alloc: CQueueLLAllocator,\n    ) -\u003e LocalBox\u003cEventNode\u003cT\u003e\u003e {\n        LocalBox::new_in(\n            Self {\n                value: Some(value),\n                time,\n                id,\n                prev: std::ptr::null_mut(),\n                next: std::ptr::null_mut(),\n            },\n            alloc,\n        )\n    }\n\n    #[allow(clippy::boxed_local)]\n    fn into_inner(mut this: LocalBox\u003cSelf\u003e) -\u003e (T, Duration) {\n        // SAFTEY:\n        // This function may only be applied to nodes that are\n        // neither head nor tail. Such notes allways contain a value\n        (unsafe { this.value.take().unwrap_unchecked() }, this.time)\n    }\n}\n\nimpl\u003cE\u003e Debug for EventNode\u003cE\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"EventNode\")\n            .field(\"prev\", \u0026self.prev)\n            .field(\"next\", \u0026self.next)\n            .field(\"time\", \u0026self.time)\n            .field(\"value\", \u0026self.value.is_some())\n            .field(\"id\", \u0026self.id)\n            .finish()\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":674905},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":674905},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":674905},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":674905},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":221},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":221},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":167},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3161696},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":6206288},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3044592},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":297380},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":297380},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":297380},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":360660},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":74,"coverable":137},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","stable","mod.rs"],"content":"use std::{collections::VecDeque, marker::PhantomData, ops::Rem, time::Duration};\n\n// mod _alloc;\nmod alloc;\nmod boxed;\nmod linked_list;\n\npub(crate) use alloc::*;\nuse linked_list::DualLinkedList;\n\n/// A calender queue.\n///\n/// This type acts as a sorter for entries of type E\n/// that occure at a given point in time, represented by the\n/// Duration type. This means that the `fetch_next`\n/// method will allways return the entry with the smallest timestamp.\n/// In general, this can be compared to a `BinaryHeap` where the entries\n/// are a tupel (E, Duration) sorted by the Duration.\n///\n/// Note however that this datatype is optimized for use in a discrete\n/// event simulation. Thus is supports O(1) inserts and removals, as\n/// well as O(1) `fetch_next`. Note that this is a amorised analysis\n/// assuming that the parameters are optimal for the given distribution\n/// of event arrival times. Additionaly the `CQueue` does not allow for\n/// the insertion of entries with a timestamp smaller that entries\n/// that was last fetched (or `Duration::ZERO` initally).\n///\n#[derive(Debug)]\npub struct CQueue\u003cE\u003e {\n    #[allow(unused)]\n    pub(crate) alloc: Box\u003cCQueueLLAllocatorInner\u003e,\n\n    // Parameters\n    pub(crate) n: usize,\n    pub(crate) t: Duration,\n    pub(crate) t_nanos: u128,\n\n    // Buckets\n    pub(crate) zero_event_bucket: VecDeque\u003c(E, Duration, usize)\u003e,\n    pub(crate) buckets: Vec\u003cDualLinkedList\u003cE\u003e\u003e,\n\n    pub(crate) head: usize,\n\n    pub(crate) t_current: Duration,\n    pub(crate) t0: Duration,\n    pub(crate) t1: Duration,\n    pub(crate) t_all: u128,\n\n    // Misc\n    pub(crate) event_id: usize,\n    pub(crate) len: usize,\n}\n\n/// A handle that identifies a event.\n#[derive(Debug, PartialEq, Eq, Hash)]\npub struct EventHandle\u003cE\u003e {\n    _phantom: PhantomData\u003cE\u003e,\n    id: usize,\n    time: Duration,\n}\n\nimpl\u003cE\u003e CQueue\u003cE\u003e {\n    /// Returns a String describing the datatype and its parameters.\n    #[must_use]\n    pub fn descriptor(\u0026self) -\u003e String {\n        format!(\"CTimeVDeque({}, {:?})\", self.n, self.t)\n    }\n\n    /// Returns the number of elements in the queue.\n    #[must_use]\n    pub fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    /// Returns the number of element in the subset that is\n    /// manage by the zero-event-time optimization.\n    #[must_use]\n    pub fn len_zero(\u0026self) -\u003e usize {\n        self.zero_event_bucket.len()\n    }\n\n    /// Returns the number of elements in the subset that is\n    /// not managed by the zero-event-time optimization.\n    #[must_use]\n    pub fn len_nonzero(\u0026self) -\u003e usize {\n        self.len() - self.len_zero()\n    }\n\n    /// Indicates whether the queue is empty.\n    #[must_use]\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    #[must_use]\n    pub fn metrics(\u0026self) -\u003e (usize, usize) {\n        let (alloc, total) = self.alloc.metrics();\n        let additional = std::mem::size_of::\u003cSelf\u003e();\n        let additional = additional + std::mem::size_of::\u003c(E, Duration, usize)\u003e() * self.len_zero();\n        (alloc + additional, total + additional)\n    }\n\n    /// Returns the timestamp of the last emitted event.\n    /// This acts as a lower bound to the insertion of new events.\n    #[must_use]\n    pub fn time(\u0026self) -\u003e Duration {\n        self.t_current\n    }\n\n    /// Creates a new parameteriszed `CQueue`.\n    #[must_use]\n    pub fn new(n: usize, t: Duration) -\u003e Self {\n        // essentialy t*n\n        let t_all = t.as_nanos() * n as u128;\n\n        let alloc = Box::new(CQueueLLAllocatorInner::new());\n\n        Self {\n            n,\n            t_nanos: t.as_nanos(),\n            t,\n\n            zero_event_bucket: VecDeque::with_capacity(64),\n            buckets: std::iter::repeat_with(|| DualLinkedList::new(alloc.handle()))\n                .take(n)\n                .collect(),\n            head: 0,\n            t_current: Duration::ZERO,\n\n            t0: Duration::ZERO,\n            t1: t,\n\n            t_all,\n\n            alloc,\n            event_id: 0,\n            len: 0,\n        }\n    }\n\n    ///\n    /// Adds an event to the calenderqueue.\n    ///\n    /// Returns an event handle to cancel the event at will.\n    ///\n    /// # Panics\n    ///\n    /// This funtion panics if the timestamp violates the lower\n    /// bound, defined by the timestamp of the last emitted event.\n    ///\n    pub fn add(\u0026mut self, time: Duration, event: E) -\u003e EventHandle\u003cE\u003e {\n        assert!(\n            time \u003e= self.t_current,\n            \"Cannot add past event to calender queue\"\n        );\n\n        self.len += 1;\n        if time == self.t_current {\n            let id = self.event_id;\n            self.zero_event_bucket.push_back((event, time, id));\n            self.event_id = id.wrapping_add(1);\n\n            EventHandle {\n                _phantom: PhantomData,\n                id,\n                time,\n            }\n        } else {\n            // delta time ?\n\n            let time_mod = time.as_nanos().rem(self.t_all);\n\n            let index = time_mod / self.t_nanos;\n            let index: usize = index as usize;\n            let index = index % self.n;\n\n            // find insert pos\n\n            let id = self.event_id;\n            self.buckets[index].add(event, time, id);\n            self.event_id = id.wrapping_add(1);\n            EventHandle {\n                _phantom: PhantomData,\n                id,\n                time,\n            }\n        }\n    }\n\n    #[allow(clippy::needless_pass_by_value)]\n    pub fn cancel(\u0026mut self, handle: EventHandle\u003cE\u003e) {\n        if handle.time \u003e= self.t_current {\n            if handle.time == self.t_current {\n                if let Some(i) = self\n                    .zero_event_bucket\n                    .iter()\n                    .position(| v| v.2 == handle.id)\n                {\n                    self.zero_event_bucket.remove(i);\n                    self.len -= 1;\n                }\n            } else {\n                let time_mod = handle.time.as_nanos().rem(self.t_all);\n\n                let index = time_mod / self.t_nanos;\n                let index: usize = index as usize;\n                let index = index % self.n;\n\n                if self.buckets[index].cancel(\u0026handle) {\n                    self.len -= 1;\n                }\n            }\n        }\n    }\n\n    ///\n    /// Fetches the smalles event from the calender queue.\n    ///\n    /// # Panics\n    ///\n    /// This function assummes that the queue is not empty.\n    /// If it is this function panics.\n    ///\n    pub fn fetch_next(\u0026mut self) -\u003e (E, Duration) {\n        assert!(!self.is_empty(), \"Cannot fetch from empty queue\");\n\n        if let Some((event, time, _)) = self.zero_event_bucket.pop_front() {\n            self.len -= 1;\n            return (event, time);\n        }\n\n        loop {\n            // Move until full bucket is found.\n            while self.buckets[self.head].is_empty() {\n                self.head = (self.head + 1) % self.n;\n                self.t0 += self.t;\n                self.t1 += self.t;\n            }\n\n            // Bucket with \u003e 0 elements found\n\n            let min = self.buckets[self.head].front_time();\n            if min \u003e self.t1 {\n                self.head = (self.head + 1) % self.n;\n                self.t0 += self.t;\n                self.t1 += self.t;\n                continue;\n            }\n\n            self.t_current = min;\n\n            // SAFTEY:\n            // Bucket is non-empty, thus pop-min returns a valid value.\n            self.len -= 1;\n            return unsafe { self.buckets[self.head].pop_min().unwrap_unchecked() };\n        }\n    }\n}\n\nimpl\u003cE\u003e Default for CQueue\u003cE\u003e {\n    fn default() -\u003e Self {\n        Self::new(1024, Duration::from_millis(5))\n    }\n}\n\nimpl\u003cE\u003e Drop for CQueue\u003cE\u003e {\n    fn drop(\u0026mut self) {\n        // Manually drop the DLL so that the alloc can be dropped last\n        for dll in self.buckets.drain(..) {\n            drop(dll);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":175},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":357172},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":357172},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":356910},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":356910},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":180704},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":119287},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":119287},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":119287},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":119287},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":119287},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2183},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2183},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2183},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":117104},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":119227},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":119227},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":121404},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1187879},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":512974},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":512974},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":512974},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":161931},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":44881},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":44881},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":44881},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":44881},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":117050},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":360847},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":180330},"fn_name":null}],"covered":62,"coverable":76},{"path":["/","Users","mk","Developer","rust","des","des-cqueue","src","stable","tests.rs"],"content":"use std::alloc::Layout;\nuse std::mem::size_of;\n\nuse super::{boxed::*, *};\nuse rand::distributions::Uniform;\nuse rand::rngs::SmallRng;\nuse rand::seq::SliceRandom;\nuse rand::*;\n\n#[test]\nfn alloc_single_page_one_alloc_one_allocator() {\n    // Layout will allways be big enoght for a Free Node\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu32 = LocalBox::new_in(42u32, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu32);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu64 = LocalBox::new_in(42u64, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu64);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu128 = LocalBox::new_in(42u128, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu128);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    // Now layout will grow\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let barray = LocalBox::new_in([42u8; 55], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 56); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let barray = LocalBox::new_in([42u8; 128], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 128); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n    drop(alloc);\n}\n\n#[test]\nfn alloc_single_page_one_alloc_shared_allocator() {\n    // Layout will allways be big enoght for a Free Node\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let bu32 = LocalBox::new_in(42u32, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu32);\n    assert!(alloc.dbg_is_empty());\n\n    let bu64 = LocalBox::new_in(42u64, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu64);\n    assert!(alloc.dbg_is_empty());\n\n    let bu128 = LocalBox::new_in(42u128, alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 16);\n    drop(bu128);\n    assert!(alloc.dbg_is_empty());\n\n    // Now layout will grow\n\n    let barray = LocalBox::new_in([42u8; 55], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 56); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n\n    let barray = LocalBox::new_in([42u8; 128], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 128); // will be aligned for free node, with align 8\n    drop(barray);\n    assert!(alloc.dbg_is_empty());\n}\n\n#[test]\nfn alloc_single_page_alloc_exceeds_page_size() {\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    assert!(alloc\n        .handle()\n        .allocate(Layout::new::\u003c[u8; 8000]\u003e())\n        .is_err())\n    // let _ = Box::new_in([42u8; 8000], alloc.handle());\n}\n\n#[test]\nfn alloc_single_page_list_alloc() {\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let mut boxes = Vec::new();\n    for i in 0..10 {\n        boxes.push(LocalBox::new_in([i as u8; 400], alloc.handle()))\n    }\n\n    // 4000 byte\n    assert_eq!(alloc.dbg_alloc_total(), 4000);\n    for i in 0..10 {\n        assert_eq!(boxes[i][0], i as u8);\n    }\n\n    // Drop the last 2000 byte\n    for _ in 0..5 {\n        boxes.pop();\n    }\n\n    assert_eq!(alloc.dbg_alloc_total(), 2000);\n\n    drop(boxes);\n\n    assert!(alloc.dbg_is_empty());\n}\n\n#[test]\nfn alloc_multiple_pages_same_size_allocation() {\n    #[allow(dead_code)]\n    struct A {\n        bytes: [u8; 32],\n        int: u128,\n        s: String,\n    }\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let mut boxes = Vec::new();\n    for _ in 0..100 {\n        boxes.push(LocalBox::new_in(\n            A {\n                bytes: [0; 32],\n                int: 42,\n                s: String::from(\"Hallow str\"),\n            },\n            alloc.handle(),\n        ));\n    }\n\n    assert!(\n        alloc.dbg_alloc_total() \u003e= size_of::\u003cA\u003e() * 100,\n        \"alloc: {} expected: {} * 100\",\n        alloc.dbg_alloc_total(),\n        size_of::\u003cA\u003e()\n    )\n}\n\n#[test]\nfn alloc_multiple_pages_skip_to_small_elements() {\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let b1 = LocalBox::new_in([0u8; 2500], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 2504); // align\n    assert_eq!(alloc.dbg_pages(), 1);\n\n    // remaining bytes of page 1 were skipped\n    // since elements are asssumed to be 2500 bytes big\n\n    let b2 = LocalBox::new_in([0u8; 128], alloc.handle());\n    assert_eq!(alloc.dbg_alloc_total(), 2504 + 128); // align\n    assert_eq!(alloc.dbg_pages(), 2);\n\n    drop(b1);\n    drop(b2);\n\n    assert_eq!(alloc.dbg_alloc_total(), 0);\n    assert_eq!(alloc.dbg_pages(), 2);\n\n    drop(alloc);\n}\n\n#[test]\nfn alloc_16_byteboxes() {\n    struct Word {\n        _opaque: [u8; 16],\n    }\n\n    impl Word {\n        fn new() -\u003e Self {\n            Self { _opaque: [42; 16] }\n        }\n    }\n\n    assert_eq!(std::mem::size_of::\u003cWord\u003e(), 16);\n\n    let alloc = CQueueLLAllocatorInner::with_page_size(4096);\n    let mut list = Vec::new();\n    for _ in 1..10 {\n        let b = LocalBox::new_in(Word::new(), alloc.handle());\n        list.push(b)\n    }\n    alloc.info();\n\n    list.remove(2);\n\n    alloc.info();\n\n    drop(list);\n\n    alloc.info();\n\n    for _ in 1..10 {\n        let b = LocalBox::new_in(Word::new(), alloc.handle());\n        std::mem::forget(b);\n    }\n\n    alloc.info();\n}\n\n#[test]\nfn cqueue_simple_event_order_nonoverlapping() {\n    let mut cqueue = CQueue::new(100, Duration::from_secs(1));\n    let events = (0..=100).map(|e| (e, Duration::from_secs(e)));\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    assert_eq!(cqueue.len(), 101);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        println!(\"Itr: {}\", c);\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_simple_event_order_wrap_around() {\n    // This test is identicall to 'cqueue_simple_event_order_nonoverlapping'\n    // but with other config options for the cqueue.\n    let mut cqueue = CQueue::new(20, Duration::from_secs(1));\n    let events = (0..=100).map(|e| (e, Duration::from_secs(e)));\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_simple_event_out_of_order_nonoverlapping() {\n    let mut cqueue = CQueue::new(100, Duration::from_secs(1));\n    let mut events = (0..=100)\n        .map(|e| (e, Duration::from_secs(e)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    let mut rng = SmallRng::seed_from_u64(123);\n    events.shuffle(\u0026mut rng);\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    assert_eq!(cqueue.len(), 101);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        println!(\"Itr: {}\", c);\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_simple_event_out_of_order_wrap_around() {\n    // This test is identicall to 'cqueue_simple_event_order_nonoverlapping'\n    // but with other config options for the cqueue.\n    let mut cqueue = CQueue::new(20, Duration::from_secs(1));\n    let mut events = (0..=100)\n        .map(|e| (e, Duration::from_secs(e)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    let mut rng = SmallRng::seed_from_u64(123);\n    events.shuffle(\u0026mut rng);\n    for (event, time) in events {\n        cqueue.add(time, event);\n    }\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let (event, time) = cqueue.fetch_next();\n        assert_eq!(c, event);\n        assert_eq!(time.as_secs(), c);\n        c += 1;\n    }\n    assert_eq!(c, 101);\n    assert_eq!(cqueue.len(), 0);\n}\n\n#[test]\nfn cqueue_zero_bucket_in_out() {\n    let mut cqueue = CQueue::new(10, Duration::new(1, 0));\n    for i in 0..10 {\n        cqueue.add(Duration::ZERO, i);\n    }\n    assert_eq!(cqueue.len_zero(), 10);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 2 - without forwarding to the current event\n\n    for i in 0..10 {\n        cqueue.add(Duration::new(9, 0), i);\n    }\n    assert_eq!(cqueue.len_zero(), 0);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 3: allready forwared\n\n    for i in 0..10 {\n        cqueue.add(Duration::new(9, 0), i);\n    }\n    assert_eq!(cqueue.len_zero(), 10);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n}\n\n#[test]\nfn cqueue_zero_bucket_cancel() {\n    let mut cqueue = CQueue::new(10, Duration::new(1, 0));\n    let mut handles = (0..10)\n        .map(|i| cqueue.add(Duration::ZERO, i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len_zero(), 10);\n\n    // remove element 6\n    cqueue.cancel(handles.remove(6));\n    assert_eq!(cqueue.len(), 9);\n    assert_eq!(cqueue.len_zero(), 9);\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        if c == 6 {\n            c += 1;\n            continue;\n        }\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 2 - without forwarding to the current event\n\n    let mut handles = (0..10)\n        .map(|i| cqueue.add(Duration::new(9, 0), i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len_zero(), 0);\n\n    cqueue.cancel(handles.remove(3));\n\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        if c == 3 {\n            c += 1;\n            continue;\n        }\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n\n    // STAGE 3: allready forwared\n\n    let mut handles = (0..10)\n        .map(|i| cqueue.add(Duration::new(9, 0), i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len_zero(), 10);\n\n    cqueue.cancel(handles.remove(0));\n\n    let mut c = 1;\n    while !cqueue.is_empty() {\n        // if c == 0 { ... }\n        assert_eq!(cqueue.len(), 10 - c);\n        let (e, _) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        c += 1;\n    }\n    assert_eq!(c, 10);\n}\n\n#[test]\nfn cqueue_out_of_order_with_overlaps() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut delay = Duration::new(1, 0);\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut events = (0..200)\n        .map(|v| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.1, 1.0)));\n            (v, delay)\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    events.shuffle(\u0026mut rng);\n    let _ = events\n        .into_iter()\n        .map(|(event, time)| cqueue.add(time, event))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut last_time = Duration::ZERO;\n    while !cqueue.is_empty() {\n        assert_eq!(cqueue.len(), 200 - c);\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e last_time);\n\n        last_time = t;\n        c += 1;\n    }\n    assert_eq!(c, 200);\n}\n\n#[test]\nfn cqueue_out_of_order_with_cancel() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut delay = Duration::new(1, 0);\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut events = (0..200)\n        .map(|v| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.1, 1.0)));\n            (v, delay, rng.sample(Uniform::new(1, 10)) == 8)\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    events.shuffle(\u0026mut rng);\n    let handles = events\n        .into_iter()\n        .map(|(event, time, cancel)| (cqueue.add(time, event), cancel, event))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let canceled = handles\n        .into_iter()\n        .filter_map(|(h, flg, event)| {\n            if flg {\n                cqueue.cancel(h);\n                Some(event)\n            } else {\n                None\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut last_time = Duration::ZERO;\n    while !cqueue.is_empty() {\n        if canceled.contains(\u0026c) {\n            c += 1;\n            continue;\n        }\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e last_time);\n\n        last_time = t;\n        c += 1;\n    }\n    // The 200th event was canceld thus the loop broke, event though one\n    // iteration was still due (to be simpliar to previous test cases)\n    assert_eq!(c, 199);\n}\n\n#[test]\nfn cqueue_out_of_order_boxes_overlapping() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut delay = Duration::new(1, 0);\n    let mut s = 0;\n    let mut event_boxes = (0..100)\n        .map(|_| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.0, 1.0)));\n            let n = rng.sample(Uniform::new(1, 4));\n            let old_s = s;\n            s += n;\n            (delay, old_s, n)\n        })\n        // .map(|(t, from, n)| (from..(from + n)).map(|i| (i, t)))\n        // .flatten()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    event_boxes.shuffle(\u0026mut rng);\n    let _ = event_boxes\n        .into_iter()\n        .map(|(t, from, n)| (from..(from + n)).map(move |i| (i, t)))\n        .flatten()\n        .map(|(e, t)| cqueue.add(t, e))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut lt = Duration::ZERO;\n    while !cqueue.is_empty() {\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e= lt);\n        c += 1;\n        lt = t;\n    }\n}\n\n#[test]\nfn cqueue_out_of_order_boxes_with_cancel() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut rng = SmallRng::seed_from_u64(123);\n    let mut delay = Duration::new(1, 0);\n    let mut s = 0;\n    let mut event_boxes = (0..100)\n        .map(|_| {\n            delay += Duration::from_secs_f64(rng.sample(Uniform::new(0.0, 1.0)));\n            let n = rng.sample(Uniform::new(1, 4));\n            let old_s = s;\n            s += n;\n            (delay, old_s, n)\n        })\n        // .map(|(t, from, n)| (from..(from + n)).map(|i| (i, t)))\n        // .flatten()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    event_boxes.shuffle(\u0026mut rng);\n    let handles = event_boxes\n        .into_iter()\n        .map(|(t, from, n)| (from..(from + n)).map(move |i| (i, t)))\n        .flatten()\n        .map(|(e, t)| (cqueue.add(t, e), e, rng.sample(Uniform::new(1, 10)) == 2))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    // Cancel events\n    let cancelled = handles\n        .into_iter()\n        .filter_map(|(h, e, flg)| {\n            if flg {\n                cqueue.cancel(h);\n                Some(e)\n            } else {\n                None\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut c = 0;\n    let mut lt = Duration::ZERO;\n    while !cqueue.is_empty() {\n        if cancelled.contains(\u0026c) {\n            c += 1;\n            continue;\n        }\n        let (e, t) = cqueue.fetch_next();\n        assert_eq!(e, c);\n        assert!(t \u003e= lt);\n        c += 1;\n        lt = t;\n    }\n}\n\n#[test]\nfn cqueue_cancel_validity() {\n    let mut cqueue = CQueue::new(32, Duration::new(1, 0));\n    let mut handles = (0..10)\n        .map(|i| Some(cqueue.add(Duration::from_secs(i), i)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len(), 10);\n\n    // Succesful cancel 0, 9\n    cqueue.cancel(handles[0].take().unwrap());\n    cqueue.cancel(handles[9].take().unwrap());\n\n    assert_eq!(cqueue.len(), 8);\n\n    // Cur [1,2,3,4,5,6,7,8]\n    for i in 1..4 {\n        let event = cqueue.fetch_next();\n        assert_eq!(event.0, i);\n    }\n    assert_eq!(cqueue.len(), 5);\n\n    // Cur [4,5,6,7,8]\n    cqueue.cancel(handles[2].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    cqueue.cancel(handles[3].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    // Suc again\n    cqueue.cancel(handles[8].take().unwrap());\n    assert_eq!(cqueue.len(), 4);\n\n    // Cur [4,5,6,7]\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let _ = cqueue.fetch_next();\n        c += 1;\n    }\n\n    assert_eq!(c, 4)\n}\n\n#[test]\nfn cqueue_cancel_validity_2() {\n    let mut cqueue = CQueue::new(10, Duration::new(3, 0));\n    let mut handles = (0..10)\n        .map(|i| Some(cqueue.add(Duration::from_secs(i), i)))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(cqueue.len(), 10);\n\n    // Succesful cancel 0, 9\n    cqueue.cancel(handles[0].take().unwrap());\n    cqueue.cancel(handles[9].take().unwrap());\n\n    assert_eq!(cqueue.len(), 8);\n\n    // Cur [1,2,3,4,5,6,7,8]\n    for i in 1..4 {\n        let event = cqueue.fetch_next();\n        assert_eq!(event.0, i);\n    }\n    assert_eq!(cqueue.len(), 5);\n\n    // Cur [4,5,6,7,8]\n    cqueue.cancel(handles[2].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    cqueue.cancel(handles[3].take().unwrap());\n    assert_eq!(cqueue.len(), 5);\n\n    // Suc again\n    cqueue.cancel(handles[8].take().unwrap());\n    assert_eq!(cqueue.len(), 4);\n\n    // Cur [4,5,6,7]\n    let mut c = 0;\n    while !cqueue.is_empty() {\n        let _ = cqueue.fetch_next();\n        c += 1;\n    }\n\n    assert_eq!(c, 4)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-macros","src","lib.rs"],"content":"#![warn(clippy::pedantic)]\n//! A crate for extending a DES simulation with NDL definitions.\n//!\n//! This crate provide macros for applieing NDL module definitions to\n//! rust structs to automate the module setup process.\n\nuse proc_macro::{self, TokenStream};\nuse proc_macro_error::proc_macro_error;\nuse syn::{parse_macro_input, DeriveInput};\n\n///\n/// A macro for deriving the `MessageBody` trait.\n///\n/// This macro requires that all subtypes of the applied type\n/// implement `MessageBody` themselfs.\n#[proc_macro_derive(MessageBody)]\n#[proc_macro_error]\npub fn derive_message_body(input: TokenStream) -\u003e TokenStream {\n    let DeriveInput {\n        ident,\n        data,\n        generics,\n        ..\n    } = parse_macro_input!(input);\n\n    match des_macros_core::message_body::derive_impl(ident, data, generics) {\n        Ok(ts) =\u003e ts.into(),\n        Err(e) =\u003e e.abort(),\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","Users","mk","Developer","rust","des","des-macros-core","src","lib.rs"],"content":"#![warn(clippy::pedantic)]\n//! Internal implmentations of proc macros.\n\npub mod message_body;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-macros-core","src","message_body.rs"],"content":"use proc_macro2::Span as Span2;\nuse proc_macro2::TokenStream;\nuse proc_macro_error::{Diagnostic, Level};\nuse quote::quote;\nuse quote::ToTokens;\nuse syn::token::Plus;\nuse syn::{parse2, Data, Fields, GenericParam, Generics, Ident, Index, TypeParamBound};\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, Diagnostic\u003e;\n\nstruct WrappedTokenStream(TokenStream);\n\nimpl ToTokens for WrappedTokenStream {\n    fn to_tokens(\u0026self, tokens: \u0026mut proc_macro2::TokenStream) {\n        tokens.extend::\u003cproc_macro2::TokenStream\u003e(self.0.clone());\n    }\n}\n\n/// Returns the derived token stream.\n///\n/// # Errors\n///\n/// Internal.\n///\n/// # Panics\n///\n/// Internal.\n#[allow(clippy::needless_pass_by_value, clippy::too_many_lines)]\npub fn derive_impl(ident: Ident, data: Data, generics: Generics) -\u003e Result\u003cTokenStream\u003e {\n    match data {\n        Data::Struct(data_struct) =\u003e {\n            let impl_ts = match data_struct.fields {\n                Fields::Named(named_fields) =\u003e {\n                    let mut ts = TokenStream::new();\n                    for field in named_fields.named {\n                        let ty = field.ty;\n                        let field_ident = field.ident.unwrap();\n\n                        ts.extend(quote! {\n                            \u003c#ty as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.#field_ident) +\n                        });\n                    }\n                    ts\n                }\n                Fields::Unnamed(unnamed_fields) =\u003e {\n                    // Does this case ever happen\n                    let mut ts = TokenStream::new();\n\n                    for (i, field) in unnamed_fields.unnamed.into_iter().enumerate() {\n                        let ty = field.ty;\n                        let field_ident = Index::from(i);\n\n                        ts.extend(quote! {\n                            \u003c#ty as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.#field_ident) +\n                        });\n                    }\n\n                    ts\n                }\n                Fields::Unit =\u003e TokenStream::new(),\n            };\n\n            let generics = generate_impl_generics(generics);\n            let (impl_generics, type_generics, where_clause) = generics.split_for_impl();\n\n            let wrapped = WrappedTokenStream(impl_ts);\n            Ok(quote! {\n                impl #impl_generics ::des::net::message::MessageBody for #ident #type_generics #where_clause {\n                    fn byte_len(\u0026self) -\u003e usize {\n                        #wrapped 0\n                    }\n                }\n            })\n        }\n        Data::Enum(data_enum) =\u003e {\n            let mut gts = TokenStream::new();\n            if data_enum.variants.is_empty() {\n                return Ok(quote! {\n                    impl ::des::net::message::MessageBody for #ident {\n                        fn byte_len(\u0026self) -\u003e usize { 0 }\n                    }\n                });\n            }\n\n            for variant in data_enum.variants {\n                let variant_ident = variant.ident;\n\n                let ts = match variant.fields {\n                    Fields::Named(named_fields) =\u003e {\n                        let mut prop_ts = TokenStream::new();\n                        let mut ts = TokenStream::new();\n\n                        for field in named_fields.named {\n                            let ty = field.ty;\n                            let field_ident = field.ident.unwrap();\n\n                            prop_ts.extend(quote! { ref #field_ident, });\n                            ts.extend(quote! {\n                                \u003c#ty as ::des::net::message::MessageBody\u003e::byte_len(#field_ident) +\n                            });\n                        }\n\n                        let wrapped = WrappedTokenStream(ts);\n                        quote! {\n                            #ident::#variant_ident { #prop_ts } =\u003e #wrapped 0\n                        }\n                    }\n                    Fields::Unnamed(unnamed_fields) =\u003e {\n                        // Does this case ever happen\n                        let mut property_ts = TokenStream::new();\n                        let mut ts = TokenStream::new();\n\n                        for (i, field) in unnamed_fields.unnamed.into_iter().enumerate() {\n                            let ty = field.ty;\n                            let field_ident = Ident::new(\u0026format!(\"v{i}\"), Span2::call_site());\n\n                            property_ts.extend(quote! { #field_ident,  });\n                            ts.extend(quote! {\n                                \u003c#ty as ::des::net::message::MessageBody\u003e::byte_len(#field_ident) +\n                            });\n                        }\n\n                        let wrapped = WrappedTokenStream(ts);\n                        quote! { #ident::#variant_ident(#property_ts) =\u003e #wrapped 0 }\n                    }\n                    Fields::Unit =\u003e {\n                        quote! {\n                            #ident::#variant_ident =\u003e 0\n                        }\n                    }\n                };\n\n                gts.extend(quote! {\n                    #ts,\n                });\n            }\n\n            let generics = generate_impl_generics(generics);\n            let (impl_generics, type_generics, where_clause) = generics.split_for_impl();\n\n            Ok(quote! {\n                impl #impl_generics ::des::net::message::MessageBody for #ident #type_generics #where_clause {\n                    fn byte_len(\u0026self) -\u003e usize {\n                        match self {\n                            #gts\n                        }\n                    }\n                }\n            })\n        }\n        Data::Union(_) =\u003e Err(Diagnostic::new(\n            Level::Error,\n            \"#[derive(MessageBody)] -- Macro does not support unions\".into(),\n        )),\n    }\n}\n\nfn generate_impl_generics(mut generics: Generics) -\u003e Generics {\n    for param in \u0026mut generics.params {\n        if let GenericParam::Type(param) = param {\n            if !param.bounds.trailing_punct() \u0026\u0026 !param.bounds.is_empty() {\n                param.bounds.push_punct(Plus {\n                    spans: [proc_macro2::Span::call_site()],\n                });\n            }\n\n            let input = quote::quote! { ::des::net::message::MessageBody };\n            param\n                .bounds\n                .push_value(TypeParamBound::Trait(parse2(input).unwrap()));\n        }\n    }\n\n    generics\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":18},"fn_name":null}],"covered":71,"coverable":77},{"path":["/","Users","mk","Developer","rust","des","des-macros-core","tests","message_body.rs"],"content":"use quote::quote;\nuse syn::{parse2, DeriveInput};\n\n#[test]\nfn struct_unit() {\n    let input = quote! {\n        struct Input;\n    };\n\n    let Ok(DeriveInput { ident, data, generics, .. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl ::des::net::message::MessageBody for Input {\n                fn byte_len(\u0026self) -\u003e usize {\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_named() {\n    let input = quote! {\n        struct Input {\n            a: u32,\n            b: Vec\u003cu8\u003e,\n            c: ()\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics, .. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl ::des::net::message::MessageBody for Input {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.a) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.b) +\n                    \u003c() as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.c) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_named_generic_nonbounded() {\n    let input = quote! {\n        struct Input\u003cT\u003e {\n            a: u32,\n            b: Vec\u003cu8\u003e,\n            c: T\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.a) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.b) +\n                    \u003cT as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.c) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_named_generic_bounded() {\n    let input = quote! {\n        struct Input\u003cT: Copy + Eq\u003e {\n            a: u32,\n            b: Vec\u003cu8\u003e,\n            c: T\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: Copy + Eq + ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.a) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.b) +\n                    \u003cT as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.c) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_named_generic_where_clause() {\n    let input = quote! {\n        struct Input\u003cT\u003e where T: Copy + std::hash::Hash {\n            a: u32,\n            b: Vec\u003cu8\u003e,\n            c: T\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e\n            where T: Copy + std::hash::Hash {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.a) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.b) +\n                    \u003cT as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.c) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_unnamed() {\n    let input = quote! {\n        struct Input(u32, Vec\u003cu8\u003e, ());\n    };\n\n    let Ok(DeriveInput { ident, data, generics, .. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl ::des::net::message::MessageBody for Input {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.0) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.1) +\n                    \u003c() as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.2) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_unnamed_generic_nonbounded() {\n    let input = quote! {\n        struct Input\u003cT\u003e(u32, Vec\u003cu8\u003e, T);\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.0) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.1) +\n                    \u003cT as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.2) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_unnamed_generic_bounded() {\n    let input = quote! {\n        struct Input\u003cT: Copy + Eq\u003e(u32, Vec\u003cu8\u003e, T);\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: Copy + Eq + ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.0) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.1) +\n                    \u003cT as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.2) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn struct_unnamed_generic_where_clause() {\n    let input = quote! {\n        struct Input\u003cT\u003e(u32, Vec\u003cu8\u003e, T) where T: Copy + std::hash::Hash;\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e\n            where T: Copy + std::hash::Hash {\n                fn byte_len(\u0026self) -\u003e usize {\n                    \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.0) +\n                    \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.1) +\n                    \u003cT as ::des::net::message::MessageBody\u003e::byte_len(\u0026self.2) +\n                    0\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn enum_unit_fields() {\n    let input = quote! {\n        enum Input {\n            A,\n            B,\n            CVariant,\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl ::des::net::message::MessageBody for Input {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A =\u003e 0,\n                          Input::B =\u003e 0,\n                          Input::CVariant =\u003e 0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn enum_unnamed_fields() {\n    let input = quote! {\n        enum Input {\n            A(u32),\n            B(Vec\u003cu8\u003e),\n            CVariant(f64, f32),\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl ::des::net::message::MessageBody for Input {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A(v0,) =\u003e \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::B(v0,) =\u003e \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::CVariant(v0, v1, ) =\u003e \n                            \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(v0) +\n                            \u003cf32 as ::des::net::message::MessageBody\u003e::byte_len(v1) + \n                            0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n\n#[test]\nfn enum_unnamed_fields_generic_unbounded() {\n    let input = quote! {\n        enum Input\u003cT\u003e {\n            A(T),\n            B(Vec\u003cu8\u003e),\n            CVariant(f64, T),\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A(v0,) =\u003e \u003cT as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::B(v0,) =\u003e \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::CVariant(v0, v1, ) =\u003e \n                            \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(v0) +\n                            \u003cT as ::des::net::message::MessageBody\u003e::byte_len(v1) + \n                            0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n\n#[test]\nfn enum_unnamed_fields_generic_bounded() {\n    let input = quote! {\n        enum Input\u003cT: Copy\u003e {\n            A(T),\n            B(Vec\u003cu8\u003e),\n            CVariant(f64, T),\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: Copy + ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A(v0,) =\u003e \u003cT as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::B(v0,) =\u003e \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::CVariant(v0, v1, ) =\u003e \n                            \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(v0) +\n                            \u003cT as ::des::net::message::MessageBody\u003e::byte_len(v1) + \n                            0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn enum_unnamed_fields_generic_where_clause() {\n    let input = quote! {\n        enum Input\u003cT\u003e where T: std::hash::Hash {\n            A(T),\n            B(Vec\u003cu8\u003e),\n            CVariant(f64, T),\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e \n             where T: std::hash::Hash {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A(v0,) =\u003e \u003cT as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::B(v0,) =\u003e \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(v0) + 0,\n                          Input::CVariant(v0, v1, ) =\u003e \n                            \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(v0) +\n                            \u003cT as ::des::net::message::MessageBody\u003e::byte_len(v1) + \n                            0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n// \n\n#[test]\nfn enum_named_fields() {\n    let input = quote! {\n        enum Input {\n            A { x: u32},\n            B { y: Vec\u003cu8\u003e, z: f64},\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl ::des::net::message::MessageBody for Input {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A { ref x, } =\u003e \u003cu32 as ::des::net::message::MessageBody\u003e::byte_len(x) + 0,\n                          Input::B { ref y, ref z, } =\u003e \n                          \u003cVec\u003cu8\u003e as ::des::net::message::MessageBody\u003e::byte_len(y) +\n                          \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(z) + \n                          0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn enum_named_fields_generic_unbounded() {\n    let input = quote! {\n        enum Input\u003cT\u003e {\n            A { x: T },\n            B { y: Vec\u003cT\u003e, z: f64},\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A { ref x, } =\u003e \u003cT as ::des::net::message::MessageBody\u003e::byte_len(x) + 0,\n                          Input::B { ref y, ref z, } =\u003e \n                          \u003cVec\u003cT\u003e as ::des::net::message::MessageBody\u003e::byte_len(y) +\n                          \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(z) + \n                          0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn enum_named_fields_generic_bounded() {\n    let input = quote! {\n        enum Input\u003cT: Copy\u003e {\n            A { x: T },\n            B { y: Vec\u003cT\u003e, z: f64},\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: Copy + ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A { ref x, } =\u003e \u003cT as ::des::net::message::MessageBody\u003e::byte_len(x) + 0,\n                          Input::B { ref y, ref z, } =\u003e \n                          \u003cVec\u003cT\u003e as ::des::net::message::MessageBody\u003e::byte_len(y) +\n                          \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(z) + \n                          0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}\n\n#[test]\nfn enum_named_fields_generic_where_clause() {\n    let input = quote! {\n        enum Input\u003cT\u003e where T: Copy {\n            A { x: T },\n            B { y: Vec\u003cT\u003e, z: f64},\n        }\n    };\n\n    let Ok(DeriveInput { ident, data, generics ,.. }) = parse2(input) else {\n        panic!(\"Failed to parse input steam\")\n    };\n    let Ok(output) = des_macros_core::message_body::derive_impl(ident, data, generics) else {\n        panic!(\"Failed with diagnostic\")\n    };\n\n    assert_eq!(\n        output.to_string(),\n        quote! {\n            impl\u003cT: ::des::net::message::MessageBody\u003e ::des::net::message::MessageBody for Input\u003cT\u003e where T: Copy {\n                fn byte_len(\u0026self) -\u003e usize {\n                    match self {\n                          Input::A { ref x, } =\u003e \u003cT as ::des::net::message::MessageBody\u003e::byte_len(x) + 0,\n                          Input::B { ref y, ref z, } =\u003e \n                          \u003cVec\u003cT\u003e as ::des::net::message::MessageBody\u003e::byte_len(y) +\n                          \u003cf64 as ::des::net::message::MessageBody\u003e::byte_len(z) + \n                          0,\n                    }\n                }\n            }\n        }\n        .to_string()\n    );\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","cluster.rs"],"content":"use std::fmt;\n\nuse super::{Delimited, Lit};\nuse crate::{\n    ast::{parse::*, Delimiter, TokenTree},\n    error::*,\n    resource::Span,\n};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ClusterDefinition {\n    pub span: Span,\n    pub lit: Lit,\n}\n\nimpl fmt::Display for ClusterDefinition {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"[{}]\", self.lit.kind)\n    }\n}\n\nimpl Spanned for ClusterDefinition {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\nimpl Parse for Option\u003cClusterDefinition\u003e {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let Some(peek) = input.ts.peek() else {\n            return Ok(None);\n        };\n        let TokenTree::Delimited(_, delim, _) = peek else {\n            return Ok(None);\n        };\n        if *delim == Delimiter::Bracket {\n            Ok(Some(ClusterDefinition::parse(input)?))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\nimpl Parse for ClusterDefinition {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let def = Delimited::\u003cLit\u003e::parse_from(Delimiter::Bracket, input)?;\n        Ok(ClusterDefinition {\n            lit: def.inner,\n            span: Span::fromto(def.delim_span.open, def.delim_span.close),\n        })\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1494},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2869},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":260},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1115},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":260},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":520},"fn_name":null}],"covered":12,"coverable":13},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","delim.rs"],"content":"use crate::{\n    ast::{parse::*, DelimSpan, Delimiter, TokenTree},\n    error::*,\n    Span,\n};\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Delimited\u003cT\u003e {\n    pub delim: Delimiter,\n    pub delim_span: DelimSpan,\n    pub inner: T,\n}\n\nimpl\u003cT\u003e Spanned for Delimited\u003cT\u003e {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(self.delim_span.open, self.delim_span.close)\n    }\n}\n\nimpl\u003cT: Parse\u003e Delimited\u003cT\u003e {\n    pub fn parse_from(delim: Delimiter, input: ParseStream\u003c'_\u003e) -\u003e Result\u003cDelimited\u003cT\u003e\u003e {\n        let Some(peek) = input.ts.peek() else {\n            return Err(Error::new(ErrorKind::ExpectedDelimited, \"expected delimited sequence, found EOF\").spanned(input.ts.last_span()));\n        };\n\n        let (span, d) = match peek {\n            TokenTree::Delimited(span, d, _) =\u003e (span, d),\n            TokenTree::Token(token, _) =\u003e {\n                return Err(Error::new(\n                    ErrorKind::ExpectedDelimited,\n                    format!(\n                        \"expected delimited sequence, found {}\",\n                        token.kind.token_kind_err_output()\n                    ),\n                )\n                .spanned(peek.span()));\n            }\n        };\n\n        if *d == delim {\n            let substream = input.substream().unwrap();\n            input.ts.bump();\n            Ok(Self {\n                delim: *d,\n                delim_span: *span,\n                inner: T::parse(\u0026substream)?,\n            })\n        } else {\n            Err(Error::new(\n                ErrorKind::UnexpectedDelim,\n                format!(\"expected delimited sequence '{delim}', found delimited sequence '{d}'\"),\n            )\n            .spanned(Span::fromto(span.open, span.close)))\n        }\n    }\n\n    pub fn parse_option_from(delim: Delimiter, input: ParseStream\u003c'_\u003e) -\u003e Result\u003cOption\u003cSelf\u003e\u003e {\n        let peek = input.ts.peek();\n        if let Some(TokenTree::Delimited(_, d, _)) = peek {\n            if delim == *d {\n                Ok(Some(Self::parse_from(delim, input)?))\n            } else {\n                Ok(None)\n            }\n        } else {\n            Ok(None)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        ast::{Ident, Lit, TokenStream},\n        resource::SourceMap,\n    };\n\n    #[test]\n    fn success_single_token_delimited() {\n        // used to test all kind of delimiters\n\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"{ ident }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = Delimited::\u003cIdent\u003e::parse_from(Delimiter::Brace, \u0026buf).unwrap();\n        assert_eq!(item.delim, Delimiter::Brace);\n        assert_eq!(item.inner, \"ident\");\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"(ident)\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = Delimited::\u003cIdent\u003e::parse_from(Delimiter::Parenthesis, \u0026buf).unwrap();\n        assert_eq!(item.delim, Delimiter::Parenthesis);\n        assert_eq!(item.inner, \"ident\");\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"[ident]\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = Delimited::\u003cIdent\u003e::parse_from(Delimiter::Bracket, \u0026buf).unwrap();\n        assert_eq!(item.delim, Delimiter::Bracket);\n        assert_eq!(item.inner, \"ident\");\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"[123]\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = Delimited::\u003cLit\u003e::parse_from(Delimiter::Bracket, \u0026buf).unwrap();\n        assert_eq!(item.delim, Delimiter::Bracket);\n        assert_eq!(format!(\"{}\", item.inner.kind), \"123\");\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1934},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":3862},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1904},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1941},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":437},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":353},"fn_name":null}],"covered":29,"coverable":32},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","eitheror.rs"],"content":"use crate::{ast::parse::*, error::Result};\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum EitherOr\u003cE, O\u003e {\n    Either(E),\n    Or(O),\n}\n\nimpl\u003cE, O\u003e Spanned for EitherOr\u003cE, O\u003e\nwhere\n    E: Spanned,\n    O: Spanned,\n{\n    fn span(\u0026self) -\u003e crate::Span {\n        match self {\n            EitherOr::Either(either) =\u003e either.span(),\n            EitherOr::Or(or) =\u003e or.span(),\n        }\n    }\n}\n\nimpl\u003cE, O\u003e Parse for EitherOr\u003cE, O\u003e\nwhere\n    E: Parse,\n    O: Parse,\n{\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let old = input.ts.state();\n        match E::parse(input) {\n            Ok(either) =\u003e Ok(EitherOr::Either(either)),\n            Err(_) =\u003e {\n                input.ts.set_state(old);\n                let or = O::parse(input)?;\n                Ok(EitherOr::Or(or))\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::{Comma, Ident, Joined, Lit, Slash, TokenStream};\n    use crate::SourceMap;\n\n    use super::*;\n\n    #[test]\n    fn single_token() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"ident\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = EitherOr::\u003cIdent, Lit\u003e::parse(\u0026buf).unwrap();\n        assert!(matches!(item, EitherOr::Either(_)));\n        assert!(buf.ts.is_empty());\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"123\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = EitherOr::\u003cIdent, Lit\u003e::parse(\u0026buf).unwrap();\n        assert!(matches!(item, EitherOr::Or(_)));\n        assert!(buf.ts.is_empty());\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"@annot\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _item = EitherOr::\u003cIdent, Lit\u003e::parse(\u0026buf).unwrap_err();\n    }\n\n    #[test]\n    fn multiple_token_reset() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"ident/subident\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = EitherOr::\u003cJoined\u003cIdent, Slash\u003e, Lit\u003e::parse(\u0026buf).unwrap();\n        assert!(matches!(item, EitherOr::Either(_)));\n        assert!(buf.ts.is_empty(), \"remaining token: {:#?}..\", buf.ts.peek());\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"123\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = EitherOr::\u003cJoined\u003cIdent, Slash\u003e, Lit\u003e::parse(\u0026buf).unwrap();\n        assert!(matches!(item, EitherOr::Or(_)));\n        assert!(buf.ts.is_empty(), \"remaining token: {:#?}..\", buf.ts.peek());\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"ident/subident\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = EitherOr::\u003cJoined\u003cIdent, Slash\u003e, Lit\u003e::parse(\u0026buf).unwrap();\n        assert!(matches!(item, EitherOr::Either(_)));\n        assert!(buf.ts.is_empty(), \"remaining token: {:#?}..\", buf.ts.peek());\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"123/+\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = EitherOr::\u003cJoined\u003cLit, Slash\u003e, Lit\u003e::parse(\u0026buf).unwrap();\n        assert!(matches!(item, EitherOr::Or(_)));\n        assert!(!buf.ts.is_empty());\n    }\n\n    #[test]\n    fn joined() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"ident, odent, 123, mudent\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let item = Joined::\u003cEitherOr\u003cIdent, Lit\u003e, Comma\u003e::parse(\u0026buf).unwrap();\n        // assert!(matches!(item, EitherOr::Either(_)));\n        assert_eq!(item.len(), 4);\n        assert!(buf.ts.is_empty(), \"remaining token: {:#?}..\", buf.ts.peek());\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":162},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":101},"fn_name":null}],"covered":7,"coverable":12},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","joined.rs"],"content":"use crate::{ast::parse::*, error::Result, Span};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Joined\u003cT, P\u003e {\n    items: Vec\u003c(T, P)\u003e,\n    last: Box\u003cT\u003e,\n}\n\nimpl\u003cT, P\u003e Joined\u003cT, P\u003e {\n    pub fn len(\u0026self) -\u003e usize {\n        self.items.len() + 1\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        false\n    }\n\n    pub fn iter(\u0026self) -\u003e JoinedIter\u003c'_, T, P\u003e {\n        JoinedIter {\n            joined: self,\n            idx: 0,\n        }\n    }\n}\n\npub struct JoinedIter\u003c'a, T, P\u003e {\n    joined: \u0026'a Joined\u003cT, P\u003e,\n    idx: usize,\n}\n\nimpl\u003c'a, T, P\u003e Iterator for JoinedIter\u003c'a, T, P\u003e {\n    type Item = \u0026'a T;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        use std::cmp::Ordering::*;\n        match self.idx.cmp(\u0026self.joined.items.len()) {\n            Less =\u003e {\n                self.idx += 1;\n                Some(\u0026self.joined.items[self.idx - 1].0)\n            }\n            Equal =\u003e {\n                self.idx += 1;\n                Some(\u0026self.joined.last)\n            }\n            Greater =\u003e None,\n        }\n    }\n}\n\nimpl\u003cT, P\u003e Spanned for Joined\u003cT, P\u003e\nwhere\n    T: Spanned,\n{\n    fn span(\u0026self) -\u003e crate::Span {\n        Span::fromto(\n            self.items\n                .first()\n                .map(|i| i.0.span())\n                .unwrap_or(self.last.span()),\n            self.last.span(),\n        )\n    }\n}\n\nimpl\u003cT, P\u003e Parse for Joined\u003cT, P\u003e\nwhere\n    T: Parse,\n    P: Parse,\n{\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let mut items = Vec::new();\n        loop {\n            let item = T::parse(input).map_err(|e| {\n                let f = format!(\"{}\", e.internal);\n                e.override_internal(format!(\"failed to parse value in joined statement: {f}\"))\n            })?;\n            match P::parse(input) {\n                Ok(delim) =\u003e items.push((item, delim)),\n                Err(_) =\u003e {\n                    return Ok(Self {\n                        items,\n                        last: Box::new(item),\n                    });\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":220},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":220},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":755},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1558},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1558},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":755},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":755},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":719},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":320},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":320},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":798},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":79},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":306},"fn_name":null}],"covered":25,"coverable":32},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","kv.rs"],"content":"use crate::{ast::parse::*, error::Result, Span};\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct KeyValueField\u003cK, V, D\u003e {\n    pub key: K,\n    pub delim: D,\n    pub value: V,\n}\n\nimpl\u003cK, V, D\u003e Spanned for KeyValueField\u003cK, V, D\u003e\nwhere\n    K: Spanned,\n    V: Spanned,\n{\n    fn span(\u0026self) -\u003e crate::Span {\n        Span::fromto(self.key.span(), self.value.span())\n    }\n}\n\nimpl\u003cK, V, D\u003e Parse for KeyValueField\u003cK, V, D\u003e\nwhere\n    K: Parse,\n    V: Parse,\n    D: Parse,\n{\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let key = K::parse(input)?;\n        let delim = D::parse(input).map_err(|e| {\n            let f = format!(\"{}\", e.internal);\n            e.override_internal(format!(\"missing delimiter in key-value pair: {f}\"))\n        })?;\n        let value = V::parse(input).map_err(|e| {\n            let f = format!(\"{}\", e.internal);\n            e.override_internal(format!(\"missing value in key-value pair: {f}\"))\n        })?;\n\n        Ok(Self { key, delim, value })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::{parse::*, Eq, Ident, KeyValueField, Lit, LitKind, TokenStream};\n    use crate::resource::SourceMap;\n\n    #[test]\n    fn success_single_delim_token() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"first = 123\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let kv = KeyValueField::\u003cIdent, Lit, Eq\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(kv.key, \"first\");\n        assert_eq!(kv.value.kind, LitKind::Integer { lit: 123 });\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"first = \\\"first\\\"\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let kv = KeyValueField::\u003cIdent, Lit, Eq\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(kv.key, \"first\");\n        assert_eq!(\n            kv.value.kind,\n            LitKind::Str {\n                lit: \"first\".to_string()\n            }\n        );\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":570},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1140},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":570},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":564},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":558},"fn_name":null}],"covered":11,"coverable":11},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","macros.rs"],"content":"macro_rules! ast_expect_single_token {\n    (\n        $(\n        $vis:vis struct $type:ident {\n            token: $token:expr,\n        }\n        )*\n\n    ) =\u003e {\n       $(\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n        $vis struct $type {\n            $vis span: crate::Span\n        }\n\n        impl crate::ast::parse::Parse for $type {\n            fn parse(input: crate::ast::parse::ParseStream)\n                -\u003e crate::error::Result\u003c$type\u003e {\n                let Some(peek) = input.ts.peek() else {\n                    return Err(\n                        crate::error::Error::new(\n                            crate::error::ErrorKind::UnexpectedToken,\n                            format!(\"expected {}, found EOF\", $token.token_kind_err_output())\n                        )\n                    );\n                };\n\n                if let crate::ast::token::TokenTree::Token(token, spacing) = peek {\n                    if crate::ast::token::Spacing::Alone != *spacing {\n                        return Err(\n                            crate::error::Error::new(\n                                crate::error::ErrorKind::ExpectedSingleFoundJoint,\n                                format!(\"expected {}, found invalid spacing\", $token.token_kind_err_output())\n                            ).spanned(token.span)\n                        );\n                    }\n\n                    if token.kind == $token {\n                        let ret = Ok(Self { span: token.span });\n                        input.ts.bump();\n                        ret\n                    } else {\n                        Err(\n                            crate::error::Error::new(\n                                crate::error::ErrorKind::UnexpectedToken,\n                                format!(\"expected {}, found {}\", $token.token_kind_err_output(), token.kind.token_kind_err_output())\n                            ).spanned(token.span)\n                        )\n                    }\n                } else {\n                    Err(\n                        crate::error::Error::new(\n                            crate::error::ErrorKind::UnexpectedDelim,\n                            format!(\"expected {}, found delim\", $token.token_kind_err_output())\n                        ).spanned(peek.span())\n                    )\n                }\n            }\n        }\n\n        impl crate::ast::parse::Spanned for $type {\n            fn span(\u0026self) -\u003e crate::resource::Span {\n                self.span\n            }\n        }\n    )*\n    };\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":6522},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":6522},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":13031},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":5550},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":5550},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":5296},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":5296},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":5296},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1202},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1202},"fn_name":null}],"covered":24,"coverable":29},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","mod.rs"],"content":"use crate::ast::parse::*;\nuse crate::ast::Annotation;\nuse crate::ast::Keyword;\nuse crate::ast::Token;\nuse crate::ast::TokenKind;\nuse crate::ast::TokenStream;\nuse crate::ast::TokenTree;\nuse crate::error::*;\nuse crate::Span;\n\n#[macro_use]\nmod macros;\n\nmod cluster;\nmod delim;\nmod eitheror;\nmod joined;\nmod kv;\nmod punct;\n\npub use self::cluster::*;\npub use self::delim::*;\npub use self::eitheror::*;\npub use self::joined::*;\npub use self::kv::*;\npub use self::punct::*;\n\n// # Tokens\n\nast_expect_single_token! {\n    pub struct Slash {\n        token: TokenKind::Slash,\n    }\n    pub struct Dot {\n        token: TokenKind::Dot,\n    }\n    pub struct DotDot {\n        token: TokenKind::DotDot,\n    }\n    pub struct DotDotDot {\n        token: TokenKind::DotDotDot,\n    }\n    pub struct Eq {\n        token: TokenKind::Eq,\n    }\n    pub struct Semi {\n        token: TokenKind::Semi,\n    }\n    pub struct Comma {\n        token: TokenKind::Comma,\n    }\n    pub struct Colon {\n        token: TokenKind::Colon,\n    }\n    pub struct Plus {\n        token: TokenKind::Plus,\n    }\n    pub struct Minus {\n        token: TokenKind::Minus,\n    }\n    pub struct LeftSingleArrow {\n        token: TokenKind::LSingleArrow,\n    }\n    pub struct LeftRightSingleArrow {\n        token: TokenKind::LSingleArrowR,\n    }\n    pub struct RightSingleArrow {\n        token: TokenKind::RSingleArrow,\n    }\n    pub struct IncludeToken {\n        token: TokenKind::Keyword(Keyword::Include),\n    }\n    pub struct ModuleToken {\n        token: TokenKind::Keyword(Keyword::Module),\n    }\n    pub struct GatesToken {\n        token: TokenKind::Keyword(Keyword::Gates),\n    }\n    pub struct SubmodulesToken {\n        token: TokenKind::Keyword(Keyword::Submodules),\n    }\n    pub struct ConnectionsToken {\n        token: TokenKind::Keyword(Keyword::Connections),\n    }\n    pub struct LinkToken {\n        token: TokenKind::Keyword(Keyword::Link),\n    }\n    pub struct EntryToken {\n        token: TokenKind::Keyword(Keyword::Entry),\n    }\n    pub struct DynToken {\n        token: TokenKind::Keyword(Keyword::Dyn),\n    }\n}\n\n// # EXT\n\npub use crate::ast::token::Ident;\npub use crate::ast::token::Lit;\n\nimpl Spanned for Ident {\n    fn span(\u0026self) -\u003e crate::Span {\n        self.span\n    }\n}\n\nimpl Parse for Ident {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        match input.ts.peek() {\n            Some(TokenTree::Token(\n                Token {\n                    kind: TokenKind::Ident(ident),\n                    ..\n                },\n                _,\n            )) =\u003e {\n                let ident = ident.clone();\n                input.ts.bump();\n                Ok(ident)\n            }\n\n            Some(TokenTree::Token(\n                Token {\n                    kind: TokenKind::Keyword(keyword),\n                    ..\n                },\n                _,\n            )) =\u003e Err(Error::new(\n                ErrorKind::ExpectedIdentFoundKeyword,\n                format!(\"expected \u003cident\u003e, found \u003ckeyword\u003e '{}'\", keyword),\n            )),\n\n            Some(TokenTree::Token(token, _)) =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                format!(\n                    \"expected \u003cident\u003e, found {}\",\n                    token.kind.token_kind_err_output()\n                ),\n            )\n            .spanned(token.span)),\n\n            Some(TokenTree::Delimited(delim, _, _)) =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                \"expected \u003cident\u003e, found delim\",\n            )\n            .spanned(Span::fromto(delim.open, delim.close))),\n\n            _ =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                \"expected \u003cident\u003e, found EOF\",\n            )),\n        }\n    }\n}\n\nimpl Spanned for Annotation {\n    fn span(\u0026self) -\u003e crate::Span {\n        self.span\n    }\n}\n\nimpl Parse for Annotation {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        match input.ts.peek() {\n            Some(TokenTree::Token(\n                Token {\n                    kind: TokenKind::Annotation(annot),\n                    ..\n                },\n                _,\n            )) =\u003e {\n                let annot = annot.clone();\n                input.ts.bump();\n                Ok(annot)\n            }\n\n            Some(TokenTree::Token(token, _)) =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                format!(\n                    \"expected \u003cannotation\u003e, found {}\",\n                    token.kind.token_kind_err_output()\n                ),\n            )\n            .spanned(token.span)),\n\n            Some(TokenTree::Delimited(delim, _, _)) =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                \"expected \u003cannotation\u003e, found delim\",\n            )\n            .spanned(Span::fromto(delim.open, delim.close))),\n\n            _ =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                \"expected \u003cannotation\u003e, found EOF\",\n            )),\n        }\n    }\n}\n\nimpl Spanned for Lit {\n    fn span(\u0026self) -\u003e crate::Span {\n        self.span\n    }\n}\n\nimpl Parse for Lit {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        match input.ts.peek() {\n            Some(TokenTree::Token(\n                Token {\n                    kind: TokenKind::Literal(lit),\n                    ..\n                },\n                _,\n            )) =\u003e {\n                let lit = lit.clone();\n                input.ts.bump();\n                Ok(lit)\n            }\n\n            Some(TokenTree::Token(token, _)) =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                format!(\n                    \"expected \u003cliteral\u003e, found {}\",\n                    token.kind.token_kind_err_output()\n                ),\n            )\n            .spanned(token.span)),\n\n            Some(TokenTree::Delimited(delim, _, _)) =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                \"expected \u003cliteral\u003e, found delim\",\n            )\n            .spanned(Span::fromto(delim.open, delim.close))),\n\n            _ =\u003e Err(Error::new(\n                ErrorKind::UnexpectedToken,\n                \"expected \u003cliteral\u003e, found EOF\",\n            )),\n        }\n    }\n}\n\nimpl Parse for TokenStream {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        if input.ts.state() == 0 {\n            Ok(TokenStream {\n                items: input.ts.raw(),\n            })\n        } else {\n            Err(Error::new(ErrorKind::MissingToken, \"missing token\"))\n        }\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":670},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":670},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":4259},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":4259},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":4203},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":790},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":790},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":772},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":45,"coverable":83},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","common","punct.rs"],"content":"use crate::{ast::parse::*, error::*, Span};\n\n// Eg \u003cLit, Comma\u003e,\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Punctuated\u003cT, P\u003e {\n    inner: Vec\u003c(T, P)\u003e,\n    last: Option\u003cBox\u003cT\u003e\u003e,\n}\n\nimpl\u003cT, P\u003e Punctuated\u003cT, P\u003e {\n    pub const fn new() -\u003e Self {\n        Self {\n            inner: Vec::new(),\n            last: None,\n        }\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.inner.len() + if self.last.is_some() { 1 } else { 0 }\n    }\n\n    pub fn first(\u0026self) -\u003e Option\u003c\u0026T\u003e {\n        self.inner.first().map(|v| \u0026v.0)\n    }\n\n    pub fn first_mut(\u0026mut self) -\u003e Option\u003c\u0026mut T\u003e {\n        self.inner.first_mut().map(|v| \u0026mut v.0)\n    }\n\n    pub fn trailing_punct(\u0026self) -\u003e bool {\n        self.last.is_none()\n    }\n\n    pub fn push_value(\u0026mut self, value: T) {\n        assert!(self.last.is_none());\n        self.last = Some(Box::new(value));\n    }\n\n    pub fn push_punct(\u0026mut self, punct: P) {\n        assert!(self.last.is_some());\n        self.inner.push((*self.last.take().unwrap(), punct))\n    }\n\n    pub fn iter(\u0026self) -\u003e PunctIter\u003c'_, T, P\u003e {\n        PunctIter {\n            punct: self,\n            idx: 0,\n        }\n    }\n}\n\nimpl\u003cT, P\u003e Spanned for Punctuated\u003cT, P\u003e\nwhere\n    T: Spanned,\n    P: Spanned,\n{\n    fn span(\u0026self) -\u003e Span {\n        if self.is_empty() {\n            Span::new(0, 0)\n        } else {\n            Span::fromto(\n                self.iter().next().unwrap().span(),\n                self.last\n                    .as_ref()\n                    .map(|v| v.span())\n                    .unwrap_or(self.inner.last().unwrap().1.span()),\n            )\n        }\n    }\n}\n\nimpl\u003cT, P\u003e Parse for Punctuated\u003cT, P\u003e\nwhere\n    T: Parse,\n    P: Parse,\n{\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let mut this = Self::new();\n        while !input.ts.is_empty() {\n            let item = T::parse(input)?;\n\n            /* .map_err(|e| {\n                if matches!(e.kind, ErrorKind::UnexpectedToken | UnexpectedEOF) {\n                    let f = format!(\"{}\", e.internal);\n                    e.override_internal(format!(\"expected value in punctuated statement: {f}\"))\n                } else {\n                    e\n                }\n            }) */\n\n            if input.ts.is_empty() {\n                // no tailing delim needed\n                this.last = Some(Box::new(item));\n                break;\n            } else {\n                let delim = P::parse(input)?;\n                this.inner.push((item, delim))\n            }\n        }\n\n        assert!(input.ts.is_empty());\n        Ok(this)\n    }\n}\n\n// # Iter\n\npub struct PunctIter\u003c'a, T, P\u003e {\n    punct: \u0026'a Punctuated\u003cT, P\u003e,\n    idx: usize,\n}\n\nimpl\u003c'a, T, P\u003e Iterator for PunctIter\u003c'a, T, P\u003e {\n    type Item = \u0026'a T;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        use std::cmp::Ordering::*;\n        match self.idx.cmp(\u0026self.punct.inner.len()) {\n            Less =\u003e {\n                self.idx += 1;\n                Some(\u0026self.punct.inner[self.idx - 1].0)\n            }\n            Equal =\u003e {\n                self.idx += 1;\n                self.punct.last.as_deref()\n            }\n            Greater =\u003e None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::ast::{Comma, Eq, Ident, KeyValueField, Lit, Punctuated, Semi, TokenStream};\n    use crate::resource::SourceMap;\n\n    #[test]\n    fn success_single_token_patterns() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"first,second,third,\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cIdent, Comma\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 3);\n        assert_eq!(punct.trailing_punct(), true);\n\n        assert_eq!(\n            punct.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\"first\", \"second\", \"third\"]\n        );\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"first,second,third\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cIdent, Comma\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 3);\n        assert_eq!(punct.trailing_punct(), false);\n\n        assert_eq!(\n            punct.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\"first\", \"second\", \"third\"]\n        );\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"first,\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cIdent, Comma\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 1);\n        assert_eq!(punct.trailing_punct(), true);\n\n        assert_eq!(punct.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e(), vec![\"first\"]);\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"first\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cIdent, Comma\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 1);\n        assert_eq!(punct.trailing_punct(), false);\n\n        assert_eq!(punct.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e(), vec![\"first\"]);\n    }\n\n    #[test]\n    fn success_multi_token_patterns() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"\n        ident = 123;\n        key = 123123123;\n        comma = 13;\n        \",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cKeyValueField\u003cIdent, Lit, Eq\u003e, Semi\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 3);\n        assert_eq!(punct.trailing_punct(), true);\n\n        assert_eq!(\n            punct\n                .iter()\n                .cloned()\n                .map(|v| (format!(\"{}\", v.key.raw), format!(\"{}\", v.value.kind), \"=\"))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"ident\".to_string(), \"123\".to_string(), \"=\"),\n                (\"key\".to_string(), \"123123123\".to_string(), \"=\"),\n                (\"comma\".to_string(), \"13\".to_string(), \"=\"),\n            ]\n        );\n    }\n\n    #[test]\n    fn success_pattern_delim_same_type() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \",,,,,,\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cComma, Comma\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 3);\n        assert_eq!(punct.trailing_punct(), true);\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \",,,,,\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let punct = Punctuated::\u003cComma, Comma\u003e::parse(\u0026buf).unwrap();\n        assert_eq!(punct.len(), 3);\n        assert_eq!(punct.trailing_punct(), false);\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":879},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":879},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":484},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":968},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1850},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":879},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":879},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1984},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3192},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":452},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":452},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2210},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1105},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":840},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":840},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":4867},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":4867},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1965},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1965},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1838},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1838},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1064},"fn_name":null}],"covered":24,"coverable":47},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","entry.rs"],"content":"use super::{EntryToken, Ident, Semi};\nuse crate::{ast::parse::*, error::*, Span};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct EntryStmt {\n    pub entry: EntryToken,\n    pub symbol: Ident,\n    pub semi: Semi,\n}\n\nimpl Spanned for EntryStmt {\n    fn span(\u0026self) -\u003e crate::Span {\n        Span::fromto(self.entry.span(), self.semi.span())\n    }\n}\n\nimpl Parse for EntryStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let entry = EntryToken::parse(input)?;\n        let symbol = Ident::parse(input)?;\n        let semi = Semi::parse(input)?;\n        Ok(Self {\n            entry,\n            symbol,\n            semi,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{ast::TokenStream, resource::SourceMap};\n\n    #[test]\n    fn parse_entry_statement() {\n        let mut smap = SourceMap::new();\n\n        // Case #0\n        let asset = smap.load_raw(\"raw:case0\", \"entry Main;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = EntryStmt::parse(\u0026buf).unwrap();\n        assert_eq!(expr.symbol, \"Main\")\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":510},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":255},"fn_name":null}],"covered":8,"coverable":10},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","include.rs"],"content":"use crate::Span;\n\nuse crate::ast::{parse::*, DotDot, EitherOr, Ident, IncludeToken, Joined, Semi, Slash};\nuse crate::error::*;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct IncludeStmt {\n    pub include: IncludeToken,\n    pub path: Joined\u003cEitherOr\u003cIdent, DotDot\u003e, Slash\u003e,\n    pub semi: Semi,\n}\n\nimpl Joined\u003cEitherOr\u003cIdent, DotDot\u003e, Slash\u003e {\n    pub fn path(\u0026self) -\u003e String {\n        self.iter()\n            .map(|v| match v {\n                EitherOr::Either(either) =\u003e \u0026either.raw[..],\n                EitherOr::Or(_) =\u003e \"..\",\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"/\")\n    }\n}\n\nimpl Spanned for IncludeStmt {\n    fn span(\u0026self) -\u003e crate::Span {\n        Span::fromto(self.include.span(), self.semi.span())\n    }\n}\n\n// # Parsing\n\nimpl Parse for IncludeStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let include = IncludeToken::parse(input)?;\n        let path = Joined::\u003c_, Slash\u003e::parse(input)?;\n        let semi = Semi::parse(input)?;\n        Ok(Self {\n            include,\n            path,\n            semi,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{IncludeStmt, Parse, ParseBuffer};\n    use crate::{\n        ast::TokenStream,\n        resource::{SourceMap, Span},\n    };\n\n    #[test]\n    fn success_single_path_component() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"include abcde;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(0, 7));\n        assert_eq!(include.semi.span, Span::new(13, 1));\n\n        assert_eq!(include.path.len(), 1);\n        assert_eq!(include.path.path(), \"abcde\");\n\n        // # Case 1\n        let offset = 14;\n        let asset = smap.load_raw(\"raw:case1\", \"include _abc1321231_123_acd;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(offset, 7));\n        assert_eq!(include.semi.span, Span::new(offset + 27, 1));\n\n        assert_eq!(include.path.len(), 1);\n        assert_eq!(include.path.path(), \"_abc1321231_123_acd\");\n\n        // # Case 2\n        let offset = 42;\n        let asset = smap.load_raw(\"raw:case2\", \"include cdc;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(offset, 7));\n        assert_eq!(include.path.len(), 1);\n        assert_eq!(include.path.path(), \"cdc\");\n\n        // # Case 3\n        let offset = 54;\n        let asset = smap.load_raw(\"raw:case3\", \"include \\n\\t\\t// AB\\n     cdc;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(offset, 7));\n\n        assert_eq!(include.path.len(), 1);\n        assert_eq!(include.path.path(), \"cdc\");\n    }\n\n    #[test]\n    fn success_more_path_components() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"include a/b/c;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(0, 7));\n        assert_eq!(include.semi.span, Span::new(13, 1));\n\n        assert_eq!(include.path.len(), 3);\n        assert_eq!(include.path.path(), \"a/b/c\");\n\n        // # Case 1\n        let offset = 14;\n        let asset = smap.load_raw(\"raw:case1\", \"include a12312/b12312/_c;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(offset, 7));\n        assert_eq!(include.semi.span, Span::new(offset + 24, 1));\n\n        assert_eq!(include.path.len(), 3);\n        assert_eq!(include.path.path(), \"a12312/b12312/_c\");\n\n        // # Case 2\n        let offset = 39;\n        let asset = smap.load_raw(\"raw:case2\", \"include a12312/b12312/_c;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let include = IncludeStmt::parse(\u0026buf).unwrap();\n        assert_eq!(include.include.span, Span::new(offset, 7));\n\n        assert_eq!(include.path.len(), 3);\n        assert_eq!(include.path.path(), \"a12312/b12312/_c\");\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":163},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":163},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":332},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":87},"fn_name":null}],"covered":14,"coverable":15},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","items.rs"],"content":"use std::sync::Arc;\n\nuse crate::{\n    ast::{\n        parse::*, EntryStmt, Ident, IncludeStmt, Keyword, LinkStmt, ModuleStmt, Token, TokenKind,\n        TokenTree,\n    },\n    error::*,\n};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct File {\n    pub items: Vec\u003cItem\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Item {\n    Include(Arc\u003cIncludeStmt\u003e),\n    Link(Arc\u003cLinkStmt\u003e),\n    Module(Arc\u003cModuleStmt\u003e),\n    Entry(Arc\u003cEntryStmt\u003e),\n}\n\n// # Impl\n\nimpl Item {\n    pub fn symbol(\u0026self) -\u003e Option\u003c\u0026Ident\u003e {\n        match self {\n            Item::Include(_) | Item::Entry(_) =\u003e None,\n            Item::Module(module) =\u003e Some(\u0026module.ident),\n            Item::Link(link) =\u003e Some(\u0026link.ident),\n        }\n    }\n}\n\n// # Spaning\n\nimpl Spanned for Item {\n    fn span(\u0026self) -\u003e crate::Span {\n        match self {\n            Self::Entry(entry) =\u003e entry.span(),\n            Self::Include(include) =\u003e include.span(),\n            Self::Link(link) =\u003e link.span(),\n            Self::Module(module) =\u003e module.span(),\n        }\n    }\n}\n\n// # Parse\n\nimpl Parse for File {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let mut items = Vec::new();\n        while !input.ts.is_empty() {\n            items.push(Item::parse(input)?)\n        }\n        Ok(File { items })\n    }\n}\n\nimpl Parse for Item {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        match input.ts.peek() {\n            Some(TokenTree::Token(\n                Token {\n                    kind: TokenKind::Keyword(keyword),\n                    span,\n                },\n                _,\n            )) =\u003e match keyword {\n                Keyword::Include =\u003e Ok(Item::Include(Arc::new(IncludeStmt::parse(input)?))),\n                Keyword::Link =\u003e Ok(Item::Link(Arc::new(LinkStmt::parse(input)?))),\n                Keyword::Module =\u003e Ok(Item::Module(Arc::new(ModuleStmt::parse(input)?))),\n                Keyword::Entry =\u003e Ok(Item::Entry(Arc::new(EntryStmt::parse(input)?))),\n                _ =\u003e Err(\n                    Error::new(ErrorKind::UnexpectedToken, \"expected top-level \u003ckeyword\u003e\")\n                        .spanned(*span),\n                ),\n            },\n\n            Some(t) =\u003e Err(\n                Error::new(ErrorKind::UnexpectedToken, \"expected top-level \u003ckeyword\u003e\")\n                    .spanned(t.span()),\n            ),\n\n            None =\u003e Err(\n                Error::new(ErrorKind::UnexpectedEOF, \"unexpected end of tokenstream\")\n                    .spanned(input.ts.last_span()),\n            ),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{ast::TokenStream, SourceMap};\n\n    #[test]\n    fn simple_top_level_definitions() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"include std; link A {} module B {} entry C;\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let file = File::parse(\u0026buf).unwrap();\n        assert_eq!(file.items.len(), 4);\n\n        assert!(matches!(file.items[0], Item::Include(_)));\n        assert!(matches!(file.items[1], Item::Link(_)));\n        assert!(matches!(file.items[2], Item::Module(_)));\n        assert!(matches!(file.items[3], Item::Entry(_)));\n\n        // # Case 1\n        let asset = smap.load_raw(\n            \"raw:case1\",\n            \"include std; link A: Super { key: 123, } module B { gates { in, out } } entry C;\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let file = File::parse(\u0026buf).unwrap();\n        assert_eq!(file.items.len(), 4);\n\n        assert!(matches!(file.items[0], Item::Include(_)));\n        assert!(matches!(file.items[1], Item::Link(_)));\n        assert!(matches!(file.items[2], Item::Module(_)));\n        assert!(matches!(file.items[3], Item::Entry(_)));\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":1179},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1179},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":330},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":669},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":435},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":435},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1658},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1415},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":339},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":839},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":24,"coverable":32},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","link.rs"],"content":"use crate::{\n    ast::{\n        parse::*, Colon, Comma, Delimited, Delimiter, Ident, Joined, KeyValueField, LinkToken, Lit,\n        Plus, Punctuated,\n    },\n    error::*,\n    resource::Span,\n};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct LinkStmt {\n    pub link_token: LinkToken,\n    pub ident: Ident,\n    pub inheritance: Option\u003cLinkInheritance\u003e,\n    pub data: LinkData,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct LinkInheritance {\n    pub colon: Colon,\n    pub symbols: Joined\u003cIdent, Plus\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct LinkData {\n    pub items: Punctuated\u003cKeyValueField\u003cIdent, Lit, Colon\u003e, Comma\u003e,\n    pub span: Span,\n}\n\n// # Spanning\n\nimpl Spanned for LinkStmt {\n    fn span(\u0026self) -\u003e crate::Span {\n        Span::fromto(self.link_token.span(), self.data.span())\n    }\n}\n\nimpl Spanned for LinkInheritance {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(self.colon.span(), self.symbols.span())\n    }\n}\n\nimpl Spanned for LinkData {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\n// # Parsing\n\nimpl Parse for LinkStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let link_token = LinkToken::parse(input)?;\n        let ident = Ident::parse(input).map_err(|e| {\n            let f = format!(\"{}\", e.internal);\n            e.override_internal(format!(\"unexpected token for link symbol: {}\", f))\n        })?;\n        let inheritance = Option::\u003cLinkInheritance\u003e::parse(input)?;\n        let data = LinkData::parse(input)?;\n\n        Ok(Self {\n            link_token,\n            ident,\n            inheritance,\n            data,\n        })\n    }\n}\n\nimpl Parse for Option\u003cLinkInheritance\u003e {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let colon = match Colon::parse(input) {\n            Ok(v) =\u003e v,\n            Err(_) =\u003e return Ok(None),\n        };\n\n        let symbols = Joined::\u003cIdent, Plus\u003e::parse(input)?;\n        Ok(Some(LinkInheritance { colon, symbols }))\n    }\n}\n\nimpl Parse for LinkData {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let items = Delimited::\u003cPunctuated\u003cKeyValueField\u003cIdent, Lit, Colon\u003e, Comma\u003e\u003e::parse_from(\n            Delimiter::Brace,\n            input,\n        )?;\n        let span = Span::fromto(items.delim_span.open, items.delim_span.close);\n        Ok(Self {\n            items: items.inner,\n            span,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::{parse::*, LinkStmt, TokenStream};\n    use crate::resource::SourceMap;\n\n    #[test]\n    fn multiple_lit_parse() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"link FastLink { ident: 123, other: 1.0 }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = LinkStmt::parse(\u0026buf).unwrap();\n        assert_eq!(expr.ident, \"FastLink\");\n        assert_eq!(expr.link_token.span.pos, 0);\n        assert_eq!(\n            expr.data\n                .items\n                .iter()\n                .cloned()\n                .map(|v| (v.key.raw, format!(\"{}\", v.value.kind)))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"ident\".to_string(), \"123\".to_string()),\n                (\"other\".to_string(), \"1.0\".to_string())\n            ]\n        );\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"link FastLink { ident: 123, other: 1.0, }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = LinkStmt::parse(\u0026buf).unwrap();\n        assert_eq!(expr.ident, \"FastLink\");\n        assert_eq!(\n            expr.data\n                .items\n                .iter()\n                .cloned()\n                .map(|v| (v.key.raw, format!(\"{}\", v.value.kind)))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"ident\".to_string(), \"123\".to_string()),\n                (\"other\".to_string(), \"1.0\".to_string())\n            ]\n        );\n    }\n\n    #[test]\n    fn inheritance_statement() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"link FastLink: pident { ident: 123, other: 1.0 }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = LinkStmt::parse(\u0026buf).unwrap();\n        assert_eq!(expr.ident, \"FastLink\");\n        assert_eq!(\n            expr.inheritance\n                .map(|v| v.symbols.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e())\n                .unwrap(),\n            vec![\"pident\"]\n        );\n        assert_eq!(expr.link_token.span.pos, 0);\n        assert_eq!(\n            expr.data\n                .items\n                .iter()\n                .cloned()\n                .map(|v| (v.key.raw, format!(\"{}\", v.value.kind)))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"ident\".to_string(), \"123\".to_string()),\n                (\"other\".to_string(), \"1.0\".to_string())\n            ]\n        );\n\n        // # Case 2\n        let asset = smap.load_raw(\n            \"raw:case2\",\n            \"link FastLink: A + B + C { ident: 123, other: 1.0, }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = LinkStmt::parse(\u0026buf).unwrap();\n        assert_eq!(expr.ident, \"FastLink\");\n        assert_eq!(\n            expr.inheritance\n                .map(|v| v.symbols.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e())\n                .unwrap(),\n            vec![\"A\", \"B\", \"C\"]\n        );\n        assert_eq!(\n            expr.data\n                .items\n                .iter()\n                .cloned()\n                .map(|v| (v.key.raw, format!(\"{}\", v.value.kind)))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"ident\".to_string(), \"123\".to_string()),\n                (\"other\".to_string(), \"1.0\".to_string())\n            ]\n        );\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":221},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":442},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":221},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":209},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":191},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":191},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":191},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":191},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":191},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":316},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":101},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":209},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":209},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":209},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","mod.rs"],"content":"mod common;\nmod entry;\nmod include;\nmod items;\nmod link;\nmod module;\n\npub use common::*;\npub use entry::*;\npub use include::*;\npub use items::*;\npub use link::*;\npub use module::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","module","connections.rs"],"content":"use std::fmt;\n\nuse crate::{\n    ast::{\n        parse::*, ClusterDefinition, Comma, ConnectionsToken, Delimited, Delimiter, Ident,\n        LeftSingleArrow, Punctuated, RightSingleArrow, Slash, LeftRightSingleArrow, EitherOr,\n    },\n    error::Result,\n    resource::Span,\n};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ConnectionsStmt {\n    pub keyword: ConnectionsToken,\n    pub span: Span,\n    pub items: Punctuated\u003cConnectionDefinition, Comma\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ConnectionDefinition {\n    pub lhs: ModuleGateReference,\n    pub rhs: ModuleGateReference,\n    pub first_arrow: EitherOr\u003cLeftSingleArrow, LeftRightSingleArrow\u003e,\n    pub second_arrow: Option\u003cRightSingleArrow\u003e,\n    pub link: Option\u003cIdent\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum ModuleGateReference {\n    Local(LocalModuleGateReference),\n    Nonlocal(NonlocalModuleGateReference),\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct LocalModuleGateReference {\n    pub gate: Ident,\n    pub gate_cluster: Option\u003cClusterDefinition\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct NonlocalModuleGateReference {\n    pub submodule: Ident,\n    pub submodule_cluster: Option\u003cClusterDefinition\u003e,\n    pub slash: Slash,\n    pub gate: LocalModuleGateReference,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum ConnectionArrow {\n    Double(LeftRightSingleArrow),\n    Left(LeftSingleArrow),\n    Right(RightSingleArrow),\n}\n\n// # Impl\n\nimpl ConnectionArrow {\n    pub fn is_double(\u0026self) -\u003e bool {\n        matches!(self, Self::Double(_))\n    }\n\n    pub fn is_right(\u0026self) -\u003e bool {\n        matches!(self, Self::Right(_))\n    }\n}\n\nimpl LocalModuleGateReference {\n    pub fn pos(\u0026self) -\u003e usize {\n        self.gate_cluster\n            .as_ref()\n            .map(|c| c.lit.as_integer() as usize)\n            .unwrap_or(0)\n    }\n}\n\nimpl fmt::Display for ModuleGateReference {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Self::Local(local) =\u003e local.fmt(f),\n            Self::Nonlocal(nonlocal) =\u003e nonlocal.fmt(f),\n        }\n    }\n}\n\nimpl fmt::Display for LocalModuleGateReference {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        if let Some(cluster) = \u0026self.gate_cluster {\n            write!(f, \"{}{}\", self.gate.raw, cluster)\n        } else {\n            write!(f, \"{}\", self.gate.raw)\n        }\n    }\n}\n\nimpl fmt::Display for NonlocalModuleGateReference {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.submodule.raw)?;\n        if let Some(cluster) = \u0026self.submodule_cluster {\n            write!(f, \"{}\", cluster)?;\n        }\n        write!(f, \"/{}\", self.gate)?;\n\n        Ok(())\n    }\n}\n\n// # Spanning\n\nimpl Spanned for ConnectionsStmt {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\nimpl Spanned for ConnectionDefinition {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(self.lhs.span(), self.rhs.span())\n    }\n}\n\nimpl Spanned for ModuleGateReference {\n    fn span(\u0026self) -\u003e Span {\n        match self {\n            Self::Local(local) =\u003e local.span(),\n            Self::Nonlocal(nonlocal) =\u003e nonlocal.span(),\n        }\n    }\n}\n\nimpl Spanned for LocalModuleGateReference {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(\n            self.gate.span(),\n            self.gate_cluster\n                .as_ref()\n                .map(|v| v.span())\n                .unwrap_or(self.gate.span()),\n        )\n    }\n}\n\nimpl Spanned for NonlocalModuleGateReference {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(self.submodule.span(), self.gate.span())\n    }\n}\n\nimpl Spanned for ConnectionArrow {\n    fn span(\u0026self) -\u003e Span {\n        match self {\n            Self::Double(d) =\u003e d.span(),\n            Self::Left(left) =\u003e left.span(),\n            Self::Right(right) =\u003e right.span(),\n        }\n    }\n}\n\n// # Parse\n\nimpl Parse for ConnectionsStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let keyword = ConnectionsToken::parse(input)?;\n        let delim = Delimited::\u003cPunctuated\u003cConnectionDefinition, Comma\u003e\u003e::parse_from(\n            Delimiter::Brace,\n            input,\n        )?;\n        let span = Span::fromto(delim.delim_span.open, delim.delim_span.close);\n        Ok(ConnectionsStmt {\n            keyword,\n            span,\n            items: delim.inner,\n        })\n    }\n}\n\nimpl Parse for ConnectionDefinition {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let first = ModuleGateReference::parse(input)?;\n        let first_arrow = EitherOr::parse(input)?;\n\n        if matches!(first_arrow, EitherOr::Either(_)){\n            // Could be a delayed connections\n            let link = Ident::parse(input)?;\n            let second_arrow = RightSingleArrow::parse(input)?;\n            let third = ModuleGateReference::parse(input)?;\n\n            Ok(ConnectionDefinition {\n                lhs: first,\n                rhs: third,\n                first_arrow,\n                second_arrow: Some(second_arrow),\n                link: Some(link),\n            })\n        } else {\n            let second = ModuleGateReference::parse(input)?;\n\n            Ok(ConnectionDefinition {\n                lhs: first,\n                first_arrow,\n                rhs: second,\n                second_arrow: None,\n                link: None,\n            })\n        }\n    }\n}\n\nimpl Parse for ModuleGateReference {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let old_state = input.ts.state();\n        match NonlocalModuleGateReference::parse(input) {\n            Ok(v) =\u003e Ok(ModuleGateReference::Nonlocal(v)),\n            Err(_e) =\u003e {\n                input.ts.set_state(old_state);\n                let local = LocalModuleGateReference::parse(input)?;\n                Ok(ModuleGateReference::Local(local))\n            }\n        }\n    }\n}\n\nimpl Parse for LocalModuleGateReference {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let gate = Ident::parse(input)?;\n        let gate_cluster = Option::\u003cClusterDefinition\u003e::parse(input)?;\n        Ok(LocalModuleGateReference { gate, gate_cluster })\n    }\n}\n\nimpl Parse for NonlocalModuleGateReference {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let submodule = Ident::parse(input)?;\n        let submodule_cluster = Option::\u003cClusterDefinition\u003e::parse(input)?;\n        let slash = Slash::parse(input)?;\n        let gate = Ident::parse(input)?;\n        let gate_cluster = Option::\u003cClusterDefinition\u003e::parse(input)?;\n\n        Ok(NonlocalModuleGateReference {\n            submodule,\n            submodule_cluster,\n            slash,\n            gate: LocalModuleGateReference { gate, gate_cluster },\n        })\n    }\n}\n\nimpl Parse for ConnectionArrow {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        LeftSingleArrow::parse(input)\n            .map(ConnectionArrow::Left)\n            .or_else(|_| RightSingleArrow::parse(input).map(ConnectionArrow::Right))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{ast::TokenStream, SourceMap};\n\n    #[test]\n    fn simple_noncluster_connections() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"connections { from \u003c--\u003e to, iden_t \u003c--\u003e from_dent }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(items.len(), 2);\n\n        assert_eq!(items[0].lhs.to_string(), \"from\");\n        assert_eq!(items[0].rhs.to_string(), \"to\");\n        assert_eq!(items[0].link, None);\n\n        assert_eq!(items[1].lhs.to_string(), \"iden_t\");\n        assert_eq!(items[1].rhs.to_string(), \"from_dent\");\n        assert_eq!(items[1].link, None);\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"connections { from \u003c--\u003e 123 }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"connections { from + \u003c--\u003e ident }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"connections {  \u003c--\u003e ident }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"connections { from \u003c--\u003e ident,, }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n    }\n\n    #[test]\n    fn simple_cluster_connections() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"connections { from[1] \u003c--\u003e to, iden_t[10] \u003c--\u003e from_dent[12] }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(items[0].lhs.to_string(), \"from[1]\");\n        assert_eq!(items[0].rhs.to_string(), \"to\");\n        assert_eq!(items[0].link, None);\n\n        assert_eq!(items[1].lhs.to_string(), \"iden_t[10]\");\n        assert_eq!(items[1].rhs.to_string(), \"from_dent[12]\");\n        assert_eq!(items[1].link, None);\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"connections { from[ident] --\u003e to }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"connections { from[] --\u003e to }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"connections { from[213 --\u003e to }\");\n        let _ts = TokenStream::new(asset).unwrap_err();\n    }\n\n    #[test]\n    fn nonlocal_noncluster_connections() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"connections { child/from \u003c--\u003e child/to, child/iden_t \u003c--\u003e child/from_dent }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(items.len(), 2);\n\n        assert_eq!(items[0].lhs.to_string(), \"child/from\");\n        assert_eq!(items[0].rhs.to_string(), \"child/to\");\n        assert_eq!(items[0].link, None);\n\n        assert_eq!(items[1].lhs.to_string(), \"child/iden_t\");\n        assert_eq!(items[1].rhs.to_string(), \"child/from_dent\");\n        assert_eq!(items[1].link, None);\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"connections { child/from --\u003e child/123 }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"connections { child/from + --\u003e child/ident }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"connections {  --\u003e child/ident }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"connections { child/ --\u003e ident }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n    }\n\n    #[test]\n    fn nonlocal_cluster_connections() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"connections { child/from[1] \u003c--\u003e child/to, child/iden_t[10] \u003c--\u003e child/from_dent[12] }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(items[0].lhs.to_string(), \"child/from[1]\");\n        assert_eq!(items[0].rhs.to_string(), \"child/to\");\n        assert_eq!(items[0].link, None);\n\n        assert_eq!(items[1].lhs.to_string(), \"child/iden_t[10]\");\n        assert_eq!(items[1].rhs.to_string(), \"child/from_dent[12]\");\n        assert_eq!(items[1].link, None);\n\n        // # Case 1\n        let asset = smap.load_raw(\n            \"raw:case1\",\n            \"connections { child/from[ident] \u003c--\u003e child/to }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"connections { child/from[] \u003c--\u003e child/to }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 3\n        let asset = smap.load_raw(\"raw:case3\", \"connections { child/from[213 \u003c--\u003e child/to }\");\n        let _ts = TokenStream::new(asset).unwrap_err();\n\n        // # Case 4\n        let asset = smap.load_raw(\n            \"raw:case4\",\n            \"connections { child[1]/from \u003c--\u003e child/to, child[10]/iden_t \u003c--\u003e child[12]/from_dent }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(items[0].lhs.to_string(), \"child[1]/from\");\n        assert_eq!(items[0].rhs.to_string(), \"child/to\");\n        assert_eq!(items[0].link, None);\n\n        assert_eq!(items[1].lhs.to_string(), \"child[10]/iden_t\");\n        assert_eq!(items[1].rhs.to_string(), \"child[12]/from_dent\");\n        assert_eq!(items[1].link, None);\n\n        // # Case 5\n        let asset = smap.load_raw(\n            \"raw:case5\",\n            \"connections { child[ident]/from \u003c--\u003e child/to }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n\n        // # Case 6\n        let asset = smap.load_raw(\"raw:case6\", \"connections { child[]/from \u003c--\u003e child[1]/to }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ConnectionsStmt::parse(\u0026buf).unwrap_err();\n    }\n\n    #[test]\n    fn delayed_connections() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"connections { from \u003c-- FastLink --\u003e to, iden_t \u003c-- L --\u003e from_dent }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(items.len(), 2);\n\n        assert_eq!(items[0].lhs.to_string(), \"from\");\n        assert_eq!(items[0].rhs.to_string(), \"to\");\n        assert_eq!(items[0].link.as_ref().map(|v| \u0026v.raw[..]), Some(\"FastLink\"));\n\n        assert_eq!(items[1].lhs.to_string(), \"iden_t\");\n        assert_eq!(items[1].rhs.to_string(), \"from_dent\");\n        assert_eq!(items[1].link.as_ref().map(|v| \u0026v.raw[..]), Some(\"L\"));\n\n        // # Case 1\n        let asset = smap.load_raw(\n            \"raw:case1\",\n            \"connections { from[1] \u003c-- FastLink --\u003e to, iden_t[5] \u003c--\u003e from_dent }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ConnectionsStmt::parse(\u0026buf).unwrap();\n        let items = stmt.items.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n        assert_eq!(items.len(), 2);\n\n        assert_eq!(items[0].lhs.to_string(), \"from[1]\");\n        assert_eq!(items[0].rhs.to_string(), \"to\");\n        assert_eq!(items[0].link.as_ref().map(|v| \u0026v.raw[..]), Some(\"FastLink\"));\n\n        assert_eq!(items[1].lhs.to_string(), \"iden_t[5]\");\n        assert_eq!(items[1].rhs.to_string(), \"from_dent\");\n        assert_eq!(items[1].link.as_ref().map(|v| \u0026v.raw[..]), None);\n    }\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":346},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":166},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":333},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":333},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":333},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":278},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":333},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":666},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":329},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":325},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":281},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":280},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":278},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":278},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":278},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":278},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":278},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":62,"coverable":95},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","module","gates.rs"],"content":"use crate::{\n    ast::{\n        parse::*, Annotation, ClusterDefinition, Comma, Delimited, Delimiter, GatesToken, Ident,\n        Punctuated, TokenKind, TokenTree,\n    },\n    error::Result,\n    resource::Span,\n};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct GatesStmt {\n    pub keyword: GatesToken,\n    pub span: Span,\n    pub items: Punctuated\u003cGateDefinition, Comma\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct GateDefinition {\n    pub ident: Ident,\n    pub cluster: Option\u003cClusterDefinition\u003e,\n}\n\n// # Spanning\n\nimpl Spanned for GatesStmt {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\nimpl Spanned for GateDefinition {\n    fn span(\u0026self) -\u003e Span {\n       self.ident.span()\n    }\n}\n\n// # Parsing\n\nimpl Parse for GatesStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let keyword = GatesToken::parse(input)?;\n        let items =\n            Delimited::\u003cPunctuated\u003cGateDefinition, Comma\u003e\u003e::parse_from(Delimiter::Brace, input)?;\n        let span = Span::fromto(items.delim_span.open, items.delim_span.close);\n        Ok(Self {\n            keyword,\n            span,\n            items: items.inner,\n        })\n    }\n}\n\nimpl Parse for GateDefinition {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let ident = Ident::parse(input)?;\n        let cluster = Option::\u003cClusterDefinition\u003e::parse(input)?;\n        Ok(Self {\n            ident,\n            cluster,\n        })\n    }\n}\n\nimpl Parse for Option\u003cAnnotation\u003e {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let Some(peek) = input.ts.peek() else {\n            return Ok(None);\n        };\n        let TokenTree::Token(token, _) = peek else {\n            return Ok(None);\n        };\n        if matches!(token.kind, TokenKind::Annotation(_)) {\n            Ok(Some(Annotation::parse(input)?))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::ast::TokenStream;\n    use crate::resource::SourceMap;\n\n    #[test]\n    fn simple_gates() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"gates { in, out, debug }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = GatesStmt::parse(\u0026buf).unwrap();\n        let defs = stmt\n            .items\n            .iter()\n            .cloned()\n            .map(|d| (d.ident.raw, d.cluster))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(defs.len(), 3);\n        assert_eq!(\n            defs,\n            vec![\n                (\"in\".to_string(), None),\n                (\"out\".to_string(), None),\n                (\"debug\".to_string(), None)\n            ]\n        );\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"gates { __ident, _hid3, debug, }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = GatesStmt::parse(\u0026buf).unwrap();\n        let defs = stmt\n            .items\n            .iter()\n            .cloned()\n            .map(|d| (d.ident.raw, d.cluster))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(defs.len(), 3);\n        assert_eq!(\n            defs,\n            vec![\n                (\"__ident\".to_string(), None),\n                (\"_hid3\".to_string(), None),\n                (\"debug\".to_string(), None)\n            ]\n        );\n\n        // # Case 2\n        let asset = smap.load_raw(\"raw:case2\", \"gates { __ident, 123, debug, }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = GatesStmt::parse(\u0026buf).unwrap_err();\n    }\n\n\n    #[test]\n    fn clusted_gates() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"gates { in[5], out[0], debug }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = GatesStmt::parse(\u0026buf).unwrap();\n        let defs = stmt\n            .items\n            .iter()\n            .cloned()\n            .map(|d| {\n                (\n                    d.ident.raw,\n                    d.cluster.map(|v| format!(\"{}\", v.lit.kind)),\n                )\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(defs.len(), 3);\n        assert_eq!(\n            defs,\n            vec![\n                (\"in\".to_string(), Some(\"5\".to_string())),\n                (\"out\".to_string(), Some(\"0\".to_string())),\n                (\"debug\".to_string(), None)\n            ]\n        );\n\n        // # Case 1\n        let asset = smap.load_raw(\n            \"raw:case1\",\n            \"gates { __ident[5], _hid3[1.0], debug[\\\"str\\\"], }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = GatesStmt::parse(\u0026buf).unwrap();\n        let defs = stmt\n            .items\n            .iter()\n            .cloned()\n            .map(|d| {\n                (\n                    d.ident.raw,\n                    d.cluster.map(|v| format!(\"{}\", v.lit.kind)),\n                )\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(defs.len(), 3);\n        assert_eq!(\n            defs,\n            vec![\n                (\"__ident\".to_string(), Some(\"5\".to_string())),\n                (\"_hid3\".to_string(), Some(\"1.0\".to_string())),\n                (\"debug\".to_string(), Some(\"\\\"str\\\"\".to_string()))\n            ]\n        );\n    }\n\n    #[test]\n    fn full_gates() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"gates { in[6] }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = GatesStmt::parse(\u0026buf).unwrap();\n        let defs = stmt\n            .items\n            .iter()\n            .cloned()\n            .map(|d| {\n                (\n                    d.ident.raw,\n                    d.cluster.map(|v| format!(\"{}\", v.lit.kind)),\n                )\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(defs.len(), 1);\n        assert_eq!(\n            defs,\n            vec![(\n                \"in\".to_string(),\n                Some(\"6\".to_string()),\n            ),]\n        );\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":440},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":880},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":433},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":433},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":433},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":433},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":27},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","module","submodules.rs"],"content":"use crate::{\n    ast::{\n        parse::*, ClusterDefinition, Colon, Comma, Delimited, Delimiter, DynToken, Eq, Ident,\n        KeyValueField, Keyword, Punctuated, SubmodulesToken, Token, TokenKind, TokenTree,\n    },\n    error::Result,\n    resource::Span,\n};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct SubmodulesStmt {\n    pub keyword: SubmodulesToken,\n    pub span: Span,\n    pub items: Punctuated\u003cSubmoduleDefinition, Comma\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct SubmoduleDefinition {\n    pub ident: Ident,\n    pub cluster: Option\u003cClusterDefinition\u003e,\n    pub colon: Colon,\n    pub typ: SubmoduleTyp,\n    pub dyn_spec: Option\u003cSubmoduleDynSpec\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum SubmoduleTyp {\n    Static(Ident),\n    Dynamic(DynToken, Ident),\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct SubmoduleDynSpec {\n    pub span: Span,\n    pub items: Punctuated\u003cKeyValueField\u003cIdent, Ident, Eq\u003e, Comma\u003e,\n}\n\n// # Impl\n\nimpl SubmoduleTyp {\n    pub fn raw(\u0026self) -\u003e String {\n        match self {\n            Self::Static(s) =\u003e s.raw.clone(),\n            Self::Dynamic(_, s) =\u003e s.raw.clone(),\n        }\n    }\n\n    pub fn is_dyn(\u0026self) -\u003e bool {\n        matches!(self, Self::Dynamic(_, _))\n    }\n}\n\n// # Spanning\n\nimpl Spanned for SubmodulesStmt {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\nimpl Spanned for SubmoduleDefinition {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(self.ident.span(), self.typ.span())\n    }\n}\n\nimpl Spanned for SubmoduleTyp {\n    fn span(\u0026self) -\u003e Span {\n        match self {\n            Self::Static(ident) =\u003e ident.span(),\n            Self::Dynamic(dyn_token, ident) =\u003e Span::fromto(dyn_token.span(), ident.span()),\n        }\n    }\n}\n\nimpl Spanned for SubmoduleDynSpec {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\n// # Parsing\n\nimpl Parse for SubmodulesStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let keyword = SubmodulesToken::parse(input)?;\n        let delim = Delimited::\u003cPunctuated\u003cSubmoduleDefinition, Comma\u003e\u003e::parse_from(\n            Delimiter::Brace,\n            input,\n        )?;\n        let span = Span::fromto(delim.delim_span.open, delim.delim_span.close);\n        Ok(SubmodulesStmt {\n            keyword,\n            span,\n            items: delim.inner,\n        })\n    }\n}\n\nimpl Parse for SubmoduleDefinition {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let ident = Ident::parse(input)?;\n        let cluster = Option::\u003cClusterDefinition\u003e::parse(input)?;\n        let colon = Colon::parse(input)?;\n        let typ = SubmoduleTyp::parse(input)?;\n        let dyn_spec = Option::\u003cSubmoduleDynSpec\u003e::parse(input)?;\n        Ok(SubmoduleDefinition {\n            ident,\n            cluster,\n            colon,\n            typ,\n            dyn_spec,\n        })\n    }\n}\n\nimpl Parse for SubmoduleTyp {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let peek = input.ts.peek();\n        match peek {\n            Some(TokenTree::Token(\n                Token {\n                    kind: TokenKind::Keyword(Keyword::Dyn),\n                    ..\n                },\n                _,\n            )) =\u003e {\n                let keyword = DynToken::parse(input)?;\n                let ident = Ident::parse(input)?;\n                Ok(Self::Dynamic(keyword, ident))\n            }\n            _ =\u003e Ok(Self::Static(Ident::parse(input)?)),\n        }\n    }\n}\n\nimpl Parse for Option\u003cSubmoduleDynSpec\u003e {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let delim =\n            Delimited::\u003cPunctuated\u003cKeyValueField\u003cIdent, Ident, Eq\u003e, Comma\u003e\u003e::parse_option_from(\n                Delimiter::Brace,\n                input,\n            )?;\n        if let Some(delim) = delim {\n            let span = delim.span();\n            Ok(Some(SubmoduleDynSpec {\n                span,\n                items: delim.inner,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::ast::TokenStream;\n    use crate::resource::SourceMap;\n\n    #[test]\n    fn single_submodules() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"submodules { parent: P, child: C }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = SubmodulesStmt::parse(\u0026buf).unwrap();\n        assert_eq!(\n            expr.items\n                .iter()\n                .cloned()\n                .map(|v| (\n                    v.ident.raw,\n                    v.typ.raw(),\n                    v.cluster.map(|v| format!(\"{}\", v.lit.kind))\n                ))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"parent\".to_string(), \"P\".to_string(), None),\n                (\"child\".to_string(), \"C\".to_string(), None),\n            ]\n        );\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"submodules { parent: P, child: _C, }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = SubmodulesStmt::parse(\u0026buf).unwrap();\n        assert_eq!(\n            expr.items\n                .iter()\n                .cloned()\n                .map(|v| (\n                    v.ident.raw,\n                    v.typ.raw(),\n                    v.cluster.map(|v| format!(\"{}\", v.lit.kind))\n                ))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"parent\".to_string(), \"P\".to_string(), None),\n                (\"child\".to_string(), \"_C\".to_string(), None),\n            ]\n        );\n    }\n\n    #[test]\n    fn clustered_submodules() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"submodules { parent[1]: P, child[\\\"str\\\"]: C }\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = SubmodulesStmt::parse(\u0026buf).unwrap();\n        assert_eq!(\n            expr.items\n                .iter()\n                .cloned()\n                .map(|v| (\n                    v.ident.raw,\n                    v.typ.raw(),\n                    v.cluster.map(|v| format!(\"{}\", v.lit.kind))\n                ))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"parent\".to_string(), \"P\".to_string(), Some(\"1\".to_string())),\n                (\n                    \"child\".to_string(),\n                    \"C\".to_string(),\n                    Some(\"\\\"str\\\"\".to_string())\n                ),\n            ]\n        );\n\n        // # Case 1\n        let asset = smap.load_raw(\"raw:case1\", \"submodules { parent[10]: P, child: _C, }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = SubmodulesStmt::parse(\u0026buf).unwrap();\n        assert_eq!(\n            expr.items\n                .iter()\n                .cloned()\n                .map(|v| (\n                    v.ident.raw,\n                    v.typ.raw(),\n                    v.cluster.map(|v| format!(\"{}\", v.lit.kind))\n                ))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\n                    \"parent\".to_string(),\n                    \"P\".to_string(),\n                    Some(\"10\".to_string())\n                ),\n                (\"child\".to_string(), \"_C\".to_string(), None),\n            ]\n        );\n    }\n\n    #[test]\n    fn dyn_submodules() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"submodules { parent: dyn P, child: C }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let expr = SubmodulesStmt::parse(\u0026buf).unwrap();\n        assert_eq!(\n            expr.items\n                .iter()\n                .cloned()\n                .map(|v| (\n                    v.ident.raw,\n                    v.typ.raw(),\n                    v.typ.is_dyn(),\n                    v.cluster.map(|v| format!(\"{}\", v.lit.kind))\n                ))\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                (\"parent\".to_string(), \"P\".to_string(), true, None),\n                (\"child\".to_string(), \"C\".to_string(), false, None)\n            ]\n        );\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":982},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":982},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":861},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":121},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":657},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1187},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":254},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":272},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":272},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":212},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":298},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":596},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":280},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":280},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":280},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":280},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":280},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":802},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":134},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":340},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":395},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":353},"fn_name":null}],"covered":48,"coverable":52},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","expr","module.rs"],"content":"use crate::{\n    ast::{\n        parse::*, Colon, Delimited, Delimiter, Ident, Joined, Keyword, ModuleToken, Plus, Token,\n        TokenKind, TokenStream, TokenTree,\n    },\n    error::*,\n    Span,\n};\n\nmod connections;\nmod gates;\nmod submodules;\n\npub use connections::*;\npub use gates::*;\npub use submodules::*;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ModuleStmt {\n    pub keyword: ModuleToken,\n    pub ident: Ident,\n    pub inheritance: Option\u003cModuleInheritance\u003e,\n    pub gates: Vec\u003cGatesStmt\u003e,\n    pub submodules: Vec\u003cSubmodulesStmt\u003e,\n    pub connections: Vec\u003cConnectionsStmt\u003e,\n    pub span: Span,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ModuleInheritance {\n    pub colon: Colon,\n    pub symbols: Joined\u003cIdent, Plus\u003e,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum ModuleTypus {\n    Primal,\n    Inherited,\n    Dynamic,\n}\n\nimpl ModuleStmt {\n    pub fn typus(\u0026self) -\u003e ModuleTypus {\n        if self.inheritance.is_some() {\n            return ModuleTypus::Inherited;\n        }\n        if self\n            .submodules\n            .iter()\n            .any(|st| st.items.iter().any(|s| s.typ.is_dyn()))\n        {\n            return ModuleTypus::Dynamic;\n        }\n        ModuleTypus::Primal\n    }\n}\n\nimpl Spanned for ModuleStmt {\n    fn span(\u0026self) -\u003e Span {\n        self.span\n    }\n}\n\nimpl Spanned for ModuleInheritance {\n    fn span(\u0026self) -\u003e Span {\n        Span::fromto(self.colon.span(), self.symbols.span())\n    }\n}\n\nimpl Parse for ModuleStmt {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let keyword = ModuleToken::parse(input)?;\n        let ident = Ident::parse(input).map_err(|e| {\n            let f = format!(\"{}\", e.internal);\n            e.override_internal(format!(\"unexpected token for module symbol: {f}\"))\n        })?;\n\n        let inheritance = Option::\u003cModuleInheritance\u003e::parse(input)?;\n        let delim = Delimited::\u003cTokenStream\u003e::parse_from(Delimiter::Brace, input)?;\n        let inner = ParseBuffer::new(input.asset, delim.inner);\n        let span = Span::fromto(keyword.span(), delim.delim_span.close);\n\n        let mut this = ModuleStmt {\n            keyword,\n            ident,\n            inheritance,\n            gates: Vec::new(),\n            submodules: Vec::new(),\n            connections: Vec::new(),\n            span,\n        };\n\n        while !inner.ts.is_empty() {\n            match inner.ts.peek() {\n                Some(TokenTree::Token(\n                    Token {\n                        kind: TokenKind::Keyword(Keyword::Gates),\n                        ..\n                    },\n                    _,\n                )) =\u003e this.gates.push(GatesStmt::parse(\u0026inner)?),\n\n                Some(TokenTree::Token(\n                    Token {\n                        kind: TokenKind::Keyword(Keyword::Submodules),\n                        ..\n                    },\n                    _,\n                )) =\u003e this.submodules.push(SubmodulesStmt::parse(\u0026inner)?),\n\n                Some(TokenTree::Token(\n                    Token {\n                        kind: TokenKind::Keyword(Keyword::Connections),\n                        ..\n                    },\n                    _,\n                )) =\u003e this.connections.push(ConnectionsStmt::parse(\u0026inner)?),\n\n                Some(other) =\u003e {\n                    return Err(Error::new(\n                        ErrorKind::ExpectedInModuleKeyword,\n                        \"expected keyword 'gates', 'submodules' or 'connections'\",\n                    )\n                    .spanned(other.span()))\n                }\n                None =\u003e unreachable!(),\n            }\n        }\n\n        Ok(this)\n    }\n}\n\nimpl Parse for Option\u003cModuleInheritance\u003e {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        let colon = match Colon::parse(input) {\n            Ok(v) =\u003e v,\n            Err(_) =\u003e return Ok(None),\n        };\n\n        let symbols = Joined::\u003cIdent, Plus\u003e::parse(input)?;\n        Ok(Some(ModuleInheritance { colon, symbols }))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::SourceMap;\n\n    #[test]\n    fn empty_module() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"module A {}\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ModuleStmt::parse(\u0026buf).unwrap();\n        assert_eq!(stmt.ident, \"A\");\n        assert_eq!(stmt.gates, vec![]);\n        assert_eq!(stmt.submodules, vec![]);\n        assert_eq!(stmt.connections, vec![]);\n    }\n\n    #[test]\n    fn keyword_triggered_modules() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\n            \"raw:case0\",\n            \"module A { gates {} connections {} submodules {}}\",\n        );\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ModuleStmt::parse(\u0026buf).unwrap();\n        assert_eq!(stmt.ident, \"A\");\n        assert!(stmt.gates.len() \u003e 0);\n        assert!(stmt.submodules.len() \u003e 0);\n        assert!(stmt.connections.len() \u003e 0);\n    }\n\n    #[test]\n    fn invalid_tokens() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"module A { 123 }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let _stmt = ModuleStmt::parse(\u0026buf).unwrap_err();\n    }\n\n    #[test]\n    fn inheritance() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let asset = smap.load_raw(\"raw:case0\", \"module A: B + C { }\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = ModuleStmt::parse(\u0026buf).unwrap();\n        assert!(stmt.inheritance.is_some())\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":91},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":91},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":786},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1572},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":786},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":774},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":768},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1339},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":620},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":253},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":311},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":91},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":719},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":774},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":901},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":647},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":121},"fn_name":null}],"covered":35,"coverable":35},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","mod.rs"],"content":"pub(crate) mod expr;\npub(crate) mod parse;\npub(crate) mod token;\npub(crate) mod validate;\n\npub use expr::*;\npub use parse::*;\npub use token::*;\npub use validate::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","parse","buffer.rs"],"content":"use std::borrow::Borrow;\n\nuse super::{cursor::Cursor, *};\nuse crate::{ast::TokenStream, Asset};\n\npub type ParseStream\u003c'a\u003e = \u0026'a ParseBuffer\u003c'a\u003e;\n\n#[derive(Debug)]\npub struct ParseBuffer\u003c'a\u003e {\n    pub asset: Asset\u003c'a\u003e,\n    pub ts: Cursor,\n}\n\nimpl\u003c'a\u003e ParseBuffer\u003c'a\u003e {\n    pub fn new(asset: Asset\u003c'a\u003e, ts: impl Borrow\u003cTokenStream\u003e) -\u003e Self {\n        Self {\n            asset,\n            ts: Cursor::new(ts.borrow()),\n        }\n    }\n\n    pub fn parse\u003cT: Parse\u003e(\u0026self) -\u003e Result\u003cT\u003e {\n        T::parse(self)\n    }\n\n    pub fn call\u003cT\u003e(\u0026self, f: fn(ParseStream\u003c'_\u003e) -\u003e Result\u003cT\u003e) -\u003e Result\u003cT\u003e {\n        f(self)\n    }\n\n    pub fn substream(\u0026self) -\u003e Option\u003cParseBuffer\u003c'a\u003e\u003e {\n        let ts = self.ts.subcursor()?;\n        Some(Self {\n            ts,\n            asset: self.asset,\n        })\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":1274},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1274},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3784},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":11},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","parse","cursor.rs"],"content":"use std::{cell::Cell, sync::Arc};\n\nuse crate::{\n    ast::token::{TokenStream, TokenTree},\n    Span,\n};\n\n#[derive(Debug)]\npub struct Cursor {\n    ts: Arc\u003cVec\u003cTokenTree\u003e\u003e,\n    idx: Cell\u003cusize\u003e,\n}\n\nimpl Cursor {\n    pub(crate) fn new(ts: \u0026TokenStream) -\u003e Self {\n        Self {\n            ts: ts.items.clone(),\n            idx: Cell::new(0),\n        }\n    }\n\n    pub(crate) fn raw(\u0026self) -\u003e Arc\u003cVec\u003cTokenTree\u003e\u003e {\n        self.ts.clone()\n    }\n\n    pub(crate) fn state(\u0026self) -\u003e usize {\n        self.idx.get()\n    }\n\n    pub(crate) fn set_state(\u0026self, state: usize) {\n        self.idx.set(state);\n    }\n\n    pub(crate) fn is_empty(\u0026self) -\u003e bool {\n        self.idx.get() \u003e= self.ts.len()\n    }\n\n    pub(crate) fn peek(\u0026self) -\u003e Option\u003c\u0026TokenTree\u003e {\n        if self.idx.get() \u003e= self.ts.len() {\n            None\n        } else {\n            Some(\u0026self.ts[self.idx.get()])\n        }\n    }\n\n    // pub(crate) fn next(\u0026self) -\u003e Option\u003c\u0026TokenTree\u003e {\n    //     if self.idx.get() \u003e= self.ts.len() {\n    //         None\n    //     } else {\n    //         self.bump();\n    //         Some(\u0026self.ts[self.idx.get() - 1])\n    //     }\n    // }\n\n    pub(crate) fn last_span(\u0026self) -\u003e Span {\n        self.ts.last().unwrap().span()\n    }\n\n    pub(crate) fn bump(\u0026self) {\n        self.idx.set(self.idx.get() + 1)\n    }\n\n    pub(crate) fn subcursor(\u0026self) -\u003e Option\u003cCursor\u003e {\n        let cur = \u0026self.ts.get(self.idx.get())?;\n        let TokenTree::Delimited(_, _, sub) = cur else {\n            return None;\n        };\n        Some(Cursor::new(sub))\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":3166},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":3166},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3166},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1359},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1359},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":163},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":163},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":7385},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":7385},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":17734},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":17734},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":310},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":17424},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":12163},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":12163},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3784},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null}],"covered":23,"coverable":24},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","parse","mod.rs"],"content":"mod buffer;\nmod cursor;\n\nuse crate::error::*;\nuse crate::Span;\n\npub use buffer::*;\n\npub trait Parse: Sized {\n    fn parse(input: ParseStream\u003c'_\u003e) -\u003e Result\u003cSelf\u003e;\n}\n\npub trait Spanned {\n    fn span(\u0026self) -\u003e Span;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","token","cursor.rs"],"content":"use crate::{\n    error::*,\n    lexer::{Token, TokenKind},\n    Asset, Span,\n};\n\nuse super::Delimiter;\n\n#[derive(Debug)]\npub(super) struct Cursor\u003c'a\u003e {\n    pub(super) ts: \u0026'a [Token],\n    pub(super) idx: usize,\n    pub(super) span_pos: usize,\n\n    pub(super) asset: \u0026'a Asset\u003c'a\u003e,\n}\n\nimpl Cursor\u003c'_\u003e {\n    pub(super) fn extract_subcursor(\u0026mut self, delim: Delimiter) -\u003e Result\u003cCursor\u003c'_\u003e\u003e {\n        let start = self.idx;\n        let start_span = self.span_pos;\n\n        let mut c = 1;\n        while c \u003e 0 \u0026\u0026 self.idx \u003c self.ts.len() {\n            let k = self.ts[self.idx].kind;\n            if k == delim.open() {\n                c += 1;\n            }\n            if k == delim.close() {\n                c -= 1;\n            }\n\n            self.span_pos += self.ts[self.idx].len;\n            self.idx += 1;\n        }\n\n        if c == 0 {\n            Ok(Cursor {\n                ts: \u0026self.ts[start..(self.idx - 1)],\n                idx: 0,\n                span_pos: start_span,\n                asset: self.asset,\n            })\n        } else {\n            Err(Error::new(ErrorKind::MissingDelim, \"missing delim\"))\n        }\n    }\n\n    pub(super) fn end_span(\u0026self) -\u003e Span {\n        assert!(self.is_done());\n        Span::new(self.span_pos, 1)\n    }\n\n    // pub(super) fn rem_stream_span(\u0026self) -\u003e Span {\n    //     Span::new(self.span_pos, self.rem_stream_len())\n    // }\n\n    // pub(super) fn rem_stream_len(\u0026self) -\u003e usize {\n    //     let mut len = 0;\n    //     for token in \u0026self.ts[self.idx..] {\n    //         len += token.len;\n    //     }\n    //     len\n    // }\n}\n\nimpl\u003c'a\u003e Cursor\u003c'a\u003e {\n    pub(super) fn new(ts: \u0026'a [Token], span_pos: usize, asset: \u0026'a Asset\u003c'a\u003e) -\u003e Self {\n        Self {\n            ts,\n            span_pos,\n            idx: 0,\n            asset,\n        }\n    }\n\n    pub(super) fn is_done(\u0026self) -\u003e bool {\n        self.idx == self.ts.len()\n    }\n\n    pub(super) fn next(\u0026mut self) -\u003e Option\u003c(Token, Span)\u003e {\n        if self.idx \u003e= self.ts.len() {\n            None\n        } else {\n            let token = self.ts[self.idx];\n            let span = Span::new(self.span_pos, token.len);\n            self.bump(1);\n            Some((token, span))\n        }\n    }\n\n    pub(super) fn bump(\u0026mut self, n: usize) {\n        for _ in 0..n {\n            self.span_pos += self.ts[self.idx].len;\n            self.idx += 1;\n        }\n    }\n\n    // pub(super) fn bump_back(\u0026mut self, n: usize) {\n    //     for _ in 0..n {\n    //         self.idx -= 1;\n    //         self.span_pos -= self.ts[self.idx].len;\n    //     }\n    // }\n\n    pub(super) fn peek(\u0026self, offset: usize) -\u003e Option\u003cToken\u003e {\n        let idx = self.idx + offset;\n        if idx \u003e= self.ts.len() {\n            None\n        } else {\n            Some(self.ts[idx])\n        }\n    }\n\n    pub(super) fn eat_while(\u0026mut self, f: impl Fn(\u0026Token) -\u003e bool) -\u003e usize {\n        let mut c = 0;\n        while self.idx \u003c self.ts.len() \u0026\u0026 f(\u0026self.ts[self.idx]) {\n            self.bump(1);\n            c += 1;\n        }\n        c\n    }\n\n    pub(super) fn eat_whitespace(\u0026mut self) -\u003e usize {\n        self.eat_while(|t| t.kind == TokenKind::Whitespace)\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":53376},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":26405},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":703},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":28373},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2671},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1968},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1968},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1968},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1968},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1968},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1966},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1966},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1966},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":521},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":17310},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":17310},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":13597},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":13597},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":13597},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":13597},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":13597},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":13597},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":23403},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":46806},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":23403},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":23403},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":703},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":703},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":703},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":703},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":28203},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":28203},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":83321},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":9800},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":9800},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":28203},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":28203},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":91924},"fn_name":null}],"covered":47,"coverable":49},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","token","mod.rs"],"content":"use std::fmt;\n\nuse self::cursor::Cursor;\nuse crate::{\n    error::{Error, ErrorKind},\n    lexer::{self, tokenize, LiteralKind},\n    Asset, Span,\n};\n\npub use stream::DelimSpan;\npub use stream::Spacing;\npub use stream::TokenStream;\npub use stream::TokenTree;\n\nmod cursor;\nmod stream;\nmod symbol;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Token {\n    pub kind: TokenKind,\n    pub span: Span,\n}\n\nimpl Token {\n    pub(super) fn new(kind: TokenKind, span: Span) -\u003e Token {\n        Token { kind, span }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum TokenKind {\n    Lt,\n    Le,\n    Gt,\n    Ge,\n    Eq,\n    EqEq,\n    Dot,\n    DotDot,\n    DotDotDot,\n    DotDotEq,\n    Comma,\n    Minus,\n    Plus,\n    Semi,\n    LDoubleArrow,\n    RDoubleArrow,\n    LSingleArrow,\n    RSingleArrow,\n    LSingleArrowR,\n    Colon,\n    Slash,\n    Keyword(Keyword),\n    OpenDelim(Delimiter),\n    CloseDelim(Delimiter),\n    Literal(Lit),\n    Ident(Ident),\n    Annotation(Annotation),\n}\n\nimpl TokenKind {\n    fn ident_or_keyword(span: Span, cursor: \u0026mut Cursor) -\u003e TokenKind {\n        let ident = Ident::from_span(span, cursor);\n        match \u0026ident.raw[..] {\n            \"module\" =\u003e TokenKind::Keyword(Keyword::Module),\n            \"gates\" =\u003e TokenKind::Keyword(Keyword::Gates),\n            \"submodules\" =\u003e TokenKind::Keyword(Keyword::Submodules),\n            \"connections\" =\u003e TokenKind::Keyword(Keyword::Connections),\n            \"link\" =\u003e TokenKind::Keyword(Keyword::Link),\n            \"include\" =\u003e TokenKind::Keyword(Keyword::Include),\n            \"entry\" =\u003e TokenKind::Keyword(Keyword::Entry),\n            \"dyn\" =\u003e TokenKind::Keyword(Keyword::Dyn),\n            _ =\u003e TokenKind::Ident(ident),\n        }\n    }\n\n    pub fn token_kind_err_output(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Lt =\u003e \"'\u003c'\",\n            Self::Le =\u003e \"'\u003c='\",\n            Self::Gt =\u003e \"'\u003e'\",\n            Self::Ge =\u003e \"'\u003e='\",\n            Self::Eq =\u003e \"'='\",\n            Self::EqEq =\u003e \"'=='\",\n            Self::Dot =\u003e \"'.'\",\n            Self::DotDot =\u003e \"'..'\",\n            Self::DotDotDot =\u003e \"'...'\",\n            Self::DotDotEq =\u003e \"'..='\",\n            Self::Comma =\u003e \"','\",\n            Self::Minus =\u003e \"'-'\",\n            Self::Plus =\u003e \"'+'\",\n            Self::Semi =\u003e \"';'\",\n            Self::LDoubleArrow =\u003e \"'\u003c==''\",\n            Self::RDoubleArrow =\u003e \"'==\u003e'\",\n            Self::LSingleArrow =\u003e \"'\u003c--''\",\n            Self::RSingleArrow =\u003e \"'--\u003e'\",\n            Self::LSingleArrowR =\u003e \"'\u003c--\u003e'\",\n            Self::Colon =\u003e \"':'\",\n            Self::Slash =\u003e \"'/'\",\n            Self::Keyword(keyword) =\u003e keyword.token_kind_err_output(),\n            Self::OpenDelim(_) =\u003e \"\u003copen_delim\u003e\",\n            Self::CloseDelim(_) =\u003e \"\u003cclose_delim\u003e\",\n            Self::Literal(_) =\u003e \"\u003cliteral\u003e\",\n            Self::Ident(_) =\u003e \"\u003cident\u003e\",\n            Self::Annotation(_) =\u003e \"\u003cannotation\u003e\",\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Keyword {\n    Module,\n    Gates,\n    Submodules,\n    Connections,\n    Link,\n    Include,\n    Entry,\n    Dyn,\n}\n\nimpl Keyword {\n    fn token_kind_err_output(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Module =\u003e \"'module'\",\n            Self::Gates =\u003e \"'gates'\",\n            Self::Submodules =\u003e \"'submodules'\",\n            Self::Connections =\u003e \"'connections'\",\n            Self::Link =\u003e \"'link'\",\n            Self::Include =\u003e \"'include'\",\n            Self::Entry =\u003e \"'entry'\",\n            Self::Dyn =\u003e \"'dyn'\",\n        }\n    }\n}\n\nimpl fmt::Display for Keyword {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.token_kind_err_output())\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n\npub enum Delimiter {\n    Parenthesis,\n    Brace,\n    Bracket,\n    Invisible,\n}\n\nimpl Delimiter {\n    fn from(kind: lexer::TokenKind) -\u003e Self {\n        match kind {\n            lexer::TokenKind::OpenParen =\u003e Delimiter::Parenthesis,\n            lexer::TokenKind::OpenBrace =\u003e Delimiter::Brace,\n            lexer::TokenKind::OpenBracket =\u003e Delimiter::Bracket,\n            _ =\u003e unimplemented!(),\n        }\n    }\n\n    fn open(\u0026self) -\u003e lexer::TokenKind {\n        match self {\n            Delimiter::Parenthesis =\u003e lexer::TokenKind::OpenParen,\n            Delimiter::Brace =\u003e lexer::TokenKind::OpenBrace,\n            Delimiter::Bracket =\u003e lexer::TokenKind::OpenBracket,\n            _ =\u003e unimplemented!(),\n        }\n    }\n\n    fn close(\u0026self) -\u003e lexer::TokenKind {\n        match self {\n            Delimiter::Parenthesis =\u003e lexer::TokenKind::CloseParen,\n            Delimiter::Brace =\u003e lexer::TokenKind::CloseBrace,\n            Delimiter::Bracket =\u003e lexer::TokenKind::CloseBracket,\n            _ =\u003e unimplemented!(),\n        }\n    }\n}\n\nimpl fmt::Display for Delimiter {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Self::Parenthesis =\u003e write!(f, \"( ... )\"),\n            Self::Brace =\u003e write!(f, \"{{ ... }}\"),\n            Self::Bracket =\u003e write!(f, \"[ ... ]\"),\n            Self::Invisible =\u003e write!(f, \"...\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum LitKind {\n    Integer { lit: i32 },\n    Float { lit: f64 },\n    Str { lit: String },\n}\n\nimpl LitKind {\n    pub(super) fn typ(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Integer { .. } =\u003e \"integer\",\n            Self::Float { .. } =\u003e \"float\",\n            Self::Str { .. } =\u003e \"string\",\n        }\n    }\n}\n\nimpl fmt::Display for LitKind {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Self::Integer { lit } =\u003e write!(f, \"{}\", lit),\n            Self::Float { lit } =\u003e write!(f, \"{:.1}\", lit),\n            Self::Str { lit } =\u003e write!(f, \"\\\"{}\\\"\", lit),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Lit {\n    pub kind: LitKind,\n    pub span: Span,\n}\n\nimpl Lit {\n    fn from_span(kind: LiteralKind, span: Span, cursor: \u0026Cursor) -\u003e Result\u003cSelf, Error\u003e {\n        let source = cursor.asset.slice_for(span);\n        match kind {\n            LiteralKind::Int { .. } =\u003e Ok(Lit {\n                kind: LitKind::Integer {\n                    lit: source\n                        .parse()\n                        .map_err(|e| Error::new(ErrorKind::ParseLitError, e))?,\n                },\n                span,\n            }),\n            LiteralKind::Float { .. } =\u003e Ok(Lit {\n                kind: LitKind::Float {\n                    lit: source\n                        .parse()\n                        .map_err(|e| Error::new(ErrorKind::ParseLitError, e))?,\n                },\n                span,\n            }),\n            LiteralKind::Str { .. } =\u003e Ok(Lit {\n                kind: LitKind::Str {\n                    lit: source\n                        .trim_start_matches('\"')\n                        .trim_end_matches('\"')\n                        .to_string(),\n                },\n                span,\n            }),\n        }\n    }\n\n    pub fn as_float(\u0026self) -\u003e f64 {\n        match self.kind {\n            LitKind::Float { lit } =\u003e lit,\n            _ =\u003e panic!(\"unexpected cast\"),\n        }\n    }\n\n    pub fn as_integer(\u0026self) -\u003e i32 {\n        match self.kind {\n            LitKind::Integer { lit } =\u003e lit,\n            _ =\u003e panic!(\"unexpected cast\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Ident {\n    pub raw: String,\n    pub span: Span,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Annotation {\n    pub raw: String,\n    pub span: Span,\n}\n\nimpl Ident {\n    fn from_span(span: Span, cursor: \u0026Cursor) -\u003e Self {\n        Self {\n            raw: cursor.asset.slice_for(span).to_string(),\n            span,\n        }\n    }\n}\n\nimpl AsRef\u003cstr\u003e for Ident {\n    fn as_ref(\u0026self) -\u003e \u0026str {\n        self.raw.as_ref()\n    }\n}\n\nimpl PartialEq\u003c\u0026str\u003e for Ident {\n    fn eq(\u0026self, other: \u0026\u0026str) -\u003e bool {\n        \u0026self.raw == other\n    }\n}\n\nimpl Annotation {\n    fn from_span(span: Span, cursor: \u0026Cursor) -\u003e Self {\n        Self {\n            raw: cursor\n                .asset\n                .slice_for(span)\n                .trim_start_matches('@')\n                .to_string(),\n            span,\n        }\n    }\n}\n\nimpl PartialEq\u003c\u0026str\u003e for Annotation {\n    fn eq(\u0026self, other: \u0026\u0026str) -\u003e bool {\n        \u0026self.raw == other\n    }\n}\n\n// # main\n\nimpl TokenStream {\n    pub fn new(asset: Asset) -\u003e Result\u003cTokenStream, Error\u003e {\n        let ts = tokenize(asset.source(), 0).collect::\u003cVec\u003c_\u003e\u003e();\n        let mut cursor = Cursor::new(\u0026ts, asset.source_span().pos, \u0026asset);\n\n        TokenStream::parse(\u0026mut cursor)\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":10889},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":7349},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":5992},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":5790},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":5297},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":5288},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":4933},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":5062},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":4523},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":4389},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1549},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1549},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":111},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":767},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":139},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1701},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":262},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":25038},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":578},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":25702},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":25038},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":578},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":831},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":831},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":831},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":726},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":138},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":138},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":521},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":521},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":521},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":521},"fn_name":null}],"covered":95,"coverable":125},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","token","stream.rs"],"content":"use super::{Cursor, Delimiter, Token};\nuse crate::{\n    ast::{token::TokenKind, Lit},\n    error::{Error, ErrorKind},\n    lexer::{self, LiteralKind},\n    Span,\n};\nuse std::sync::Arc;\n\n#[derive(Debug, Clone)]\npub struct TokenStream {\n    pub items: Arc\u003cVec\u003cTokenTree\u003e\u003e,\n}\n\n#[derive(Debug, Clone)]\npub enum TokenTree {\n    Token(Token, Spacing),\n    Delimited(DelimSpan, Delimiter, TokenStream),\n}\n\nimpl TokenTree {\n    pub fn span(\u0026self) -\u003e Span {\n        match self {\n            Self::Token(token, _) =\u003e token.span,\n            Self::Delimited(delim, _, _) =\u003e Span::fromto(delim.open, delim.close),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Spacing {\n    Alone,\n    Joint,\n}\n\nimpl Spacing {\n    fn infer(token: lexer::TokenKind, next: lexer::TokenKind) -\u003e Spacing {\n        use lexer::TokenKind::*;\n        match (token, next) {\n            (Eq, Eq) =\u003e Spacing::Joint,\n            (Plus, Eq) | (Minus, Eq) | (Star, Eq) | (Slash, Eq) =\u003e Spacing::Joint,\n            _ =\u003e Spacing::Alone,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct DelimSpan {\n    pub open: Span,\n    pub close: Span,\n}\n\nimpl TokenStream {\n    pub(super) fn parse(cursor: \u0026mut Cursor) -\u003e Result\u003cTokenStream, Error\u003e {\n        let mut items = Vec::new();\n        loop {\n            cursor.eat_whitespace();\n            if cursor.is_done() {\n                return Ok(Self {\n                    items: Arc::new(items),\n                });\n            }\n\n            let Some(tree) = TokenTree::parse(cursor)? else {\n                return Ok(Self {\n                    items: Arc::new(items),\n                });\n            };\n            items.push(tree);\n        }\n    }\n}\n\nimpl TokenTree {\n    pub(super) fn parse(cursor: \u0026mut Cursor) -\u003e Result\u003cOption\u003cTokenTree\u003e, Error\u003e {\n        cursor.eat_whitespace();\n\n        // let span = cursor.rem_stream_span();\n        // println!(\"[TokenTree]\\n{}\", cursor.asset.slice_for(span));\n\n        // will not be a whitespace\n        let Some((mut token, mut span)) = cursor.next() else {\n            unimplemented!()\n        };\n\n        if token.kind.is_delim_open() {\n            let delim = Delimiter::from(token.kind);\n            let open = span;\n\n            let mut sub = cursor.extract_subcursor(delim)?;\n            let ts = TokenStream::parse(\u0026mut sub)?;\n            let close = sub.end_span();\n\n            Ok(TokenTree::Delimited(DelimSpan { open, close }, delim, ts).into())\n        } else {\n            use crate::lexer::TokenKind::*;\n\n            loop {\n                // normal token\n                return match token.kind {\n                    Dot =\u003e {\n                        // Check for second dot\n                        let Some(next) = cursor.peek(0) else {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::Dot, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        };\n\n                        if next.kind != Dot {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::Dot, span),\n                                Spacing::infer(token.kind, next.kind),\n                            )\n                            .into());\n                        }\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        // check for third dot.\n                        let Some(next) = cursor.peek(0) else {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::DotDot, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        };\n\n                        if next.kind == Eq {\n                            let (_, s) = cursor.next().unwrap();\n                            span = Span::fromto(span, s);\n\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::DotDotEq, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        }\n\n                        if next.kind != Dot {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::DotDot, span),\n                                Spacing::infer(token.kind, next.kind),\n                            )\n                            .into());\n                        }\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        Ok(\n                            TokenTree::Token(\n                                Token::new(TokenKind::DotDotDot, span),\n                                Spacing::Alone,\n                            )\n                            .into(),\n                        )\n                    }\n\n                    Colon =\u003e Ok(TokenTree::Token(\n                        Token::new(TokenKind::Colon, span),\n                        Spacing::Alone,\n                    )\n                    .into()),\n                    Slash =\u003e Ok(TokenTree::Token(\n                        Token::new(TokenKind::Slash, span),\n                        Spacing::Alone,\n                    )\n                    .into()),\n                    Semi =\u003e Ok(\n                        TokenTree::Token(Token::new(TokenKind::Semi, span), Spacing::Alone).into(),\n                    ),\n                    Comma =\u003e Ok(TokenTree::Token(\n                        Token::new(TokenKind::Comma, span),\n                        Spacing::Alone,\n                    )\n                    .into()),\n\n                    Plus =\u003e Ok(\n                        TokenTree::Token(Token::new(TokenKind::Plus, span), Spacing::Alone).into(),\n                    ),\n\n                    Eq =\u003e {\n                        if cursor.peek(0).map(|t| t.kind) != Some(Eq) {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::Eq, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        }\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        if cursor.peek(0).map(|t| t.kind) != Some(Gt) {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::EqEq, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        }\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        Ok(TokenTree::Token(\n                            Token::new(TokenKind::RDoubleArrow, span),\n                            Spacing::Alone,\n                        )\n                        .into())\n                    }\n\n                    Minus =\u003e {\n                        if cursor.peek(0).map(|t| t.kind) != Some(Minus) {\n                            if let Some(lexer::Token {\n                                kind: Literal { kind, .. },\n                                len,\n                            }) = cursor.peek(0)\n                            {\n                                if matches!(\n                                    kind,\n                                    LiteralKind::Int { .. } | LiteralKind::Float { .. }\n                                ) {\n                                    span = Span::new(span.pos, span.len + len);\n                                    cursor.bump(1);\n                                    let lit = Lit::from_span(kind, span, cursor)?;\n                                    return Ok(TokenTree::Token(\n                                        Token::new(TokenKind::Literal(lit), span),\n                                        Spacing::Alone,\n                                    )\n                                    .into());\n                                }\n                            }\n\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::Minus, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        }\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        if cursor.peek(0).map(|t| t.kind) != Some(Gt) {\n                            unimplemented!(\"-- without --\u003e\")\n                        }\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        Ok(TokenTree::Token(\n                            Token::new(TokenKind::RSingleArrow, span),\n                            Spacing::Alone,\n                        )\n                        .into())\n                    }\n                    Lt =\u003e match cursor.peek(0).map(|t| t.kind) {\n                        Some(Eq) =\u003e {\n                            let (_, s) = cursor.next().unwrap();\n                            span = Span::fromto(span, s);\n\n                            if cursor.peek(0).map(|t| t.kind) != Some(Eq) {\n                                return Ok(TokenTree::Token(\n                                    Token::new(TokenKind::Le, span),\n                                    Spacing::Alone,\n                                )\n                                .into());\n                            }\n\n                            let (_, s) = cursor.next().unwrap();\n                            span = Span::fromto(span, s);\n\n                            Ok(TokenTree::Token(\n                                Token::new(TokenKind::LDoubleArrow, span),\n                                Spacing::Alone,\n                            )\n                            .into())\n                        }\n                        Some(Minus) =\u003e {\n                            let (_, s) = cursor.next().unwrap();\n                            span = Span::fromto(span, s);\n\n                            if cursor.peek(0).map(|t| t.kind) != Some(Minus) {\n                                unimplemented!(\"\u003c- but not \u003c--\")\n                            }\n\n                            let (_, s) = cursor.next().unwrap();\n                            span = Span::fromto(span, s);\n\n                            if cursor.peek(0).map(|t| t.kind) == Some(Gt) {\n                                let (_, s) = cursor.next().unwrap();\n                                span = Span::fromto(span, s);\n                                Ok(TokenTree::Token(\n                                    Token::new(TokenKind::LSingleArrowR, span),\n                                    Spacing::Alone,\n                                )\n                                .into())\n                            } else {\n                                Ok(TokenTree::Token(\n                                    Token::new(TokenKind::LSingleArrow, span),\n                                    Spacing::Alone,\n                                )\n                                .into())\n                            }\n                        }\n                        _ =\u003e Ok(\n                            TokenTree::Token(Token::new(TokenKind::Lt, span), Spacing::Alone)\n                                .into(),\n                        ),\n                    },\n                    Gt =\u003e {\n                        if cursor.peek(0).map(|t| t.kind) != Some(Eq) {\n                            return Ok(TokenTree::Token(\n                                Token::new(TokenKind::Gt, span),\n                                Spacing::Alone,\n                            )\n                            .into());\n                        };\n\n                        let (_, s) = cursor.next().unwrap();\n                        span = Span::fromto(span, s);\n\n                        Ok(\n                            TokenTree::Token(Token::new(TokenKind::Ge, span), Spacing::Alone)\n                                .into(),\n                        )\n                    }\n\n                    OpenBrace | OpenBracket | OpenParen =\u003e {\n                        unreachable!(\"\")\n                    }\n                    CloseBrace | CloseBracket | CloseParen =\u003e Err(Error::new(\n                        ErrorKind::MissingDelim,\n                        format!(\"missing opening delimiter for {:?}\", token),\n                    )),\n\n                    Ident =\u003e Ok(TokenTree::Token(\n                        Token::new(TokenKind::ident_or_keyword(span, cursor), span),\n                        Spacing::Alone,\n                    )\n                    .into()),\n                    Annotation =\u003e Ok(TokenTree::Token(\n                        Token::new(\n                            TokenKind::Annotation(super::Annotation::from_span(span, cursor)),\n                            span,\n                        ),\n                        Spacing::Alone,\n                    )\n                    .into()),\n\n                    Literal { kind, .. } =\u003e Ok(TokenTree::Token(\n                        Token::new(\n                            TokenKind::Literal(super::Lit::from_span(kind, span, cursor)?),\n                            span,\n                        ),\n                        Spacing::Alone,\n                    )\n                    .into()),\n\n                    Comment | Whitespace =\u003e {\n                        match cursor.next() {\n                            Some(value) =\u003e (token, span) = value,\n                            None =\u003e {\n                                return Ok(None);\n                            }\n                        }\n                        continue;\n                    }\n\n                    _ =\u003e unimplemented!(\"missing parser for {token:?}\"),\n                };\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{SourceMap, ast::token};\n    use super::*;\n\n    #[test]\n    fn recognize_arrows() {\n        let mut smap = SourceMap::new();\n        let asset = smap.load_raw(\n            \"raw:token:0\",\n            \"module A {{\n            connections {{\n                a \u003c--\u003e b,\n                c \u003c-- Link --\u003e d\n            }}\n        }}\",\n        );\n\n        let ts = TokenStream::new(asset).unwrap();\n        let TokenTree::Delimited(_, _, ref module_stmt) = ts.items[2] else {\n            unreachable!()\n        };\n        let TokenTree::Delimited(_, _, ref module_stmt) = module_stmt.items[0] else {\n            unreachable!()\n        };\n\n        dbg!(module_stmt);\n\n        let TokenTree::Delimited(_, _, ref conn_stmt) = module_stmt.items[1] else {\n            unreachable!()\n        };\n\n        let TokenTree::Delimited(_, _, ref list) = conn_stmt.items[0] else {\n            unreachable!()\n        };\n\n\n        let TokenTree::Token(ref arrow, _) = list.items[1] else {\n            unreachable!()\n        };\n        assert_eq!(arrow.kind, token::TokenKind::LSingleArrowR);\n\n        let TokenTree::Token(ref arrow, _) = list.items[5] else {\n            unreachable!()\n        };\n        assert_eq!(arrow.kind, token::TokenKind::LSingleArrow);\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":990},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":990},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2489},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2489},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":15344},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":15344},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2485},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2485},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":12859},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":12855},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":12859},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":12859},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":25718},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1970},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3940},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1968},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1966},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1966},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":11047},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":11047},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1218},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1218},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1218},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1218},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":411},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":411},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1229},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1229},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1229},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1229},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":141},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":228},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":140},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":825},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":825},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":825},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":825},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":825},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":825},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":158},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":158},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":158},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":101,"coverable":195},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","token","symbol.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","validate","blanket.rs"],"content":"use super::*;\nuse crate::ast::{EntryStmt, IncludeStmt};\n\nimpl Validate for IncludeStmt {\n    fn validate(\u0026self, _: \u0026mut ErrorsMut) {}\n}\n\nimpl Validate for EntryStmt {\n    fn validate(\u0026self, _: \u0026mut ErrorsMut) {}\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":252},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","validate","items.rs"],"content":"use super::*;\nuse crate::ast::{File, Item, Spanned};\n\nimpl Validate for File {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        let mut symbols = Vec::with_capacity(self.items.len());\n        for item in self.items.iter() {\n            // (0) Internal validation\n            item.validate(errors);\n\n            // (1) Symbol duplication\n            if let Some(symbol) = item.symbol() {\n                if symbols.contains(\u0026\u0026symbol.raw) {\n                    errors.add(\n                        Error::new(\n                            ErrorKind::SymbolDuplication,\n                            format!(\n                                \"cannot create new symbol '{}', was allready defined\",\n                                symbol.raw\n                            ),\n                        )\n                        .spanned(item.span()),\n                    )\n                } else {\n                    symbols.push(\u0026symbol.raw)\n                }\n            }\n        }\n    }\n}\n\nimpl Validate for Item {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        match self {\n            Self::Entry(entry) =\u003e entry.validate(errors),\n            Self::Include(include) =\u003e include.validate(errors),\n            Self::Link(link) =\u003e link.validate(errors),\n            Self::Module(module) =\u003e module.validate(errors),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::{Parse, ParseBuffer, TokenStream},\n        SourceMap,\n    };\n\n    use super::*;\n\n    #[test]\n    fn symbol_dupliaction() {\n        let mut smap = SourceMap::new();\n\n        let asset = smap.load_raw(\"raw:case0\", \"module A {} module B {} module A {}\");\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n\n        let stmt = File::parse(\u0026buf).unwrap();\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n\n        assert_eq!(errors.len(), 1);\n        assert_eq!(errors.get(0).unwrap().kind, ErrorKind::SymbolDuplication);\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":337},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":337},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":1516},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":1179},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":2028},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":842},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1179},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1179},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":669},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","validate","link.rs"],"content":"use super::*;\nuse crate::ast::{LinkData, LinkInheritance, LinkStmt, LitKind, Spanned};\n\nimpl Validate for LinkStmt {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        if let Some(ref inh) = self.inheritance {\n            inh.validate(errors)\n        }\n        self.data.validate(errors);\n    }\n}\n\nimpl Validate for LinkInheritance {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        let mut symbols = Vec::with_capacity(self.symbols.len());\n        for symbol in self.symbols.iter() {\n            if symbols.contains(\u0026\u0026symbol.raw) {\n                errors.add(\n                    Error::new(\n                        ErrorKind::LinkInheritanceDuplicatedSymbols,\n                        format!(\n                            \"found duplicated symbol '{}' in link inheritance statement\",\n                            symbol.raw\n                        ),\n                    )\n                    .spanned(self.span()),\n                );\n                continue;\n            }\n            symbols.push(\u0026symbol.raw);\n        }\n    }\n}\n\nimpl Validate for LinkData {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        for item in self.items.iter() {\n            // Do not make generic to Key\u003cIdent, Lit, _\u003e since known values\n            // are only known in linkdata context\n            match item.key.raw.as_str() {\n                \"jitter\" =\u003e {\n                    if !matches!(item.value.kind, LitKind::Float { .. }) {\n                        errors.add(\n                            Error::new(\n                                ErrorKind::LinkKnownKeysInvalidValue,\n                                \"known key 'jitter' expects a value of type float\",\n                            )\n                            .spanned(item.span()),\n                        );\n                    }\n                }\n                \"latency\" =\u003e {\n                    if !matches!(item.value.kind, LitKind::Float { .. }) {\n                        errors.add(\n                            Error::new(\n                                ErrorKind::LinkKnownKeysInvalidValue,\n                                \"known key 'latency' expects a value of type float \",\n                            )\n                            .spanned(item.span()),\n                        );\n                    }\n                }\n                \"bitrate\" =\u003e {\n                    if !matches!(item.value.kind, LitKind::Integer { .. }) {\n                        errors.add(\n                            Error::new(\n                                ErrorKind::LinkKnownKeysInvalidValue,\n                                \"known key 'bitrate' expects a value of type interger\",\n                            )\n                            .spanned(item.span()),\n                        );\n                    }\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::{Parse, ParseBuffer, TokenStream},\n        SourceMap,\n    };\n\n    use super::*;\n\n    fn load_link(smap: \u0026mut SourceMap, asset: \u0026str, s: \u0026str) -\u003e LinkStmt {\n        let asset = smap.load_raw(asset, s);\n        let ts = TokenStream::new(asset).unwrap();\n        let buf = ParseBuffer::new(asset, ts);\n        LinkStmt::parse(\u0026buf).unwrap()\n    }\n\n    #[test]\n    fn inheritance_dup() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let link = load_link(\u0026mut smap, \"raw:case0\", \"link A: B + C + D + B {}\");\n        let mut errors = Errors::new().as_mut();\n        link.validate(\u0026mut errors);\n\n        assert_eq!(errors.len(), 1);\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::LinkInheritanceDuplicatedSymbols\n        );\n\n        // # Case 1\n        let link = load_link(\u0026mut smap, \"raw:case1\", \"link A: SomeLink + SomeLink {}\");\n        let mut errors = Errors::new().as_mut();\n        link.validate(\u0026mut errors);\n\n        assert_eq!(errors.len(), 1);\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::LinkInheritanceDuplicatedSymbols\n        );\n    }\n\n    #[test]\n    fn known_values_invalid_typ() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0\n        let link = load_link(\u0026mut smap, \"raw:case0\", \"link A { jitter: 100 }\");\n        let mut errors = Errors::new().as_mut();\n        link.validate(\u0026mut errors);\n\n        assert_eq!(errors.len(), 1);\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::LinkKnownKeysInvalidValue\n        );\n\n        // # Case 1\n        let link = load_link(\u0026mut smap, \"raw:case1\", \"link A { bitrate: 1.0 }\");\n        let mut errors = Errors::new().as_mut();\n        link.validate(\u0026mut errors);\n\n        assert_eq!(errors.len(), 1);\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::LinkKnownKeysInvalidValue\n        );\n\n        // # Case 1\n        let link = load_link(\n            \u0026mut smap,\n            \"raw:case1\",\n            \"link A { latency: \\\"str\\\", bitrate: 1.0 }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        link.validate(\u0026mut errors);\n\n        assert_eq!(errors.len(), 2);\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::LinkKnownKeysInvalidValue\n        );\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":277},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":212},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":675},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":490},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":490},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":177},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":327},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":147},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":138},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":48},"fn_name":null}],"covered":41,"coverable":41},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","validate","mod.rs"],"content":"use crate::error::*;\n\nmod blanket;\nmod items;\nmod link;\nmod module;\n\npub trait Validate {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ast","validate","module.rs"],"content":"use super::*;\nuse crate::ast::*;\n\nimpl Validate for ModuleStmt {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        let has_inh = self.inheritance.is_some();\n        let has_dyn = self\n            .submodules\n            .iter()\n            .any(|s| s.items.iter().any(|s| s.typ.is_dyn()));\n        if has_inh \u0026\u0026 has_dyn {\n            errors.add(\n                Error::new(\n                    ErrorKind::ModuleBothInheritanceAndDyn,\n                    \"module is defined with both inheritance and dyn members: not supported\",\n                )\n                .spanned(self.span()),\n            );\n        }\n\n        if let Some(ref inh) = self.inheritance {\n            inh.validate(errors)\n        }\n        self.gates.iter().for_each(|s| s.validate(errors));\n        self.submodules.iter().for_each(|s| s.validate(errors));\n        self.connections.iter().for_each(|s| s.validate(errors));\n    }\n}\n\nimpl Validate for ModuleInheritance {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        let mut symbols = Vec::with_capacity(self.symbols.len());\n        for symbol in self.symbols.iter() {\n            if symbols.contains(\u0026\u0026symbol.raw) {\n                errors.add(\n                    Error::new(\n                        ErrorKind::ModuleInheritanceDuplicatedSymbols,\n                        format!(\n                            \"found duplicated symbol '{}' in module inheritance statement\",\n                            symbol.raw\n                        ),\n                    )\n                    .spanned(self.span()),\n                );\n                continue;\n            }\n            symbols.push(\u0026symbol.raw);\n        }\n    }\n}\n\nimpl Validate for GatesStmt {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        let mut symbols = Vec::with_capacity(self.items.len());\n        for gate_def in self.items.iter() {\n            // (0) Duplication checking\n            if symbols.contains(\u0026\u0026gate_def.ident.raw) {\n                errors.add(\n                    Error::new(\n                        ErrorKind::ModuleGatesDuplicatedSymbols,\n                        format!(\n                            \"gate(-cluster) '{}' was defined multiple times\",\n                            gate_def.ident.raw\n                        ),\n                    )\n                    .spanned(gate_def.span()),\n                );\n            } else {\n                symbols.push(\u0026gate_def.ident.raw);\n            }\n            // (2) Literal checking\n            if let Some(cluster) = gate_def.cluster.as_ref() {\n                if let LitKind::Integer { ref lit } = cluster.lit.kind {\n                    if *lit \u003e 0 {\n                        /* GOOD */\n                    } else {\n                        errors.add(\n                            Error::new(\n                                ErrorKind::ModuleGatesInvalidClusterSize,\n                                format!(\n                                \"cannot create gate-cluster of size '{}', requires positiv integer\",\n                                lit\n                            ),\n                            )\n                            .spanned(cluster.span()),\n                        );\n                    }\n                } else {\n                    errors.add(Error::new(\n                        ErrorKind::InvalidLitTyp,\n                        format!(\n                            \"cannot create gate-cluster with literal of type {}, expected literal of type integer\",\n                            cluster.lit.kind.typ()\n                        ),\n                    ).spanned(cluster.span()))\n                }\n            }\n        }\n    }\n}\n\nimpl Validate for SubmodulesStmt {\n    fn validate(\u0026self, errors: \u0026mut ErrorsMut) {\n        let mut symbols = Vec::with_capacity(self.items.len());\n        for submod_def in self.items.iter() {\n            // (0) Duplication checking\n            if symbols.contains(\u0026\u0026submod_def.ident.raw) {\n                errors.add(\n                    Error::new(\n                        ErrorKind::ModuleSubDuplicatedSymbols,\n                        format!(\n                            \"submodule(-cluster) '{}' was defined multiple times\",\n                            submod_def.ident.raw\n                        ),\n                    )\n                    .spanned(submod_def.span()),\n                );\n            } else {\n                symbols.push(\u0026submod_def.ident.raw);\n            }\n\n            // (2) Literal checking\n            if let Some(cluster) = submod_def.cluster.as_ref() {\n                if let LitKind::Integer { ref lit } = cluster.lit.kind {\n                    if *lit \u003e 0 {\n                        /* GOOD */\n                    } else {\n                        errors.add(Error::new(\n                            ErrorKind::ModuleSubInvalidClusterSize,\n                            format!(\n                                \"cannot create submodule cluster of size '{}', requires positiv integer\",\n                                lit\n                            ),\n                        ).spanned(cluster.span()));\n                    }\n                } else {\n                    errors.add(\n                        Error::new(\n                            ErrorKind::InvalidLitTyp,\n                            format!(\n                                \"invalid literal type {}, expected literal of type integer\",\n                                cluster.lit.kind.typ()\n                            ),\n                        )\n                        .spanned(cluster.span()),\n                    )\n                }\n            }\n        }\n    }\n}\n\nimpl Validate for ConnectionsStmt {\n    fn validate(\u0026self, _errors: \u0026mut ErrorsMut) {}\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::{Parse, ParseBuffer},\n        SourceMap,\n    };\n\n    use super::*;\n\n    fn load_module(smap: \u0026mut SourceMap, asset: \u0026str, raw: \u0026str) -\u003e ModuleStmt {\n        let asset = smap.load_raw(asset, raw);\n        let ts = TokenStream::new(asset).expect(\"Failed to create tokenstream, in validation pass\");\n        let buf = ParseBuffer::new(asset, ts);\n\n        ModuleStmt::parse(\u0026buf).expect(\"Failed to create object, in validation pass\")\n    }\n\n\n    #[test]\n    fn invalid_gates() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0 (baseline)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case0\",\n            \"module A { \n            gates {\n                in,\n                out[5],\n                inout,\n                outin[2],\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert!(errors.is_empty());\n\n        // # Case 1 (duplication)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case1\",\n            \"module A { \n            gates {\n                in,\n                out[5],\n                inout,\n                outin[2],\n                in,\n                out,\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 2);\n\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::ModuleGatesDuplicatedSymbols\n        );\n        assert_eq!(\n            errors.get(1).unwrap().kind,\n            ErrorKind::ModuleGatesDuplicatedSymbols\n        );\n\n        // # Case 2 (annotation)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case2\",\n            \"module A { \n            gates {\n                in,\n                out[5],\n                inout,\n                outin[2]\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 0);\n\n        // # Case 3 (literals)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case3\",\n            \"module A { \n            gates {\n                in,\n                out[1.0],\n                inout,\n                outin[\\\"\\\"]\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 2);\n\n        assert_eq!(errors.get(0).unwrap().kind, ErrorKind::InvalidLitTyp);\n        assert_eq!(errors.get(1).unwrap().kind, ErrorKind::InvalidLitTyp);\n\n        // # Case 3 (cluster-size)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case3\",\n            \"module A { \n            gates {\n                in,\n                out[0],\n                inout,\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 1);\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::ModuleGatesInvalidClusterSize\n        );\n    }\n\n    #[test]\n    fn invalid_submodules() {\n        let mut smap = SourceMap::new();\n\n        // # Case 0 (baseline)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case0\",\n            \"module A { \n            submodules {\n                in: A,\n                out[5]: B,\n                inout: C,\n                outin[2]: D,\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert!(errors.is_empty());\n\n        // # Case 1 (duplication)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case1\",\n            \"module A { \n            submodules {\n                in: In,\n                in: Out,\n                out: Out,\n                out[4]: In\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 2);\n\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::ModuleSubDuplicatedSymbols\n        );\n        assert_eq!(\n            errors.get(1).unwrap().kind,\n            ErrorKind::ModuleSubDuplicatedSymbols\n        );\n\n        // # Case 2 (literals)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case2\",\n            \"module A { \n            submodules {\n                in: In,\n                out[\\\"str\\\"]: Out,\n                pash[0.0]: C\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 2);\n\n        assert_eq!(errors.get(0).unwrap().kind, ErrorKind::InvalidLitTyp);\n        assert_eq!(errors.get(1).unwrap().kind, ErrorKind::InvalidLitTyp);\n\n        // # Case 2 (cluster-size)\n        let stmt = load_module(\n            \u0026mut smap,\n            \"raw:case2\",\n            \"module A { \n            submodules {\n                in: In,\n                out[0]: Out,\n            }\n         }\",\n        );\n        let mut errors = Errors::new().as_mut();\n        stmt.validate(\u0026mut errors);\n        assert_eq!(errors.len(), 1);\n\n        assert_eq!(\n            errors.get(0).unwrap().kind,\n            ErrorKind::ModuleSubInvalidClusterSize\n        );\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":678},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":678},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":678},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":678},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":2271},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":804},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":798},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":881},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":274},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":132},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":203},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":203},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":584},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":389},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":373},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":498},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":274},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":274},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":653},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":371},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":427},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":90},"fn_name":null}],"covered":87,"coverable":87},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","bin","ast-expr.rs"],"content":"use des_ndl::ast::*;\nuse des_ndl::*;\n\nconst TEXT: \u0026str = \"\nmodule A {\n    gates {\n        in @input,\n        out @output,\n    }\n\n    submodules {\n        in: In,\n        out[1]: Out,\n    }\n\n    connections {\n        in --\u003e LaLink --\u003e out\n    }\n}\n\";\n\nfn main() {\n    let mut smap = SourceMap::new();\n    let asset = smap.load_raw(\"raw:srctext\", TEXT);\n\n    let ts = TokenStream::new(asset).unwrap();\n    let buf = ParseBuffer::new(asset, ts);\n    let expr = ModuleStmt::parse(\u0026buf).unwrap();\n\n    println!(\"{expr:#?}\");\n    // for entry in expr.iter() {\n    //     println!(\"- {entry:?}\")\n    // }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","bin","ast-tokenstream.rs"],"content":"use des_ndl::{ast::TokenStream, *};\n\nconst TEXT: \u0026str = \"\ninclude str;\ninclude ast as ast;\n\n// Comments\n\nmodule A {\n    gates {\n        in @input\n        out[5] @output\n    }\n    connections {\n        in --\u003e out[1]\n    }\n}\n\";\n\nfn main() {\n    let mut smap = SourceMap::new();\n    let asset = smap.load_raw(\"raw:srctext\", TEXT);\n\n    let ts = TokenStream::new(asset).unwrap();\n    println!(\"{:#?}\", ts)\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","bin","ctx-full.rs"],"content":"use des_ndl::*;\n\nfn main() {\n    let mut ctx = match Context::load(\"des-ndl/src/bin/case-2/main.ndl\") {\n        Ok(ctx) =\u003e ctx,\n        Err(e) =\u003e {\n            println!(\"[{e}]\");\n            return;\n        }\n    };\n    let entry = ctx.entry.take().unwrap();\n    drop(ctx);\n\n    println!(\"################################################################\");\n    println!(\"{:#?}\", entry.connections);\n    drop(entry);\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":4,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","bin","ctx-include.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::*;\n\nfn main() -\u003e RootResult\u003c()\u003e {\n    let ctx = Context::load(\"des-ndl/src/bin/case-0/main.ndl\")?;\n\n    // println!(\"{:#?}\", tbl);\n    // println!(\"{:#?}\", tbl2);\n    println!(\"{:#?}\", ctx.ir);\n    Ok(())\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","bin","ctx-ir.rs"],"content":"use des_ndl::*;\n\nfn main() {\n    let mut ctx = match Context::load(\"des-ndl2/blueprint.ndl\") {\n        Ok(ctx) =\u003e ctx,\n        Err(e) =\u003e {\n            println!(\"[{e}]\");\n            return;\n        }\n    };\n    let entry = ctx.entry.take();\n    drop(ctx);\n\n    println!(\"{:#?}\", entry);\n    drop(entry);\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":4,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","context.rs"],"content":"use std::{\n    collections::HashMap,\n    path::{Path, PathBuf},\n    sync::Arc,\n};\n\nuse crate::{\n    ast::{self, validate::Validate, Parse, ParseBuffer, Spanned, TokenStream},\n    error::*,\n    ir,\n    resource::{fs::canon, AssetIdentifier},\n    util::dfs_cycles,\n    SourceMap, Span,\n};\n\n#[derive(Debug)]\npub struct Context {\n    pub smap: SourceMap,\n\n    pub root: AssetIdentifier,\n    pub assets: Vec\u003cAssetIdentifier\u003e,\n    pub deps: HashMap\u003cAssetIdentifier, Vec\u003cAssetIdentifier\u003e\u003e,\n\n    pub ast: HashMap\u003cAssetIdentifier, ast::File\u003e,\n    pub ir: HashMap\u003cAssetIdentifier, ir::Items\u003e,\n    pub entry: Option\u003cArc\u003cir::Module\u003e\u003e,\n}\n\nimpl Context {\n    pub fn load(path: impl AsRef\u003cPath\u003e) -\u003e RootResult\u003cContext\u003e {\n        let path = path.as_ref().to_path_buf();\n\n        let mut this = Self::load_initial_tree(path)?;\n        let mut errors = Errors::new().as_mut();\n\n        this.ast_validate_assets(\u0026mut errors);\n        if !errors.is_empty() {\n            return Err(RootError::new(errors.into_inner(), this.smap));\n        }\n\n        this.load_deps(\u0026mut errors);\n        if !errors.is_empty() {\n            return Err(RootError::new(errors.into_inner(), this.smap));\n        }\n\n        this.load_ir(\u0026mut errors);\n        if !errors.is_empty() {\n            return Err(RootError::new(errors.into_inner(), this.smap));\n        }\n\n        this.load_entry_and_check_dyn(\u0026mut errors);\n        if !errors.is_empty() {\n            return Err(RootError::new(errors.into_inner(), this.smap));\n        }\n\n        Ok(this)\n    }\n\n    fn load_initial_tree(path: PathBuf) -\u003e RootResult\u003cContext\u003e {\n        let mut smap = SourceMap::new();\n        let ident = AssetIdentifier::Root {\n            path,\n            alias: \"root\".to_string(),\n        };\n\n        let asset = match smap.load_file(ident.clone()).map_err(Error::from_io) {\n            Ok(asset) =\u003e asset,\n            Err(e) =\u003e return Err(RootError::single(e, smap)),\n        };\n        let ts = match TokenStream::new(asset) {\n            Ok(ts) =\u003e ts,\n            Err(e) =\u003e return Err(RootError::single(e, smap)),\n        };\n        let buf = ParseBuffer::new(asset, ts);\n        let file = match ast::File::parse(\u0026buf) {\n            Ok(file) =\u003e file,\n            Err(e) =\u003e return Err(RootError::single(e, smap)),\n        };\n\n        let mut this = Context {\n            smap,\n            root: ident.clone(),\n            assets: vec![ident.clone()],\n            deps: HashMap::new(),\n\n            ast: HashMap::from([(ident, file)]),\n            ir: HashMap::new(),\n            entry: None,\n        };\n        if let Err(e) = this.load_includes() {\n            return Err(RootError::single(e, this.smap));\n        }\n        Ok(this)\n    }\n\n    fn load_includes(\u0026mut self) -\u003e Result\u003c()\u003e {\n        let mut i = 0;\n        while i \u003c self.assets.len() {\n            let asset = self.assets[i].clone();\n            let items = self\n                .ast\n                .get(\u0026asset)\n                .expect(\"Asset was registered, but not ast provided\");\n\n            let mut tasks = Vec::new();\n            for item in \u0026items.items {\n                if let ast::Item::Include(include) = item {\n                    let ipath = include.path.path();\n                    match asset.path() {\n                        Ok(anchor) =\u003e {\n                            assert!(anchor\n                                .extension()\n                                .map(|e| e.to_string_lossy().contains(\"ndl\"))\n                                .unwrap_or(false));\n\n                            let mut anchor = anchor.parent().unwrap().to_path_buf();\n                            for comp in ipath.split('/') {\n                                anchor.push(comp)\n                            }\n                            anchor = canon(anchor);\n                            anchor.set_extension(\"ndl\");\n                            // anchor = anchor.canonicalize().unwrap();\n\n                            if !self\n                                .assets\n                                .iter()\n                                .any(|asset| asset.path().unwrap() == \u0026anchor)\n                            {\n                                tasks.push((anchor, include.span()))\n                            };\n                        }\n                        Err(_) =\u003e todo!(),\n                    }\n                }\n            }\n\n            // drop scope for items\n            for (path, span) in tasks {\n                let alias = self.root.relative_asset_alias(\u0026path);\n\n                let ident = AssetIdentifier::Included {\n                    path,\n                    alias,\n                    include: span,\n                };\n                let asset = self.smap.load_file(ident.clone()).map_err(Error::from_io)?;\n                let ts = TokenStream::new(asset)?;\n                let buf = ParseBuffer::new(asset, ts);\n\n                let file = ast::File::parse(\u0026buf)?;\n                self.assets.push(ident.clone());\n                self.ast.insert(ident, file);\n            }\n\n            i += 1;\n        }\n        Ok(())\n    }\n\n    fn ast_validate_assets(\u0026mut self, errors: \u0026mut ErrorsMut) {\n        for ast in self.ast.values() {\n            ast.validate(errors)\n        }\n    }\n\n    pub(crate) fn asts_for_asset(\n        \u0026self,\n        asset: \u0026AssetIdentifier,\n    ) -\u003e Vec\u003c(\u0026AssetIdentifier, \u0026ast::File)\u003e {\n        let iter = self\n            .deps\n            .get(asset)\n            .unwrap()\n            .iter()\n            .map(|k| (k, self.ast.get(k).unwrap()));\n\n        let asset = self.assets.iter().find(|a| *a == asset).unwrap(); // for lifetimes\n        let init = std::iter::once((asset, self.ast.get(asset).unwrap()));\n\n        Vec::from_iter(init.chain(iter))\n    }\n\n    pub(crate) fn ir_for_asset(\n        \u0026self,\n        asset: \u0026AssetIdentifier,\n        include_self: bool,\n    ) -\u003e Vec\u003c(\u0026AssetIdentifier, \u0026ir::Items)\u003e {\n        let iter = self\n            .deps\n            .get(asset)\n            .unwrap()\n            .iter()\n            .map(|k| (k, self.ir.get(k).unwrap()));\n\n        if include_self {\n            let asset = self.assets.iter().find(|a| *a == asset).unwrap(); // for lifetimes\n            let init = std::iter::once((asset, self.ir.get(asset).unwrap()));\n\n            Vec::from_iter(init.chain(iter))\n        } else {\n            iter.collect()\n        }\n    }\n\n    fn load_deps(\u0026mut self, errors: \u0026mut ErrorsMut) {\n        if !self.deps.is_empty() {\n            return;\n        }\n\n        let mut topo: Vec\u003cVec\u003cusize\u003e\u003e = vec![Vec::new(); self.assets.len()];\n        let mut topo_span: Vec\u003cVec\u003cSpan\u003e\u003e = vec![Vec::new(); self.assets.len()];\n\n        // Build topology from raw edges.\n        for i in 0..self.assets.len() {\n            let ast = self.ast.get(\u0026self.assets[i]).unwrap();\n            for item in ast.items.iter() {\n                if let ast::Item::Include(include) = item {\n                    let ipath = include.path.path();\n                    let mut anchor = self.assets[i]\n                        .path()\n                        .unwrap()\n                        .parent()\n                        .unwrap()\n                        .to_path_buf();\n                    for comp in ipath.split('/') {\n                        anchor.push(comp)\n                    }\n                    anchor = canon(anchor);\n                    anchor.set_extension(\"ndl\");\n\n                    let Some(asset_pos) = self.assets.iter().position(|asset| *asset.path().unwrap() == anchor) else {\n                        unreachable!()\n                    };\n\n                    topo[i].push(asset_pos);\n                    topo_span[i].push(include.span())\n                }\n            }\n        }\n\n        // Check for cycles - throw error if found\n        match dfs_cycles(\u0026topo) {\n            Ok(reachability) =\u003e {\n                // Add fully expanded dep trees\n                for i in 0..self.assets.len() {\n                    let mut deps = Vec::with_capacity(self.assets.len());\n                    for (j, \u0026reachable) in reachability[i].iter().enumerate() {\n                        if reachable \u0026\u0026 i != j {\n                            deps.push(self.assets[j].clone());\n                        }\n                    }\n\n                    self.deps.insert(self.assets[i].clone(), deps);\n                }\n            }\n            Err(cycles) =\u003e {\n                // Append each elementary cycles as its own error\n                for cycle in cycles {\n                    let s = cycle[0];\n\n                    let mut fmt = vec![self.assets[s].alias()];\n                    for \u0026e in cycle.iter().rev() {\n                        fmt.push(self.assets[e].alias());\n                    }\n\n                    // find inital edge for span\n                    let mut span = Span::new(0, 0);\n                    for j in 0..topo[s].len() {\n                        if topo[s][j] == cycle[1] {\n                            span = topo_span[s][j]\n                        }\n                    }\n\n                    errors.add(\n                        Error::new(\n                            ErrorKind::CyclicDeps,\n                            format!(\"found cyclic includes: {}\", fmt.join(\" \u003c- \")),\n                        )\n                        .spanned(span),\n                    )\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":732},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":606},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2688},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":606},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1380},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2040},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1380},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":324},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":510},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1326},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1116},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":660},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":756},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":108,"coverable":118},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","error","errors.rs"],"content":"use std::ops::Deref;\n\nuse super::*;\n\n#[derive(Debug)]\npub struct Errors {\n    pub(crate) list: LinkedList\u003cError\u003e,\n}\n\npub struct ErrorsMut {\n    errors: Errors,\n    mappings: Vec\u003cBox\u003cdyn Fn(Error) -\u003e Error\u003e\u003e,\n}\n\nimpl Errors {\n    pub fn len(\u0026self) -\u003e usize {\n        self.list.len()\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    pub fn get(\u0026self, n: usize) -\u003e Option\u003c\u0026Error\u003e {\n        self.list.iter().nth(n)\n    }\n\n    pub fn new() -\u003e Errors {\n        Errors {\n            list: LinkedList::new(),\n        }\n    }\n\n    pub fn as_mut(self) -\u003e ErrorsMut {\n        ErrorsMut {\n            errors: self,\n            mappings: Vec::new(),\n        }\n    }\n}\n\nimpl ErrorsMut {\n    pub fn with_mapping(\n        \u0026mut self,\n        mapping: impl Fn(Error) -\u003e Error + 'static,\n        f: impl FnOnce(\u0026mut ErrorsMut),\n    ) {\n        self.mappings.push(Box::new(mapping));\n        f(self);\n        self.mappings.pop();\n    }\n\n    pub fn add(\u0026mut self, mut error: Error) {\n        for map in self.mappings.iter().rev() {\n            error = map(error);\n        }\n        self.errors.list.push_back(error)\n    }\n\n    pub fn into_inner(self) -\u003e Errors {\n        self.errors\n    }\n}\n\nimpl Default for Errors {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Deref for ErrorsMut {\n    type Target = Errors;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.errors\n    }\n}\n\nimpl Deref for Errors {\n    type Target = LinkedList\u003cError\u003e;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.list\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":2331},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":2331},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":866},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":866},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":370},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":370},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":429},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":429},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":333},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":333},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1134},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1134},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1134},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1134},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":275},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":827},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":275},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2083},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2083},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":54},"fn_name":null}],"covered":24,"coverable":26},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","error","mod.rs"],"content":"use crate::Span;\nuse std::{collections::LinkedList, error, fmt, io};\n\nmod errors;\nmod root;\n\npub use self::errors::*;\npub use self::root::*;\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\n#[derive(Debug)]\npub struct Error {\n    pub kind: ErrorKind,\n    pub internal: Box\u003cdyn error::Error + Send + Sync\u003e,\n    pub span: Option\u003cSpan\u003e,\n    pub hints: Vec\u003cErrorHint\u003e,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(u8)]\npub enum ErrorKind {\n    ParseLitError,\n    MissingDelim,\n    UnexpectedToken,\n    UnexpectedDelim,\n    ExpectedSingleFoundJoint,\n    ExpectedDelimited,\n    ExpectedInModuleKeyword,\n    ExpectedIdentFoundKeyword,\n    MissingToken,\n    UnexpectedEOF,\n    LinkInheritanceDuplicatedSymbols,\n    ModuleInheritanceDuplicatedSymbols,\n    ModuleBothInheritanceAndDyn,\n    LinkKnownKeysInvalidValue,\n    ModuleGatesDuplicatedSymbols,\n    ModuleGatesInvalidClusterSize,\n    ModuleSubDuplicatedSymbols,\n    ModuleSubInvalidClusterSize,\n    InvalidAnnotation,\n    InvalidLitTyp,\n    SymbolDuplication,\n    IoError,\n    CyclicDeps,\n    RootError,\n    SymbolNotFound,\n    LinkMissingRequiredFields,\n    LinkLocalCyclicDeps,\n    InvalidConGateServiceTyp,\n    InvalidConDefSizes,\n    InvalidConClusterIndex,\n    ModuleLocalCyclicDeps,\n    ModuleDynConstraintsBroken,\n    ModuleDynNotResolved,\n    MissingEntryPoint,\n}\n\n#[derive(Debug)]\npub enum ErrorHint {\n    Note(String),\n    Help(String),\n    Solution(ErrorSolution),\n}\n\n#[derive(Debug)]\npub struct ErrorSolution {\n    pub description: String,\n    pub span: Span,\n    pub replacement: String,\n}\n\nimpl Error {\n    pub fn new(kind: ErrorKind, internal: impl Into\u003cBox\u003cdyn error::Error + Send + Sync\u003e\u003e) -\u003e Self {\n        Self {\n            kind,\n            internal: internal.into(),\n            span: None,\n            hints: Vec::new(),\n        }\n    }\n\n    pub fn map(self, f: impl FnOnce(Error) -\u003e Error) -\u003e Error {\n        f(self)\n    }\n\n    pub fn solution(\u0026self) -\u003e Option\u003c\u0026ErrorSolution\u003e {\n        self.hints.iter().find_map(|h| {\n            if let ErrorHint::Solution(s) = h {\n                Some(s)\n            } else {\n                None\n            }\n        })\n    }\n\n    pub fn spanned(mut self, span: Span) -\u003e Self {\n        self.span = Some(span);\n        self\n    }\n\n    pub fn override_internal(\n        mut self,\n        internal: impl Into\u003cBox\u003cdyn error::Error + Send + Sync\u003e\u003e,\n    ) -\u003e Self {\n        self.internal = internal.into();\n        self\n    }\n\n    pub fn add_hints(mut self, hint: impl Into\u003cErrorHint\u003e) -\u003e Self {\n        self.hints.push(hint.into());\n        let mut l = self.hints.len() - 1;\n        for i in 0..self.hints.len() {\n            if i \u003e= l {\n                break;\n            }\n            if let ErrorHint::Solution(_) = self.hints[i] {\n                self.hints.swap(i, l);\n                l -= 1;\n            }\n        }\n        self\n    }\n\n    pub fn from_io(io: io::Error) -\u003e Self {\n        Self {\n            kind: ErrorKind::IoError,\n            internal: Box::new(io),\n            span: None,\n            hints: Vec::new(),\n        }\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{} ({})\", self.internal, self.kind)\n    }\n}\n\nimpl error::Error for Error {}\n\nimpl fmt::Display for ErrorKind {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        \u003cSelf as fmt::Debug\u003e::fmt(self, f)\n    }\n}\n\n// # composite errors\n","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":1620},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1620},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1620},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":666},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":354},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1582},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1582},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1582},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":774},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":492},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":78},"fn_name":null}],"covered":27,"coverable":32},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","error","root.rs"],"content":"use std::{\n    error, fmt,\n    io::{self, Write},\n};\n\nuse termcolor::{Buffer, BufferWriter, Color, ColorChoice, ColorSpec, WriteColor};\n\nuse super::{Error, ErrorHint, Errors};\nuse crate::resource::SourceMap;\n\npub type RootResult\u003cT\u003e = Result\u003cT, RootError\u003e;\n\npub struct RootError {\n    pub errors: Errors,\n    pub smap: SourceMap,\n}\n\nimpl RootError {\n    pub fn new(errors: Errors, smap: SourceMap) -\u003e RootError {\n        Self { errors, smap }\n    }\n\n    pub fn single(error: Error, smap: SourceMap) -\u003e RootError {\n        let mut errors = Errors::new();\n        errors.list.push_back(error);\n        Self { errors, smap }\n    }\n}\n\nimpl Error {\n    fn fmt(\u0026self, smap: \u0026SourceMap, fmt: \u0026mut Buffer) -\u003e fmt::Result {\n        self.fmt_title(fmt).map_err(|_| fmt::Error)?;\n        self.fmt_span(smap, fmt).map_err(|_| fmt::Error)?;\n        self.fmt_hint(smap, fmt).map_err(|_| fmt::Error)?;\n        Ok(())\n    }\n\n    fn fmt_title(\u0026self, fmt: \u0026mut Buffer) -\u003e io::Result\u003c()\u003e {\n        fmt.set_color(ColorSpec::new().set_fg(Some(Color::Red)).set_bold(true))?;\n        write!(fmt, \"error[{}]: \", self.kind as u8)?;\n\n        fmt.reset()?;\n        fmt.set_color(ColorSpec::new().set_bold(true))?;\n        writeln!(fmt, \"{} ({})\", self.internal, self.kind)?;\n\n        Ok(())\n    }\n\n    fn fmt_span(\u0026self, smap: \u0026SourceMap, fmt: \u0026mut Buffer) -\u003e io::Result\u003c()\u003e {\n        let Some(span) = self.span else { return Ok(()) };\n        let asset = smap.asset_for(span).expect(\"Failed to fetch asset\");\n        let line = smap.line_for(span).expect(\"Failed to fetch asset\");\n\n        // File path line\n        fmt.set_color(ColorSpec::new().set_fg(Some(Color::Blue)).set_bold(true))?;\n        write!(fmt, \"   --\u003e \")?;\n\n        fmt.reset()?;\n        writeln!(\n            fmt,\n            \"{}:{}\",\n            asset.ident.path().unwrap().to_str().unwrap(),\n            line\n        )?;\n\n        let (pstr, p) = smap.slice_padded_for(span);\n        // Print padded lines\n        fmt.set_color(ColorSpec::new().set_fg(Some(Color::Blue)).set_bold(true))?;\n        if p == 0 {\n            write!(fmt, \"{:\u003e3} | \", line)?;\n        } else {\n            write!(fmt, \"    | \")?;\n        }\n        fmt.reset()?;\n\n        let mut line_drawn = 1;\n\n        for c in pstr.chars() {\n            write!(fmt, \"{}\", c)?;\n            if c == '\\n' {\n                fmt.set_color(ColorSpec::new().set_fg(Some(Color::Blue)).set_bold(true))?;\n\n                if line_drawn != p {\n                    write!(fmt, \"    | \")?;\n                } else {\n                    write!(fmt, \"{:\u003e3} | \", line)?;\n                }\n                line_drawn += 1;\n                fmt.reset()?;\n            }\n        }\n\n        writeln!(fmt)?;\n\n        Ok(())\n    }\n\n    fn fmt_hint(\u0026self, smap: \u0026SourceMap, fmt: \u0026mut Buffer) -\u003e io::Result\u003c()\u003e {\n        for hint in \u0026self.hints {\n            match hint {\n                ErrorHint::Help(help) =\u003e {\n                    fmt.set_color(ColorSpec::new().set_fg(Some(Color::Blue)).set_bold(true))?;\n                    write!(fmt, \"    = \")?;\n\n                    fmt.reset()?;\n                    fmt.set_color(ColorSpec::new().set_bold(true))?;\n                    write!(fmt, \"help: \")?;\n\n                    fmt.reset()?;\n                    writeln!(fmt, \"{}\", help)?;\n                }\n                ErrorHint::Note(note) =\u003e {\n                    fmt.set_color(ColorSpec::new().set_fg(Some(Color::Blue)).set_bold(true))?;\n                    write!(fmt, \"    = \")?;\n\n                    fmt.reset()?;\n                    fmt.set_color(ColorSpec::new().set_bold(true))?;\n                    write!(fmt, \"note: \")?;\n\n                    fmt.reset()?;\n                    writeln!(fmt, \"{}\", note)?;\n                }\n                ErrorHint::Solution(solution) =\u003e {\n                    let sasset = smap.asset_for(solution.span).unwrap();\n                    let sline = sasset.line_for(solution.span.pos);\n\n                    fmt.set_color(ColorSpec::new().set_fg(Some(Color::Blue)).set_bold(true))?;\n                    writeln!(fmt, \"    = {}\", solution.description)?;\n                    writeln!(\n                        fmt,\n                        \"       in {}:{}\",\n                        sasset.ident.path().unwrap().to_str().unwrap(),\n                        sline\n                    )?;\n\n                    fmt.reset()?;\n                }\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl error::Error for RootError {}\nimpl fmt::Display for RootError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let stream = BufferWriter::stderr(ColorChoice::Always);\n        let mut buffer = stream.buffer();\n        for error in \u0026*self.errors {\n            error.fmt(\u0026self.smap, \u0026mut buffer)?;\n        }\n        write!(f, \"{}\", String::from_utf8_lossy(buffer.as_slice()))\n    }\n}\nimpl fmt::Debug for RootError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        \u003cSelf as fmt::Display\u003e::fmt(self, f)\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":4956},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":4956},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4956},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":330},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":132},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":77,"coverable":80},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ir","link.rs"],"content":"use crate::ast::{self, LinkStmt, Spanned};\nuse std::{collections::HashMap, fmt, sync::Arc};\n\nuse super::*;\n\n#[derive(Clone, PartialEq)]\npub struct Link {\n    pub ast: Arc\u003cLinkStmt\u003e,\n\n    pub ident: RawSymbol,\n    pub fields: HashMap\u003cString, Literal\u003e,\n\n    // common\n    pub jitter: f64,\n    pub latency: f64,\n    pub bitrate: i32,\n\n    pub(crate) dirty: bool,\n}\n\nimpl fmt::Debug for Link {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"Link\")\n            .field(\"ast\", \u0026self.ast.span())\n            .field(\"ident\", \u0026self.ident)\n            .field(\"fields\", \u0026self.fields)\n            .field(\"jitter\", \u0026self.jitter)\n            .field(\"latency\", \u0026self.latency)\n            .field(\"bitrate\", \u0026self.bitrate)\n            .field(\"dirty\", \u0026self.dirty)\n            .finish()\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Literal {\n    Float(f64),\n    Integer(i32),\n    String(String),\n}\n\nimpl Literal {\n    pub fn as_float_casted(\u0026self) -\u003e f64 {\n        match self {\n            Self::Float(f) =\u003e *f,\n            Self::Integer(i) =\u003e *i as f64,\n            Self::String(s) =\u003e s.parse().expect(\"Force casted as float\"),\n        }\n    }\n\n    pub fn as_integer_casted(\u0026self) -\u003e i32 {\n        match self {\n            Self::Integer(i) =\u003e *i,\n            Self::Float(f) =\u003e *f as i32,\n            Self::String(s) =\u003e s.parse().expect(\"Force casted as integer\"),\n        }\n    }\n}\n\nimpl From\u003cast::Lit\u003e for Literal {\n    fn from(value: ast::Lit) -\u003e Self {\n        match value.kind {\n            ast::LitKind::Float { lit } =\u003e Literal::Float(lit),\n            ast::LitKind::Integer { lit } =\u003e Literal::Integer(lit),\n            ast::LitKind::Str { lit } =\u003e Literal::String(lit),\n        }\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":24},"fn_name":null}],"covered":7,"coverable":24},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ir","mod.rs"],"content":"use std::sync::Arc;\n\nmod link;\nmod module;\nmod refs;\nmod symbol;\n\npub use self::link::*;\npub use self::module::*;\npub use self::refs::*;\npub use self::symbol::*;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Items {\n    pub items: Vec\u003cItem\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Item {\n    Link(Arc\u003cLink\u003e),\n    Module(Arc\u003cModule\u003e),\n}\n\nimpl Items {\n    pub fn link(\u0026self, ident: impl AsRef\u003cstr\u003e) -\u003e Option\u003cArc\u003cLink\u003e\u003e {\n        let ident = ident.as_ref();\n        self.items.iter().find_map(|v| {\n            if let Item::Link(l) = v {\n                if l.ident.raw == ident {\n                    Some(l.clone())\n                } else {\n                    None\n                }\n            } else {\n                None\n            }\n        })\n    }\n\n    pub fn module(\u0026self, ident: impl AsRef\u003cstr\u003e) -\u003e Option\u003cArc\u003cModule\u003e\u003e {\n        let ident = ident.as_ref();\n        self.items.iter().find_map(|v| {\n            if let Item::Module(l) = v {\n                if l.ident.raw == ident {\n                    Some(l.clone())\n                } else {\n                    None\n                }\n            } else {\n                None\n            }\n        })\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":16},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ir","module.rs"],"content":"use std::{\n    fmt::{self, Debug, Display},\n    sync::Arc,\n};\n\nuse super::*;\nuse crate::{\n    ast::{ClusterDefinition, ModuleStmt},\n    ir::GateRef,\n    Span,\n};\n\n#[derive(Clone, PartialEq)]\npub struct Module {\n    pub ast: Arc\u003cModuleStmt\u003e,\n\n    pub ident: RawSymbol,\n    pub inherited: Vec\u003cSymbol\u003e,\n    pub gates: Vec\u003cGate\u003e,\n    pub submodules: Vec\u003cSubmodule\u003e,\n    pub connections: Vec\u003cConnection\u003e,\n\n    pub(crate) dirty: bool,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Gate {\n    pub ident: RawSymbol,\n    pub cluster: Cluster,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Submodule {\n    pub span: Span,\n    pub ident: RawSymbol,\n    pub typ: Symbol,\n    pub cluster: Cluster,\n    pub dynamic: bool,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Cluster {\n    Standalone,\n    Clusted(usize),\n}\n#[derive(Debug, Clone, PartialEq)]\npub struct Connection {\n    pub lhs: ConnectionEndpoint,\n    pub rhs: ConnectionEndpoint,\n    pub delay: Option\u003cSymbol\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum ConnectionEndpoint {\n    Local(RawSymbol, Cluster),\n    Nonlocal(RawSymbol, Cluster, (RawSymbol, Cluster)),\n}\n\n// # Impl\n\nimpl Module {\n    pub fn all_modules(this: Arc\u003cModule\u003e) -\u003e Vec\u003cArc\u003cModule\u003e\u003e {\n        let mut result = Vec::new();\n        Self::_all_modules(this, \u0026mut result);\n        result\n    }\n\n    fn _all_modules(this: Arc\u003cModule\u003e, result: \u0026mut Vec\u003cArc\u003cModule\u003e\u003e) {\n        if !result.iter().any(|r| Arc::ptr_eq(r, \u0026this)) {\n            result.push(this.clone());\n            for submod in \u0026this.submodules {\n                let Some(sub) = submod.typ.as_module_arc() else {\n                    continue;\n                };\n                Self::_all_modules(sub, result);\n            }\n        }\n    }\n}\n\n// impl ConnectionEndpoint {\n//     pub fn new(endp: \u0026ModuleGateReference, gate: \u0026GateRef) -\u003e Self {\n//         match endp {\n//             ModuleGateReference::Local(local) =\u003e ConnectionEndpoint::Local(\n//                 RawSymbol {\n//                     raw: local.gate.raw.clone(),\n//                 },\n//                 Cluster::new(gate),\n//             ),\n//             ModuleGateReference::Nonlocal(nonlocal) =\u003e ConnectionEndpoint::Nonlocal(\n//                 RawSymbol {\n//                     raw: nonlocal.submodule.raw.clone(),\n//                 },\n//                 Cluster::new(gate),\n//                 (\n//                     RawSymbol {\n//                         raw: nonlocal.gate.gate.raw.clone(),\n//                     },\n//                     Cluster::new(gate),\n//                 ),\n//             ),\n//         }\n//     }\n// }\n\nimpl Cluster {\n    pub fn new(gate: \u0026GateRef) -\u003e Self {\n        match gate.pos {\n            Some(pos) =\u003e Self::Clusted(pos),\n            None =\u003e Self::Standalone,\n        }\n    }\n\n    pub fn contains(\u0026self, other: \u0026Self) -\u003e bool {\n        match self {\n            Self::Standalone =\u003e matches!(other, Self::Standalone),\n            Self::Clusted(cs) =\u003e match other {\n                Self::Standalone =\u003e true,\n                Self::Clusted(i) =\u003e i \u003c cs,\n            },\n        }\n    }\n\n    pub fn as_size(\u0026self) -\u003e usize {\n        match self {\n            Self::Standalone =\u003e 1,\n            Self::Clusted(n) =\u003e *n,\n        }\n    }\n\n    pub fn as_index(\u0026self) -\u003e usize {\n        match self {\n            Self::Standalone =\u003e 0,\n            Self::Clusted(n) =\u003e *n,\n        }\n    }\n}\n\nimpl From\u003cGateRef\u003c'_\u003e\u003e for ConnectionEndpoint {\n    fn from(value: GateRef\u003c'_\u003e) -\u003e Self {\n        let gc = Cluster::new(\u0026value);\n        match value.submod {\n            Some((pos, submod, cl)) =\u003e ConnectionEndpoint::Nonlocal(\n                RawSymbol { raw: submod },\n                if pos == 0 \u0026\u0026 cl == Cluster::Standalone {\n                    Cluster::Standalone\n                } else {\n                    Cluster::Clusted(pos)\n                },\n                (value.def.ident.clone(), gc),\n            ),\n            None =\u003e ConnectionEndpoint::Local(value.def.ident.clone(), gc),\n        }\n    }\n}\n\nimpl From\u003c\u0026ClusterDefinition\u003e for Cluster {\n    fn from(value: \u0026ClusterDefinition) -\u003e Self {\n        Cluster::Clusted(value.lit.as_integer() as usize)\n    }\n}\n\nimpl From\u003c\u0026Option\u003cClusterDefinition\u003e\u003e for Cluster {\n    fn from(value: \u0026Option\u003cClusterDefinition\u003e) -\u003e Self {\n        value\n            .as_ref()\n            .map(Cluster::from)\n            .unwrap_or(Cluster::Standalone)\n    }\n}\n\n\nimpl Display for Cluster {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Self::Standalone =\u003e Ok(()),\n            Self::Clusted(c) =\u003e write!(f, \"[{c}]\"),\n        }\n    }\n}\n\nimpl Debug for Module {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"Module\")\n            .field(\"ident\", \u0026self.ident)\n            .field(\n                \"inherited\",\n                \u0026self.inherited.iter().map(|v| v.raw()).collect::\u003cVec\u003c_\u003e\u003e(),\n            )\n            .field(\"gates\", \u0026self.gates)\n            .field(\"submodules\", \u0026self.submodules)\n            .field(\"connections\", \u0026self.connections)\n            .field(\"dirty\", \u0026self.dirty)\n            .finish()\n    }\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":504},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":780},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":204},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":24},"fn_name":null}],"covered":39,"coverable":55},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ir","refs.rs"],"content":"use super::*;\n\n#[derive(Debug)]\npub struct GateRef\u003c'a\u003e {\n    pub submod: Option\u003c(usize, String, Cluster)\u003e,\n    pub def: \u0026'a Gate,\n    pub pos: Option\u003cusize\u003e,\n}\n\n#[derive(Debug)]\npub struct SubmoduleRef\u003c'a\u003e {\n    pub def: \u0026'a Submodule,\n    pub pos: usize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","ir","symbol.rs"],"content":"use std::sync::Arc;\n\nuse super::*;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct RawSymbol {\n    pub raw: String,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Symbol {\n    Module(Arc\u003cModule\u003e),\n    Link(Arc\u003cLink\u003e),\n    Unresolved(RawSymbol),\n}\n\n// # Impl\n\nimpl RawSymbol {\n    pub fn could_be_submodule(\u0026self, ident: impl AsRef\u003cstr\u003e, cluster: \u0026Cluster) -\u003e bool {\n        self.raw == format!(\"{}{}\", ident.as_ref(), cluster)\n    }\n}\n\nimpl Symbol {\n    pub fn as_link(\u0026self) -\u003e Option\u003c\u0026Link\u003e {\n        match self {\n            Self::Link(l) =\u003e Some(\u0026**l),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn as_module(\u0026self) -\u003e Option\u003c\u0026Module\u003e {\n        match self {\n            Self::Module(m) =\u003e Some(\u0026**m),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn as_link_arc(\u0026self) -\u003e Option\u003cArc\u003cLink\u003e\u003e {\n        match self {\n            Self::Link(l) =\u003e Some(l.clone()),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn as_module_arc(\u0026self) -\u003e Option\u003cArc\u003cModule\u003e\u003e {\n        match self {\n            Self::Module(m) =\u003e Some(m.clone()),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn raw(\u0026self) -\u003e \u0026RawSymbol {\n        match self {\n            Self::Link(l) =\u003e \u0026l.ident,\n            Self::Module(m) =\u003e \u0026m.ident,\n            Self::Unresolved(i) =\u003e i,\n        }\n    }\n}\n\nimpl From\u003cArc\u003cModule\u003e\u003e for Symbol {\n    fn from(module: Arc\u003cModule\u003e) -\u003e Self {\n        Symbol::Module(module)\n    }\n}\n\nimpl From\u003cArc\u003cLink\u003e\u003e for Symbol {\n    fn from(link: Arc\u003cLink\u003e) -\u003e Self {\n        Symbol::Link(link)\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":750},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":750},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":726},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":324},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":324},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":324},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":390},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":390},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":60},"fn_name":null}],"covered":17,"coverable":27},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","lexer","cursor.rs"],"content":"use std::str::Chars;\n\n/// Peekable iterator over a char sequence.\n///\n/// Next characters can be peeked via `first` method,\n/// and position can be shifted forward via `bump` method.\npub struct Cursor\u003c'a\u003e {\n    /// Iterator over chars. Slightly faster than a \u0026str.\n    chars: Chars\u003c'a\u003e,\n    initial_len: usize,\n\n    pub idx: usize,\n\n    #[cfg(debug_assertions)]\n    prev: char,\n}\n\n/// The end of file character.\npub const EOF_CHAR: char = '\\0';\n\nimpl\u003c'a\u003e Cursor\u003c'a\u003e {\n    pub fn new(input: \u0026'a str, start_idx: usize) -\u003e Cursor\u003c'a\u003e {\n        Cursor {\n            initial_len: input.len(),\n            chars: input.chars(),\n\n            idx: start_idx,\n\n            #[cfg(debug_assertions)]\n            prev: EOF_CHAR,\n        }\n    }\n\n    /// Returns the last eaten symbol (or `'\\0'` in release builds).\n    /// (For debug assertions only.)\n    pub fn prev(\u0026self) -\u003e char {\n        #[cfg(debug_assertions)]\n        {\n            self.prev\n        }\n\n        #[cfg(not(debug_assertions))]\n        {\n            EOF_CHAR\n        }\n    }\n\n    /// Peeks the next symbol from the input stream without consuming it.\n    /// If requested position doesn't exist, `EOF_CHAR` is returned.\n    /// However, getting `EOF_CHAR` doesn't always mean actual end of file,\n    /// it should be checked with `is_eof` method.\n    pub fn first(\u0026self) -\u003e char {\n        // `.next()` optimizes better than `.nth(0)`\n        self.chars.clone().next().unwrap_or(EOF_CHAR)\n    }\n\n    /// Peeks the second symbol from the input stream without consuming it.\n    pub fn second(\u0026self) -\u003e char {\n        // `.next()` optimizes better than `.nth(1)`\n        let mut iter = self.chars.clone();\n        iter.next();\n        iter.next().unwrap_or(EOF_CHAR)\n    }\n\n    /// Checks if there is nothing more to consume.\n    pub fn is_eof(\u0026self) -\u003e bool {\n        self.chars.as_str().is_empty()\n    }\n\n    /// Returns amount of already consumed symbols.\n    pub fn len_consumed(\u0026self) -\u003e usize {\n        self.initial_len - self.chars.as_str().len()\n    }\n\n    /// Resets the number of bytes consumed to 0.\n    pub fn reset_len_consumed(\u0026mut self) {\n        self.initial_len = self.chars.as_str().len();\n    }\n\n    /// Moves to the next character.\n    pub fn bump(\u0026mut self) -\u003e Option\u003cchar\u003e {\n        let c = self.chars.next()?;\n\n        #[cfg(debug_assertions)]\n        {\n            self.prev = c;\n        }\n\n        Some(c)\n    }\n\n    /// Eats symbols while predicate returns true or until the end of file is reached.\n    pub fn eat_while(\u0026mut self, mut predicate: impl FnMut(char) -\u003e bool) {\n        // It was tried making optimized version of this for eg. line comments, but\n        // LLVM can inline all of this and compile it down to fast iteration over bytes.\n        while predicate(self.first()) \u0026\u0026 !self.is_eof() {\n            let _ = self.chars.next();\n        }\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":538},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":538},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":538},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":18175},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":18175},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":18175},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":66760},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":66760},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":732},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":732},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":732},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":732},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":64362},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":64362},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":51690},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":51690},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":25424},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":25424},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":27092},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":54184},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":16528},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":131728},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":38400},"fn_name":null}],"covered":23,"coverable":25},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","lexer","mod.rs"],"content":"use self::LiteralKind::*;\nuse self::TokenKind::*;\nuse cursor::Cursor;\n\nmod cursor;\n\n#[cfg(test)]\nmod tests;\n\n/// Creates an iterator that produces tokens from the input string.\npub fn tokenize(input: \u0026str, start_idx: usize) -\u003e impl Iterator\u003cItem = Token\u003e + '_ {\n    let mut cursor = Cursor::new(input, start_idx);\n    std::iter::from_fn(move || {\n        if cursor.is_eof() {\n            None\n        } else {\n            cursor.reset_len_consumed();\n            Some(cursor.advance_token())\n        }\n    })\n}\n\n///\n/// A raw syntactical element in of the given source asset.\n/// Note that the [Loc] always references the [SourceMap] buffer\n/// not the relative position in the current asset.\n///\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct Token {\n    /// The type of token encountered.\n    pub kind: TokenKind,\n    /// The location of the token in the source asset.\n    pub len: usize,\n}\n\nimpl Token {\n    ///\n    /// Creates a new token from the given raw parameters.\n    ///\n    pub fn new(kind: TokenKind, len: usize) -\u003e Self {\n        Self { kind, len }\n    }\n}\n\n///\n/// The tokens type.\n///\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum TokenKind {\n    // A single line comment\n    Comment,\n    /// Any whitespace characters sequence.\n    Whitespace,\n    /// Any token that can be either type, var name or keyqord\n    Ident,\n    /// Any token that is a ident, prefixed by an @.\n    Annotation,\n    /// A invalid identifer.\n    InvalidIdent,\n    /// A nonterminated token prefix.\n    UnknownPrefix,\n    /// A literal value.\n    Literal {\n        kind: LiteralKind,\n        suffix_start: usize,\n    },\n\n    /// \";\"\n    Semi,\n    /// \",\"\n    Comma,\n    /// \".\"\n    Dot,\n    /// \"(\"\n    OpenParen,\n    /// \")\"\n    CloseParen,\n    /// \"{\"\n    OpenBrace,\n    /// \"}\"\n    CloseBrace,\n    /// \"[\"\n    OpenBracket,\n    /// \"]\"\n    CloseBracket,\n    /// \"@\"\n    At,\n    /// \"#\"\n    Pound,\n    /// \"~\"\n    Tilde,\n    /// \"?\"\n    Question,\n    /// \":\"\n    Colon,\n    /// \"$\"\n    Dollar,\n    /// \"=\"\n    Eq,\n    /// \"!\"\n    Bang,\n    /// \"\u003c\"\n    Lt,\n    /// \"\u003e\"\n    Gt,\n    /// \"-\"\n    Minus,\n    /// \"\u0026\"\n    And,\n    /// \"|\"\n    Or,\n    /// \"+\"\n    Plus,\n    /// \"*\"\n    Star,\n    /// \"/\"\n    Slash,\n    /// \"^\"\n    Caret,\n    /// \"%\"\n    Percent,\n\n    /// Unknown token, not expected by the lexer, e.g. \"\"\n    Unknown,\n}\n\nimpl TokenKind {\n    pub(super) fn is_delim_open(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            TokenKind::OpenParen | TokenKind::OpenBrace | TokenKind::OpenBracket\n        )\n    }\n}\n\n///\n/// A literal value definition token.\n///\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum LiteralKind {\n    Int { base: Base, empty_int: bool },\n    Float { base: Base, empty_exp: bool },\n    Str { terminated: bool },\n}\n\n///\n/// The numeric bases numbers can be wirtten in.\n///\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum Base {\n    Binary,\n    Octal,\n    Hexadecimal,\n    Decimal,\n}\n\n// impl Base {\n//     pub(crate) fn radix(\u0026self) -\u003e u32 {\n//         match self {\n//             Base::Binary =\u003e 2,\n//             Base::Octal =\u003e 8,\n//             Base::Decimal =\u003e 10,\n//             \u0026Base::Hexadecimal =\u003e 16,\n//         }\n//     }\n// }\n\n/// True if `c` is considered a whitespace.\npub fn is_whitespace(c: char) -\u003e bool {\n    matches!(\n        c,\n        // Usual ASCII suspects\n        '\\u{0009}'   // \\t\n        | '\\u{000A}' // \\n\n        | '\\u{000B}' // vertical tab\n        | '\\u{000C}' // form feed\n        | '\\u{000D}' // \\r\n        | '\\u{0020}' // space\n\n        // NEXT LINE from latin1\n        | '\\u{0085}'\n\n        // Bidi markers\n        | '\\u{200E}' // LEFT-TO-RIGHT MARK\n        | '\\u{200F}' // RIGHT-TO-LEFT MARK\n\n        // Dedicated whitespace characters from Unicode\n        | '\\u{2028}' // LINE SEPARATOR\n        | '\\u{2029}' // PARAGRAPH SEPARATOR\n    )\n}\n\n/// True if `c` is valid as a first character of an identifier.\npub fn is_id_start(c: char) -\u003e bool {\n    // This is XID_Start OR '_' (which formally is not a XID_Start).\n    c == '_' || unicode_xid::UnicodeXID::is_xid_start(c)\n}\n\n/// True if `c` is valid as a non-first character of an identifier.\npub fn is_id_continue(c: char) -\u003e bool {\n    unicode_xid::UnicodeXID::is_xid_continue(c)\n}\n\n// /// The passed string is lexically an identifier.\n// pub fn is_ident(string: \u0026str) -\u003e bool {\n//     let mut chars = string.chars();\n//     if let Some(start) = chars.next() {\n//         is_id_start(start) \u0026\u0026 chars.all(is_id_continue)\n//     } else {\n//         false\n//     }\n// }\n\nimpl Cursor\u003c'_\u003e {\n    /// Parses a token from the input string.\n    fn advance_token(\u0026mut self) -\u003e Token {\n        let first_char = self.bump().unwrap();\n        let token_kind = match first_char {\n            // Slash, comment or block comment.\n            '/' =\u003e match self.first() {\n                '/' =\u003e self.line_comment(),\n                _ =\u003e Slash,\n            },\n\n            c if is_id_start(c) =\u003e self.ident_or_unknown_prefix(),\n\n            // Whitespace sequence.\n            c if is_whitespace(c) \u0026\u0026 c == '\\n' =\u003e self.whitespace(),\n            c if is_whitespace(c) =\u003e self.whitespace(),\n\n            // Numeric literal.\n            c @ '0'..='9' =\u003e {\n                let literal_kind = self.number(c);\n                let suffix_start = self.len_consumed();\n                self.eat_literal_suffix();\n                TokenKind::Literal {\n                    kind: literal_kind,\n                    suffix_start,\n                }\n            }\n            '@' =\u003e {\n                if is_id_start(self.first()) {\n                    let _ = self.bump();\n                    let token = self.ident_or_unknown_prefix();\n                    assert_eq!(token, TokenKind::Ident);\n                    TokenKind::Annotation\n                } else {\n                    At\n                }\n            }\n\n            // One-symbol tokens.\n            ';' =\u003e Semi,\n            ',' =\u003e Comma,\n            '.' =\u003e Dot,\n            '(' =\u003e OpenParen,\n            ')' =\u003e CloseParen,\n            '{' =\u003e OpenBrace,\n            '}' =\u003e CloseBrace,\n            '[' =\u003e OpenBracket,\n            ']' =\u003e CloseBracket,\n\n            '#' =\u003e Pound,\n            '~' =\u003e Tilde,\n            '?' =\u003e Question,\n            ':' =\u003e Colon,\n            '$' =\u003e Dollar,\n            '=' =\u003e Eq,\n            '!' =\u003e Bang,\n            '\u003c' =\u003e Lt,\n            '\u003e' =\u003e Gt,\n            '-' =\u003e Minus,\n            '\u0026' =\u003e And,\n            '|' =\u003e Or,\n            '+' =\u003e Plus,\n            '*' =\u003e Star,\n            '^' =\u003e Caret,\n            '%' =\u003e Percent,\n\n            // String literal.\n            '\"' =\u003e {\n                let terminated = self.double_quoted_string();\n                // let suffix_start = self.pos_within_token();\n                if terminated {\n                    self.eat_literal_suffix();\n                }\n                let kind = Str { terminated };\n                Literal {\n                    kind,\n                    suffix_start: self.len_consumed() - 1,\n                }\n            }\n\n            _ =\u003e Unknown,\n        };\n        self.idx += self.len_consumed();\n\n        Token::new(token_kind, self.len_consumed())\n    }\n\n    /// Eats double-quoted string and returns true\n    /// if string is terminated.\n    fn double_quoted_string(\u0026mut self) -\u003e bool {\n        debug_assert!(self.prev() == '\"');\n        while let Some(c) = self.bump() {\n            match c {\n                '\"' =\u003e {\n                    return true;\n                }\n                '\\\\' if self.first() == '\\\\' || self.first() == '\"' =\u003e {\n                    // Bump again to skip escaped character.\n                    self.bump();\n                }\n                _ =\u003e (),\n            }\n        }\n        // End of file reached.\n        false\n    }\n\n    fn line_comment(\u0026mut self) -\u003e TokenKind {\n        debug_assert!(self.prev() == '/' \u0026\u0026 self.first() == '/');\n        self.bump();\n\n        self.eat_while(|c| c != '\\n');\n        Comment\n    }\n\n    fn whitespace(\u0026mut self) -\u003e TokenKind {\n        debug_assert!(is_whitespace(self.prev()));\n        self.eat_while(is_whitespace);\n        Whitespace\n    }\n\n    fn ident_or_unknown_prefix(\u0026mut self) -\u003e TokenKind {\n        debug_assert!(is_id_start(self.prev()));\n        // Start is already eaten, eat the rest of identifier.\n        self.eat_while(is_id_continue);\n        // Known prefixes must have been handled earlier. So if\n        // we see a prefix here, it is definitely an unknown prefix.\n        match self.first() {\n            '#' | '\"' | '\\'' =\u003e UnknownPrefix,\n            c if !c.is_ascii() \u0026\u0026 unic_emoji_char::is_emoji(c) =\u003e {\n                self.fake_ident_or_unknown_prefix()\n            }\n            _ =\u003e Ident,\n        }\n    }\n\n    fn fake_ident_or_unknown_prefix(\u0026mut self) -\u003e TokenKind {\n        // Start is already eaten, eat the rest of identifier.\n        self.eat_while(|c| {\n            unicode_xid::UnicodeXID::is_xid_continue(c)\n                || (!c.is_ascii() \u0026\u0026 unic_emoji_char::is_emoji(c))\n                || c == '\\u{200d}'\n        });\n        // Known prefixes must have been handled earlier. So if\n        // we see a prefix here, it is definitely an unknown prefix.\n        match self.first() {\n            '#' | '\"' | '\\'' =\u003e UnknownPrefix,\n            _ =\u003e InvalidIdent,\n        }\n    }\n\n    fn number(\u0026mut self, first_digit: char) -\u003e LiteralKind {\n        debug_assert!('0' \u003c= self.prev() \u0026\u0026 self.prev() \u003c= '9');\n        let mut base = Base::Decimal;\n        if first_digit == '0' {\n            // Attempt to parse encoding base.\n            let has_digits = match self.first() {\n                'b' =\u003e {\n                    base = Base::Binary;\n                    self.bump();\n                    self.eat_decimal_digits()\n                }\n                'o' =\u003e {\n                    base = Base::Octal;\n                    self.bump();\n                    self.eat_decimal_digits()\n                }\n                'x' =\u003e {\n                    base = Base::Hexadecimal;\n                    self.bump();\n                    self.eat_hexadecimal_digits()\n                }\n                // Not a base prefix.\n                '0'..='9' | '_' | '.' | 'e' | 'E' =\u003e {\n                    self.eat_decimal_digits();\n                    true\n                }\n                // Just a 0.\n                _ =\u003e {\n                    return Int {\n                        base,\n                        empty_int: false,\n                    }\n                }\n            };\n            // Base prefix was provided, but there were no digits\n            // after it, e.g. \"0x\".\n            if !has_digits {\n                return Int {\n                    base,\n                    empty_int: true,\n                };\n            }\n        } else {\n            // No base prefix, parse number in the usual way.\n            self.eat_decimal_digits();\n        };\n\n        match self.first() {\n            // Don't be greedy if this is actually an\n            // integer literal followed by field/method access or a range pattern\n            // (`0..2` and `12.foo()`)\n            '.' if self.second() != '.' \u0026\u0026 !is_id_start(self.second()) =\u003e {\n                // might have stuff after the ., and if it does, it needs to start\n                // with a number\n                self.bump();\n                let mut empty_exp = false;\n                if self.first().is_ascii_digit() {\n                    self.eat_decimal_digits();\n                    match self.first() {\n                        'e' | 'E' =\u003e {\n                            self.bump();\n                            empty_exp = !self.eat_float_exponent();\n                        }\n                        _ =\u003e (),\n                    }\n                }\n                Float { base, empty_exp }\n            }\n            'e' | 'E' =\u003e {\n                self.bump();\n                let empty_exp = !self.eat_float_exponent();\n                Float { base, empty_exp }\n            }\n            _ =\u003e Int {\n                base,\n                empty_int: false,\n            },\n        }\n    }\n\n    fn eat_decimal_digits(\u0026mut self) -\u003e bool {\n        let mut has_digits = false;\n        loop {\n            match self.first() {\n                '_' =\u003e {\n                    self.bump();\n                }\n                '0'..='9' =\u003e {\n                    has_digits = true;\n                    self.bump();\n                }\n                _ =\u003e break,\n            }\n        }\n        has_digits\n    }\n\n    fn eat_hexadecimal_digits(\u0026mut self) -\u003e bool {\n        let mut has_digits = false;\n        loop {\n            match self.first() {\n                '_' =\u003e {\n                    self.bump();\n                }\n                '0'..='9' | 'a'..='f' | 'A'..='F' =\u003e {\n                    has_digits = true;\n                    self.bump();\n                }\n                _ =\u003e break,\n            }\n        }\n        has_digits\n    }\n\n    fn eat_float_exponent(\u0026mut self) -\u003e bool {\n        debug_assert!(self.prev() == 'e' || self.prev() == 'E');\n        if self.first() == '-' || self.first() == '+' {\n            self.bump();\n        }\n        self.eat_decimal_digits()\n    }\n\n    fn eat_literal_suffix(\u0026mut self) {\n        self.eat_identifier();\n    }\n    fn eat_identifier(\u0026mut self) {\n        if !is_id_start(self.first()) {\n            return;\n        }\n        self.bump();\n\n        self.eat_while(is_id_continue);\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":538},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":538},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":26500},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":25962},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":538},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":25424},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":25424},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":25441},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":12859},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":10889},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":12859},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":69068},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":27086},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":69068},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":32814},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":65604},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":27583},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":27583},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":25424},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":25424},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":39354},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":382},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":302},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":38150},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":37494},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":24594},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":7564},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":412},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":1230},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1701},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1701},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":263},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":261},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1218},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":176},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":484},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":665},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":9890},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":19780},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":9890},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":9890},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":6558},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":13116},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":6558},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":6558},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":6558},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":6558},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":2415},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":741},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":406},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":747},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":1098},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":1112},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":1112},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":2079},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":2079},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":2153},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":967},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":967},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":1112},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":1112},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":842},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":842},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":842},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":842},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":842},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":129,"coverable":172},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","lexer","tests.rs"],"content":"use crate::lexer::{Base, LiteralKind, Token, TokenKind};\n\nuse super::tokenize;\n\n#[test]\nfn token_examples() {\n    const EX_1: \u0026'static str = \"ident./@ \\t\\nA[]\";\n    let stream = tokenize(EX_1, 0).collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(\n        stream,\n        vec![\n            Token::new(TokenKind::Ident, 5),\n            Token::new(TokenKind::Dot, 1),\n            Token::new(TokenKind::Slash, 1),\n            Token::new(TokenKind::At, 1),\n            Token::new(TokenKind::Whitespace, 3),\n            Token::new(TokenKind::Ident, 1),\n            Token::new(TokenKind::OpenBracket, 1),\n            Token::new(TokenKind::CloseBracket, 1),\n        ]\n    );\n\n    const EX_2: \u0026'static str = \"123, ;#\\n// A \\t\\nident\";\n    let stream = tokenize(EX_2, 0).collect::\u003cVec\u003c_\u003e\u003e();\n    assert_eq!(\n        stream,\n        vec![\n            Token::new(\n                TokenKind::Literal {\n                    kind: LiteralKind::Int {\n                        base: Base::Decimal,\n                        empty_int: false\n                    },\n                    suffix_start: 3,\n                },\n                3\n            ),\n            Token::new(TokenKind::Comma, 1),\n            Token::new(TokenKind::Whitespace, 1),\n            Token::new(TokenKind::Semi, 1),\n            Token::new(TokenKind::Pound, 1),\n            Token::new(TokenKind::Whitespace, 1),\n            Token::new(TokenKind::Comment, 6),\n            Token::new(TokenKind::Whitespace, 1),\n            Token::new(TokenKind::Ident, 5),\n        ]\n    );\n}\n\n#[test]\nfn token_lex_literal() {\n    let token = tokenize(\"1234\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Int {\n                    base: Base::Decimal,\n                    empty_int: false\n                },\n                suffix_start: 4\n            },\n            len: 4,\n        }\n    );\n\n    let token = tokenize(\"0xa1234\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Int {\n                    base: Base::Hexadecimal,\n                    empty_int: false\n                },\n                suffix_start: 7\n            },\n            len: 7,\n        }\n    );\n\n    let token = tokenize(\"0b101010\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Int {\n                    base: Base::Binary,\n                    empty_int: false\n                },\n                suffix_start: 8\n            },\n            len: 8,\n        }\n    );\n\n    let token = tokenize(\"0x\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Int {\n                    base: Base::Hexadecimal,\n                    empty_int: true\n                },\n                suffix_start: 2\n            },\n            len: 2,\n        }\n    );\n\n    let token = tokenize(\"0.0\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Float {\n                    base: Base::Decimal,\n                    empty_exp: false\n                },\n                suffix_start: 3\n            },\n            len: 3,\n        }\n    );\n\n    let token = tokenize(\"1231231230.01231231236\", 0)\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Float {\n                    base: Base::Decimal,\n                    empty_exp: false\n                },\n                suffix_start: 22\n            },\n            len: 22,\n        }\n    );\n\n    let token = tokenize(\"0b0.0\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Float {\n                    base: Base::Binary,\n                    empty_exp: false\n                },\n                suffix_start: 5\n            },\n            len: 5,\n        }\n    );\n}\n\n#[test]\nfn token_lex_literal_str() {\n    let token = tokenize(\"\\\"ba@#123c\\\"\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Literal {\n                kind: LiteralKind::Str { terminated: true },\n                suffix_start: 9\n            },\n            len: 10,\n        }\n    );\n}\n\n#[test]\nfn token_lex_ident() {\n    let token = tokenize(\"abc\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Ident,\n            len: 3,\n        }\n    );\n\n    let token = tokenize(\"abc1\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Ident,\n            len: 4,\n        }\n    );\n\n    let token = tokenize(\"_abc1\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Ident,\n            len: 5,\n        }\n    );\n}\n\n#[test]\nfn token_lex_annotation() {\n    let token = tokenize(\"@abc\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Annotation,\n            len: 4,\n        }\n    );\n\n    let token = tokenize(\"@abc1\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Annotation,\n            len: 5,\n        }\n    );\n\n    let token = tokenize(\"@_abc\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::Annotation,\n            len: 5,\n        }\n    );\n\n    let token = tokenize(\"@ abc\", 0).collect::\u003cVec\u003c_\u003e\u003e().remove(0);\n    assert_eq!(\n        token,\n        Token {\n            kind: TokenKind::At,\n            len: 1,\n        }\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","lib.rs"],"content":"#![allow(clippy::needless_range_loop)]\n\npub mod ast;\npub mod error;\npub mod ir;\n\npub(crate) mod context;\npub(crate) mod lexer;\npub(crate) mod resolve;\npub(crate) mod resource;\n\npub(crate) mod util;\n\npub use self::resource::Asset;\npub use self::resource::AssetIdentifier;\npub use self::resource::SourceMap;\npub use self::resource::Span;\n\npub use self::context::Context;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","ast_tables.rs"],"content":"use std::sync::Arc;\n\nuse crate::{\n    ast::{self, Item, LinkStmt, ModuleStmt, Spanned},\n    error::*,\n    resource::AssetIdentifier,\n    util::dfs_cycles,\n    Context, SourceMap, Span,\n};\n\n// # Links\n\n#[derive(Debug, Clone, PartialEq)]\npub struct LinkAstTable {\n    source: AssetIdentifier,\n    links: Vec\u003cArc\u003cLinkStmt\u003e\u003e,\n    ptr: usize,\n}\n\nimpl LinkAstTable {\n    /// Orders local deps in loadable order, returning true on success,\n    /// false on error. Errors are attached to the ErrorsMut object.\n    pub fn order_local_deps(\u0026mut self, errors: \u0026mut ErrorsMut) -\u003e bool {\n        let (local, nonlocal) = self.local_mut();\n        let mut s = 0;\n\n        // Generate topo;\n        let mut topo = vec![Vec::new(); local.len()];\n        for i in 0..local.len() {\n            let Some(ref inh) = local[i].inheritance else {\n                continue;\n            };\n\n            for dep in inh.symbols.iter() {\n                let ldep = local\n                    .iter()\n                    .position(|l| l.ident.raw == dep.raw);\n                if let Some(ldep) = ldep {\n                    topo[i].push(ldep);\n                } else {\n                    // ignore nonloca dep\n                }\n            }\n        }\n\n        if let Err(cycles) = dfs_cycles(\u0026topo) {\n            for cycle in cycles {\n                let s = cycle[0];\n\n                let mut fmt = vec![\u0026local[s].ident.raw[..]];\n                for \u0026e in cycle.iter().rev() {\n                    fmt.push(\u0026local[e].ident.raw[..]);\n                }\n\n                errors.add(\n                    Error::new(\n                        ErrorKind::LinkLocalCyclicDeps,\n                        format!(\n                            \"found cyclic definition of local links: {}\",\n                            fmt.join(\" \u003c- \")\n                        ),\n                    )\n                    .spanned(local[s].span()),\n                );\n            }\n\n            return false;\n        }\n\n        while s \u003c local.len() {\n            // let mut loadable = false;\n            let mut i = s;\n\n            'seacher: while i \u003c local.len() {\n                // check if i depents are in ..s\n                if let Some(ref inh) = local[i].inheritance {\n                    'inner: for dep in inh.symbols.iter() {\n                        let valid = local[..s].iter().any(|l| l.ident.raw == dep.raw);\n                        if !valid {\n                            let valid_nonlocal = nonlocal.iter().any(|l| l.ident.raw == dep.raw);\n                            if valid_nonlocal {\n                                continue 'inner;\n                            }\n\n                            i += 1;\n                            continue 'seacher;\n                        }\n                    }\n                    // all deps are valid\n                    // loadable = true;\n                    break;\n                } else {\n                    // loadable = true;\n                    break;\n                }\n            }\n\n            // not all deps may be loadable, since nonlocal deps are not repr\n            if s != i \u0026\u0026 i \u003c local.len() {\n                local.swap(s, i);\n            }\n\n            s += 1;\n        }\n\n        true\n    }\n\n    pub fn local(\u0026self) -\u003e \u0026[Arc\u003cLinkStmt\u003e] {\n        \u0026self.links[..self.ptr]\n    }\n\n    pub fn local_mut(\u0026mut self) -\u003e (\u0026mut [Arc\u003cLinkStmt\u003e], \u0026mut [Arc\u003cLinkStmt\u003e]) {\n        self.links.split_at_mut(self.ptr)\n    }\n\n    pub fn from_ctx(ctx: \u0026Context, asset: \u0026AssetIdentifier, errors: \u0026mut ErrorsMut) -\u003e Self {\n        let mut links = Vec::new();\n\n        let asts = ctx.asts_for_asset(asset);\n        let ptr = asts[0]\n            .1\n            .items\n            .iter()\n            .filter(|i| matches!(i, Item::Link(_)))\n            .count();\n\n        for (_, ast) in asts {\n            for item in \u0026ast.items {\n                if let Item::Link(link) = item {\n                    links.push(link.clone())\n                }\n            }\n        }\n\n        Self::check_dup(\u0026links, errors);\n\n        Self {\n            source: asset.clone(),\n            links,\n            ptr,\n        }\n    }\n\n    fn check_dup(links: \u0026[Arc\u003cLinkStmt\u003e], errors: \u0026mut ErrorsMut) {\n        if links.len() \u003c= 1 {\n            return;\n        }\n        for s in 0..(links.len() - 1) {\n            let mut dups = Vec::new();\n            for i in (s + 1)..links.len() {\n                if links[s].ident.raw == links[i].ident.raw {\n                    dups.push(i)\n                }\n            }\n\n            if !dups.is_empty() {\n                let mut e = Error::new(\n                    ErrorKind::SymbolDuplication,\n                    format!(\n                        \"found duplicated symbol '{}', with {} duplications\",\n                        links[s].ident.raw,\n                        dups.len()\n                    ),\n                )\n                .spanned(links[s].span());\n                for i in dups {\n                    e = e.add_hints(ErrorHint::Note(format!(\n                        \"duplicated symbol definition found at {:?}\",\n                        links[i].span()\n                    )));\n                }\n\n                errors.add(e)\n            }\n        }\n    }\n}\n\n// # Modules\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ModuleAstTable {\n    source: AssetIdentifier,\n    modules: Vec\u003cArc\u003cModuleStmt\u003e\u003e,\n    ptr: usize,\n}\n\nimpl ModuleAstTable {\n    pub fn order_local_deps(\u0026mut self, errors: \u0026mut ErrorsMut) -\u003e bool {\n        let (local, _) = self.local_mut();\n\n        // Generate topo\n        let mut topo = vec![Vec::new(); local.len()];\n        for i in 0..local.len() {\n            // 1) submodules links\n            let submodules = \u0026local[i].submodules;\n            for dep in submodules.iter().flat_map(|s| s.items.iter()) {\n                let ldep = local\n                    .iter()\n                    .position(|l| l.ident.raw == dep.typ.raw());\n                if let Some(ldep) = ldep {\n                    topo[i].push(ldep);\n                }\n            }\n\n            // 2) inheritance links\n            let Some(inh) = \u0026local[i].inheritance else { continue };\n            for dep in inh.symbols.iter() {\n                let ldep = local\n                    .iter()\n                    .position(|l| l.ident.raw == dep.raw);\n                if let Some(ldep) = ldep {\n                    topo[i].push(ldep)\n                }\n            }\n        }\n\n        if let Err(cycles) = dfs_cycles(\u0026topo) {\n            for cycle in cycles {\n                let s = cycle[0];\n\n                let mut fmt = vec![\u0026local[s].ident.raw[..]];\n                for \u0026e in cycle.iter().rev() {\n                    fmt.push(\u0026local[e].ident.raw[..]);\n                }\n\n                errors.add(\n                    Error::new(\n                        ErrorKind::ModuleLocalCyclicDeps,\n                        format!(\n                            \"found cyclic definition of local modules: {}\",\n                            fmt.join(\" \u003c- \")\n                        ),\n                    )\n                    .spanned(local[s].span()),\n                );\n            }\n            return false;\n        }\n\n        let mut topo_remapping = (0..topo.len()).collect::\u003cVec\u003c_\u003e\u003e();\n\n        let mut s = 0;\n        while s \u003c local.len() {\n            let mut i = s;\n            while i \u003c local.len() {\n                // Check whether i can be loaded with local[..s]\n                // use local topo\n                let edges = \u0026topo[i];\n                let local_valid = edges.iter().all(|\u0026e| topo_remapping[e] \u003c s);\n                if !local_valid {\n                    i += 1;\n                    continue;\n                }\n\n                break;\n            }\n\n            if s != i \u0026\u0026 i \u003c local.len() {\n                local.swap(s, i);\n                topo.swap(s, i);\n                topo_remapping.swap(s, i);\n            }\n            s += 1;\n        }\n\n        true\n    }\n\n    pub fn local(\u0026self) -\u003e \u0026[Arc\u003cModuleStmt\u003e] {\n        \u0026self.modules[..self.ptr]\n    }\n\n    pub fn local_mut(\u0026mut self) -\u003e (\u0026mut [Arc\u003cModuleStmt\u003e], \u0026mut [Arc\u003cModuleStmt\u003e]) {\n        self.modules.split_at_mut(self.ptr)\n    }\n\n    pub fn from_ctx(ctx: \u0026Context, asset: \u0026AssetIdentifier, errors: \u0026mut ErrorsMut) -\u003e Self {\n        let mut modules = Vec::new();\n\n        let asts = ctx.asts_for_asset(asset);\n        let ptr = asts[0]\n            .1\n            .items\n            .iter()\n            .filter(|i| matches!(i, Item::Module(_)))\n            .count();\n\n        // println!(\"{asts:#?}\");\n\n        for (_, ast) in asts {\n            for item in \u0026ast.items {\n                if let Item::Module(module) = item {\n                    modules.push(module.clone())\n                }\n            }\n        }\n\n        Self::check_dup(\u0026modules, errors);\n\n        Self {\n            source: asset.clone(),\n            modules,\n            ptr,\n        }\n    }\n\n    fn check_dup(modules: \u0026[Arc\u003cModuleStmt\u003e], errors: \u0026mut ErrorsMut) {\n        if modules.len() \u003c= 1 {\n            return;\n        }\n        for s in 0..(modules.len() - 1) {\n            let mut dups = Vec::new();\n            for i in (s + 1)..modules.len() {\n                if modules[s].ident.raw == modules[i].ident.raw {\n                    dups.push(i)\n                }\n            }\n\n            if !dups.is_empty() {\n                let mut e = Error::new(\n                    ErrorKind::SymbolDuplication,\n                    format!(\n                        \"Found duplicated symbol '{}', {} duplications\",\n                        modules[s].ident.raw,\n                        dups.len()\n                    ),\n                )\n                .spanned(modules[s].span());\n                for i in dups {\n                    e = e.add_hints(ErrorHint::Note(format!(\n                        \"duplicated symbol definition found at {:?}\",\n                        modules[i].span()\n                    )));\n                }\n\n                errors.add(e)\n            }\n        }\n    }\n}\n\npub struct GlobalAstTable\u003c'a\u003e {\n    this: AssetIdentifier,\n    smap: \u0026'a SourceMap,\n    modules: Vec\u003cArc\u003cModuleStmt\u003e\u003e,\n    links: Vec\u003cArc\u003cLinkStmt\u003e\u003e,\n}\n\nimpl\u003c'a\u003e GlobalAstTable\u003c'a\u003e {\n    pub fn new(ctx: \u0026'a Context, this: \u0026AssetIdentifier) -\u003e GlobalAstTable\u003c'a\u003e {\n        let mut modules = Vec::new();\n        let mut links = Vec::new();\n\n        for file in ctx.ast.values() {\n            for item in \u0026file.items {\n                match item {\n                    ast::Item::Module(module) =\u003e modules.push(module.clone()),\n                    ast::Item::Link(link) =\u003e links.push(link.clone()),\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        GlobalAstTable {\n            this: this.clone(),\n            smap: \u0026ctx.smap,\n            modules,\n            links,\n        }\n    }\n\n    pub fn err_resolve_symbol(\u0026self, symbol: \u0026str, expect_module: bool, mut error: Error) -\u003e Error {\n        for module in \u0026self.modules {\n            if module.ident.raw == symbol {\n                let target_asset = self.smap.asset_for(module.span()).unwrap();\n                let target = target_asset.ident.path().unwrap().to_str().unwrap();\n\n                if expect_module {\n                    error.hints.push(ErrorHint::Help(format!(\n                        \"similar symbol '{symbol}' was found, but not included ({target})\"\n                    )));\n\n                    let this = self.smap.asset(\u0026self.this).unwrap();\n                    let span = Span::new(this.offset, 0);\n                    if let Some(include) = this.include_for(target_asset) {\n                        let replacement = format!(\"include {};\", include);\n\n                        error.hints.push(ErrorHint::Solution(ErrorSolution {\n                            description: format!(\"try including '{symbol}' from '{include}'\"),\n                            span,\n                            replacement,\n                        }));\n                    }\n                } else {\n                    error.hints.push(ErrorHint::Note(format!(\n                        \"similar symbol '{symbol}' was found, but it is a module ({target})\"\n                    )));\n                }\n            }\n        }\n\n        for link in \u0026self.links {\n            if link.ident.raw == symbol {\n                let target_asset = self.smap.asset_for(link.span()).unwrap();\n                let target = target_asset.ident.path().unwrap().to_str().unwrap();\n\n                if !expect_module {\n                    error.hints.push(ErrorHint::Help(format!(\n                        \"similar symbol '{symbol}' was found, but not included\"\n                    )));\n\n                    let this = self.smap.asset(\u0026self.this).unwrap();\n                    let span = Span::new(this.offset, 0);\n\n                    if let Some(include) = this.include_for(target_asset) {\n                        let replacement = format!(\"include {};\", include);\n                        error.hints.push(ErrorHint::Solution(ErrorSolution {\n                            description: format!(\"try including '{symbol}' from '{include}'\"),\n                            span,\n                            replacement,\n                        }));\n                    }\n                } else {\n                    error.hints.push(ErrorHint::Note(format!(\n                        \"similar symbol '{symbol}' was found, but it is a link ({target})\"\n                    )));\n                }\n            }\n        }\n\n        error\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":408},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":228},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":204},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":132},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":2496},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":888},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2400},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":186},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":846},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":582},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1746},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":330},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1278},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":630},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1164},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":210},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":726},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":498},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":498},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":840},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":510},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":2496},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":888},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":2400},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":618},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":618},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":378},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":378},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1176},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":798},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":378},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":1320},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":5832},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1356},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":384},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":780},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":54},"fn_name":null}],"covered":182,"coverable":203},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","ir_tables.rs"],"content":"use std::sync::Arc;\n\nuse crate::{\n    context::Context,\n    error::*,\n    ir::{Item, Link, Module},\n    resource::AssetIdentifier,\n};\n\n#[derive(Debug)]\npub struct LinkIrTable {\n    links: Vec\u003cArc\u003cLink\u003e\u003e,\n}\n\nimpl LinkIrTable {\n    pub fn get(\u0026self, key: impl AsRef\u003cstr\u003e) -\u003e Option\u003cArc\u003cLink\u003e\u003e {\n        let key = key.as_ref();\n        self.links.iter().find(|v| v.ident.raw == key).cloned()\n    }\n\n    pub fn add(\u0026mut self, local: Arc\u003cLink\u003e) {\n        self.links.push(local)\n    }\n\n    pub fn from_ctx(\n        ctx: \u0026Context,\n        asset: \u0026AssetIdentifier,\n        _errors: \u0026mut ErrorsMut,\n        include_self: bool,\n    ) -\u003e Self {\n        let mut links = Vec::new();\n\n        for (_, ir) in ctx.ir_for_asset(asset, include_self) {\n            for item in ir.items.iter() {\n                if let Item::Link(link) = item {\n                    links.push(link.clone())\n                }\n            }\n        }\n\n        // no dup checking nessecary since done in ast stage\n\n        Self { links }\n    }\n}\n\n#[derive(Debug)]\npub struct ModuleIrTable {\n    modules: Vec\u003cArc\u003cModule\u003e\u003e,\n}\n\nimpl ModuleIrTable {\n    pub fn get(\u0026self, key: impl AsRef\u003cstr\u003e) -\u003e Option\u003cArc\u003cModule\u003e\u003e {\n        let key = key.as_ref();\n        self.modules.iter().find(|v| v.ident.raw == key).cloned()\n    }\n\n    pub fn add(\u0026mut self, local: Arc\u003cModule\u003e) {\n        self.modules.push(local)\n    }\n\n    pub fn from_ctx(\n        ctx: \u0026Context,\n        asset: \u0026AssetIdentifier,\n        _errors: \u0026mut ErrorsMut,\n        include_self: bool,\n    ) -\u003e Self {\n        let mut modules = Vec::new();\n\n        for (_, ir) in ctx.ir_for_asset(asset, include_self) {\n            for item in ir.items.iter() {\n                if let Item::Module(module) = item {\n                    modules.push(module.clone())\n                }\n            }\n        }\n\n        // no dup checking nessecary since done in ast stage\n\n        Self { modules }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":312},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":492},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":492},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1866},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":540},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":546},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":672},"fn_name":null}],"covered":20,"coverable":20},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","link.rs"],"content":"use std::{collections::HashMap, sync::Arc};\n\nuse crate::{\n    ast::{LinkStmt, Spanned},\n    error::*,\n    ir::{Link, RawSymbol},\n    resolve::LinkIrTable,\n};\n\nuse super::GlobalAstTable;\n\nimpl Link {\n    pub fn from_ast(\n        link: Arc\u003cLinkStmt\u003e,\n        ir_links: \u0026LinkIrTable,\n        globals: \u0026GlobalAstTable,\n        errors: \u0026mut ErrorsMut,\n    ) -\u003e Link {\n        let errlen = errors.len();\n        // We can assume\n        // - no dup, valid fields (if existent)\n        let mut ir = Link {\n            ident: RawSymbol {\n                raw: link.ident.raw.clone(),\n            },\n\n            fields: HashMap::new(),\n            jitter: f64::NEG_INFINITY,\n            latency: f64::NEG_INFINITY,\n            bitrate: i32::MIN,\n\n            ast: link.clone(),\n\n            dirty: false,\n        };\n\n        // Apply inheritence in order\n        if let Some(ref inh) = link.inheritance {\n            for symbol in inh.symbols.iter() {\n                // Resolve ident\n                // All values in scope are allread in IR table\n                // - local elements are non-nessecary in scope, but in order\n                let Some(dep) = ir_links.get(symbol) else {\n                    errors.add(Error::new(\n                        ErrorKind::SymbolNotFound,\n                        format!(\"did not find link symbol '{}', not in scope\", symbol.raw)\n                    ).spanned(inh.span()).map(|e| globals.err_resolve_symbol(\u0026symbol.raw, false, e)));\n                    continue;\n                };\n                ir.apply(\u0026dep);\n            }\n        }\n\n        for field in link.data.items.iter() {\n            match field.key.raw.as_str() {\n                \"jitter\" =\u003e ir.jitter = field.value.as_float(),\n                \"latency\" =\u003e ir.latency = field.value.as_float(),\n                \"bitrate\" =\u003e ir.bitrate = field.value.as_integer(),\n                other =\u003e {\n                    let _ = ir\n                        .fields\n                        .insert(other.to_string(), field.value.clone().into());\n                }\n            }\n        }\n\n        if ir.jitter == f64::NEG_INFINITY {\n            errors.add(\n                Error::new(\n                    ErrorKind::LinkMissingRequiredFields,\n                    \"missing required field 'jitter', was not defined locally or in prototypes\",\n                )\n                .spanned(ir.ast.span()),\n            );\n        }\n        if ir.latency == f64::NEG_INFINITY {\n            errors.add(\n                Error::new(\n                    ErrorKind::LinkMissingRequiredFields,\n                    \"missing required field 'latency', was not defined locally or in prototypes\",\n                )\n                .spanned(ir.ast.span()),\n            );\n        }\n        if ir.bitrate == i32::MIN {\n            errors.add(\n                Error::new(\n                    ErrorKind::LinkMissingRequiredFields,\n                    \"missing required field 'bitrate', was not defined locally or in prototypes\",\n                )\n                .spanned(ir.ast.span()),\n            );\n        }\n\n        if errlen \u003c errors.len() {\n            ir.dirty = true;\n        }\n\n        ir\n    }\n\n    fn apply(\u0026mut self, other: \u0026Link) {\n        self.jitter = other.jitter;\n        self.latency = other.latency;\n        self.bitrate = other.bitrate;\n        for (k, v) in other.fields.iter() {\n            let _ = self.fields.insert(k.clone(), v.clone());\n        }\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":390},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":378},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":186},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":138},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":12},"fn_name":null}],"covered":44,"coverable":49},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","local_tables.rs"],"content":"use super::IterIter;\nuse crate::{\n    ast::{LocalModuleGateReference, ModuleGateReference, NonlocalModuleGateReference, Spanned},\n    error::*,\n    ir::*,\n};\nuse std::iter;\n\npub struct LocalGatesTable\u003c'a\u003e {\n    gates: \u0026'a [Gate],\n}\n\nimpl\u003c'a\u003e LocalGatesTable\u003c'a\u003e {\n    pub fn new(gates: \u0026'a [Gate]) -\u003e Self {\n        Self { gates }\n    }\n\n    pub fn resolve(\n        \u0026self,\n        gatec_def: \u0026'a LocalModuleGateReference,\n    ) -\u003e Result\u003cBox\u003cdyn Iterator\u003cItem = GateRef\u003c'a\u003e\u003e + 'a\u003e\u003e {\n        let Some(def) = self\n            .gates\n            .iter()\n            .find(|g| g.ident.raw == gatec_def.gate.raw) else {\n                return Err(Error::new(\n                    ErrorKind::SymbolNotFound,\n                    format!(\"did not find gate symbol '{}', not in scope\", gatec_def.gate.raw)\n                ))\n            };\n        match (\u0026gatec_def.gate_cluster, def.cluster) {\n            (None, Cluster::Standalone) =\u003e Ok(Box::new(iter::once(GateRef {\n                def,\n                pos: None,\n                submod: None,\n            }))),\n            (None, Cluster::Clusted(cl)) =\u003e Ok(Box::new((0..cl).map(|pos| GateRef {\n                def,\n                pos: Some(pos),\n                submod: None,\n            }))),\n            (Some(c), Cluster::Clusted(cl)) if (c.lit.as_integer() as usize) \u003c cl =\u003e {\n                Ok(Box::new(iter::once(GateRef {\n                    def,\n                    pos: Some(c.lit.as_integer() as usize),\n                    submod: None,\n                })))\n            }\n            (Some(c), Cluster::Clusted(cl)) =\u003e Err(Error::new(\n                ErrorKind::InvalidConClusterIndex,\n                format!(\n                    \"cannot index into gate cluster of size {} with index {}\",\n                    cl,\n                    c.lit.as_integer()\n                ),\n            )),\n            (Some(_), Cluster::Standalone) =\u003e Err(Error::new(\n                ErrorKind::InvalidConClusterIndex,\n                format!(\n                    \"cannot index into gate '{}' since it is not a cluster\",\n                    def.ident.raw\n                ),\n            )),\n        }\n    }\n}\n\npub struct SharedGatesTable\u003c'a\u003e {\n    local: \u0026'a LocalGatesTable\u003c'a\u003e,\n    submodules: \u0026'a LocalSubmoduleTable\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e SharedGatesTable\u003c'a\u003e {\n    pub fn new(local: \u0026'a LocalGatesTable\u003c'a\u003e, submodules: \u0026'a LocalSubmoduleTable\u003c'a\u003e) -\u003e Self {\n        Self { local, submodules }\n    }\n\n    pub fn resolve(\n        \u0026self,\n        def: \u0026'a ModuleGateReference,\n    ) -\u003e Result\u003cBox\u003cdyn Iterator\u003cItem = GateRef\u003c'a\u003e\u003e + 'a\u003e\u003e {\n        match def {\n            ModuleGateReference::Local(gatec_def) =\u003e self.local.resolve(gatec_def),\n            ModuleGateReference::Nonlocal(submodgate_def) =\u003e {\n                let submodules = self.submodules.resolve(submodgate_def)?;\n                let mut gates_iters = Vec::new();\n                for submodule_ref in submodules {\n                    let Some(submodule) = submodule_ref.def.typ.as_module() else {\n                        // type of submodule is not specified, thus ignore this error as transitent.\n                        unimplemented!()\n                    };\n                    let tbl = LocalGatesTable::new(\u0026submodule.gates);\n                    let mut gates = tbl.resolve(\u0026submodgate_def.gate)?.collect::\u003cVec\u003c_\u003e\u003e();\n                    for gate in \u0026mut gates {\n                        gate.submod = Some((\n                            submodule_ref.pos,\n                            submodule_ref.def.ident.raw.clone(),\n                            submodule_ref.def.cluster,\n                        ));\n                    }\n\n                    gates_iters.push(gates.into_iter());\n                }\n\n                Ok(Box::new(IterIter::new(gates_iters.into_iter())))\n            }\n        }\n    }\n}\n\npub struct LocalSubmoduleTable\u003c'a\u003e {\n    modules: \u0026'a [Submodule],\n}\n\nimpl\u003c'a\u003e LocalSubmoduleTable\u003c'a\u003e {\n    pub fn new(modules: \u0026'a [Submodule]) -\u003e Self {\n        Self { modules }\n    }\n\n    pub fn resolve(\n        \u0026self,\n        submodgate_def: \u0026'a NonlocalModuleGateReference,\n    ) -\u003e Result\u003cBox\u003cdyn Iterator\u003cItem = SubmoduleRef\u003c'a\u003e\u003e + 'a\u003e\u003e {\n        let Some(def) = self\n            .modules\n            .iter()\n            .find(|def| def.ident.raw == submodgate_def.submodule.raw) else {\n                return Err(Error::new(\n                    ErrorKind::SymbolNotFound,\n                    format!(\"did not find submodule symbol '{}', not in scope\", submodgate_def.submodule.raw)\n                ).spanned(submodgate_def.span()))\n        };\n\n        match (\u0026submodgate_def.submodule_cluster, def.cluster) {\n            (None, Cluster::Standalone) =\u003e Ok(Box::new(iter::once(SubmoduleRef { def, pos: 0 }))),\n            (None, Cluster::Clusted(cl)) =\u003e {\n                Ok(Box::new((0..cl).map(|pos| SubmoduleRef { def, pos })))\n            }\n            (Some(c), Cluster::Clusted(cl)) if (c.lit.as_integer() as usize) \u003c cl =\u003e {\n                Ok(Box::new(iter::once(SubmoduleRef {\n                    def,\n                    pos: c.lit.as_integer() as usize,\n                })))\n            }\n            (Some(c), Cluster::Clusted(cl)) =\u003e Err(Error::new(\n                ErrorKind::InvalidConClusterIndex,\n                format!(\n                    \"cannot index into submdoule cluster of size {} with index {}\",\n                    cl,\n                    c.lit.as_integer()\n                ),\n            )),\n            (Some(_), Cluster::Standalone) =\u003e Err(Error::new(\n                ErrorKind::InvalidConClusterIndex,\n                format!(\n                    \"cannot index into submodule '{}' since it is not a cluster\",\n                    def.ident.raw\n                ),\n            )),\n        }\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":858},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":396},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":792},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":396},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":396},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1404},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1008},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1776},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":870},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":43,"coverable":82},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","mod.rs"],"content":"use std::path::PathBuf;\nuse std::sync::Arc;\n\nuse crate::ast;\nuse crate::context::Context;\nuse crate::error::*;\nuse crate::ir;\nuse crate::resource::AssetIdentifier;\n\nmod ast_tables;\nmod ir_tables;\nmod link;\nmod local_tables;\nmod module;\nmod util;\n\npub use self::ast_tables::*;\npub use self::ir_tables::*;\n// pub use self::link::*;\npub use self::local_tables::*;\n// pub use self::module::*;\n\npub(crate) use self::util::*;\n\nimpl Context {\n    pub(super) fn load_ir(\u0026mut self, errors: \u0026mut ErrorsMut) {\n        let order = self.ir_load_order();\n        for asset in order {\n            let asset_str = asset.alias().to_string();\n            let asset_path = asset.path().unwrap_or(\u0026PathBuf::new()).clone();\n\n            // Add asset info to all errors.\n            errors.with_mapping(\n                move |e| {\n                    e.add_hints(ErrorHint::Note(format!(\n                        \"found in assset '{}' ({:?})\",\n                        asset_str, asset_path\n                    )))\n                },\n                |errors| {\n                    // Collect all defined items.\n                    let mut items = Vec::new();\n\n                    // Link deriving uses ast-link defs for local info, ir_links allready symbolised in\n                    // dependencies and a global ast context for symbol resoloution.\n                    let mut ast_links = LinkAstTable::from_ctx(self, \u0026asset, errors);\n                    let mut ir_links = LinkIrTable::from_ctx(self, \u0026asset, errors, false);\n                    let global_ast = GlobalAstTable::new(self, \u0026asset);\n\n                    // Resolve links\n                    // - all nonlocal dependencies are allready ir\n                    // - local dependencies may be out of order\n                    if ast_links.order_local_deps(errors) {\n                        for link in ast_links.local() {\n                            let ident = link.ident.raw.clone();\n                            errors.with_mapping(\n                                move |e| {\n                                    e.add_hints(ErrorHint::Note(format!(\n                                        \"found in link definition '{}'\",\n                                        ident\n                                    )))\n                                },\n                                |errors| {\n                                    // Use the link_specific symboliser to parse a link;\n                                    let ir = ir::Link::from_ast(\n                                        link.clone(),\n                                        \u0026ir_links,\n                                        \u0026global_ast,\n                                        errors,\n                                    );\n                                    let ir = Arc::new(ir);\n\n                                    // Add the link to the local ir_table to ensure that other links\n                                    // in this link can use it in later iterations.\n                                    // order is ensure by order_local_deps\n                                    ir_links.add(ir.clone());\n                                    items.push(ir::Item::Link(ir));\n                                },\n                            );\n                        }\n                    }\n\n                    // Modules use local ast info, and dependency ir info, with global ast-debug info\n                    let mut ast_modules = ModuleAstTable::from_ctx(self, \u0026asset, errors);\n                    let mut ir_modules = ModuleIrTable::from_ctx(self, \u0026asset, errors, false);\n                    let global_ast = GlobalAstTable::new(self, \u0026asset);\n\n                    // Resolve mdoules\n                    // - same\n                    if ast_modules.order_local_deps(errors) {\n                        // println!(\"{:#?}\", ast_modules.local());\n                        for module in ast_modules.local() {\n                            let ident = module.ident.raw.clone();\n                            errors.with_mapping(\n                                move |e| {\n                                    e.add_hints(ErrorHint::Note(format!(\n                                        \"found in module definition '{}'\",\n                                        ident\n                                    )))\n                                },\n                                |errors| {\n                                    // Use the local symboliser for modules.\n                                    let ir = ir::Module::from_ast(\n                                        module.clone(),\n                                        \u0026ir_modules,\n                                        \u0026ir_links,\n                                        \u0026global_ast,\n                                        errors,\n                                    );\n\n                                    let ir = Arc::new(ir);\n\n                                    // Add the module to the local ir_table to ensure that other modules\n                                    // in this module can use it in later iterations.\n                                    // order is ensure by order_local_deps\n                                    ir_modules.add(ir.clone());\n                                    items.push(ir::Item::Module(ir));\n                                },\n                            )\n                        }\n                    }\n\n                    // Address collected items with asset identifier\n                    self.ir.insert(asset, ir::Items { items });\n                },\n            );\n        }\n    }\n\n    fn ir_load_order(\u0026self) -\u003e Vec\u003cAssetIdentifier\u003e {\n        let mut order = Vec::new();\n        let mut rem = self.assets.clone();\n        while !rem.is_empty() {\n            for i in 0..rem.len() {\n                let deps = self.deps.get(\u0026rem[i]).unwrap();\n                let mut loadable = true;\n                for dep in deps {\n                    if !order.contains(dep) {\n                        loadable = false;\n                        break;\n                    }\n                }\n\n                if loadable {\n                    let asset = rem.remove(i);\n                    order.push(asset);\n                    break;\n                }\n            }\n        }\n\n        order\n    }\n\n    pub(super) fn load_entry_and_check_dyn(\u0026mut self, errors: \u0026mut ErrorsMut) {\n        let ir_table = ModuleIrTable::from_ctx(self, \u0026self.root, errors, true);\n\n        let asts = self.asts_for_asset(\u0026self.root);\n        for ast in \u0026asts {\n            for item in \u0026ast.1.items {\n                let ast::Item::Entry(entry) = item else {\n                    continue;\n                };\n\n                let Some(symbol) = ir_table.get(\u0026entry.symbol.raw) else {\n                    errors.add(Error::new(\n                        ErrorKind::SymbolNotFound,\n                        format!(\"defined entry symbol '{}' not in scope\", entry.symbol.raw)\n                    ));\n                    return;\n                };\n                self.check_dyn(symbol.clone(), errors);\n                self.entry = Some(symbol);\n                return;\n            }\n        }\n\n        errors.add(Error::new(\n            ErrorKind::MissingEntryPoint,\n            \"missing entry point to ndl topology\",\n        ));\n    }\n\n    #[allow(clippy::only_used_in_recursion)]\n    fn check_dyn(\u0026self, arc: Arc\u003cir::Module\u003e, errors: \u0026mut ErrorsMut) {\n        let arc2 = arc.clone();\n        errors.with_mapping(\n            move |e| e.add_hints(ErrorHint::Note(format!(\"in module '{}'\", arc.ident.raw))),\n            move |errors| {\n                for submodule in arc2.submodules.iter() {\n                    if submodule.dynamic {\n                        unreachable!();\n                    }\n\n                    if let Some(sub) = submodule.typ.as_module_arc() {\n                        self.check_dyn(sub, errors)\n                    }\n                }\n            },\n        )\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1008},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":528},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":726},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":558},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":972},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":480},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":576},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":312},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":312},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":492},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":312},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":876},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":330},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":552},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":552},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":444},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":168},"fn_name":null}],"covered":88,"coverable":96},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","module.rs"],"content":"use std::sync::Arc;\n\nuse crate::{\n    ast::{ModuleStmt, Spanned},\n    error::*,\n    ir::{\n        Cluster, Connection, ConnectionEndpoint, Gate, Module, RawSymbol,\n        Submodule, Symbol,\n    },\n    resolve::{LinkIrTable, LocalGatesTable, LocalSubmoduleTable, ModuleIrTable, SharedGatesTable},\n};\n\nuse super::GlobalAstTable;\n\nimpl Module {\n    pub fn from_ast(\n        ast: Arc\u003cModuleStmt\u003e,\n        modules: \u0026ModuleIrTable,\n        links: \u0026LinkIrTable,\n        global: \u0026GlobalAstTable,\n        errors: \u0026mut ErrorsMut,\n    ) -\u003e Module {\n        let errlen = errors.len();\n\n        // load deps;\n        // TODO: check for dirty deps.\n        let mut deps = Vec::new();\n        let mut inherited = Vec::new();\n        if let Some(ref inh) = ast.inheritance {\n            for dep in inh.symbols.iter() {\n                let typ = match modules.get(dep) {\n                    Some(v) =\u003e v,\n                    None =\u003e {\n                        errors.add(\n                            Error::new(\n                                ErrorKind::SymbolNotFound,\n                                format!(\n                                    \"did not find inheritance symbol '{}', not in scope\",\n                                    dep.raw\n                                ),\n                            )\n                            .spanned(dep.span())\n                            .map(|e| global.err_resolve_symbol(\u0026dep.raw, true, e)),\n                        );\n                        inherited.push(Symbol::Unresolved(RawSymbol {\n                            raw: dep.raw.clone(),\n                        }));\n                        continue;\n                    }\n                };\n                deps.push(typ.clone());\n                inherited.push(Symbol::from(typ));\n            }\n        }\n\n        // Include gate definitions\n        let mut ir_gates: Vec\u003cGate\u003e = Vec::with_capacity(ast.gates.len());\n        for inh in \u0026deps {\n            ir_gates.extend(inh.gates.iter().cloned());\n        }\n        for gate in ast.gates.iter().flat_map(|stmt| stmt.items.iter()) {\n            if ir_gates.iter().any(|d| d.ident.raw == gate.ident.raw) {\n                errors.add(\n                    Error::new(\n                        ErrorKind::SymbolDuplication,\n                        format!(\n                            \"gate(-cluster) '{}' was defined multiple times\",\n                            gate.ident.raw\n                        ),\n                    )\n                    .spanned(gate.span()),\n                );\n                continue;\n            }\n            ir_gates.push(Gate {\n                ident: RawSymbol {\n                    raw: gate.ident.raw.clone(),\n                },\n                cluster: gate\n                    .cluster\n                    .as_ref()\n                    .map(Cluster::from)\n                    .unwrap_or(Cluster::Standalone),\n            });\n        }\n\n        // Include submodule definition\n        let mut ir_submodules: Vec\u003cSubmodule\u003e = Vec::with_capacity(ast.submodules.len());\n        for inh in \u0026deps {\n            ir_submodules.extend(inh.submodules.iter().cloned());\n        }\n        for submodule_ast in ast.submodules.iter().flat_map(|stmt| stmt.items.iter()) {\n            if ir_submodules\n                .iter()\n                .any(|d| d.ident.raw == submodule_ast.ident.raw)\n            {\n                errors.add(\n                    Error::new(\n                        ErrorKind::SymbolDuplication,\n                        format!(\n                            \"submodule(-cluster) '{}' was defined multiple times\",\n                            submodule_ast.ident.raw\n                        ),\n                    )\n                    .spanned(submodule_ast.span()),\n                );\n                continue;\n            }\n\n            let cluster = Cluster::from(\u0026submodule_ast.cluster);\n\n            // Confirm existence of symbol\n            let typ = modules\n                .get(\u0026submodule_ast.typ.raw())\n                .map(Symbol::from)\n                .unwrap_or_else(|| {\n                    println!(\"seaching: {}\", submodule_ast.typ.raw());\n                    println!(\"modules: {modules:#?}\");\n\n                    errors.add(\n                        Error::new(\n                            ErrorKind::SymbolNotFound,\n                            format!(\n                                \"did not find submodule symbol '{}', not in scope\",\n                                submodule_ast.typ.raw()\n                            ),\n                        )\n                        .spanned(submodule_ast.typ.span())\n                        .map(|e| global.err_resolve_symbol(\u0026submodule_ast.typ.raw(), true, e)),\n                    );\n                    Symbol::Unresolved(RawSymbol {\n                        raw: submodule_ast.typ.raw(),\n                    })\n                });\n\n            let submod_ir = if let Some(ref specs) = submodule_ast.dyn_spec {\n                // since we not monomorphise a new entry, create a new instance\n                if let Some(mut override_ir) = typ.as_module().cloned() {\n                    // override the existing specs.\n                    for spec in specs.items.iter() {\n                        // found overide \u003cdyn_field\u003e = \u003cvalue\u003e\n                        let dyn_field = \u0026spec.key.raw;\n                        let Some(dyn_field) = override_ir.submodules.iter_mut().find(|d| d.ident.raw == *dyn_field) else {\n                            // \u003cdyn_field\u003e pointed to an unknown submodule (of the submodule)\n                            errors.add(Error::new(\n                                ErrorKind::SymbolNotFound,\n                                format!(\"did not find submodule symbol for dyn-spec '{}', not in scope\", dyn_field)\n                            ).spanned(spec.key.span()));\n                            continue;\n                        };\n\n                        let typ = modules.get(\u0026spec.value.raw);\n                        if let Some(ref typ) = typ {\n                            if let Some(expected_proto) = dyn_field.typ.as_module_arc() {\n                                // check wheter the provided type is really\n                                // implementing the expected proto\n                                let valid = typ.inherited.iter().any(|s| {\n                                    Arc::ptr_eq(\u0026s.as_module_arc().unwrap(), \u0026expected_proto)\n                                });\n                                if !valid {\n                                    errors.add(\n                                        Error::new(\n                                            ErrorKind::ModuleDynConstraintsBroken,\n                                            format!(\"module '{}' does not inherit '{}', thus cannot be assigned to dyn field '{}'\", typ.ident.raw, expected_proto.ident.raw, spec.key.raw)\n                                        ).spanned(spec.span())\n                                    )\n                                }\n                            }\n                        }\n\n                        let typ = typ.map(Symbol::from).unwrap_or_else(|| {\n                            errors.add(\n                                Error::new(\n                                    ErrorKind::SymbolNotFound,\n                                    format!(\n                                        \"did not find dyn-spec submodule symbol '{}', not in scope\",\n                                        spec.value.raw\n                                    ),\n                                )\n                                .spanned(spec.value.span())\n                                .map(|e| global.err_resolve_symbol(\u0026spec.value.raw, true, e)),\n                            );\n                            Symbol::Unresolved(RawSymbol {\n                                raw: submodule_ast.typ.raw(),\n                            })\n                        });\n\n                        dyn_field.dynamic = false;\n                        dyn_field.typ = typ;\n                    }\n\n                    let ident = RawSymbol {\n                        raw: submodule_ast.ident.raw.clone(),\n                    };\n                    Submodule {\n                        span: override_ir.ast.span(),\n                        ident,\n                        cluster,\n                        typ: Symbol::from(Arc::new(override_ir)),\n                        dynamic: submodule_ast.typ.is_dyn(),\n                    }\n                } else {\n                    // if the symbol is not resolved either way just add it in its incomplete form\n                    let ident = RawSymbol {\n                        raw: submodule_ast.ident.raw.clone(),\n                    };\n                    Submodule {\n                        span: submodule_ast.span(),\n                        ident,\n                        cluster,\n                        typ,\n                        dynamic: submodule_ast.typ.is_dyn(),\n                    }\n                }\n            } else {\n                let ident = RawSymbol {\n                    raw: submodule_ast.ident.raw.clone(),\n                };\n                Submodule {\n                    span: submodule_ast.span(),\n                    ident,\n                    cluster,\n                    typ,\n                    dynamic: submodule_ast.typ.is_dyn(),\n                }\n            };\n\n            if let Some(s) = submod_ir.typ.as_module() {\n                let mut missing = Vec::new();\n                for dep in s.submodules.iter() {\n                    if dep.dynamic {\n                        missing.push(\u0026dep.ident.raw[..])\n                    }\n                }\n\n                if !missing.is_empty() {\n                    let s = missing.join(\", \");\n                    errors.add(Error::new(\n                        ErrorKind::ModuleDynNotResolved,\n                        format!(\n                            \"missing specification for dynamic members of submodule '{}': missing fields '{}'\",\n                            submod_ir.ident.raw, s\n                        ),\n                    ).spanned(submod_ir.span))\n                }\n            }\n\n            ir_submodules.push(submod_ir);\n        }\n\n        let local_gtable = LocalGatesTable::new(\u0026ir_gates);\n        let sm_table = LocalSubmoduleTable::new(\u0026ir_submodules);\n        let shared_gtable = SharedGatesTable::new(\u0026local_gtable, \u0026sm_table);\n\n        let mut ir_connections: Vec\u003cConnection\u003e = Vec::with_capacity(ast.connections.len());\n        for inh in \u0026deps {\n            ir_connections.extend(inh.connections.iter().cloned());\n        }\n        for con in ast.connections.iter().flat_map(|s| s.items.iter()) {\n            let delay = if let Some(link) = \u0026con.link {\n                let Some(link) = links.get(\u0026link.raw) else {\n                        errors.add(Error::new(\n                            ErrorKind::SymbolNotFound,\n                            format!(\"did not find link symbol '{}', not in scope\", link.raw)\n                        ).spanned(con.span()).map(|e| global.err_resolve_symbol(\u0026link.raw, false, e)));\n                        continue\n                    };\n                Some(Symbol::from(link))\n            } else {\n                None\n            };\n\n            let lhs = shared_gtable.resolve(\u0026con.lhs);\n            let rhs = shared_gtable.resolve(\u0026con.rhs);\n\n            let (lhs, rhs) = match (lhs, rhs) {\n                (Ok(lhs), Ok(rhs)) =\u003e (lhs, rhs),\n                (Err(e), Ok(_)) =\u003e {\n                    errors.add(e);\n                    continue;\n                }\n                (Ok(_), Err(e)) =\u003e {\n                    errors.add(e);\n                    continue;\n                }\n                (Err(e1), Err(e2)) =\u003e {\n                    errors.add(e1);\n                    errors.add(e2);\n                    continue;\n                }\n            };\n\n            let mut lhs = lhs.collect::\u003cVec\u003c_\u003e\u003e();\n            let mut rhs = rhs.collect::\u003cVec\u003c_\u003e\u003e();\n\n            let n = lhs.len().min(rhs.len());\n            for _ in 0..n {\n                let l = lhs.pop().unwrap();\n                let r = rhs.pop().unwrap();\n\n                // TODO: Topo check whether the gates can hold connections\n\n\n                // if l.def.service_typ == GateServiceType::Input {\n                //     errors.add(Error::new(\n                //             ErrorKind::InvalidConGateServiceTyp,\n                //             format!(\"Gate '{}' cannot serve as connection source, since it is of serivce type '{:?}'\", l.def.ident.raw, l.def.service_typ)\n                //         ));\n                // }\n\n                // if r.def.service_typ == GateServiceType::Output {\n                //     errors.add(Error::new(\n                //             ErrorKind::InvalidConGateServiceTyp,\n                //             format!(\"Gate '{}' cannot serve as connection target, since it is of serivce type '{:?}'\", r.def.ident.raw, r.def.service_typ)\n                //     ));\n                // }\n\n                ir_connections.push(Connection {\n                    lhs: ConnectionEndpoint::from(l),\n                    rhs: ConnectionEndpoint::from(r),\n                    delay: delay.clone(),\n                });\n            }\n\n            if !lhs.is_empty() {\n                errors.add(Error::new(\n                        ErrorKind::InvalidConDefSizes,\n                        format!(\"Invalid connection statement, source domain is bigger than target domain (by {} gates)\", lhs.len())\n                    ))\n            }\n            if !rhs.is_empty() {\n                errors.add(Error::new(\n                        ErrorKind::InvalidConDefSizes,\n                        format!(\"Invalid connection statement, target domain is bigger than source domain (by {} gates)\", rhs.len())\n                    ))\n            }\n        }\n\n        let ident = RawSymbol {\n            raw: ast.ident.raw.clone(),\n        };\n        Module {\n            ast,\n            ident,\n            inherited,\n            gates: ir_gates,\n            submodules: ir_submodules,\n            connections: ir_connections,\n            dirty: errlen \u003c errors.len(),\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":564},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":702},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":996},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":906},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":702},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":972},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":282},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":690},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":702},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":720},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":396},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":252},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":486},"fn_name":null}],"covered":149,"coverable":170},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resolve","util.rs"],"content":"use std::marker::PhantomData;\n\npub struct IterIter\u003cI, I2, T\u003e {\n    iter: I,\n    subiter: Option\u003cI2\u003e,\n    phantom: PhantomData\u003c(I2, T)\u003e,\n}\n\nimpl\u003cI, I2, T\u003e IterIter\u003cI, I2, T\u003e\nwhere\n    I: Iterator\u003cItem = I2\u003e,\n    I2: Iterator\u003cItem = T\u003e,\n{\n    pub fn new(mut iter: I) -\u003e Self {\n        let subiter = iter.next();\n        Self {\n            iter,\n            subiter,\n            phantom: PhantomData,\n        }\n    }\n}\n\nimpl\u003cI, I2, T\u003e Iterator for IterIter\u003cI, I2, T\u003e\nwhere\n    I: Iterator\u003cItem = I2\u003e,\n    I2: Iterator\u003cItem = T\u003e,\n{\n    type Item = T;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if let Some(subiter) = \u0026mut self.subiter {\n            if let Some(item) = subiter.next() {\n                Some(item)\n            } else {\n                self.subiter = self.iter.next();\n                self.next()\n            }\n        } else {\n            None\n        }\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":264},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1104},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1944},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":264},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resource","fs.rs"],"content":"use std::path::{Component, Path, PathBuf};\n\npub(crate) fn common_path(lhs: impl AsRef\u003cPath\u003e, rhs: impl AsRef\u003cPath\u003e) -\u003e PathBuf {\n    let lhs = lhs.as_ref().components();\n    let rhs = rhs.as_ref().components();\n\n    let mut result = PathBuf::new();\n\n    for (l, r) in lhs.zip(rhs) {\n        if l == r {\n            match l {\n                Component::ParentDir =\u003e {\n                    assert!(result.pop(), \"cannot escape scope\");\n                }\n                l =\u003e result.push(l),\n            }\n        } else {\n            break;\n        }\n    }\n\n    result\n}\n\n#[allow(clippy::while_let_on_iterator)]\npub(crate) fn strip_prefix(path: impl AsRef\u003cPath\u003e, prefix: impl AsRef\u003cPath\u003e) -\u003e PathBuf {\n    let mut lhs = prefix.as_ref().components();\n    let mut rhs = path.as_ref().components();\n\n    while let Some(l) = lhs.next() {\n        let r = rhs.next().unwrap();\n        assert_eq!(l, r);\n    }\n\n    canon(PathBuf::from_iter(rhs))\n}\n\npub(crate) fn canon(path: impl AsRef\u003cPath\u003e) -\u003e PathBuf {\n    let comps = path.as_ref().components();\n    let mut result = PathBuf::new();\n    for comp in comps {\n        match comp {\n            Component::ParentDir =\u003e {\n                assert!(result.pop())\n            }\n            other =\u003e result.push(other),\n        }\n    }\n    result\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn no_parent_path() {\n        assert_eq!(common_path(\"a/b/c/d\", \"a/b/o/p\"), PathBuf::from(\"a/b\"));\n\n        assert_eq!(\n            common_path(\"lookup/a/b\", \"lookup/c/d\"),\n            PathBuf::from(\"lookup\")\n        );\n\n        assert_eq!(common_path(\"a/b/c/d\", \"a/b/c/d\"), PathBuf::from(\"a/b/c/d\"));\n\n        assert_eq!(common_path(\"a/b/c/d\", \"e/a/b/o/p\"), PathBuf::from(\"\"));\n        assert_eq!(common_path(\"a/b/c/d\", \"\"), PathBuf::from(\"\"));\n    }\n\n    #[test]\n    fn parent_steps() {\n        assert_eq!(common_path(\"a/../a/d\", \"a/../o/p\"), PathBuf::from(\"\"));\n\n        assert_eq!(\n            common_path(\"lookup/../b\", \"lookup/a/../d\"),\n            PathBuf::from(\"lookup\")\n        );\n\n        assert_eq!(common_path(\"a/../c/d\", \"a/../c/d\"), PathBuf::from(\"c/d\"));\n\n        assert_ne!(common_path(\"a/../c/d\", \"/c/d\"), PathBuf::from(\"/c/d\"));\n    }\n\n    #[test]\n    fn strip_no_parent_prefix() {\n        assert_eq!(strip_prefix(\"a/b/c/d\", \"a/b\"), PathBuf::from(\"c/d\"));\n        assert_eq!(strip_prefix(\"a/b/c/d\", \"a/b/c\"), PathBuf::from(\"d\"));\n        assert_eq!(strip_prefix(\"a/b/c/d\", \"\"), PathBuf::from(\"a/b/c/d\"));\n    }\n\n    #[test]\n    fn strip_parent_steps() {\n        assert_eq!(strip_prefix(\"a/b/c/../d\", \"a/b\"), PathBuf::from(\"d\"));\n    }\n\n    #[test]\n    fn canon_paths() {\n        assert_eq!(canon(\"a/../b\"), PathBuf::from(\"b\"));\n        assert_eq!(canon(\"a/c/../../b\"), PathBuf::from(\"b\"));\n        assert_eq!(canon(\"a/c/../b\"), PathBuf::from(\"a/b\"));\n    }\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":4,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":293},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":218},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1341},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":551},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":229},"fn_name":null}],"covered":23,"coverable":23},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resource","mod.rs"],"content":"#![allow(unused)]\n\nuse std::{\n    fs::File,\n    io::{Error, ErrorKind, Read, Result},\n    path::{Path, PathBuf},\n};\n\npub(crate) mod fs;\n\nmod span;\npub use self::span::*;\n\n#[cfg(test)]\nmod tests;\n\n#[derive(Debug)]\npub struct SourceMap {\n    pub(crate) buffer: String,\n    pub(crate) assets: Vec\u003cSourceMappedAsset\u003e,\n}\n\n#[derive(Debug)]\npub(crate) struct SourceMappedAsset {\n    pub offset: usize,\n    pub len: usize,\n    pub ident: AssetIdentifier,\n    pub line_pos_mapping: Vec\u003cusize\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub enum AssetIdentifier {\n    Raw {\n        alias: String,\n    },\n    Root {\n        path: PathBuf,\n        alias: String,\n    },\n    Included {\n        path: PathBuf,\n        alias: String,\n        include: Span,\n    },\n}\n\nimpl AssetIdentifier {\n    fn root_path(\u0026self) -\u003e Option\u003c\u0026Path\u003e {\n        match self {\n            Self::Raw { .. } =\u003e None,\n            Self::Root { path, .. } =\u003e Some(path),\n            Self::Included { path, .. } =\u003e Some(path),\n        }\n    }\n}\n\nimpl From\u003c\u0026str\u003e for AssetIdentifier {\n    fn from(value: \u0026str) -\u003e Self {\n        if value.starts_with(\"raw:\") {\n            return AssetIdentifier::Raw {\n                alias: value[5..].to_string(),\n            };\n        }\n\n        let path = PathBuf::from(\u0026value[9..]);\n        if value.starts_with(\"include:\") {\n            return AssetIdentifier::Included {\n                alias: path.to_str().unwrap().to_string(),\n                path,\n                include: Span::new(0, 0),\n            };\n        }\n\n        AssetIdentifier::Root {\n            alias: path.to_str().unwrap().to_string(),\n            path,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\npub struct Asset\u003c'a\u003e {\n    map: \u0026'a SourceMap,\n    mapping: \u0026'a SourceMappedAsset,\n}\n\nimpl SourceMap {\n    pub fn new() -\u003e Self {\n        Self {\n            buffer: String::new(),\n            assets: Vec::new(),\n        }\n    }\n\n    pub fn load_file(\u0026mut self, ident: impl Into\u003cAssetIdentifier\u003e) -\u003e Result\u003cAsset\u003c'_\u003e\u003e {\n        let ident = ident.into();\n        let mut file = File::open(ident.path()?)?;\n        let offset = self.buffer.len();\n        let n = file.read_to_string(\u0026mut self.buffer)?;\n\n        let mapping = SourceMappedAsset::new(ident, offset, n, self);\n        self.assets.push(mapping);\n\n        Ok(Asset {\n            map: self,\n            mapping: self.assets.last().unwrap(),\n        })\n    }\n\n    pub fn load_raw(\u0026mut self, ident: impl Into\u003cAssetIdentifier\u003e, raw: \u0026str) -\u003e Asset\u003c'_\u003e {\n        let ident = ident.into();\n        assert!(matches!(ident, AssetIdentifier::Raw { .. }));\n\n        let offset = self.buffer.len();\n        let n = raw.len();\n        self.buffer.push_str(raw);\n\n        let mapping = SourceMappedAsset::new(ident, offset, n, self);\n        self.assets.push(mapping);\n\n        Asset {\n            map: self,\n            mapping: self.assets.last().unwrap(),\n        }\n    }\n\n    pub(crate) fn span_for(\u0026self, asset: \u0026AssetIdentifier) -\u003e Option\u003cSpan\u003e {\n        self.assets\n            .iter()\n            .find(|a| a.ident == *asset)\n            .map(|v| v.span())\n    }\n\n    pub(crate) fn slice_for(\u0026self, span: Span) -\u003e \u0026str {\n        \u0026self.buffer[span.pos..(span.pos + span.len)]\n    }\n\n    pub(crate) fn slice_padded_for(\u0026self, span: Span) -\u003e (\u0026str, usize) {\n        // println!(\"{span:?}\");\n\n        let asset = self\n            .asset_for(span)\n            .expect(\"Failed to assign asset to span\");\n        let bounds = (asset.offset, asset.offset + asset.len);\n        // println!(\"{}: {:?}\", asset.offset, asset.line_pos_mapping);\n\n        let line_start = asset.line_for(span.pos);\n        let line_end = asset.line_for(span.pos + span.len);\n        let len = line_end - line_start + 1;\n        let pad = if len \u003e 2 { 1 } else { 2 };\n\n        let lso = line_start;\n\n        let line_start = line_start.saturating_sub(pad);\n        let line_end = line_end\n            .saturating_add(pad)\n            .min(asset.line_pos_mapping.len() - 1);\n\n        let line_offset = if line_start != 0 {\n            lso - line_start\n        } else {\n            lso - line_start - 1\n        };\n\n        let start = *asset\n            .line_pos_mapping\n            .get(line_start.saturating_sub(1))\n            .unwrap_or(\u0026bounds.0)\n            .max(\u0026bounds.0);\n        let end = (asset.line_pos_mapping[line_end] - 1).min(bounds.1);\n\n        (\u0026self.buffer[start..end], line_offset)\n    }\n\n    pub(crate) fn asset(\u0026self, ident: \u0026AssetIdentifier) -\u003e Option\u003c\u0026SourceMappedAsset\u003e {\n        self.assets.iter().find(|a| a.ident == *ident)\n    }\n\n    pub(crate) fn asset_for(\u0026self, span: Span) -\u003e Option\u003c\u0026SourceMappedAsset\u003e {\n        self.assets.iter().find(|asset| asset.contains(span))\n    }\n\n    pub(crate) fn line_for(\u0026self, span: Span) -\u003e Option\u003cusize\u003e {\n        let asset = self.asset_for(span)?;\n        Some(asset.line_for(span.pos))\n    }\n}\n\nimpl Default for SourceMap {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl SourceMappedAsset {\n    pub(crate) fn new(ident: AssetIdentifier, offset: usize, len: usize, map: \u0026SourceMap) -\u003e Self {\n        let data = \u0026map.buffer[offset..(offset + len)];\n\n        // pos is a mapping line-start-index --\u003e line-number (index)\n\n        let mut idx = 0;\n        let mut pos = vec![0];\n\n        for c in data.chars() {\n            if c == '\\n' {\n                pos.push(offset + idx + 1);\n            }\n            idx += c.len_utf8();\n        }\n\n        Self {\n            ident,\n            offset,\n            len,\n            line_pos_mapping: pos,\n        }\n    }\n\n    pub fn include_for(\u0026self, other: \u0026SourceMappedAsset) -\u003e Option\u003cString\u003e {\n        let s = self.ident.alias();\n        let o = other.ident.alias();\n\n        let s = s.split('/').collect::\u003cVec\u003c_\u003e\u003e();\n        let o = o.split('/').collect::\u003cVec\u003c_\u003e\u003e();\n\n        let n = s.len().min(o.len());\n        for i in 0..n {\n            if s[i] != o[i] {\n                let mut include = String::new();\n                let up = n - i;\n                for _ in 0..up {\n                    include.push_str(\"../\");\n                }\n                for \u0026e in o.iter().skip(i) {\n                    include.push_str(e);\n                    include.push('/');\n                }\n                include.pop();\n                return Some(include);\n            }\n        }\n\n        None\n    }\n\n    pub(crate) fn span(\u0026self) -\u003e Span {\n        Span::new(self.offset, self.len)\n    }\n\n    pub(crate) fn contains(\u0026self, span: Span) -\u003e bool {\n        let end = span.pos + span.len;\n        self.offset \u003c= span.pos \u0026\u0026 end \u003c= self.offset + self.len\n    }\n\n    pub(crate) fn line_for(\u0026self, pos: usize) -\u003e usize {\n        for i in 0..self.line_pos_mapping.len() {\n            if self.line_pos_mapping[i] \u003e pos {\n                return i;\n            }\n        }\n\n        self.line_pos_mapping.len()\n    }\n}\n\nimpl AssetIdentifier {\n    pub fn raw(s: \u0026str) -\u003e Self {\n        Self::Raw {\n            alias: s.to_string(),\n        }\n    }\n\n    pub fn alias(\u0026self) -\u003e \u0026str {\n        match self {\n            Self::Raw { alias } | Self::Root { alias, .. } | Self::Included { alias, .. } =\u003e alias,\n        }\n    }\n\n    pub(crate) fn relative_asset_alias(\u0026self, path: \u0026Path) -\u003e String {\n        let common = fs::common_path(self.path().unwrap(), path);\n        let sub = fs::strip_prefix(path, common);\n        let sub = sub.with_extension(\"\").to_string_lossy().to_string();\n        sub\n    }\n\n    pub(crate) fn path(\u0026self) -\u003e Result\u003c\u0026PathBuf\u003e {\n        match self {\n            Self::Raw { .. } =\u003e Err(Error::new(ErrorKind::Other, \"asset is not io-bound\")),\n            Self::Included { path, .. } =\u003e Ok(path),\n            Self::Root { path, .. } =\u003e Ok(path),\n        }\n    }\n}\n\nimpl\u003c'a\u003e Asset\u003c'a\u003e {\n    pub(crate) fn new(map: \u0026'a SourceMap, mapping: \u0026'a SourceMappedAsset) -\u003e Self {\n        Self { map, mapping }\n    }\n\n    pub(crate) fn alias(\u0026self) -\u003e \u0026str {\n        self.mapping.ident.alias()\n    }\n\n    pub(crate) fn source_span(\u0026self) -\u003e Span {\n        Span::new(self.mapping.offset, self.mapping.len)\n    }\n\n    pub(crate) fn source(\u0026self) -\u003e \u0026'a str {\n        \u0026self.map.buffer[self.mapping.offset..(self.mapping.offset + self.mapping.len)]\n    }\n\n    pub(crate) fn slice_for(\u0026self, span: Span) -\u003e \u0026str {\n        self.map.slice_for(span)\n    }\n\n    pub(crate) fn slice_padded_for(\u0026self, span: Span) -\u003e (\u0026str, usize) {\n        self.map.slice_padded_for(span)\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":403},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":403},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":403},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":864},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":864},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":432},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":186},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":7376},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":7376},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":243},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":281},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":900},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":525},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":525},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":525},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":525},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":66086},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":71009},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":5448},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":65561},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":674},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":3710},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":3464},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":348},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":696},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":1332},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":1332},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":330},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1002},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":524},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":524},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":524},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":524},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":7376},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":7376},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":99,"coverable":125},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resource","span.rs"],"content":"use std::fmt;\n\n#[derive(Clone, Copy, PartialEq, Eq, Hash)]\npub struct Span {\n    pub(crate) pos: usize,\n    pub(crate) len: usize,\n}\n\nimpl Span {\n    pub fn new(pos: usize, len: usize) -\u003e Self {\n        // assert!(len \u003e 0);\n        Span { pos, len }\n    }\n\n    pub fn fromto(mut lhs: Span, mut rhs: Span) -\u003e Self {\n        if lhs.pos \u003e rhs.pos {\n            std::mem::swap(\u0026mut lhs, \u0026mut rhs);\n        }\n        let len = (rhs.pos + rhs.len) - lhs.pos;\n        Self { pos: lhs.pos, len }\n    }\n\n    pub fn after(\u0026self) -\u003e Span {\n        Self {\n            pos: self.pos + self.len,\n            len: 0,\n        }\n    }\n}\n\nimpl fmt::Debug for Span {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\u0026format!(\"Span[{}..(+{})]\", self.pos, self.len))\n            // .field(\"pos\", \u0026self.pos)\n            // .field(\"len\", \u0026self.len)\n            .finish()\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":16154},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":4024},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":4024},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":4024},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":4024},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":31},"fn_name":null}],"covered":7,"coverable":10},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","resource","tests.rs"],"content":"use super::*;\n\nconst FILE_A: \u0026'static str = \"0123456789\"; // 10 bytes, 1 line\nconst FILE_B: \u0026'static str = \"A\\nBB\\nCCC\\nDDDD\\nEEE\\nFF\\nG\"; // 22 bytes, 7 lines\nconst FILE_C: \u0026'static str = \"module A {\\nB\\n}\\n\"; // 15 bytes, 4 lines\n\n#[test]\nfn source_map_loading() {\n    let mut map = SourceMap::new();\n\n    let a = map.load_raw(AssetIdentifier::raw(\"a\"), FILE_A);\n    assert_eq!(a.alias(), \"a\");\n    assert_eq!(a.source(), FILE_A);\n    assert_eq!(a.source_span(), Span::new(0, 10));\n\n    assert_eq!(\n        map.asset_for(Span::new(0, 7)).map(|v| v.ident.alias()),\n        Some(\"a\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(3, 2)).map(|v| v.ident.alias()),\n        Some(\"a\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(5, 5)).map(|v| v.ident.alias()),\n        Some(\"a\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(5, 7)).map(|v| v.ident.alias()),\n        None\n    );\n\n    let b = map.load_raw(AssetIdentifier::raw(\"b\"), FILE_B);\n    assert_eq!(b.alias(), \"b\");\n    assert_eq!(b.source(), FILE_B);\n    assert_eq!(b.source_span(), Span::new(10, 22));\n\n    assert_eq!(\n        map.asset_for(Span::new(10, 7)).map(|v| v.ident.alias()),\n        Some(\"b\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(15, 10)).map(|v| v.ident.alias()),\n        Some(\"b\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(20, 12)).map(|v| v.ident.alias()),\n        Some(\"b\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(5, 20)).map(|v| v.ident.alias()),\n        None\n    );\n    assert_eq!(\n        map.asset_for(Span::new(31, 5)).map(|v| v.ident.alias()),\n        None\n    );\n\n    let c = map.load_raw(AssetIdentifier::raw(\"c\"), FILE_C);\n    assert_eq!(c.alias(), \"c\");\n    assert_eq!(c.source(), FILE_C);\n    assert_eq!(c.source_span(), Span::new(32, 15));\n\n    assert_eq!(\n        map.asset_for(Span::new(32, 7)).map(|v| v.ident.alias()),\n        Some(\"c\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(37, 8)).map(|v| v.ident.alias()),\n        Some(\"c\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(32, 12)).map(|v| v.ident.alias()),\n        Some(\"c\")\n    );\n    assert_eq!(\n        map.asset_for(Span::new(32, 20)).map(|v| v.ident.alias()),\n        None\n    );\n    assert_eq!(\n        map.asset_for(Span::new(31, 5)).map(|v| v.ident.alias()),\n        None\n    );\n}\n\nconst EX0: \u0026'static str = \"include str;\ninclude x;\n\nmodule M {\n    gates {\n        in[5] @input\n    }\n\n    connections {\n        in --\u003e\n    }\n}\n\nentry M;\n// Comment befor EOF\n\";\n\n#[test]\nfn source_map_padded_span() {\n    let mut smap = SourceMap::new();\n    smap.load_raw(\"raw:ex0\", EX0);\n\n    // Full padding.\n    let span = EX0.bytes().position(|c| c == b'5').unwrap();\n    let span = Span::new(span, 1);\n\n    let (padded_slice, offset) = smap.slice_padded_for(span);\n    assert_eq!(offset, 2);\n    assert_eq!(\n        padded_slice,\n        \"module M {\\n    gates {\\n        in[5] @input\\n    }\\n\"\n    );\n\n    // Trunc end\n    let span = EX0.bytes().position(|c| c == b'y').unwrap();\n    let span = Span::new(span, 1);\n\n    let (padded_slice, offset) = smap.slice_padded_for(span);\n    assert_eq!(offset, 2);\n    assert_eq!(padded_slice, \"}\\n\\nentry M;\\n// Comment befor EOF\");\n\n    // Trunc start (offset 1)\n    let span = EX0.bytes().position(|c| c == b'x').unwrap();\n    let span = Span::new(span, 1);\n\n    let (padded_slice, offset) = smap.slice_padded_for(span);\n    assert_eq!(offset, 1);\n    assert_eq!(padded_slice, \"include str;\\ninclude x;\\n\\nmodule M {\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","src","util.rs"],"content":"// calculates the cyles in a dependency graph\npub fn dfs_cycles(topo: \u0026[Vec\u003cusize\u003e]) -\u003e std::result::Result\u003cVec\u003cVec\u003cbool\u003e\u003e, Vec\u003cVec\u003cusize\u003e\u003e\u003e {\n    // inner dfs to seach for all cycles back to the root.\n    fn _dfs(\n        i: usize,\n        s: usize,\n        v: \u0026mut [bool],\n        p: \u0026mut Vec\u003cusize\u003e,\n        t: \u0026[Vec\u003cusize\u003e],\n        c: \u0026mut Vec\u003cVec\u003cusize\u003e\u003e,\n    ) {\n        if v[i] {\n            // Node allready visited\n            if i == s {\n                c.push(p.clone())\n            }\n        } else {\n            v[i] = true;\n            p.push(i);\n            for \u0026e in \u0026t[i] {\n                _dfs(e, s, v, p, t, c);\n            }\n            p.pop();\n        }\n    }\n\n    // iterate over all possible routes, and find all route specific cyless\n    let mut cycles = Vec::new();\n    let mut reachability = Vec::new();\n    for s in 0..topo.len() {\n        let mut visited = vec![false; topo.len()];\n        let mut prev = Vec::with_capacity(topo.len());\n        _dfs(s, s, \u0026mut visited, \u0026mut prev, topo, \u0026mut cycles);\n        reachability.push(visited);\n    }\n\n    if cycles.is_empty() {\n        return Ok(reachability);\n    }\n\n    // dedup the found cylces\n    let mut i = 0;\n    while i \u003c cycles.len() {\n        // Consider i unquie, remove all duplicates of cycle i\n        let s = cycles[i][0];\n\n        // Iteate over all remaining elements, maybe dropping them if dup\n        let mut k = i + 1;\n        'outer: while k \u003c cycles.len() {\n            // Cyles sizes must match, is assumed in the following\n            if cycles[i].len() != cycles[k].len() {\n                k += 1;\n                continue 'outer;\n            }\n\n            // Find the start point of the cycle\n            // by using index 0 of the first occurence, we ensure that nodes lower i\n            // tend to be the start point of cycles\n            let Some(p) = cycles[k].iter().position(|\u0026v| s == v) else {\n                k += 1;\n                continue 'outer;\n            };\n\n            // If all elements (at offset) match remove the cyles\n            // else it is a different cylce with shared nodes.\n            let n = cycles[i].len();\n            for o in 1..n {\n                if cycles[i][o] != cycles[k][(p + o) % n] {\n                    k += 1;\n                    continue 'outer;\n                }\n            }\n\n            cycles.remove(k);\n        }\n\n        i += 1;\n    }\n\n    Err(cycles)\n}\n","traces":[{"line":2,"address":[],"length":0,"stats":{"Line":750},"fn_name":null},{"line":4,"address":[],"length":0,"stats":{"Line":2598},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":2598},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":978},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2370},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":2370},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2418},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1584},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2370},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":750},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":750},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2778},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1014},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1014},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1014},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1014},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":750},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":708},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":42},"fn_name":null}],"covered":33,"coverable":37},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","common.rs"],"content":"#[macro_export]\nmacro_rules! check_err {\n    ($e:expr =\u003e $code:expr, $msg:literal) =\u003e {\n        let e = $e.unwrap();\n        assert_eq!(e.kind, $code);\n        assert!(e.span.is_some());\n        assert_eq!(format!(\"{}\", e.internal), $msg);\n        assert!(e.solution().is_none())\n    };\n    ($e:expr =\u003e $code:expr, $msg:literal, $solution:expr) =\u003e {\n        let e = $e.unwrap();\n        assert_eq!(e.kind, $code);\n        assert!(e.span.is_some());\n        assert_eq!(format!(\"{}\", e.internal), $msg);\n        assert_eq!(e.solution().unwrap().description, $solution);\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","cyclic.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn cyclic_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/cyclic_baseline/main.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.submodules[0].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[1].typ.as_module().unwrap().ident.raw, \"B\");\n\n    Ok(())\n}\n\n#[test]\nfn cyclic_includes() {\n    let err = Context::load(\"tests/cyclic_includes/main.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::CyclicDeps,\n        \"found cyclic includes: sub1 \u003c- sub2 \u003c- sub3 \u003c- sub1\"\n    );\n}\n\n#[test]\nfn cyclic_local_links() {\n    let err = Context::load(\"tests/cyclic_local_links.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::LinkLocalCyclicDeps,\n        \"found cyclic definition of local links: A \u003c- B \u003c- C \u003c- A\"\n    );\n}\n\n#[test]\nfn cyclic_local_modules() {\n    let err = Context::load(\"tests/cyclic_local_modules.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleLocalCyclicDeps,\n        \"found cyclic definition of local modules: A \u003c- B \u003c- C \u003c- A\"\n    );\n}\n\n#[test]\nfn cyclic_local_selfreferential() {\n    let err = Context::load(\"tests/cyclic_local_selfreferential.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 4);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::LinkLocalCyclicDeps,\n        \"found cyclic definition of local links: LDirect \u003c- LDirect\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::LinkLocalCyclicDeps,\n        \"found cyclic definition of local links: LIndirect1 \u003c- LIndirect2 \u003c- LIndirect1\"\n    );\n\n    check_err!(errs.get(2) =\u003e\n        ErrorKind::ModuleLocalCyclicDeps,\n        \"found cyclic definition of local modules: Direct \u003c- Direct\"\n    );\n\n    check_err!(errs.get(3) =\u003e\n        ErrorKind::ModuleLocalCyclicDeps,\n        \"found cyclic definition of local modules: IndirectA \u003c- IndirectB \u003c- IndirectA\"\n    );\n}\n\n#[test]\nfn cyclic_module_inh() {\n    let err = Context::load(\"tests/cyclic_module_inh.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleLocalCyclicDeps,\n        \"found cyclic definition of local modules: A \u003c- C \u003c- B \u003c- A\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::ModuleLocalCyclicDeps,\n        \"found cyclic definition of local modules: H1 \u003c- H2 \u003c- H1\"\n    );\n}\n\n#[test]\nfn cyclic_dependable() {\n    let err = Context::load(\"tests/cyclic_dependable/main.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleLocalCyclicDeps,\n        \"found cyclic definition of local modules: A \u003c- B \u003c- A\"\n    );\n\n    // cause cyclic will not be loaded\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find inheritance symbol 'B', not in scope\",\n        \"try including 'B' from '../sub'\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","dyn.rs"],"content":"use des_ndl::ast::ModuleTypus;\nuse des_ndl::error::*;\nuse des_ndl::ir::Item;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn dyn_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/dyn_baseline.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n    let ir = \u0026ctx.ir.values().collect::\u003cVec\u003c_\u003e\u003e()[0].items;\n    let Item::Module(ref basic) = ir[0] else {\n        unreachable!()\n    };\n    assert_eq!(basic.ident.raw, \"Basic\");\n    assert_eq!(\n        basic\n            .inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        Vec::\u003cString\u003e::new()\n    );\n    assert_eq!(basic.ast.typus(), ModuleTypus::Primal);\n\n    let Item::Module(ref a) = ir[1] else {\n        unreachable!()\n    };\n    assert_eq!(a.ident.raw, \"A\");\n    assert_eq!(\n        a.inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        vec![\"Basic\".to_string()]\n    );\n    assert_eq!(a.ast.typus(), ModuleTypus::Inherited);\n\n    let Item::Module(ref b) = ir[2] else {\n        unreachable!()\n    };\n    assert_eq!(b.ident.raw, \"B\");\n    assert_eq!(\n        b.inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        vec![\"Basic\".to_string()]\n    );\n    assert_eq!(b.ast.typus(), ModuleTypus::Inherited);\n\n    let Item::Module(ref dyn_m) = ir[3] else {\n        unreachable!()\n    };\n    assert_eq!(dyn_m.ident.raw, \"Dyn\");\n    assert_eq!(\n        dyn_m\n            .inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        Vec::\u003cString\u003e::new()\n    );\n    assert_eq!(dyn_m.ast.typus(), ModuleTypus::Dynamic);\n\n    // follow entry\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.gates.len(), 0);\n    assert_eq!(entry.submodules[0].dynamic, false);\n\n    let sub1 = entry.submodules[0].typ.as_module_arc().unwrap();\n    assert_eq!(sub1.ident.raw, \"Dyn\");\n    assert_eq!(sub1.gates.len(), 0);\n    assert_eq!(sub1.submodules[0].dynamic, false);\n\n    let sub2 = sub1.submodules[0].typ.as_module_arc().unwrap();\n    assert_eq!(sub2.ident.raw, \"A\");\n    assert_eq!(sub2.gates.len(), 2);\n    // assert_eq!(sub2.submodules[0].dynamic, false);\n\n    Ok(())\n}\n\n#[test]\nfn dyn_constraint_broken() {\n    let err = Context::load(\"tests/dyn_constraint_broken.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleDynConstraintsBroken,\n        \"module 'A' does not inherit 'Basic', thus cannot be assigned to dyn field 'sub'\"\n    );\n}\n\n#[test]\nfn dyn_non_resovle_dyn_spec() {\n    let err = Context::load(\"tests/dyn_non_resovle_dyn_spec.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find submodule symbol 'WrongSymbol', not in scope\"\n    );\n\n    // This test ensures that the dyn clause is completely ignored, thus throwing no errors\n    // additionally the symbol M should still exist\n\n    // thus T whould be fully valid\n}\n\n#[test]\nfn dyn_unknown_key() {\n    let err = Context::load(\"tests/dyn_unknown_key.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find submodule symbol for dyn-spec 'wrongkey', not in scope\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::ModuleDynNotResolved,\n        \"missing specification for dynamic members of submodule 'd': missing fields 'sub'\"\n    );\n}\n\n#[test]\nfn dyn_unknown_value() {\n    let err = Context::load(\"tests/dyn_unknown_value.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find dyn-spec submodule symbol 'Wrong', not in scope\"\n    );\n}\n\n#[test]\nfn dyn_extending_override() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/dyn_extending_override.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n    let ir = \u0026ctx.ir.values().collect::\u003cVec\u003c_\u003e\u003e()[0].items;\n    let Item::Module(ref basic) = ir[0] else {\n        unreachable!()\n    };\n    assert_eq!(basic.ident.raw, \"Basic\");\n    assert_eq!(\n        basic\n            .inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        Vec::\u003cString\u003e::new()\n    );\n    assert_eq!(basic.ast.typus(), ModuleTypus::Primal);\n\n    let Item::Module(ref a) = ir[1] else {\n        unreachable!()\n    };\n    assert_eq!(a.ident.raw, \"A\");\n    assert_eq!(\n        a.inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        vec![\"Basic\".to_string()]\n    );\n    assert_eq!(a.ast.typus(), ModuleTypus::Inherited);\n\n    let Item::Module(ref b) = ir[2] else {\n        unreachable!()\n    };\n    assert_eq!(b.ident.raw, \"B\");\n    assert_eq!(\n        b.inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        vec![\"Basic\".to_string()]\n    );\n    assert_eq!(b.ast.typus(), ModuleTypus::Inherited);\n\n    let Item::Module(ref dyn_m) = ir[3] else {\n        unreachable!()\n    };\n    assert_eq!(dyn_m.ident.raw, \"Dyn\");\n    assert_eq!(\n        dyn_m\n            .inherited\n            .iter()\n            .map(|s| s.raw().raw.clone())\n            .collect::\u003cVec\u003cString\u003e\u003e(),\n        Vec::\u003cString\u003e::new()\n    );\n    assert_eq!(dyn_m.ast.typus(), ModuleTypus::Dynamic);\n\n    // follow entry\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.gates.len(), 0);\n    assert_eq!(entry.submodules[0].dynamic, false);\n\n    let sub1 = entry.submodules[0].typ.as_module_arc().unwrap();\n    assert_eq!(sub1.ident.raw, \"Dyn\");\n    assert_eq!(sub1.gates.len(), 0);\n    assert_eq!(sub1.submodules[0].dynamic, false);\n\n    let sub2 = sub1.submodules[0].typ.as_module_arc().unwrap();\n    assert_eq!(sub2.ident.raw, \"A\");\n    assert_eq!(sub2.gates.len(), 3);\n    // assert_eq!(sub2.submodules[0].dynamic, false);\n\n    Ok(())\n}\n\n#[test]\nfn dyn_not_resolved() {\n    let err = Context::load(\"tests/dyn_not_resolved.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleDynNotResolved,\n        \"missing specification for dynamic members of submodule 'd': missing fields 'sub'\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::ModuleDynNotResolved,\n        \"missing specification for dynamic members of submodule 'b': missing fields 'a, c'\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","gates_ast.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::Cluster;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn gates_ast_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/gates_ast_baseline.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.gates.len(), 4);\n\n    assert_eq!(entry.gates[0].ident.raw, \"in\");\n    assert_eq!(entry.gates[0].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.gates[1].ident.raw, \"out\");\n    assert_eq!(entry.gates[1].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.gates[2].ident.raw, \"influx\");\n    assert_eq!(entry.gates[2].cluster, Cluster::Clusted(5));\n\n    assert_eq!(entry.gates[3].ident.raw, \"outflow\");\n    assert_eq!(entry.gates[3].cluster, Cluster::Clusted(1));\n\n    Ok(())\n}\n\n#[test]\nfn gates_ast_nodelim() {\n    let err = Context::load(\"tests/gates_ast_nodelim.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ExpectedDelimited,\n        \"expected delimited sequence, found ';'\"\n    );\n}\n\n#[test]\nfn gates_ast_wrong_delim() {\n    let err = Context::load(\"tests/gates_ast_wrong_delim.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedDelim,\n        \"expected delimited sequence '{ ... }', found delimited sequence '[ ... ]'\"\n    );\n}\n\n\n#[test]\nfn gates_ast_symbol_dup() {\n    let err = Context::load(\"tests/gates_ast_symbol_dup.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleGatesDuplicatedSymbols,\n        \"gate(-cluster) 'influx' was defined multiple times\"\n    );\n}\n\n#[test]\nfn gates_ast_invalid_cluster() {\n    let err = Context::load(\"tests/gates_ast_invalid_cluster.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 4);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::InvalidLitTyp,\n        \"cannot create gate-cluster with literal of type float, expected literal of type integer\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::InvalidLitTyp,\n        \"cannot create gate-cluster with literal of type string, expected literal of type integer\"\n    );\n\n    check_err!(errs.get(2) =\u003e\n        ErrorKind::ModuleGatesInvalidClusterSize,\n        \"cannot create gate-cluster of size '0', requires positiv integer\"\n    );\n\n    check_err!(errs.get(3) =\u003e\n        ErrorKind::ModuleGatesInvalidClusterSize,\n        \"cannot create gate-cluster of size '-1', requires positiv integer\"\n    );\n}\n\n#[test]\nfn gates_ast_invalid_punct() {\n    let err = Context::load(\"tests/gates_ast_invalid_punct.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"expected \u003cident\u003e, found ','\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","gates_ir.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::Cluster;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn gates_ir_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/gates_ir_baseline.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.gates.len(), 4);\n\n    assert_eq!(entry.gates[0].ident.raw, \"in\");\n    assert_eq!(entry.gates[0].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.gates[1].ident.raw, \"out\");\n    assert_eq!(entry.gates[1].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.gates[2].ident.raw, \"influx\");\n    assert_eq!(entry.gates[2].cluster, Cluster::Clusted(5));\n\n    assert_eq!(entry.gates[3].ident.raw, \"outflow\");\n    assert_eq!(entry.gates[3].cluster, Cluster::Clusted(1));\n\n    Ok(())\n}\n\n#[test]\nfn gates_ir_local_dup() {\n    let err = Context::load(\"tests/gates_ir_local_dup.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolDuplication,\n        \"gate(-cluster) 'in' was defined multiple times\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","link_ast.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::{Item, Literal};\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn link_ast_baseline() -\u003e RootResult\u003c()\u003e {\n    let ctx = Context::load(\"tests/link_ir_baseline.ndl\")?;\n    let ir = ctx.ir.values().collect::\u003cVec\u003c_\u003e\u003e()[0];\n\n    assert!(matches!(ir.items[0], Item::Link(_)));\n    assert!(matches!(ir.items[1], Item::Link(_)));\n    assert!(matches!(ir.items[2], Item::Link(_)));\n\n    let a = ir.link(\"A\").unwrap();\n    let b = ir.link(\"B\").unwrap();\n    let c = ir.link(\"C\").unwrap();\n\n    assert_eq!(a.ident.raw, \"A\");\n    assert_eq!(b.ident.raw, \"B\");\n    assert_eq!(c.ident.raw, \"C\");\n\n    assert_eq!(a.jitter, 0.2);\n    assert_eq!(b.jitter, 0.2);\n    assert_eq!(c.jitter, 1.0);\n\n    assert_eq!(a.fields.get(\"bparam\"), None);\n    assert_eq!(\n        b.fields.get(\"bparam\"),\n        Some(\u0026Literal::String(\"string\".to_string()))\n    );\n    assert_eq!(\n        c.fields.get(\"bparam\"),\n        Some(\u0026Literal::String(\"strong\".to_string()))\n    );\n\n    Ok(())\n}\n\n#[test]\nfn link_ast_noident() {\n    let err = Context::load(\"tests/link_ast_noident.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"unexpected token for link symbol: expected \u003cident\u003e, found delim\"\n    );\n}\n\n#[test]\nfn link_ast_invalid_inh() {\n    let err = Context::load(\"tests/link_ast_invalid_inh.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"failed to parse value in joined statement: expected \u003cident\u003e, found delim\"\n    );\n}\n\n#[test]\nfn link_ast_invalid_kv() {\n    let err = Context::load(\"tests/link_ast_invalid_kv.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"missing delimiter in key-value pair: expected ':', found \u003cliteral\u003e\"\n    );\n}\n\n#[test]\nfn link_ast_invalid_kv2() {\n    let err = Context::load(\"tests/link_ast_invalid_kv2.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"missing value in key-value pair: expected \u003cliteral\u003e, found \u003cident\u003e\"\n    );\n}\n\n#[test]\nfn link_ast_nodelim() {\n    let err = Context::load(\"tests/link_ast_nodelim.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ExpectedDelimited,\n        \"expected delimited sequence, found 'module'\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","link_ir.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::{Item, Literal};\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn link_ir_baseline() -\u003e RootResult\u003c()\u003e {\n    let ctx = Context::load(\"tests/link_ir_baseline.ndl\")?;\n    let ir = ctx.ir.values().collect::\u003cVec\u003c_\u003e\u003e()[0];\n\n    assert!(matches!(ir.items[0], Item::Link(_)));\n    assert!(matches!(ir.items[1], Item::Link(_)));\n    assert!(matches!(ir.items[2], Item::Link(_)));\n\n    let a = ir.link(\"A\").unwrap();\n    let b = ir.link(\"B\").unwrap();\n    let c = ir.link(\"C\").unwrap();\n\n    assert_eq!(a.ident.raw, \"A\");\n    assert_eq!(b.ident.raw, \"B\");\n    assert_eq!(c.ident.raw, \"C\");\n\n    assert_eq!(a.jitter, 0.2);\n    assert_eq!(b.jitter, 0.2);\n    assert_eq!(c.jitter, 1.0);\n\n    assert_eq!(a.fields.get(\"bparam\"), None);\n    assert_eq!(\n        b.fields.get(\"bparam\"),\n        Some(\u0026Literal::String(\"string\".to_string()))\n    );\n    assert_eq!(\n        c.fields.get(\"bparam\"),\n        Some(\u0026Literal::String(\"strong\".to_string()))\n    );\n\n    Ok(())\n}\n\n#[test]\nfn link_ir_inh() {\n    let err = Context::load(\"tests/link_ir_inh.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find link symbol 'C', not in scope\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find link symbol 'C', not in scope\"\n    );\n}\n\n#[test]\nfn link_ir_inh_with_solutions() {\n    let err = Context::load(\"tests/link_ir_inh2/main.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find link symbol 'C', not in scope\",\n        \"try including 'C' from '../sub1'\"\n\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find link symbol 'C', not in scope\",\n        \"try including 'C' from '../sub1'\"\n    );\n}\n\n#[test]\nfn link_ir_inh_dup() {\n    let err = Context::load(\"tests/link_ir_inh_dup.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::LinkInheritanceDuplicatedSymbols,\n        \"found duplicated symbol 'C' in link inheritance statement\"\n    );\n}\n\n#[test]\nfn link_ir_known_values() {\n    let err = Context::load(\"tests/link_ir_known_values.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::LinkKnownKeysInvalidValue,\n        \"known key 'jitter' expects a value of type float\"\n    );\n}\n\n#[test]\nfn link_ir_local_dup() {\n    let err = Context::load(\"tests/link_ir_local_dup.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolDuplication,\n        \"cannot create new symbol 'A', was allready defined\"\n    );\n}\n\n#[test]\nfn link_ir_nonlocal_dup() {\n    let err = Context::load(\"tests/link_ir_nonlocal_dup/main.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolDuplication,\n        \"found duplicated symbol 'A', with 1 duplications\"\n    );\n}\n\n#[test]\nfn link_ir_requried_values() {\n    let err = Context::load(\"tests/link_ir_required_values.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 2);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::LinkMissingRequiredFields,\n        \"missing required field 'latency', was not defined locally or in prototypes\"\n    );\n\n    check_err!(errs.get(1) =\u003e\n        ErrorKind::LinkMissingRequiredFields,\n        \"missing required field 'bitrate', was not defined locally or in prototypes\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","module_ast.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::Cluster;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn module_ast_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/module_ast_baseline.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n\n    assert_eq!(entry.ident.raw, \"Main\");\n\n    assert_eq!(entry.gates.len(), 4);\n    // inh\n    assert_eq!(entry.gates[0].ident.raw, \"in\");\n    assert_eq!(entry.gates[0].cluster, Cluster::Standalone);\n    assert_eq!(entry.gates[1].ident.raw, \"out\");\n    assert_eq!(entry.gates[1].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.gates[2].ident.raw, \"uplink\");\n    assert_eq!(entry.gates[2].cluster, Cluster::Clusted(2));\n    assert_eq!(entry.gates[3].ident.raw, \"downlink\");\n    assert_eq!(entry.gates[3].cluster, Cluster::Clusted(2));\n\n    assert_eq!(\n        entry.submodules[0].typ.as_module().unwrap().ident.raw,\n        \"Sub\"\n    );\n    let sub = entry.submodules[0].typ.as_module().unwrap();\n    assert_eq!(sub.connections, vec![]);\n    assert_eq!(sub.submodules, vec![]);\n\n    assert_eq!(sub.gates.len(), 2);\n\n    assert_eq!(sub.gates[0].ident.raw, \"in\");\n    assert_eq!(sub.gates[0].cluster, Cluster::Standalone);\n    assert_eq!(sub.gates[1].ident.raw, \"out\");\n    assert_eq!(sub.gates[1].cluster, Cluster::Standalone);\n\n    Ok(())\n}\n\n#[test]\nfn module_ast_noident() {\n    let err = Context::load(\"tests/module_ast_noident.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"unexpected token for module symbol: expected \u003cident\u003e, found delim\"\n    );\n}\n\n#[test]\nfn module_ast_noident2() {\n    let err = Context::load(\"tests/module_ast_noident2.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"unexpected token for module symbol: expected \u003cident\u003e, found \u003cliteral\u003e\"\n    );\n}\n\n#[test]\nfn module_ast_nodelim() {\n    let err = Context::load(\"tests/module_ast_nodelim.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ExpectedDelimited,\n        \"expected delimited sequence, found EOF\"\n    );\n}\n\n#[test]\nfn module_ast_nodelim2() {\n    let err = Context::load(\"tests/module_ast_nodelim2.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ExpectedDelimited,\n        \"expected delimited sequence, found ';'\"\n    );\n}\n\n#[test]\nfn module_ast_invalid_inh() {\n    let err = Context::load(\"tests/module_ast_invalid_inh.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"failed to parse value in joined statement: expected \u003cident\u003e, found delim\"\n    );\n}\n\n#[test]\nfn module_ast_invalid_inh2() {\n    let err = Context::load(\"tests/module_ast_invalid_inh2.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleInheritanceDuplicatedSymbols,\n        \"found duplicated symbol 'A' in module inheritance statement\"\n    );\n}\n\n#[test]\nfn module_ast_inh_dyn() {\n    let err = Context::load(\"tests/module_ast_inh_dyn.ndl\").unwrap_err();\n    println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleBothInheritanceAndDyn,\n        \"module is defined with both inheritance and dyn members: not supported\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","submodules_ast.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::Cluster;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn submodules_ast_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/submodules_ast_baseline.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.submodules.len(), 3);\n\n    assert_eq!(entry.submodules[0].ident.raw, \"a\");\n    assert_eq!(entry.submodules[0].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[0].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.submodules[1].ident.raw, \"b\");\n    assert_eq!(entry.submodules[1].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[1].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.submodules[2].ident.raw, \"c\");\n    assert_eq!(entry.submodules[2].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[2].cluster, Cluster::Clusted(4));\n\n    Ok(())\n}\n\n#[test]\nfn submodules_ast_nodelim() {\n    let err = Context::load(\"tests/submodules_ast_nodelim.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ExpectedDelimited,\n        \"expected delimited sequence, found ';'\"\n    );\n}\n\n#[test]\nfn submodules_ast_wrong_delim() {\n    let err = Context::load(\"tests/submodules_ast_wrong_delim.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedDelim,\n        \"expected delimited sequence '{ ... }', found delimited sequence '( ... )'\"\n    );\n}\n\n#[test]\nfn submodules_ast_symbol_dup() {\n    let err = Context::load(\"tests/submodules_ast_symbol_dup.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::ModuleSubDuplicatedSymbols,\n        \"submodule(-cluster) 'a' was defined multiple times\"\n    );\n}\n\n#[test]\nfn submodules_ast_missing_ty() {\n    let err = Context::load(\"tests/submodules_ast_missing_ty.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::UnexpectedToken,\n        \"expected \u003cident\u003e, found ','\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","des-ndl","tests","submodules_ir.rs"],"content":"use des_ndl::error::*;\nuse des_ndl::ir::Cluster;\nuse des_ndl::*;\n\n#[macro_use]\nmod common;\n\n#[test]\nfn submodules_ir_baseline() -\u003e RootResult\u003c()\u003e {\n    let mut ctx = Context::load(\"tests/submodules_ir_baseline.ndl\")?;\n    let entry = ctx.entry.take().unwrap();\n\n    assert_eq!(entry.ident.raw, \"M\");\n    assert_eq!(entry.submodules.len(), 3);\n\n    assert_eq!(entry.submodules[0].ident.raw, \"a\");\n    assert_eq!(entry.submodules[0].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[0].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.submodules[1].ident.raw, \"b\");\n    assert_eq!(entry.submodules[1].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[1].cluster, Cluster::Standalone);\n\n    assert_eq!(entry.submodules[2].ident.raw, \"c\");\n    assert_eq!(entry.submodules[2].typ.as_module().unwrap().ident.raw, \"A\");\n    assert_eq!(entry.submodules[2].cluster, Cluster::Clusted(4));\n\n    Ok(())\n}\n\n#[test]\nfn submodules_ir_local_dup() {\n    let err = Context::load(\"tests/submodules_ir_local_dup.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolDuplication,\n        \"submodule(-cluster) 'a' was defined multiple times\"\n    );\n}\n\n#[test]\nfn submodules_ir_unknown_ty() {\n    let err = Context::load(\"tests/submodules_ir_unknown_ty.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find submodule symbol 'A', not in scope\"\n    );\n}\n\n#[test]\nfn submodules_ir_unknown_ty_soloution() {\n    let err = Context::load(\"tests/submodules_ir_unknown_ty_solution/main.ndl\").unwrap_err();\n    // println!(\"{err}\");\n\n    let errs = err.errors;\n    assert_eq!(errs.len(), 1);\n\n    check_err!(errs.get(0) =\u003e\n        ErrorKind::SymbolNotFound,\n        \"did not find submodule symbol 'A', not in scope\",\n        \"try including 'A' from '../sub1'\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","cqueue","main.rs"],"content":"use des::prelude::*;\n\nstruct App {\n    event_delay: Duration,\n    num_events: usize,\n}\nimpl Application for App {\n    type EventSet = EvSet;\n    type Lifecycle = App;\n}\n\nimpl EventLifecycle\u003cApp\u003e for App {\n    fn at_sim_start(rt: \u0026mut Runtime\u003cSelf\u003e) {\n        let mut delay = Duration::ZERO;\n        for _ in 0..rt.app.num_events {\n            rt.add_event_in(EvSet {}, delay);\n            let offset = random::\u003cf64\u003e() * 2.0 * rt.app.event_delay.as_secs_f64();\n            delay += Duration::from_secs_f64(offset);\n        }\n    }\n}\n\nstruct EvSet {}\nimpl EventSet\u003cApp\u003e for EvSet {\n    fn handle(self, rt: \u0026mut Runtime\u003cApp\u003e) {\n        rt.add_event_in(EvSet {}, rt.app.event_delay);\n        // NOP\n    }\n}\n\nfn main() {\n    let args = std::env::args().collect::\u003cVec\u003c_\u003e\u003e();\n\n    let event_delay: Duration = args\n        .iter()\n        .find(|v| v.starts_with(\"delay=\"))\n        .map(|s| s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1].parse::\u003cf64\u003e().unwrap())\n        .map(Duration::from_secs_f64)\n        .unwrap_or(Duration::from_secs(1));\n\n    let num_events: usize = args\n        .iter()\n        .find(|v| v.starts_with(\"num=\"))\n        .map(|s| {\n            s.split('=').collect::\u003cVec\u003c_\u003e\u003e()[1]\n                .parse::\u003cusize\u003e()\n                .unwrap()\n        })\n        .unwrap_or(400);\n\n    let rt = Builder::seeded(123).max_time(100_000.0.into()).build(App {\n        event_delay,\n        num_events,\n    });\n\n    let _ = rt.run();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","droptest","main.rs"],"content":"use des::{prelude::*, registry};\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\nmod modules;\npub use modules::*;\n\nstatic MODULE_LEN: AtomicUsize = AtomicUsize::new(0);\n\nfn main() {\n    let app = Sim::ndl(\"examples/droptest/main.ndl\", registry![Network, Bob, Alice])\n        .map_err(|e| println!(\"{e}\"))\n        .unwrap();\n\n    let rt = Builder::seeded(0x123).build(app);\n\n    let (app, time, p) = rt.run().unwrap();\n    let globals = app.globals();\n    drop(app);\n\n    // println!(\"{:?}\", globals);\n\n    drop(globals);\n\n    // // Assume full drop.\n    assert_eq!(MODULE_LEN.load(Ordering::SeqCst), 0);\n\n    assert_eq!(p.event_count, 6);\n    assert_eq!(time.as_millis(), 387)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","droptest","modules.rs"],"content":"use std::sync::atomic::Ordering;\n\nuse crate::MODULE_LEN;\nuse des::prelude::*;\n\n#[derive(Default)]\npub struct Alice();\n\nimpl Module for Alice {\n    fn at_sim_start(\u0026mut self, _: usize) {\n        let msg = Message::new().kind(1).content(42usize).build();\n        send(msg, (\"netOut\", 0));\n\n        println!(\"SimStared\");\n        let prev = MODULE_LEN.fetch_add(1, Ordering::SeqCst);\n        println!(\"Alice simstared: MODULE_LEN := {}\", prev + 1)\n    }\n\n    fn handle_message(\u0026mut self, _: Message) {\n        // let (msg, head) = msg.cast::\u003cusize\u003e();\n        // println!(\"Received msg: {} - {:?}\", msg, head);\n    }\n}\n\nimpl Drop for Alice {\n    fn drop(\u0026mut self) {\n        println!(\"\u003cDROP\u003e Alice\");\n        MODULE_LEN.fetch_sub(1, Ordering::SeqCst);\n    }\n}\n\n#[derive(Default)]\npub struct Bob();\n\nimpl Module for Bob {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        let prev = MODULE_LEN.fetch_add(1, Ordering::SeqCst);\n        println!(\"Bob simstared: MODULE_LEN := {}\", prev + 1)\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        let (msg, _) = msg.cast::\u003cusize\u003e();\n\n        // println!(\"Received msg: {} - {:?}\", msg, head);\n\n        let msg = Message::new().kind(2).content(msg).build();\n        send(msg, (\"netOut\", 0))\n    }\n}\n\nimpl Drop for Bob {\n    fn drop(\u0026mut self) {\n        println!(\"\u003cDROP\u003e Bob\");\n        MODULE_LEN.fetch_sub(1, Ordering::SeqCst);\n    }\n}\n\n#[derive(Default)]\npub struct Network();\n\nimpl Module for Network {\n    fn at_sim_start(\u0026mut self, _: usize) {\n        let prev = MODULE_LEN.fetch_add(1, Ordering::SeqCst);\n        println!(\"Network simstared: MODULE_LEN := {}\", prev + 1);\n    }\n\n    fn handle_message(\u0026mut self, _: Message) {\n        unimplemented!()\n    }\n}\n\nimpl Drop for Network {\n    fn drop(\u0026mut self) {\n        println!(\"\u003cDROP\u003e Network\");\n        MODULE_LEN.fetch_sub(1, Ordering::SeqCst);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","multisim","main.rs"],"content":"use std::sync::atomic::Ordering::SeqCst;\nuse std::sync::{atomic::AtomicUsize, Arc, Barrier};\nuse std::thread;\n\nuse des::prelude::*;\n\nfn main() {\n    let n = 5;\n    let mut handles = Vec::with_capacity(n);\n\n    let barrier = Arc::new(Barrier::new(n));\n    let active = Arc::new(AtomicUsize::new(0));\n    let counter = Arc::new(AtomicUsize::new(0));\n\n    for _ in 0..n {\n        let barrier_c = barrier.clone();\n        let active_c = active.clone();\n        let counter_c = counter.clone();\n\n        handles.push(thread::spawn(move || {\n            create_runtime_and_wait(barrier_c, active_c, counter_c)\n        }))\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    assert_eq!(active.load(SeqCst), 0);\n    assert_eq!(counter.load(SeqCst), n)\n}\n\nfn create_runtime_and_wait(\n    barrier: Arc\u003cBarrier\u003e,\n    active: Arc\u003cAtomicUsize\u003e,\n    counter: Arc\u003cAtomicUsize\u003e,\n) {\n    barrier.wait();\n\n    // Create runtime\n    let app = Sim::new(());\n\n    let rt = Builder::new().build(app);\n    let prev = active.fetch_add(1, SeqCst);\n    assert_eq!(prev, 0);\n    counter.fetch_add(1, SeqCst);\n\n    // Do work\n    thread::sleep(Duration::from_millis(500));\n\n    // Deregister\n    let prev = active.fetch_sub(1, SeqCst);\n    assert_eq!(prev, 1);\n\n    drop(rt);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","ndl","main.rs"],"content":"use des::{prelude::*, registry};\n\nmod members;\nuse members::*;\n\n#[derive(Debug, Default)]\nstruct A;\n\nimpl Module for A {}\n\nfn main() {\n    let app = Sim::ndl(\"examples/ndl/main.ndl\", registry![A, Alice, Bob]).unwrap();\n\n    let rt = Builder::seeded(0x123).build(app);\n\n    let (_, time, profile) = rt.run().unwrap();\n\n    // assert_eq!(tie, 18224.956482853);\n\n    assert_eq!(time.as_secs(), 12279);\n    assert_eq!(profile.event_count, 18_001_000);\n\n    // profile\n    //     .write_to(\"examples/ndl/bench\")\n    //     .expect(\"Failed to write bench\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","ndl","members.rs"],"content":"use std::ops::Deref;\n\nuse des::prelude::*;\nuse tracing::info;\n\n#[derive(Default)]\npub struct Alice();\n\nimpl Module for Alice {\n    fn handle_message(\u0026mut self, msg: Message) {\n        let mut pkt = msg;\n        info!(\n            \"Received at {}: Message with content: {}\",\n            SimTime::now(),\n            pkt.content::\u003cString\u003e().deref()\n        );\n\n        if pkt.header().id \u003e 60_000 {\n            // TERMINATE\n        } else {\n            pkt.header_mut().id += 1;\n            send(pkt, (\"netOut\", 0))\n        }\n    }\n}\n\n#[derive(Default)]\npub struct Bob();\n\nimpl Module for Bob {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        schedule_in(\n            Message::new()\n                .kind(0xff)\n                .content(\"Init\".to_string())\n                .build(),\n            Duration::ZERO,\n        )\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        if msg.header().kind == 0xff {\n            info!(target: \"Bob\", \"Initalizing\");\n            drop(msg);\n            info!(target: \"Bob\", \"Dropped init msg\");\n            send(\n                Message::new()\n                    .kind(1)\n                    // .src(0x7f_00_00_01, 80)\n                    // .dest(0x7f_00_00_02, 80)\n                    .id(0)\n                    .content(\"Ping\".to_string())\n                    .build(),\n                (\"netOut\", 2),\n            );\n        } else {\n            let mut pkt = msg;\n            pkt.header_mut().id += 1;\n\n            info!(\n                \"Received at {}: Message with content: {}\",\n                SimTime::now(),\n                pkt.content::\u003cString\u003e().deref()\n            );\n\n            pkt.content_mut::\u003cString\u003e().push('#');\n\n            send(pkt, (\"netOut\", 2));\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","ndl2","main.rs"],"content":"use des::{prelude::*, registry};\n\n#[derive(Default)]\nstruct Sub;\nimpl Module for Sub {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        if current().name() == \"a\" {\n            send(Message::new().build(), \"out\");\n        }\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        send(msg, \"out\");\n        tracing::info!(\"EY\");\n    }\n}\n\n#[derive(Default)]\nstruct Main;\nimpl Module for Main {\n    fn at_sim_end(\u0026mut self) {\n        tracing::info!(target: \"custom\", \"at sim end\")\n    }\n}\n\nfn main() {\n    // Logger::new()\n    //     .interal_max_log_level(log::LevelFilter::Debug)\n    //     .set_logger();\n\n    let app = match Sim::ndl(\"examples/ndl2/main.ndl\", registry![Main, Sub]) {\n        Ok(v) =\u003e v,\n        Err(e) =\u003e {\n            println!(\"{e}\");\n            panic!(\"exiting due to previouis error\")\n        }\n    };\n    let rt = Builder::seeded(123).max_itr(10).build(app);\n    let _ = rt.run();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","plugin","main.rs"],"content":"use des::{\n    net::{\n        module::{set_setup_fn, ModuleContext},\n        processing::ProcessingElement,\n    },\n    prelude::*,\n    registry,\n};\n\n#[derive(Default)]\nstruct A {}\n\nimpl Module for A {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        send(Message::new().content(42).build(), \"out\");\n        send(Message::new().content(69).build(), \"out\");\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        let span = ::tracing::span!(::tracing::Level::INFO, \"a-recv\", age = 2, size = 3);\n        let _g = span.enter();\n        tracing::info!(\"recv: {} {}\", msg.str(), msg.content::\u003ci32\u003e())\n    }\n}\n\n#[derive(Default)]\nstruct PacketCounter {\n    count: usize,\n}\n\nimpl ProcessingElement for PacketCounter {\n    fn incoming(\u0026mut self, msg: Message) -\u003e Option\u003cMessage\u003e {\n        self.count += 1;\n        Some(msg)\n    }\n}\n\nimpl Drop for PacketCounter {\n    fn drop(\u0026mut self) {\n        assert_eq!(self.count, 2);\n    }\n}\n\n#[derive(Default)]\nstruct B {}\n\nimpl Module for B {\n    fn stack(\u0026self) -\u003e impl ProcessingElement + 'static\n    where\n        Self: Sized,\n    {\n        PacketCounter::default()\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        send(msg, \"out\")\n    }\n}\n\n#[derive(Default)]\nstruct Main;\nimpl Module for Main {}\n\nfn empty(_: \u0026ModuleContext) {}\n\nfn main() {\n    // Logger::new().set_logger();\n    // tracing_subscriber::fmt()\n    //     .with_max_level(LevelFilter::TRACE)\n    //     .init();\n\n    des::tracing::init();\n\n    // Subscriber::default().init().unwrap();\n\n    set_setup_fn(empty);\n\n    let app = Sim::ndl(\"examples/plugin/main.ndl\", registry![A, B, Main]).unwrap();\n    let rt = Builder::new().build(app);\n    let _res = rt.run();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","proto","main.rs"],"content":"use des::{prelude::*, registry};\n\n#[derive(Debug, Default)]\nstruct AppA {}\n\nimpl Module for AppA {\n    fn handle_message(\u0026mut self, _msg: Message) {\n        println!(\"A: [{}] {:?}\", SimTime::now(), _msg);\n        assert_eq!(SimTime::now(), 1.0);\n    }\n}\n\n#[derive(Debug, Default)]\nstruct AppB {}\n\nimpl Module for AppB {\n    fn handle_message(\u0026mut self, _msg: Message) {\n        println!(\"B: [{}] {:?}\", SimTime::now(), _msg);\n        assert_eq!(SimTime::now(), 2.0);\n    }\n}\n\n#[derive(Debug, Default)]\nstruct Runner {}\n\nimpl Module for Runner {\n    fn handle_message(\u0026mut self, _msg: Message) {}\n}\n\n#[derive(Debug, Default)]\nstruct MultiRunner {}\n\nimpl Module for MultiRunner {\n    fn at_sim_start(\u0026mut self, _stage: usize) {\n        schedule_at(Message::new().kind(42).build(), 1.0.into());\n    }\n\n    fn handle_message(\u0026mut self, mut msg: Message) {\n        // println!(\"M: [{}] {:?}\", SimTime::now(), msg);\n        if msg.header().kind == 42 {\n            let mut dup = msg.dup::\u003c()\u003e();\n            dup.header_mut().kind = 123;\n            send(dup, (\"toAppl\", 0));\n            // processing_time(Duration::new(1, 0));\n            // println!(\"AAA\");\n            msg.header_mut().kind = 69;\n            send_in(msg, (\"toAppl\", 1), Duration::from_secs(1));\n            schedule_in(Message::new().kind(69).build(), Duration::new(2, 0));\n        } else {\n            // Send at 1.0 with processing 1.0 and delay 1.0\n            assert_eq!(SimTime::now(), 3.0);\n        }\n    }\n}\n\n#[derive(Debug, Default)]\nstruct Main;\nimpl Module for Main {}\n\nfn main() {\n    // Logger::new().try_set_logger().unwrap();\n    let app = Sim::ndl(\n        \"examples/proto/main.ndl\",\n        registry![AppA, AppB, Runner, MultiRunner, Main],\n    )\n    .unwrap();\n\n    // println!(\"{:?}\", app.globals().parameters);\n\n    let rt = Builder::seeded(0x123).build(app);\n    let (app, _time, _event_count) = rt.run().unwrap();\n\n    let _ = app\n        .globals()\n        .topology\n        .lock()\n        .unwrap()\n        .write_to_svg(\"examples/proto/graph\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","ptrhell","main.rs"],"content":"use des::{prelude::*, registry};\n\nmod modules;\npub use modules::*;\n\nfn main() {\n    // Logger::new().try_set_logger().unwrap();\n\n    let app = Sim::ndl(\"examples/ptrhell/main.ndl\", registry![Bob, Alice, Network]).unwrap();\n\n    let rt = Builder::seeded(0x123).build(app);\n\n    let (_, time, p) = rt.run().unwrap();\n\n    assert_eq!(p.event_count, 6);\n    assert_eq!(time.as_millis(), 387)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","ptrhell","modules.rs"],"content":"use des::prelude::*;\n\n#[derive(Debug, Default)]\npub struct Alice();\n\nimpl Module for Alice {\n    fn at_sim_start(\u0026mut self, _: usize) {\n        let msg = Message::new().kind(1).content(42usize).build();\n        send(msg, (\"netOut\", 0));\n\n        tracing::info!(\"SimStared\");\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        let (msg, head) = msg.cast::\u003cusize\u003e();\n        tracing::info!(target: \"inet\", \"Received msg: {} - {:?}\", msg, head);\n    }\n}\n\n#[derive(Debug, Default)]\npub struct Bob();\n\nimpl Module for Bob {\n    fn handle_message(\u0026mut self, msg: Message) {\n        let (msg, head) = msg.cast::\u003cusize\u003e();\n\n        println!(\"Received msg: {} - {:?}\", msg, head);\n\n        let msg = Message::new().kind(2).content(msg).build();\n        send(msg, (\"netOut\", 0))\n    }\n}\n\n#[derive(Debug, Default)]\npub struct Network();\n\nimpl Module for Network {\n    fn handle_message(\u0026mut self, _: Message) {\n        unimplemented!()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","test-bin","main.rs"],"content":"use des::net::AsyncFn;\nuse des::prelude::*;\nuse des::time;\n\nfn main() {\n    let mut sim = Sim::new(());\n    sim.node(\n        \"alice\",\n        AsyncFn::new(|_| async move {\n            tokio::select! {\n                _ = time::sleep(Duration::from_secs(10)) =\u003e unreachable!(),\n                _ = time::sleep(Duration::from_secs(5)) =\u003e println!(\"resolved\"),\n            }\n        })\n        .require_join(),\n    );\n\n    let _ = Builder::seeded(123).build(sim).run();\n    todo!()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","utils","main.rs"],"content":"use des::{prelude::*, registry};\n\nmod members;\nuse members::*;\n\n#[derive(Debug, Default)]\nstruct A;\nimpl Module for A {}\n\nfn main() {\n    let mut app = Sim::ndl(\"examples/utils/main.ndl\", registry![A, Alice, Bob])\n        .map_err(|e| println!(\"{e}\"))\n        .unwrap();\n    app.include_par_file(\"examples/utils/init.par\").unwrap();\n\n    let rt = Builder::seeded(0x123).quiet().build(app);\n    let (app, time, p) = rt.run().unwrap();\n\n    let topo = app.globals().topology.lock().unwrap().clone();\n\n    assert_eq!(topo.nodes().len(), 4 + 1);\n    assert_eq!(topo.edges(), 14);\n\n    let _ = topo.write_to_svg(\"examples/utils/graph\");\n\n    assert_eq!(p.event_count, 48);\n    assert_eq!(time.as_secs(), 83)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","utils","members.rs"],"content":"use std::ops::Deref;\n\nuse des::prelude::*;\n\nuse tracing::info;\n\n#[derive(Debug, Default)]\npub struct Alice();\n\nimpl Module for Alice {\n    fn handle_message(\u0026mut self, msg: Message) {\n        let pkt = msg;\n        info!(\n            \"Received at {}: Message with content: {}\",\n            SimTime::now(),\n            pkt.content::\u003cString\u003e().deref()\n        );\n\n        if pkt.content::\u003cString\u003e().len() \u003e par(\"limit\").unwrap().parse::\u003cusize\u003e().unwrap() {\n            // TERMINATE\n        } else {\n            // pkt.content_mut::\u003cString\u003e().push('#');\n            send(pkt, (\"netOut\", 0))\n        }\n    }\n}\n\n#[derive(Debug, Default)]\npub struct Bob();\n\nimpl Module for Bob {\n    fn num_sim_start_stages(\u0026self) -\u003e usize {\n        2\n    }\n\n    fn at_sim_start(\u0026mut self, stage: usize) {\n        match stage {\n            0 =\u003e {\n                info!(\"Initalizing\");\n                send(\n                    Message::new()\n                        .kind(1)\n                        // .src(0x7f_00_00_01, 80)\n                        // .dest(0x7f_00_00_02, 80)\n                        .content(\"Ping\".to_string())\n                        .build(),\n                    (\"netOut\", 2),\n                );\n            }\n            1 =\u003e {\n                // Nothing\n            }\n            _ =\u003e unreachable!(),\n        }\n    }\n\n    fn handle_message(\u0026mut self, msg: Message) {\n        let mut pkt = msg;\n\n        info!(\n            \"Received at {}: Message with content: {}\",\n            SimTime::now(),\n            pkt.content::\u003cString\u003e().deref()\n        );\n\n        pkt.content_mut::\u003cString\u003e().push_str(\u0026par(\"char\").unwrap());\n\n        send(pkt, (\"netOut\", 2));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mk","Developer","rust","des","examples","waiter","main.rs"],"content":"use rand::distributions::Standard;\nuse std::{collections::VecDeque, fmt::Debug};\n\nuse des::prelude::*;\n\n#[derive(Debug, Clone)]\nstruct Customer {\n    pub arrived: SimTime,\n    pub duration: Duration,\n}\n\n#[derive(Debug)]\nstruct Application {\n    // Params\n    n: usize,\n    l: f64,\n    m: f64,\n    queue: VecDeque\u003cCustomer\u003e,\n    busy: bool,\n\n    // Metrics\n    wait_times: Vec\u003cDuration\u003e,\n    busy_time: SimTime,\n}\n\nimpl Application {\n    fn eval(\u0026self, t: SimTime) {\n        let busy_perc = self.busy_time / t;\n\n        let avg_wait = self\n            .wait_times\n            .iter()\n            .fold(Duration::ZERO, |acc, \u0026i| acc + i)\n            / self.wait_times.len() as u32;\n\n        println!(\"=== Simulation finished ===\");\n        println!(\"l = {} \\tm = {}\", self.l, self.m);\n        println!();\n        println!(\"Finshed at t := {}\", t);\n        println!(\"Busy := {}\", busy_perc);\n        println!(\"(avg) waittime := {:?}\", avg_wait);\n\n        assert!((busy_perc - 0.4996535454771872).abs() \u003c 0.01);\n        assert_eq!(avg_wait, Duration::from_secs_f64(1.002135171))\n    }\n}\n\nimpl des::runtime::Application for Application {\n    type EventSet = Events;\n    type Lifecycle = ();\n}\n\n#[derive(Debug)]\n#[allow(clippy::large_enum_variant)]\nenum Events {\n    ServerDone(ServerDone),\n    CustomerArrival(CustomerArrival),\n}\n\nimpl EventSet\u003cApplication\u003e for Events {\n    fn handle(self, rt: \u0026mut Runtime\u003cApplication\u003e) {\n        match self {\n            Self::ServerDone(event) =\u003e event.handle(rt),\n            Self::CustomerArrival(event) =\u003e event.handle(rt),\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct ServerDone {\n    started: SimTime,\n    _pad: [u8; 300],\n}\n\nimpl ServerDone {\n    fn handle(self, rt: \u0026mut Runtime\u003cApplication\u003e) {\n        let busy_interval = rt.sim_time() - self.started;\n        rt.app.busy_time += busy_interval;\n\n        let customer = rt.app.queue.pop_front();\n        match customer {\n            Some(customer) =\u003e {\n                // log wait time\n                rt.app.busy = true;\n                rt.app.wait_times.push(rt.sim_time() - customer.arrived);\n                rt.add_event_in(\n                    Events::ServerDone(ServerDone {\n                        started: rt.sim_time(),\n                        _pad: [0; 300],\n                    }),\n                    customer.duration,\n                )\n            }\n            None =\u003e {\n                rt.app.busy = false;\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct CustomerArrival {\n    idx: usize,\n}\n\nimpl CustomerArrival {\n    fn handle(self, rt: \u0026mut Runtime\u003cApplication\u003e) {\n        if self.idx \u003e rt.app.n {\n            return;\n        }\n\n        // Gen next event\n        let duration = expdist(rt, 1.0 / rt.app.l);\n        let next = expdist(rt, 1.0 / rt.app.m);\n\n        let customer = Customer {\n            arrived: rt.sim_time(),\n            duration: Duration::from_secs_f64(duration),\n        };\n\n        if rt.app.busy {\n            rt.app.queue.push_back(customer);\n        } else {\n            rt.app.busy = true;\n            rt.app.wait_times.push(Duration::ZERO);\n            rt.add_event_in(\n                Events::ServerDone(ServerDone {\n                    started: rt.sim_time(),\n                    _pad: [0; 300],\n                }),\n                customer.duration,\n            );\n        }\n\n        rt.add_event_in(\n            Events::CustomerArrival(CustomerArrival { idx: self.idx + 1 }),\n            Duration::from_secs_f64(next),\n        );\n    }\n}\n\nfn expdist\u003cA: des::runtime::Application\u003e(rt: \u0026mut Runtime\u003cA\u003e, p: f64) -\u003e f64 {\n    let x: f64 = rt.rng_sample(Standard);\n    x.ln() / -p\n}\n\nfn main() {\n    let app = Application {\n        n: 100_000,\n        l: 1.0,\n        m: 2.0,\n\n        queue: VecDeque::new(),\n        busy: false,\n\n        wait_times: Vec::new(),\n        busy_time: SimTime::ZERO,\n    };\n\n    let mut rt = Builder::seeded(0x42069).build(app);\n    // Create first event\n    let l = rt.app.l;\n    let dur = Duration::from_secs_f64(expdist(\u0026mut rt, l));\n    rt.add_event_in(Events::CustomerArrival(CustomerArrival { idx: 0 }), dur);\n\n    let (app, t_max, _) = rt.run().unwrap();\n    app.eval(t_max);\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>