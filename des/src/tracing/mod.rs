//! Structured event tracing with simulation specific context.
//!
//! A tracing subscriber in the context of a simulation may need
//! some more functionality that normal subscribers. Notabley
//! differentiating between nodes and using the simulation time
//! to index events is required.
//!
//! ## Overview
//!
//! A tracing subscriber collect events from a simulation, annotated with
//! additional context information in the form of spans. For mor information
//! on tracing in general read the [docs](https://docs.rs/tracing).
//!
//! This subscriber implementation is inspired by
//! the standard `tracing-subscriber` with some additional simulation context
//! ontop. Events that are created through the `tracing` frontend
//! will only be logged if the set `Filters` return a
//! max allowed level higher (more verbose) or equal  to the events
//! level. If allowed, each scope uses a `ScopeConfiguration`,
//! generated by the subscribers `ScopeConfigurationPolicy` on the fly,
//! to format and output the event.
//!
//! Formatters allow events to be outputed in various formats, that
//! may be more beneficial to the users application. Different output
//! target allow the user to not only log to `stdout` but abitrary
//! targets.
//!
//! ## Filters
//!
//! Each event, be it a log or a span has an associated level. Filters
//! define the max allowed level for each event, based on dynamic filter
//! directives. Such directives can be defined by [`Subscriber::with_filter`]
//! or read in from the enviroment variable `RUST_LOG`.
//!
//! The format for `RUST_LOG` is as follows:
//!
//! `scope/target[span{key=\"value\"}]=level`
//! A filter consists of two parts:
//! - An optional directive before the equals sign
//! - An assigned level after the equals sign
//!
//! A filter directive may have multiple criteria to
//! decide, whether the filter applies to the current event.
//! - `scope` applies a filter only to a given scope (prefix match). Scope must allways be followed by a `:`
//! - `target` requires the events module path to start with the given subpath
//! - `span` requires a span with the given name to be active
//! - a `key=\"value\"` pair requires any span to contain a key value pair, matching
//!   the input
//!
//! Note that all these instructions are optional and independent.
//! Thus `mytrg[myspan{id=\"1\"}]=info` does not imply that the key-value pair
//! must be inside a span called `myspan`
//! Additionally leaving out some parameters is also valid
//! (`[spanname]=info`, `target[{key=\"value\"}]=warn`, `target=trace`).
//!
//! Lastly an empty filter with only a level is also valid, and allwas applied.
//! Multiple filters may be defined, seperated by a `,`. The last filter that
//! was applied defines the allowed max level.
//!

mod filter;
mod format;
mod output;
mod policy;
mod span;

use self::{filter::Filters, policy::DefaultScopeConfigurationPolicy, span::SpanInfo};
use crate::{
    prelude::SimTime,
    sync::{Mutex, RwLock},
};
use fxhash::{FxBuildHasher, FxHashMap};
use std::{
    fmt::Debug,
    sync::{
        atomic::{AtomicU64, Ordering},
        mpsc::{channel, Receiver, Sender},
    },
};
use tracing::{
    level_filters::STATIC_MAX_LEVEL,
    metadata::LevelFilter,
    span::{Attributes, Id, Record},
    subscriber::{with_default, SetGlobalDefaultError},
};

pub use self::format::ColorfulTracingFormatter;
pub use self::format::NoColorFormatter;
pub use self::format::TracingFormatter;
pub use self::output::TracingOutput;
pub use self::output::TracingRecord;
pub use self::policy::ScopeConfiguration;
pub use self::policy::ScopeConfigurationPolicy;

/// A token describing a logger scope.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct ScopeToken(u64);

// is only set on the simulation thread, but read by all
// use static mut with a file-local saftey contract.
static SCOPE_CURRENT_TOKEN: AtomicU64 = AtomicU64::new(u64::MAX);
static SCOPE_TOKEN_NEXT: AtomicU64 = AtomicU64::new(0);
static SCOPES: Mutex<Option<Sender<(ScopeToken, String)>>> = Mutex::new(None);

/// Creates a new scope attached to the tracing subscriber.
///
/// This function is intended for internal use, but remains
/// public, since it may be usefull in rare scenarios
#[doc(hidden)]
pub fn new_scope(s: &str) -> ScopeToken {
    let token = ScopeToken(SCOPE_TOKEN_NEXT.fetch_add(1, Ordering::SeqCst));
    let lock = SCOPES.lock();
    if let Some(scopes) = &*lock {
        scopes.send((token, s.to_string())).expect("Failed to send");
    } else {
        // WARNING MAYBE
    }
    token
}

/// Indicates that the begin of a scope, that was allread registerd.
///
/// This function is intended for internal use, but remains
/// public, since it may be usefull in rare scenarios
#[doc(hidden)]
pub fn enter_scope(token: ScopeToken) {
    SCOPE_CURRENT_TOKEN.store(token.0, Ordering::SeqCst);
}

/// Indicates that no scope is currently active.
///
/// This function is intended for internal use, but remains
/// public, since it may be usefull in rare scenarios
#[doc(hidden)]
pub fn leave_scope() {
    SCOPE_CURRENT_TOKEN.store(u64::MAX, Ordering::SeqCst);
}

/// A subscriber to tracing events emitted by `des`.
///
/// Note that this subscriber extends the usual functionality of
/// tracing, by capturing the module context, aswell as the simulation
/// time too. Capturing the simulation context is
/// done by introducing custom spans.
///
/// This subscriber should only be used in combination with a
/// des `Runtime` that executes a `NetworkApplication`.
#[must_use]
pub struct Subscriber<P: ScopeConfigurationPolicy> {
    policy: P,
    scopes: RwLock<FxHashMap<u64, Scope>>,
    filters: Filters,
    max_log_level: LevelFilter,

    scopes_tx: Sender<(ScopeToken, String)>,
    scopes_rx: Mutex<Receiver<(ScopeToken, String)>>,

    //
    span_id: AtomicU64,
    spans: RwLock<FxHashMap<Id, SpanInfo>>,
    stack: RwLock<Vec<Id>>,
}

struct Scope {
    path: String,
    output: Box<dyn TracingOutput>,
    fmt: Box<dyn TracingFormatter>,
}

impl<P: ScopeConfigurationPolicy> Subscriber<P> {
    /// Creates a new tracing Subscriber with the given policy.
    pub fn new(policy: P) -> Self {
        let (scopes_tx, scopes_rx) = channel();

        Self {
            policy,
            scopes: RwLock::new(FxHashMap::with_hasher(FxBuildHasher::default())),
            filters: Filters::from_env().expect("Failed to parse from env"),
            max_log_level: STATIC_MAX_LEVEL,

            scopes_tx,
            scopes_rx: Mutex::new(scopes_rx),

            span_id: AtomicU64::new(1),
            spans: RwLock::new(FxHashMap::with_hasher(FxBuildHasher::default())),
            stack: RwLock::new(Vec::new()),
        }
    }

    /// Sets the maximum log level of the subscriber.
    ///
    /// All trace events not at least reaching this level,
    /// will be discarded.
    pub fn with_max_level(mut self, level: LevelFilter) -> Self {
        self.max_log_level = level;
        self
    }

    /// Adds a target filter in textual repr to the subscriber.
    pub fn with_filter(mut self, filter: impl AsRef<str>) -> Self {
        self.filters = filter.as_ref().parse().expect("Failed to parse");
        self
    }

    /// Sets the tracer as the global default.
    ///
    /// # Errors
    ///
    /// May fail if a subscriber has been set before.
    pub fn init(self) -> Result<(), SetGlobalDefaultError>
    where
        P: 'static,
    {
        let tx = self.scopes_tx.clone();
        tracing::subscriber::set_global_default(self)?;
        let _ = SCOPES.lock().replace(tx);
        Ok(())
    }

    /// Set the subscriber as the default in the closure
    pub fn with<R>(self, f: impl FnOnce() -> R) -> R
    where
        P: 'static,
    {
        let tx = self.scopes_tx.clone();
        let prev = SCOPES.lock().replace(tx);
        let ret = with_default(self, f);
        *SCOPES.lock() = prev;
        ret
    }
}

impl<P: ScopeConfigurationPolicy> Subscriber<P> {
    fn check_scopes(&self) {
        let rx = self.scopes_rx.lock();
        while let Ok((id, scope_name)) = rx.try_recv() {
            let mut scopes = self.scopes.write();
            let cfg = self.policy.configure(&scope_name);
            let a = scopes.insert(
                id.0,
                Scope {
                    path: if scope_name.is_empty() {
                        "@root".into()
                    } else {
                        scope_name
                    },
                    output: cfg.output,
                    fmt: cfg.fmt,
                },
            );
            assert!(a.is_none());
        }
    }
}

impl<P: ScopeConfigurationPolicy + 'static> tracing::Subscriber for Subscriber<P> {
    fn enabled(&self, metadata: &tracing::Metadata<'_>) -> bool {
        self.filters.callsite_filter_for(metadata) >= *metadata.level()
    }

    fn new_span(&self, span: &Attributes<'_>) -> Id {
        self.check_scopes();
        if !self.enabled(span.metadata()) {
            return Id::from_u64(0);
        }

        let id = Id::from_u64(
            self.span_id
                .fetch_add(1, std::sync::atomic::Ordering::SeqCst),
        );

        let info = SpanInfo::from_attrs(span);
        self.spans.write().insert(id.clone(), info);
        id
    }

    fn record(&self, id: &Id, record: &Record<'_>) {
        if let Some(info) = self.spans.write().get_mut(id) {
            info.fields.record(record);
        }
    }

    fn record_follows_from(&self, _: &Id, _: &Id) {
        todo!()
    }

    fn event_enabled(&self, event: &tracing::Event<'_>) -> bool {
        self.enabled(event.metadata())
    }

    fn event(&self, event: &tracing::Event<'_>) {
        // (-1) Target

        // (0) Identify current scope
        self.check_scopes();
        let scope_id = SCOPE_CURRENT_TOKEN.load(Ordering::SeqCst);
        let mut scopes = self.scopes.write();
        let scope = scopes.get_mut(&scope_id);

        // (1) Collect active spans
        let spans = self.spans.read();
        let active = self
            .stack
            .read()
            .iter()
            .map(|id| spans.get(id).unwrap())
            .collect::<Vec<_>>();

        let mut record = TracingRecord {
            time: SimTime::now(),
            scope: None,
            target: event.metadata().target(),
            spans: &active,
            event,
        };

        let allowed_max_level = self.filters.level_filter_for(&record);
        if allowed_max_level < *event.metadata().level() {
            return;
        }

        if let Some(Scope { output, fmt, path }) = scope {
            // must be in this order because brwchk
            record.scope = Some(&*path);
            output.write(&mut **fmt, record).unwrap();
        } else {
            // TODO: todo!()
            // unimplemented!("no scope found")
            eprintln!("no scope found");
        }
    }

    fn enter(&self, span: &Id) {
        self.stack.write().push(span.clone());
    }

    fn exit(&self, span: &Id) {
        assert_eq!(self.stack.write().pop(), Some(span.clone()));
    }

    fn try_close(&self, id: Id) -> bool {
        let mut spans = self.spans.write();
        let Some(span) = spans.get_mut(&id) else {
            return false;
        };
        span.sc -= 1;
        if span.sc == 0 {
            spans.remove(&id);
        }

        false
    }

    fn clone_span(&self, id: &Id) -> Id {
        if let Some(info) = self.spans.write().get_mut(id) {
            info.sc += 1;
        }
        id.clone()
    }
}

impl Default for Subscriber<DefaultScopeConfigurationPolicy> {
    fn default() -> Self {
        Self::new(DefaultScopeConfigurationPolicy)
    }
}

unsafe impl<P: ScopeConfigurationPolicy> Send for Subscriber<P> {}
unsafe impl<P: ScopeConfigurationPolicy> Sync for Subscriber<P> {}

impl<P: ScopeConfigurationPolicy> Debug for Subscriber<P> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Subscriber").finish()
    }
}
