#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use des::prelude::*;
mod members {
    use des::prelude::*;
    use log::info;
    use std::ops::Deref;
    pub struct Alice();
    impl ::des::net::__Buildable0 for Alice {
        fn build<A>(
            mut this: ::des::net::ModuleRef,
            ctx: &mut ::des::net::BuildContext<'_, A>,
        ) -> ::des::net::ModuleRef {
            use des::net::*;
            let _ =
                this.create_gate_cluster("netIn", 3usize, ::des::net::GateServiceType::Undefined);
            let _ =
                this.create_gate_cluster("netOut", 3usize, ::des::net::GateServiceType::Undefined);
            this
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Alice {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Alice")
        }
    }
    impl Module for Alice {
        fn new() -> Self {
            Self()
        }
        fn handle_message(&mut self, msg: Message) {
            let mut pkt = msg;
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &["Received at ", ": Message with content: "],
                            &[
                                ::core::fmt::ArgumentV1::new_display(&sim_time()),
                                ::core::fmt::ArgumentV1::new_display(
                                    &pkt.content::<String>().deref(),
                                ),
                            ],
                        ),
                        lvl,
                        &(
                            "t_utils::members",
                            "t_utils::members",
                            "examples\\utils\\members.rs",
                            18u32,
                        ),
                        ::log::__private_api::Option::None,
                    );
                }
            };
            if pkt.header().hop_count > par("limit").unwrap().parse::<usize>().unwrap() {
            } else {
                pkt.register_hop();
                send(pkt, ("netOut", 0))
            }
        }
    }
    pub struct Bob();
    impl ::des::net::__Buildable0 for Bob {
        fn build<A>(
            mut this: ::des::net::ModuleRef,
            ctx: &mut ::des::net::BuildContext<'_, A>,
        ) -> ::des::net::ModuleRef {
            use des::net::*;
            let mut child_child: ::des::net::ModuleRef =
                Alice::build_named_with_parent("child", this.clone(), ctx);
            let _ =
                this.create_gate_cluster("netIn", 3usize, ::des::net::GateServiceType::Undefined);
            let _ =
                this.create_gate_cluster("netOut", 3usize, ::des::net::GateServiceType::Undefined);
            let _ = this.create_gate_cluster("uplink", 1usize, ::des::net::GateServiceType::Output);
            let _ =
                this.create_gate_cluster("downlink", 1usize, ::des::net::GateServiceType::Input);
            let mut child_child_netIn_gate0: ::des::net::GateRef = child_child
                .gate("netIn", 0usize)
                .expect(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Internal macro err. Could not find child gate \'",
                            "[",
                            "]\'.",
                        ],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&"netIn"),
                            ::core::fmt::ArgumentV1::new_display(&0usize),
                        ],
                    ));
                    res
                })
                .clone();
            let mut netOut_gate0_ref: ::des::net::GateRef = this
                .gate("netOut", 0usize)
                .expect(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Internal macro err. Could not find local gate \'",
                            "[",
                            "]\'.",
                        ],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&"netOut"),
                            ::core::fmt::ArgumentV1::new_display(&0usize),
                        ],
                    ));
                    res
                })
                .clone();
            let channel = ::des::net::Channel::new(
                ::des::net::ObjectPath::channel_with(
                    &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["", "->"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(&netOut_gate0_ref.name()),
                                ::core::fmt::ArgumentV1::new_display(
                                    &child_child_netIn_gate0.name(),
                                ),
                            ],
                        ));
                        res
                    },
                    &this.path(),
                ),
                ::des::net::ChannelMetrics {
                    bitrate: 100usize,
                    latency: ::des::time::Duration::from_secs_f64(0.1f64),
                    jitter: ::des::time::Duration::from_secs_f64(0.1f64),
                    cost: 1f64,
                    queuesize: 0usize,
                },
            );
            ctx.create_channel(channel.clone());
            netOut_gate0_ref.set_next_gate(child_child_netIn_gate0);
            netOut_gate0_ref.set_channel(channel);
            let mut child_child_netIn_gate1: ::des::net::GateRef = child_child
                .gate("netIn", 1usize)
                .expect(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Internal macro err. Could not find child gate \'",
                            "[",
                            "]\'.",
                        ],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&"netIn"),
                            ::core::fmt::ArgumentV1::new_display(&1usize),
                        ],
                    ));
                    res
                })
                .clone();
            let mut netOut_gate1_ref: ::des::net::GateRef = this
                .gate("netOut", 1usize)
                .expect(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Internal macro err. Could not find local gate \'",
                            "[",
                            "]\'.",
                        ],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&"netOut"),
                            ::core::fmt::ArgumentV1::new_display(&1usize),
                        ],
                    ));
                    res
                })
                .clone();
            let channel = ::des::net::Channel::new(
                ::des::net::ObjectPath::channel_with(
                    &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["", "->"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(&netOut_gate1_ref.name()),
                                ::core::fmt::ArgumentV1::new_display(
                                    &child_child_netIn_gate1.name(),
                                ),
                            ],
                        ));
                        res
                    },
                    &this.path(),
                ),
                ::des::net::ChannelMetrics {
                    bitrate: 100usize,
                    latency: ::des::time::Duration::from_secs_f64(0.1f64),
                    jitter: ::des::time::Duration::from_secs_f64(0.1f64),
                    cost: 1f64,
                    queuesize: 0usize,
                },
            );
            ctx.create_channel(channel.clone());
            netOut_gate1_ref.set_next_gate(child_child_netIn_gate1);
            netOut_gate1_ref.set_channel(channel);
            let mut child_child_netIn_gate2: ::des::net::GateRef = child_child
                .gate("netIn", 2usize)
                .expect(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Internal macro err. Could not find child gate \'",
                            "[",
                            "]\'.",
                        ],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&"netIn"),
                            ::core::fmt::ArgumentV1::new_display(&2usize),
                        ],
                    ));
                    res
                })
                .clone();
            let mut netOut_gate2_ref: ::des::net::GateRef = this
                .gate("netOut", 2usize)
                .expect(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Internal macro err. Could not find local gate \'",
                            "[",
                            "]\'.",
                        ],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&"netOut"),
                            ::core::fmt::ArgumentV1::new_display(&2usize),
                        ],
                    ));
                    res
                })
                .clone();
            let channel = ::des::net::Channel::new(
                ::des::net::ObjectPath::channel_with(
                    &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["", "->"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(&netOut_gate2_ref.name()),
                                ::core::fmt::ArgumentV1::new_display(
                                    &child_child_netIn_gate2.name(),
                                ),
                            ],
                        ));
                        res
                    },
                    &this.path(),
                ),
                ::des::net::ChannelMetrics {
                    bitrate: 100usize,
                    latency: ::des::time::Duration::from_secs_f64(0.1f64),
                    jitter: ::des::time::Duration::from_secs_f64(0.1f64),
                    cost: 1f64,
                    queuesize: 0usize,
                },
            );
            ctx.create_channel(channel.clone());
            netOut_gate2_ref.set_next_gate(child_child_netIn_gate2);
            netOut_gate2_ref.set_channel(channel);
            let mut netIn_gate0_ref: ::des::net::GateRef = this
                .gate("netIn", 0usize)
                .expect(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Internal macro err. Could not find local gate \'",
                            "[",
                            "]\'.",
                        ],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&"netIn"),
                            ::core::fmt::ArgumentV1::new_display(&0usize),
                        ],
                    ));
                    res
                })
                .clone();
            let mut child_child_netOut_gate0: ::des::net::GateRef = child_child
                .gate("netOut", 0usize)
                .expect(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Internal macro err. Could not find child gate \'",
                            "[",
                            "]\'.",
                        ],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&"netOut"),
                            ::core::fmt::ArgumentV1::new_display(&0usize),
                        ],
                    ));
                    res
                })
                .clone();
            let channel = ::des::net::Channel::new(
                ::des::net::ObjectPath::channel_with(
                    &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["", "->"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(
                                    &child_child_netOut_gate0.name(),
                                ),
                                ::core::fmt::ArgumentV1::new_display(&netIn_gate0_ref.name()),
                            ],
                        ));
                        res
                    },
                    &this.path(),
                ),
                ::des::net::ChannelMetrics {
                    bitrate: 100usize,
                    latency: ::des::time::Duration::from_secs_f64(0.1f64),
                    jitter: ::des::time::Duration::from_secs_f64(0.1f64),
                    cost: 1f64,
                    queuesize: 0usize,
                },
            );
            ctx.create_channel(channel.clone());
            child_child_netOut_gate0.set_next_gate(netIn_gate0_ref);
            child_child_netOut_gate0.set_channel(channel);
            let mut netIn_gate1_ref: ::des::net::GateRef = this
                .gate("netIn", 1usize)
                .expect(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Internal macro err. Could not find local gate \'",
                            "[",
                            "]\'.",
                        ],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&"netIn"),
                            ::core::fmt::ArgumentV1::new_display(&1usize),
                        ],
                    ));
                    res
                })
                .clone();
            let mut child_child_netOut_gate1: ::des::net::GateRef = child_child
                .gate("netOut", 1usize)
                .expect(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Internal macro err. Could not find child gate \'",
                            "[",
                            "]\'.",
                        ],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&"netOut"),
                            ::core::fmt::ArgumentV1::new_display(&1usize),
                        ],
                    ));
                    res
                })
                .clone();
            let channel = ::des::net::Channel::new(
                ::des::net::ObjectPath::channel_with(
                    &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["", "->"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(
                                    &child_child_netOut_gate1.name(),
                                ),
                                ::core::fmt::ArgumentV1::new_display(&netIn_gate1_ref.name()),
                            ],
                        ));
                        res
                    },
                    &this.path(),
                ),
                ::des::net::ChannelMetrics {
                    bitrate: 100usize,
                    latency: ::des::time::Duration::from_secs_f64(0.1f64),
                    jitter: ::des::time::Duration::from_secs_f64(0.1f64),
                    cost: 1f64,
                    queuesize: 0usize,
                },
            );
            ctx.create_channel(channel.clone());
            child_child_netOut_gate1.set_next_gate(netIn_gate1_ref);
            child_child_netOut_gate1.set_channel(channel);
            let mut netIn_gate2_ref: ::des::net::GateRef = this
                .gate("netIn", 2usize)
                .expect(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Internal macro err. Could not find local gate \'",
                            "[",
                            "]\'.",
                        ],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&"netIn"),
                            ::core::fmt::ArgumentV1::new_display(&2usize),
                        ],
                    ));
                    res
                })
                .clone();
            let mut child_child_netOut_gate2: ::des::net::GateRef = child_child
                .gate("netOut", 2usize)
                .expect(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Internal macro err. Could not find child gate \'",
                            "[",
                            "]\'.",
                        ],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&"netOut"),
                            ::core::fmt::ArgumentV1::new_display(&2usize),
                        ],
                    ));
                    res
                })
                .clone();
            let channel = ::des::net::Channel::new(
                ::des::net::ObjectPath::channel_with(
                    &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["", "->"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(
                                    &child_child_netOut_gate2.name(),
                                ),
                                ::core::fmt::ArgumentV1::new_display(&netIn_gate2_ref.name()),
                            ],
                        ));
                        res
                    },
                    &this.path(),
                ),
                ::des::net::ChannelMetrics {
                    bitrate: 100usize,
                    latency: ::des::time::Duration::from_secs_f64(0.1f64),
                    jitter: ::des::time::Duration::from_secs_f64(0.1f64),
                    cost: 1f64,
                    queuesize: 0usize,
                },
            );
            ctx.create_channel(channel.clone());
            child_child_netOut_gate2.set_next_gate(netIn_gate2_ref);
            child_child_netOut_gate2.set_channel(channel);
            ctx.create_module(child_child);
            this
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Bob {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Bob")
        }
    }
    impl Module for Bob {
        fn new() -> Self {
            Self()
        }
        fn num_sim_start_stages(&self) -> usize {
            2
        }
        fn at_sim_start(&mut self, stage: usize) {
            match stage {
                0 => {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api_log(
                                ::core::fmt::Arguments::new_v1(&["Initalizing"], &[]),
                                lvl,
                                &(
                                    "t_utils::members",
                                    "t_utils::members",
                                    "examples\\utils\\members.rs",
                                    49u32,
                                ),
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    send(
                        Message::new().kind(1).content("Ping".to_string()).build(),
                        ("netOut", 2),
                    );
                }
                1 => {}
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
        fn handle_message(&mut self, msg: Message) {
            let mut pkt = msg;
            pkt.register_hop();
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &["Received at ", ": Message with content: "],
                            &[
                                ::core::fmt::ArgumentV1::new_display(&sim_time()),
                                ::core::fmt::ArgumentV1::new_display(
                                    &pkt.content::<String>().deref(),
                                ),
                            ],
                        ),
                        lvl,
                        &(
                            "t_utils::members",
                            "t_utils::members",
                            "examples\\utils\\members.rs",
                            71u32,
                        ),
                        ::log::__private_api::Option::None,
                    );
                }
            };
            pkt.content_mut::<String>().push_str(&par("char").unwrap());
            send(pkt, ("netOut", 2));
        }
    }
}
use members::*;
struct A();
#[automatically_derived]
impl ::core::fmt::Debug for A {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(f, "A")
    }
}
#[automatically_derived]
impl ::core::default::Default for A {
    #[inline]
    fn default() -> A {
        A {}
    }
}
impl A {
    pub fn run(self) -> ::des::runtime::RuntimeResult<::des::net::SubsystemRef> {
        self.run_with_options(::des::runtime::RuntimeOptions::default())
    }
    pub fn run_with_options(
        self,
        options: ::des::runtime::RuntimeOptions,
    ) -> ::des::runtime::RuntimeResult<::des::net::SubsystemRef> {
        use des::net::NetworkRuntime;
        use des::runtime::Runtime;
        let net_rt = self.build_rt();
        let rt = Runtime::new_with(net_rt, options);
        rt.run().map_app(|network_app| network_app.finish())
    }
    pub fn build_rt(self) -> ::des::net::NetworkRuntime<::des::net::SubsystemRef> {
        let this = self;
        let this = ::des::net::SubsystemRef::main(this);
        let this_path = this.path();
        let mut runtime = ::des::net::NetworkRuntime::new(this.clone());
        let mut builder = ::des::net::BuildContext::new(&mut runtime);
        builder.push_subsystem(this);
        let ctx: &mut ::des::net::BuildContext<'_, SubsystemRef> = &mut builder;
        use des::net::*;
        ctx.include_par_file("examples/utils\\init.par");
        let mut bob1_child: ::des::net::ModuleRef =
            Bob::build_named("bob[1]".parse().unwrap(), ctx);
        let mut bob2_child: ::des::net::ModuleRef =
            Bob::build_named("bob[2]".parse().unwrap(), ctx);
        let mut bob1_child_uplink_gate0: ::des::net::GateRef = bob1_child
            .gate("uplink", 0usize)
            .expect(&{
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &[
                        "Internal macro err. Could not find child gate \'",
                        "[",
                        "]\'.",
                    ],
                    &[
                        ::core::fmt::ArgumentV1::new_display(&"uplink"),
                        ::core::fmt::ArgumentV1::new_display(&0usize),
                    ],
                ));
                res
            })
            .clone();
        let mut bob2_child_downlink_gate0: ::des::net::GateRef = bob2_child
            .gate("downlink", 0usize)
            .expect(&{
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &[
                        "Internal macro err. Could not find child gate \'",
                        "[",
                        "]\'.",
                    ],
                    &[
                        ::core::fmt::ArgumentV1::new_display(&"downlink"),
                        ::core::fmt::ArgumentV1::new_display(&0usize),
                    ],
                ));
                res
            })
            .clone();
        let channel = ::des::net::Channel::new(
            ::des::net::ObjectPath::channel_with(
                &{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["", "->"],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&bob1_child_uplink_gate0.name()),
                            ::core::fmt::ArgumentV1::new_display(&bob2_child_downlink_gate0.name()),
                        ],
                    ));
                    res
                },
                &this_path,
            ),
            ::des::net::ChannelMetrics {
                bitrate: 10000usize,
                latency: ::des::time::Duration::from_secs_f64(0.05f64),
                jitter: ::des::time::Duration::from_secs_f64(0.01f64),
                cost: 1f64,
                queuesize: 0usize,
            },
        );
        bob1_child_uplink_gate0.set_next_gate(bob2_child_downlink_gate0);
        bob1_child_uplink_gate0.set_channel(channel);
        let mut bob2_child_uplink_gate0: ::des::net::GateRef = bob2_child
            .gate("uplink", 0usize)
            .expect(&{
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &[
                        "Internal macro err. Could not find child gate \'",
                        "[",
                        "]\'.",
                    ],
                    &[
                        ::core::fmt::ArgumentV1::new_display(&"uplink"),
                        ::core::fmt::ArgumentV1::new_display(&0usize),
                    ],
                ));
                res
            })
            .clone();
        let mut bob1_child_downlink_gate0: ::des::net::GateRef = bob1_child
            .gate("downlink", 0usize)
            .expect(&{
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &[
                        "Internal macro err. Could not find child gate \'",
                        "[",
                        "]\'.",
                    ],
                    &[
                        ::core::fmt::ArgumentV1::new_display(&"downlink"),
                        ::core::fmt::ArgumentV1::new_display(&0usize),
                    ],
                ));
                res
            })
            .clone();
        let channel = ::des::net::Channel::new(
            ::des::net::ObjectPath::channel_with(
                &{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["", "->"],
                        &[
                            ::core::fmt::ArgumentV1::new_display(&bob2_child_uplink_gate0.name()),
                            ::core::fmt::ArgumentV1::new_display(&bob1_child_downlink_gate0.name()),
                        ],
                    ));
                    res
                },
                &this_path,
            ),
            ::des::net::ChannelMetrics {
                bitrate: 10000usize,
                latency: ::des::time::Duration::from_secs_f64(0.05f64),
                jitter: ::des::time::Duration::from_secs_f64(0.01f64),
                cost: 1f64,
                queuesize: 0usize,
            },
        );
        bob2_child_uplink_gate0.set_next_gate(bob1_child_downlink_gate0);
        bob2_child_uplink_gate0.set_channel(channel);
        ctx.create_module(bob1_child);
        ctx.create_module(bob2_child);
        runtime
    }
}
fn main() {
    let app = A::default().build_rt();
    let rt = Runtime::new_with(app, RuntimeOptions::seeded(0x123).quiet());
    let (app, time, p) = rt.run().unwrap();
    let topo = app.globals().topology.borrow().clone();
    match (&topo.nodes().count(), &4) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                let kind = ::core::panicking::AssertKind::Eq;
                ::core::panicking::assert_failed(
                    kind,
                    &*left_val,
                    &*right_val,
                    ::core::option::Option::None,
                );
            }
        }
    };
    match (&topo.edges().count(), &14) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                let kind = ::core::panicking::AssertKind::Eq;
                ::core::panicking::assert_failed(
                    kind,
                    &*left_val,
                    &*right_val,
                    ::core::option::Option::None,
                );
            }
        }
    };
    let _ = topo.write_to_svg("examples/utils/graph");
    match (&p.event_count, &94) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                let kind = ::core::panicking::AssertKind::Eq;
                ::core::panicking::assert_failed(
                    kind,
                    &*left_val,
                    &*right_val,
                    ::core::option::Option::None,
                );
            }
        }
    };
    if !time.eq_approx(
        ::des::time::SimTime::from_duration(std::time::Duration::from_secs_f64(45.0)),
        std::time::Duration::from_nanos(100),
    ) {
        :: core :: panicking :: panic ("assertion failed: time.eq_approx(::des::time::SimTime::from_duration(std::time::Duration::from_secs_f64(45.0)),\\n    std::time::Duration::from_nanos(100))")
    }
}
